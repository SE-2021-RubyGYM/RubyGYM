{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrAdd = arrAdd;\nexports.arrDel = arrDel;\nexports.calcDropPosition = calcDropPosition;\nexports.calcSelectedKeys = calcSelectedKeys;\nexports.conductExpandParent = conductExpandParent;\nexports.convertDataToTree = convertDataToTree;\nexports.getDragChildrenKeys = getDragChildrenKeys;\nexports.getPosition = getPosition;\nexports.isFirstChild = isFirstChild;\nexports.isLastChild = isLastChild;\nexports.isTreeNode = isTreeNode;\nexports.parseCheckedKeys = parseCheckedKeys;\nexports.posToArr = posToArr;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _warning = _interopRequireDefault(require(\"rc-util/lib/warning\"));\n\nvar _TreeNode = _interopRequireDefault(require(\"./TreeNode\"));\n\nvar _excluded = [\"children\"];\n\nfunction arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n\n  return clone;\n}\n\nfunction arrAdd(list, value) {\n  var clone = list.slice();\n\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n\n  return clone;\n}\n\nfunction posToArr(pos) {\n  return pos.split('-');\n}\n\nfunction getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\n\nfunction isTreeNode(node) {\n  return node && node.type && node.type.isTreeNode;\n}\n\nfunction getDragChildrenKeys(dragNodeKey, keyEntities) {\n  // not contains self\n  // self for left or right drag\n  var dragChildrenKeys = [];\n  var entity = keyEntities[dragNodeKey];\n\n  function dig() {\n    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    list.forEach(function (_ref) {\n      var key = _ref.key,\n          children = _ref.children;\n      dragChildrenKeys.push(key);\n      dig(children);\n    });\n  }\n\n  dig(entity.children);\n  return dragChildrenKeys;\n}\n\nfunction isLastChild(treeNodeEntity) {\n  if (treeNodeEntity.parent) {\n    var posArr = posToArr(treeNodeEntity.pos);\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\n  }\n\n  return false;\n}\n\nfunction isFirstChild(treeNodeEntity) {\n  var posArr = posToArr(treeNodeEntity.pos);\n  return Number(posArr[posArr.length - 1]) === 0;\n} // Only used when drag, not affect SSR.\n\n\nfunction calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {\n  var _abstractDropNodeEnti;\n\n  var clientX = event.clientX,\n      clientY = event.clientY;\n\n  var _event$target$getBoun = event.target.getBoundingClientRect(),\n      top = _event$target$getBoun.top,\n      height = _event$target$getBoun.height; // optional chain for testing\n\n\n  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);\n  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent; // find abstract drop node by horizontal offset\n\n  var abstractDropNodeEntity = keyEntities[targetNode.props.eventKey];\n\n  if (clientY < top + height / 2) {\n    // first half, set abstract drop node to previous node\n    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {\n      return flattenedNode.data.key === abstractDropNodeEntity.key;\n    });\n    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\n    var prevNodeKey = flattenedNodes[prevNodeIndex].data.key;\n    abstractDropNodeEntity = keyEntities[prevNodeKey];\n  }\n\n  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;\n  var abstractDragOverEntity = abstractDropNodeEntity;\n  var dragOverNodeKey = abstractDropNodeEntity.key;\n  var dropPosition = 0;\n  var dropLevelOffset = 0; // Only allow cross level drop when dragging on a non-expanded node\n\n  if (!expandKeys.includes(initialAbstractDropNodeKey)) {\n    for (var i = 0; i < rawDropLevelOffset; i += 1) {\n      if (isLastChild(abstractDropNodeEntity)) {\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\n        dropLevelOffset += 1;\n      } else {\n        break;\n      }\n    }\n  }\n\n  var abstractDragDataNode = dragNode.props.data;\n  var abstractDropDataNode = abstractDropNodeEntity.node;\n  var dropAllowed = true;\n\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\n    dragNode: abstractDragDataNode,\n    dropNode: abstractDropDataNode,\n    dropPosition: -1\n  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {\n    // first half of first node in first level\n    dropPosition = -1;\n  } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {\n    // drop on expanded node\n    // only allow drop inside\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 0\n    })) {\n      dropPosition = 0;\n    } else {\n      dropAllowed = false;\n    }\n  } else if (dropLevelOffset === 0) {\n    if (rawDropLevelOffset > -1.5) {\n      // | Node     | <- abstractDropNode\n      // | -^-===== | <- mousePosition\n      // 1. try drop after\n      // 2. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    } else {\n      // | Node     | <- abstractDropNode\n      // | ---==^== | <- mousePosition\n      // whether it has children or doesn't has children\n      // always\n      // 1. try drop inside\n      // 2. try drop after\n      // 3. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 0\n      })) {\n        dropPosition = 0;\n      } else if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    }\n  } else {\n    // | Node1 | <- abstractDropNode\n    //      |  Node2  |\n    // --^--|----=====| <- mousePosition\n    // 1. try insert after Node1\n    // 2. do not allow drop\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 1\n    })) {\n      dropPosition = 1;\n    } else {\n      dropAllowed = false;\n    }\n  }\n\n  return {\n    dropPosition: dropPosition,\n    dropLevelOffset: dropLevelOffset,\n    dropTargetKey: abstractDropNodeEntity.key,\n    dropTargetPos: abstractDropNodeEntity.pos,\n    dragOverNodeKey: dragOverNodeKey,\n    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,\n    dropAllowed: dropAllowed\n  };\n}\n/**\r\n * Return selectedKeys according with multiple prop\r\n * @param selectedKeys\r\n * @param props\r\n * @returns [string]\r\n */\n\n\nfunction calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n\n  return selectedKeys;\n}\n\nvar internalProcessProps = function internalProcessProps(props) {\n  return props;\n};\n\nfunction convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n\n  var _ref2 = processor || {},\n      _ref2$processProps = _ref2.processProps,\n      processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;\n\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_ref3) {\n    var children = _ref3.children,\n        props = (0, _objectWithoutProperties2.default)(_ref3, _excluded);\n    var childrenNodes = convertDataToTree(children, processor);\n    return /*#__PURE__*/_react.default.createElement(_TreeNode.default, processProps(props), childrenNodes);\n  });\n}\n/**\r\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\r\n */\n\n\nfunction parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  } // Convert keys to object format\n\n\n  var keyProps;\n\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if ((0, _typeof2.default)(keys) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    (0, _warning.default)(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  return keyProps;\n}\n/**\r\n * If user use `autoExpandParent` we should get the list of parent node\r\n * @param keyList\r\n * @param keyEntities\r\n */\n\n\nfunction conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = new Set();\n\n  function conductUp(key) {\n    if (expandedKeys.has(key)) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    expandedKeys.add(key);\n    var parent = entity.parent,\n        node = entity.node;\n    if (node.disabled) return;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return (0, _toConsumableArray2.default)(expandedKeys);\n}","map":{"version":3,"sources":["D:/4_PROJECTS/RubyGYM/client/node_modules/rc-tree/lib/util.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","arrAdd","arrDel","calcDropPosition","calcSelectedKeys","conductExpandParent","convertDataToTree","getDragChildrenKeys","getPosition","isFirstChild","isLastChild","isTreeNode","parseCheckedKeys","posToArr","_toConsumableArray2","_typeof2","_objectWithoutProperties2","_react","_warning","_TreeNode","_excluded","list","clone","slice","index","indexOf","splice","push","pos","split","level","concat","node","type","dragNodeKey","keyEntities","dragChildrenKeys","entity","dig","arguments","length","undefined","forEach","_ref","key","children","treeNodeEntity","parent","posArr","Number","event","dragNode","targetNode","indent","startMousePosition","allowDrop","flattenedNodes","expandKeys","direction","_abstractDropNodeEnti","clientX","clientY","_event$target$getBoun","target","getBoundingClientRect","top","height","horizontalMouseOffset","x","rawDropLevelOffset","abstractDropNodeEntity","props","eventKey","nodeIndex","findIndex","flattenedNode","data","prevNodeIndex","prevNodeKey","initialAbstractDropNodeKey","abstractDragOverEntity","dragOverNodeKey","dropPosition","dropLevelOffset","includes","i","abstractDragDataNode","abstractDropDataNode","dropAllowed","dropNode","dropTargetKey","dropTargetPos","dropContainerKey","selectedKeys","multiple","internalProcessProps","treeData","processor","_ref2","_ref2$processProps","processProps","Array","isArray","map","_ref3","default","childrenNodes","createElement","keys","keyProps","checkedKeys","halfCheckedKeys","checked","halfChecked","keyList","expandedKeys","Set","conductUp","has","add","disabled"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.arrAdd = arrAdd;\r\nexports.arrDel = arrDel;\r\nexports.calcDropPosition = calcDropPosition;\r\nexports.calcSelectedKeys = calcSelectedKeys;\r\nexports.conductExpandParent = conductExpandParent;\r\nexports.convertDataToTree = convertDataToTree;\r\nexports.getDragChildrenKeys = getDragChildrenKeys;\r\nexports.getPosition = getPosition;\r\nexports.isFirstChild = isFirstChild;\r\nexports.isLastChild = isLastChild;\r\nexports.isTreeNode = isTreeNode;\r\nexports.parseCheckedKeys = parseCheckedKeys;\r\nexports.posToArr = posToArr;\r\n\r\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\r\n\r\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\r\n\r\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\r\n\r\nvar _react = _interopRequireDefault(require(\"react\"));\r\n\r\nvar _warning = _interopRequireDefault(require(\"rc-util/lib/warning\"));\r\n\r\nvar _TreeNode = _interopRequireDefault(require(\"./TreeNode\"));\r\n\r\nvar _excluded = [\"children\"];\r\n\r\nfunction arrDel(list, value) {\r\n  var clone = list.slice();\r\n  var index = clone.indexOf(value);\r\n\r\n  if (index >= 0) {\r\n    clone.splice(index, 1);\r\n  }\r\n\r\n  return clone;\r\n}\r\n\r\nfunction arrAdd(list, value) {\r\n  var clone = list.slice();\r\n\r\n  if (clone.indexOf(value) === -1) {\r\n    clone.push(value);\r\n  }\r\n\r\n  return clone;\r\n}\r\n\r\nfunction posToArr(pos) {\r\n  return pos.split('-');\r\n}\r\n\r\nfunction getPosition(level, index) {\r\n  return \"\".concat(level, \"-\").concat(index);\r\n}\r\n\r\nfunction isTreeNode(node) {\r\n  return node && node.type && node.type.isTreeNode;\r\n}\r\n\r\nfunction getDragChildrenKeys(dragNodeKey, keyEntities) {\r\n  // not contains self\r\n  // self for left or right drag\r\n  var dragChildrenKeys = [];\r\n  var entity = keyEntities[dragNodeKey];\r\n\r\n  function dig() {\r\n    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\r\n    list.forEach(function (_ref) {\r\n      var key = _ref.key,\r\n          children = _ref.children;\r\n      dragChildrenKeys.push(key);\r\n      dig(children);\r\n    });\r\n  }\r\n\r\n  dig(entity.children);\r\n  return dragChildrenKeys;\r\n}\r\n\r\nfunction isLastChild(treeNodeEntity) {\r\n  if (treeNodeEntity.parent) {\r\n    var posArr = posToArr(treeNodeEntity.pos);\r\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction isFirstChild(treeNodeEntity) {\r\n  var posArr = posToArr(treeNodeEntity.pos);\r\n  return Number(posArr[posArr.length - 1]) === 0;\r\n} // Only used when drag, not affect SSR.\r\n\r\n\r\nfunction calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {\r\n  var _abstractDropNodeEnti;\r\n\r\n  var clientX = event.clientX,\r\n      clientY = event.clientY;\r\n\r\n  var _event$target$getBoun = event.target.getBoundingClientRect(),\r\n      top = _event$target$getBoun.top,\r\n      height = _event$target$getBoun.height; // optional chain for testing\r\n\r\n\r\n  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);\r\n  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent; // find abstract drop node by horizontal offset\r\n\r\n  var abstractDropNodeEntity = keyEntities[targetNode.props.eventKey];\r\n\r\n  if (clientY < top + height / 2) {\r\n    // first half, set abstract drop node to previous node\r\n    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {\r\n      return flattenedNode.data.key === abstractDropNodeEntity.key;\r\n    });\r\n    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\r\n    var prevNodeKey = flattenedNodes[prevNodeIndex].data.key;\r\n    abstractDropNodeEntity = keyEntities[prevNodeKey];\r\n  }\r\n\r\n  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;\r\n  var abstractDragOverEntity = abstractDropNodeEntity;\r\n  var dragOverNodeKey = abstractDropNodeEntity.key;\r\n  var dropPosition = 0;\r\n  var dropLevelOffset = 0; // Only allow cross level drop when dragging on a non-expanded node\r\n\r\n  if (!expandKeys.includes(initialAbstractDropNodeKey)) {\r\n    for (var i = 0; i < rawDropLevelOffset; i += 1) {\r\n      if (isLastChild(abstractDropNodeEntity)) {\r\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\r\n        dropLevelOffset += 1;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  var abstractDragDataNode = dragNode.props.data;\r\n  var abstractDropDataNode = abstractDropNodeEntity.node;\r\n  var dropAllowed = true;\r\n\r\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\r\n    dragNode: abstractDragDataNode,\r\n    dropNode: abstractDropDataNode,\r\n    dropPosition: -1\r\n  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {\r\n    // first half of first node in first level\r\n    dropPosition = -1;\r\n  } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {\r\n    // drop on expanded node\r\n    // only allow drop inside\r\n    if (allowDrop({\r\n      dragNode: abstractDragDataNode,\r\n      dropNode: abstractDropDataNode,\r\n      dropPosition: 0\r\n    })) {\r\n      dropPosition = 0;\r\n    } else {\r\n      dropAllowed = false;\r\n    }\r\n  } else if (dropLevelOffset === 0) {\r\n    if (rawDropLevelOffset > -1.5) {\r\n      // | Node     | <- abstractDropNode\r\n      // | -^-===== | <- mousePosition\r\n      // 1. try drop after\r\n      // 2. do not allow drop\r\n      if (allowDrop({\r\n        dragNode: abstractDragDataNode,\r\n        dropNode: abstractDropDataNode,\r\n        dropPosition: 1\r\n      })) {\r\n        dropPosition = 1;\r\n      } else {\r\n        dropAllowed = false;\r\n      }\r\n    } else {\r\n      // | Node     | <- abstractDropNode\r\n      // | ---==^== | <- mousePosition\r\n      // whether it has children or doesn't has children\r\n      // always\r\n      // 1. try drop inside\r\n      // 2. try drop after\r\n      // 3. do not allow drop\r\n      if (allowDrop({\r\n        dragNode: abstractDragDataNode,\r\n        dropNode: abstractDropDataNode,\r\n        dropPosition: 0\r\n      })) {\r\n        dropPosition = 0;\r\n      } else if (allowDrop({\r\n        dragNode: abstractDragDataNode,\r\n        dropNode: abstractDropDataNode,\r\n        dropPosition: 1\r\n      })) {\r\n        dropPosition = 1;\r\n      } else {\r\n        dropAllowed = false;\r\n      }\r\n    }\r\n  } else {\r\n    // | Node1 | <- abstractDropNode\r\n    //      |  Node2  |\r\n    // --^--|----=====| <- mousePosition\r\n    // 1. try insert after Node1\r\n    // 2. do not allow drop\r\n    if (allowDrop({\r\n      dragNode: abstractDragDataNode,\r\n      dropNode: abstractDropDataNode,\r\n      dropPosition: 1\r\n    })) {\r\n      dropPosition = 1;\r\n    } else {\r\n      dropAllowed = false;\r\n    }\r\n  }\r\n\r\n  return {\r\n    dropPosition: dropPosition,\r\n    dropLevelOffset: dropLevelOffset,\r\n    dropTargetKey: abstractDropNodeEntity.key,\r\n    dropTargetPos: abstractDropNodeEntity.pos,\r\n    dragOverNodeKey: dragOverNodeKey,\r\n    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,\r\n    dropAllowed: dropAllowed\r\n  };\r\n}\r\n/**\r\n * Return selectedKeys according with multiple prop\r\n * @param selectedKeys\r\n * @param props\r\n * @returns [string]\r\n */\r\n\r\n\r\nfunction calcSelectedKeys(selectedKeys, props) {\r\n  if (!selectedKeys) return undefined;\r\n  var multiple = props.multiple;\r\n\r\n  if (multiple) {\r\n    return selectedKeys.slice();\r\n  }\r\n\r\n  if (selectedKeys.length) {\r\n    return [selectedKeys[0]];\r\n  }\r\n\r\n  return selectedKeys;\r\n}\r\n\r\nvar internalProcessProps = function internalProcessProps(props) {\r\n  return props;\r\n};\r\n\r\nfunction convertDataToTree(treeData, processor) {\r\n  if (!treeData) return [];\r\n\r\n  var _ref2 = processor || {},\r\n      _ref2$processProps = _ref2.processProps,\r\n      processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;\r\n\r\n  var list = Array.isArray(treeData) ? treeData : [treeData];\r\n  return list.map(function (_ref3) {\r\n    var children = _ref3.children,\r\n        props = (0, _objectWithoutProperties2.default)(_ref3, _excluded);\r\n    var childrenNodes = convertDataToTree(children, processor);\r\n    return /*#__PURE__*/_react.default.createElement(_TreeNode.default, processProps(props), childrenNodes);\r\n  });\r\n}\r\n/**\r\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\r\n */\r\n\r\n\r\nfunction parseCheckedKeys(keys) {\r\n  if (!keys) {\r\n    return null;\r\n  } // Convert keys to object format\r\n\r\n\r\n  var keyProps;\r\n\r\n  if (Array.isArray(keys)) {\r\n    // [Legacy] Follow the api doc\r\n    keyProps = {\r\n      checkedKeys: keys,\r\n      halfCheckedKeys: undefined\r\n    };\r\n  } else if ((0, _typeof2.default)(keys) === 'object') {\r\n    keyProps = {\r\n      checkedKeys: keys.checked || undefined,\r\n      halfCheckedKeys: keys.halfChecked || undefined\r\n    };\r\n  } else {\r\n    (0, _warning.default)(false, '`checkedKeys` is not an array or an object');\r\n    return null;\r\n  }\r\n\r\n  return keyProps;\r\n}\r\n/**\r\n * If user use `autoExpandParent` we should get the list of parent node\r\n * @param keyList\r\n * @param keyEntities\r\n */\r\n\r\n\r\nfunction conductExpandParent(keyList, keyEntities) {\r\n  var expandedKeys = new Set();\r\n\r\n  function conductUp(key) {\r\n    if (expandedKeys.has(key)) return;\r\n    var entity = keyEntities[key];\r\n    if (!entity) return;\r\n    expandedKeys.add(key);\r\n    var parent = entity.parent,\r\n        node = entity.node;\r\n    if (node.disabled) return;\r\n\r\n    if (parent) {\r\n      conductUp(parent.key);\r\n    }\r\n  }\r\n\r\n  (keyList || []).forEach(function (key) {\r\n    conductUp(key);\r\n  });\r\n  return (0, _toConsumableArray2.default)(expandedKeys);\r\n}"]},"metadata":{},"sourceType":"script"}