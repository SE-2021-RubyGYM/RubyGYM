{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/documentselection\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Selection from './selection';\nimport LiveRange from './liverange';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nconst storePrefix = 'selection:';\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class DocumentSelection {\n  /**\n   * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n   *\n   * @param {module:engine/model/document~Document} doc Document which owns this selection.\n   */\n  constructor(doc) {\n    /**\n     * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n     *\n     * @protected\n     */\n    this._selection = new LiveSelection(doc);\n\n    this._selection.delegate('change:range').to(this);\n\n    this._selection.delegate('change:attribute').to(this);\n\n    this._selection.delegate('change:marker').to(this);\n  }\n  /**\n   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n   * collapsed.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isCollapsed() {\n    return this._selection.isCollapsed;\n  }\n  /**\n   * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n   * Together with {@link #focus} they define the direction of selection, which is important\n   * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n   * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n   *\n   * Is set to `null` if there are no ranges in selection.\n   *\n   * @see #focus\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n\n\n  get anchor() {\n    return this._selection.anchor;\n  }\n  /**\n   * Selection focus. Focus is a position where the selection ends.\n   *\n   * Is set to `null` if there are no ranges in selection.\n   *\n   * @see #anchor\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n\n\n  get focus() {\n    return this._selection.focus;\n  }\n  /**\n   * Returns number of ranges in selection.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get rangeCount() {\n    return this._selection.rangeCount;\n  }\n  /**\n   * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get hasOwnRange() {\n    return this._selection.hasOwnRange;\n  }\n  /**\n   * Specifies whether the {@link #focus}\n   * precedes {@link #anchor}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isBackward() {\n    return this._selection.isBackward;\n  }\n  /**\n   * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n   *\n   * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n   *\n   * @readonly\n   * @returns {Boolean}\n   */\n\n\n  get isGravityOverridden() {\n    return this._selection.isGravityOverridden;\n  }\n  /**\n   * A collection of selection {@link module:engine/model/markercollection~Marker markers}.\n   * Marker is a selection marker when selection range is inside the marker range.\n   *\n   * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.\n   *\n   * @readonly\n   * @type {module:utils/collection~Collection}\n   */\n\n\n  get markers() {\n    return this._selection.markers;\n  }\n  /**\n   * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n   *\n   * @protected\n   */\n\n\n  get _ranges() {\n    return this._selection._ranges;\n  }\n  /**\n   * Returns an iterable that iterates over copies of selection ranges.\n   *\n   * @returns {Iterable.<module:engine/model/range~Range>}\n   */\n\n\n  getRanges() {\n    return this._selection.getRanges();\n  }\n  /**\n   * Returns the first position in the selection.\n   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n\n\n  getFirstPosition() {\n    return this._selection.getFirstPosition();\n  }\n  /**\n   * Returns the last position in the selection.\n   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n\n\n  getLastPosition() {\n    return this._selection.getLastPosition();\n  }\n  /**\n   * Returns a copy of the first range in the selection.\n   * First range is the one which {@link module:engine/model/range~Range#start start} position\n   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n   * (not to confuse with the first range added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getFirstRange() {\n    return this._selection.getFirstRange();\n  }\n  /**\n   * Returns a copy of the last range in the selection.\n   * Last range is the one which {@link module:engine/model/range~Range#end end} position\n   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n   * recently added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getLastRange() {\n    return this._selection.getLastRange();\n  }\n  /**\n   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n   *\n   * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n   *\n   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n   * but will not return blocks nested in other blocks.\n   *\n   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<blockQuote>\n   *\t\t\t<paragraph>b</paragraph>\n   *\t\t</blockQuote>\n   *\t\t<paragraph>c]d</paragraph>\n   *\n   * In this case the paragraph will also be returned, despite the collapsed selection:\n   *\n   *\t\t<paragraph>[]a</paragraph>\n   *\n   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n   *\n   *\t\t[<blockA></blockA>\n   *\t\t<blockB>\n   *\t\t\t<blockC></blockC>\n   *\t\t\t<blockD></blockD>\n   *\t\t</blockB>\n   *\t\t<blockE></blockE>]\n   *\n   * If the selection is inside a block all the inner blocks (A & B) are returned:\n   *\n   * \t\t<block>\n   *\t\t\t<blockA>[a</blockA>\n   * \t\t\t<blockB>b]</blockB>\n   * \t\t</block>\n   *\n   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<paragraph>b</paragraph>\n   *\t\t<paragraph>]c</paragraph> // this block will not be returned\n   *\n   * @returns {Iterable.<module:engine/model/element~Element>}\n   */\n\n\n  getSelectedBlocks() {\n    return this._selection.getSelectedBlocks();\n  }\n  /**\n   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n   * one range in the selection, and that range contains exactly one element.\n   * Returns `null` if there is no selected element.\n   *\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  getSelectedElement() {\n    return this._selection.getSelectedElement();\n  }\n  /**\n   * Checks whether the selection contains the entire content of the given element. This means that selection must start\n   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n   * touching the element's end.\n   *\n   * By default, this method will check whether the entire content of the selection's current root is selected.\n   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n   *\n   * @param {module:engine/model/element~Element} [element=this.anchor.root]\n   * @returns {Boolean}\n   */\n\n\n  containsEntireContent(element) {\n    return this._selection.containsEntireContent(element);\n  }\n  /**\n   * Unbinds all events previously bound by document selection.\n   */\n\n\n  destroy() {\n    this._selection.destroy();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  getAttributeKeys() {\n    return this._selection.getAttributeKeys();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  getAttributes() {\n    return this._selection.getAttributes();\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n\n\n  getAttribute(key) {\n    return this._selection.getAttribute(key);\n  }\n  /**\n   * Checks if the selection has an attribute for given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n   */\n\n\n  hasAttribute(key) {\n    return this._selection.hasAttribute(key);\n  }\n  /**\n   * Refreshes selection attributes and markers according to the current position in the model.\n   */\n\n\n  refresh() {\n    this._selection._updateMarkers();\n\n    this._selection._updateAttributes(false);\n  }\n  /**\n   * Registers a marker group prefix or a marker name to be collected in the\n   * {@link ~DocumentSelection#markers selection markers collection}.\n   *\n   * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.\n   *\n   * @param {String} prefixOrName The marker group prefix or marker name.\n   */\n\n\n  observeMarkers(prefixOrName) {\n    this._selection.observeMarkers(prefixOrName);\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   *\t\tselection.is( 'selection' ); // -> true\n   *\t\tselection.is( 'documentSelection' ); // -> true\n   *\t\tselection.is( 'model:selection' ); // -> true\n   *\t\tselection.is( 'model:documentSelection' ); // -> true\n   *\n   *\t\tselection.is( 'view:selection' ); // -> false\n   *\t\tselection.is( 'element' ); // -> false\n   *\t\tselection.is( 'node' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'selection' || type == 'model:selection' || type == 'documentSelection' || type == 'model:documentSelection';\n  }\n  /**\n   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n   *\n   * The location can be specified in the same form as\n   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n   *\n   * @see module:engine/model/writer~Writer#setSelectionFocus\n   * @protected\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  _setFocus(itemOrPosition, offset) {\n    this._selection.setFocus(itemOrPosition, offset);\n  }\n  /**\n   * Sets this selection's ranges and direction to the specified location based on the given\n   * {@link module:engine/model/selection~Selectable selectable}.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n   *\n   * @see module:engine/model/writer~Writer#setSelection\n   * @protected\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n\n\n  _setTo(selectable, placeOrOffset, options) {\n    this._selection.setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n   *\n   * @see module:engine/model/writer~Writer#setSelectionAttribute\n   * @protected\n   * @param {String} key Key of the attribute to set.\n   * @param {*} value Attribute value.\n   */\n\n\n  _setAttribute(key, value) {\n    this._selection.setAttribute(key, value);\n  }\n  /**\n   * Removes an attribute with given key from the selection.\n   * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n   * event with removed attribute key.\n   * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n   *\n   * @see module:engine/model/writer~Writer#removeSelectionAttribute\n   * @protected\n   * @param {String} key Key of the attribute to remove.\n   */\n\n\n  _removeAttribute(key) {\n    this._selection.removeAttribute(key);\n  }\n  /**\n   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n   *\n   * @protected\n   * @returns {Iterable.<*>}\n   */\n\n\n  _getStoredAttributes() {\n    return this._selection._getStoredAttributes();\n  }\n  /**\n   * Temporarily changes the gravity of the selection from the left to the right.\n   *\n   * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n   * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n   * This method allows to temporarily override this behavior by forcing the gravity to the right.\n   *\n   * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n   * of the process.\n   *\n   * @see module:engine/model/writer~Writer#overrideSelectionGravity\n   * @protected\n   * @returns {String} The unique id which allows restoring the gravity.\n   */\n\n\n  _overrideGravity() {\n    return this._selection.overrideGravity();\n  }\n  /**\n   * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n   *\n   * Restoring the gravity is only possible using the unique identifier returned by\n   * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n   * the same number of times it was overridden.\n   *\n   * @see module:engine/model/writer~Writer#restoreSelectionGravity\n   * @protected\n   * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n   */\n\n\n  _restoreGravity(uid) {\n    this._selection.restoreGravity(uid);\n  }\n  /**\n   * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n   *\n   * @protected\n   * @param {String} key Attribute key to convert.\n   * @returns {String} Converted attribute key, applicable for selection store.\n   */\n\n\n  static _getStoreAttributeKey(key) {\n    return storePrefix + key;\n  }\n  /**\n   * Checks whether the given attribute key is an attribute stored on an element.\n   *\n   * @protected\n   * @param {String} key\n   * @returns {Boolean}\n   */\n\n\n  static _isStoreAttributeKey(key) {\n    return key.startsWith(storePrefix);\n  }\n\n}\nmix(DocumentSelection, EmitterMixin);\n/**\n * Fired when selection range(s) changed.\n *\n * @event change:range\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed because the structure of the model has been changed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n */\n\n/**\n * Fired when selection attribute changed.\n *\n * @event change:attribute\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed in the model and its attributes were refreshed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n */\n\n/**\n * Fired when selection marker(s) changed.\n *\n * @event change:marker\n * @param {Boolean} directChange This is always set to `false` in case of `change:marker` event as there is no possibility\n * to change markers directly through {@link module:engine/model/documentselection~DocumentSelection} API.\n * See also {@link module:engine/model/documentselection~DocumentSelection#event:change:range} and\n * {@link module:engine/model/documentselection~DocumentSelection#event:change:attribute}.\n * @param {Array.<module:engine/model/markercollection~Marker>} oldMarkers Markers in which the selection was before the change.\n */\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\n\nclass LiveSelection extends Selection {\n  // Creates an empty live selection for given {@link module:engine/model/document~Document}.\n  // @param {module:engine/model/document~Document} doc Document which owns this selection.\n  constructor(doc) {\n    super(); // List of selection markers.\n    // Marker is a selection marker when selection range is inside the marker range.\n    //\n    // @type {module:utils/collection~Collection}\n\n    this.markers = new Collection({\n      idProperty: 'name'\n    }); // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/model~Model}\n\n    this._model = doc.model; // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/document~Document}\n\n    this._document = doc; // Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n    // last time. Possible values of priority are: `'low'` and `'normal'`.\n    //\n    // Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n    // attributes API are set with `'normal'` priority.\n    //\n    // @private\n    // @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n\n    this._attributePriority = new Map(); // Position to which the selection should be set if the last selection range was moved to the graveyard.\n    // @private\n    // @member {module:engine/model/position~Position} module:engine/model/liveselection~LiveSelection#_selectionRestorePosition\n\n    this._selectionRestorePosition = null; // Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n    // @private\n    // @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n\n    this._hasChangedRange = false; // Each overriding gravity adds an UID to the set and each removal removes it.\n    // Gravity is overridden when there's at least one UID in the set.\n    // Gravity is restored when the set is empty.\n    // This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n    // @private\n    // @type {Set}\n\n    this._overriddenGravityRegister = new Set(); // Prefixes of marker names that should affect `LiveSelection#markers` collection.\n    // @private\n    // @type {Set}\n\n    this._observedMarkers = new Set(); // Ensure selection is correct after each operation.\n\n    this.listenTo(this._model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      if (!operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop') {\n        return;\n      } // Fix selection if the last range was removed from it and we have a position to which we can restore the selection.\n\n\n      if (this._ranges.length == 0 && this._selectionRestorePosition) {\n        this._fixGraveyardSelection(this._selectionRestorePosition);\n      } // \"Forget\" the restore position even if it was not \"used\".\n\n\n      this._selectionRestorePosition = null;\n\n      if (this._hasChangedRange) {\n        this._hasChangedRange = false;\n        this.fire('change:range', {\n          directChange: false\n        });\n      }\n    }, {\n      priority: 'lowest'\n    }); // Ensure selection is correct and up to date after each range change.\n\n    this.on('change:range', () => {\n      for (const range of this.getRanges()) {\n        if (!this._document._validateSelectionRange(range)) {\n          /**\n           * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n           * starts or ends at incorrect position.\n           *\n           * @error document-selection-wrong-position\n           * @param {module:engine/model/range~Range} range\n           */\n          throw new CKEditorError('document-selection-wrong-position', this, {\n            range\n          });\n        }\n      }\n    }); // Update markers data stored by the selection after each marker change.\n    // This handles only marker changes done through marker operations (not model tree changes).\n\n    this.listenTo(this._model.markers, 'update', (evt, marker, oldRange, newRange) => {\n      this._updateMarker(marker, newRange);\n    }); // Ensure selection is up to date after each change block.\n\n    this.listenTo(this._document, 'change', (evt, batch) => {\n      clearAttributesStoredInElement(this._model, batch);\n    });\n  }\n\n  get isCollapsed() {\n    const length = this._ranges.length;\n    return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;\n  }\n\n  get anchor() {\n    return super.anchor || this._document._getDefaultRange().start;\n  }\n\n  get focus() {\n    return super.focus || this._document._getDefaultRange().end;\n  }\n\n  get rangeCount() {\n    return this._ranges.length ? this._ranges.length : 1;\n  } // Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n  // {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n  //\n  // @readonly\n  // @type {Boolean}\n\n\n  get hasOwnRange() {\n    return this._ranges.length > 0;\n  } // When set to `true` then selection attributes on node before the caret won't be taken\n  // into consideration while updating selection attributes.\n  //\n  // @protected\n  // @type {Boolean}\n\n\n  get isGravityOverridden() {\n    return !!this._overriddenGravityRegister.size;\n  } // Unbinds all events previously bound by live selection.\n\n\n  destroy() {\n    for (let i = 0; i < this._ranges.length; i++) {\n      this._ranges[i].detach();\n    }\n\n    this.stopListening();\n  }\n\n  *getRanges() {\n    if (this._ranges.length) {\n      yield* super.getRanges();\n    } else {\n      yield this._document._getDefaultRange();\n    }\n  }\n\n  getFirstRange() {\n    return super.getFirstRange() || this._document._getDefaultRange();\n  }\n\n  getLastRange() {\n    return super.getLastRange() || this._document._getDefaultRange();\n  }\n\n  setTo(selectable, optionsOrPlaceOrOffset, options) {\n    super.setTo(selectable, optionsOrPlaceOrOffset, options);\n\n    this._updateAttributes(true);\n\n    this._updateMarkers();\n  }\n\n  setFocus(itemOrPosition, offset) {\n    super.setFocus(itemOrPosition, offset);\n\n    this._updateAttributes(true);\n\n    this._updateMarkers();\n  }\n\n  setAttribute(key, value) {\n    if (this._setAttribute(key, value)) {\n      // Fire event with exact data.\n      const attributeKeys = [key];\n      this.fire('change:attribute', {\n        attributeKeys,\n        directChange: true\n      });\n    }\n  }\n\n  removeAttribute(key) {\n    if (this._removeAttribute(key)) {\n      // Fire event with exact data.\n      const attributeKeys = [key];\n      this.fire('change:attribute', {\n        attributeKeys,\n        directChange: true\n      });\n    }\n  }\n\n  overrideGravity() {\n    const overrideUid = uid(); // Remember that another overriding has been requested. It will need to be removed\n    // before the gravity is to be restored.\n\n    this._overriddenGravityRegister.add(overrideUid);\n\n    if (this._overriddenGravityRegister.size === 1) {\n      this._updateAttributes(true);\n    }\n\n    return overrideUid;\n  }\n\n  restoreGravity(uid) {\n    if (!this._overriddenGravityRegister.has(uid)) {\n      /**\n       * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n       * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n       *\n       * @error document-selection-gravity-wrong-restore\n       * @param {String} uid The unique identifier returned by\n       * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.\n       */\n      throw new CKEditorError('document-selection-gravity-wrong-restore', this, {\n        uid\n      });\n    }\n\n    this._overriddenGravityRegister.delete(uid); // Restore gravity only when all overriding have been restored.\n\n\n    if (!this.isGravityOverridden) {\n      this._updateAttributes(true);\n    }\n  }\n\n  observeMarkers(prefixOrName) {\n    this._observedMarkers.add(prefixOrName);\n\n    this._updateMarkers();\n  }\n\n  _popRange() {\n    this._ranges.pop().detach();\n  }\n\n  _pushRange(range) {\n    const liveRange = this._prepareRange(range); // `undefined` is returned when given `range` is in graveyard root.\n\n\n    if (liveRange) {\n      this._ranges.push(liveRange);\n    }\n  } // Prepares given range to be added to selection. Checks if it is correct,\n  // converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n  // and sets listeners listening to the range's change event.\n  //\n  // @private\n  // @param {module:engine/model/range~Range} range\n\n\n  _prepareRange(range) {\n    this._checkRange(range);\n\n    if (range.root == this._document.graveyard) {\n      // @if CK_DEBUG // console.warn( 'Trying to add a Range that is in the graveyard root. Range rejected.' );\n      return;\n    }\n\n    const liveRange = LiveRange.fromRange(range); // If selection range is moved to the graveyard remove it from the selection object.\n    // Also, save some data that can be used to restore selection later, on `Model#applyOperation` event.\n\n    liveRange.on('change:range', (evt, oldRange, data) => {\n      this._hasChangedRange = true;\n\n      if (liveRange.root == this._document.graveyard) {\n        this._selectionRestorePosition = data.deletionPosition;\n\n        const index = this._ranges.indexOf(liveRange);\n\n        this._ranges.splice(index, 1);\n\n        liveRange.detach();\n      }\n    });\n    return liveRange;\n  }\n\n  _updateMarkers() {\n    if (!this._observedMarkers.size) {\n      return;\n    }\n\n    const markers = [];\n    let changed = false;\n\n    for (const marker of this._model.markers) {\n      const markerGroup = marker.name.split(':', 1)[0];\n\n      if (!this._observedMarkers.has(markerGroup)) {\n        continue;\n      }\n\n      const markerRange = marker.getRange();\n\n      for (const selectionRange of this.getRanges()) {\n        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n          markers.push(marker);\n        }\n      }\n    }\n\n    const oldMarkers = Array.from(this.markers);\n\n    for (const marker of markers) {\n      if (!this.markers.has(marker)) {\n        this.markers.add(marker);\n        changed = true;\n      }\n    }\n\n    for (const marker of Array.from(this.markers)) {\n      if (!markers.includes(marker)) {\n        this.markers.remove(marker);\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this.fire('change:marker', {\n        oldMarkers,\n        directChange: false\n      });\n    }\n  }\n\n  _updateMarker(marker, markerRange) {\n    const markerGroup = marker.name.split(':', 1)[0];\n\n    if (!this._observedMarkers.has(markerGroup)) {\n      return;\n    }\n\n    let changed = false;\n    const oldMarkers = Array.from(this.markers);\n    const hasMarker = this.markers.has(marker);\n\n    if (!markerRange) {\n      if (hasMarker) {\n        this.markers.remove(marker);\n        changed = true;\n      }\n    } else {\n      let contained = false;\n\n      for (const selectionRange of this.getRanges()) {\n        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n          contained = true;\n          break;\n        }\n      }\n\n      if (contained && !hasMarker) {\n        this.markers.add(marker);\n        changed = true;\n      } else if (!contained && hasMarker) {\n        this.markers.remove(marker);\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this.fire('change:marker', {\n        oldMarkers,\n        directChange: false\n      });\n    }\n  } // Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n  //\n  // @protected\n  // @param {Boolean} clearAll\n  // @fires change:attribute\n\n\n  _updateAttributes(clearAll) {\n    const newAttributes = toMap(this._getSurroundingAttributes());\n    const oldAttributes = toMap(this.getAttributes());\n\n    if (clearAll) {\n      // If `clearAll` remove all attributes and reset priorities.\n      this._attributePriority = new Map();\n      this._attrs = new Map();\n    } else {\n      // If not, remove only attributes added with `low` priority.\n      for (const [key, priority] of this._attributePriority) {\n        if (priority == 'low') {\n          this._attrs.delete(key);\n\n          this._attributePriority.delete(key);\n        }\n      }\n    }\n\n    this._setAttributesTo(newAttributes); // Let's evaluate which attributes really changed.\n\n\n    const changed = []; // First, loop through all attributes that are set on selection right now.\n    // Check which of them are different than old attributes.\n\n    for (const [newKey, newValue] of this.getAttributes()) {\n      if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {\n        changed.push(newKey);\n      }\n    } // Then, check which of old attributes got removed.\n\n\n    for (const [oldKey] of oldAttributes) {\n      if (!this.hasAttribute(oldKey)) {\n        changed.push(oldKey);\n      }\n    } // Fire event with exact data (fire only if anything changed).\n\n\n    if (changed.length > 0) {\n      this.fire('change:attribute', {\n        attributeKeys: changed,\n        directChange: false\n      });\n    }\n  } // Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n  // parameter).\n  //\n  // @private\n  // @param {String} key Attribute key.\n  // @param {*} value Attribute value.\n  // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n  // is caused by `Batch` API.\n  // @returns {Boolean} Whether value has changed.\n\n\n  _setAttribute(key, value) {\n    let directChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const priority = directChange ? 'normal' : 'low';\n\n    if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n      // Priority too low.\n      return false;\n    }\n\n    const oldValue = super.getAttribute(key); // Don't do anything if value has not changed.\n\n    if (oldValue === value) {\n      return false;\n    }\n\n    this._attrs.set(key, value); // Update priorities map.\n\n\n    this._attributePriority.set(key, priority);\n\n    return true;\n  } // Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n  // parameter).\n  //\n  // NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n  // be changed according to `directChange` parameter.\n  //\n  // @private\n  // @param {String} key Attribute key.\n  // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n  // is caused by `Batch` API.\n  // @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n  // existing attribute had higher priority.\n\n\n  _removeAttribute(key) {\n    let directChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const priority = directChange ? 'normal' : 'low';\n\n    if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n      // Priority too low.\n      return false;\n    } // Update priorities map.\n\n\n    this._attributePriority.set(key, priority); // Don't do anything if value has not changed.\n\n\n    if (!super.hasAttribute(key)) {\n      return false;\n    }\n\n    this._attrs.delete(key);\n\n    return true;\n  } // Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n  // `directChange` parameter).\n  //\n  // @private\n  // @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n  // @returns {Set.<String>} Changed attribute keys.\n\n\n  _setAttributesTo(attrs) {\n    const changed = new Set();\n\n    for (const [oldKey, oldValue] of this.getAttributes()) {\n      // Do not remove attribute if attribute with same key and value is about to be set.\n      if (attrs.get(oldKey) === oldValue) {\n        continue;\n      } // All rest attributes will be removed so changed attributes won't change .\n\n\n      this._removeAttribute(oldKey, false);\n    }\n\n    for (const [key, value] of attrs) {\n      // Attribute may not be set because of attributes or because same key/value is already added.\n      const gotAdded = this._setAttribute(key, value, false);\n\n      if (gotAdded) {\n        changed.add(key);\n      }\n    }\n\n    return changed;\n  } // Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n  //\n  // @protected\n  // @returns {Iterable.<*>}\n\n\n  *_getStoredAttributes() {\n    const selectionParent = this.getFirstPosition().parent;\n\n    if (this.isCollapsed && selectionParent.isEmpty) {\n      for (const key of selectionParent.getAttributeKeys()) {\n        if (key.startsWith(storePrefix)) {\n          const realKey = key.substr(storePrefix.length);\n          yield [realKey, selectionParent.getAttribute(key)];\n        }\n      }\n    }\n  } // Checks model text nodes that are closest to the selection's first position and returns attributes of first\n  // found element. If there are no text nodes in selection's first position parent, it returns selection\n  // attributes stored in that parent.\n  //\n  // @private\n  // @returns {Iterable.<*>} Collection of attributes.\n\n\n  _getSurroundingAttributes() {\n    const position = this.getFirstPosition();\n    const schema = this._model.schema;\n    let attrs = null;\n\n    if (!this.isCollapsed) {\n      // 1. If selection is a range...\n      const range = this.getFirstRange(); // ...look for a first character node in that range and take attributes from it.\n\n      for (const value of range) {\n        // If the item is an object, we don't want to get attributes from its children.\n        if (value.item.is('element') && schema.isObject(value.item)) {\n          break;\n        }\n\n        if (value.type == 'text') {\n          attrs = value.item.getAttributes();\n          break;\n        }\n      }\n    } else {\n      // 2. If the selection is a caret or the range does not contain a character node...\n      const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n      const nodeAfter = position.textNode ? position.textNode : position.nodeAfter; // When gravity is overridden then don't take node before into consideration.\n\n      if (!this.isGravityOverridden) {\n        // ...look at the node before caret and take attributes from it if it is a character node.\n        attrs = getAttrsIfCharacter(nodeBefore);\n      } // 3. If not, look at the node after caret...\n\n\n      if (!attrs) {\n        attrs = getAttrsIfCharacter(nodeAfter);\n      } // 4. If not, try to find the first character on the left, that is in the same node.\n      // When gravity is overridden then don't take node before into consideration.\n\n\n      if (!this.isGravityOverridden && !attrs) {\n        let node = nodeBefore;\n\n        while (node && !schema.isInline(node) && !attrs) {\n          node = node.previousSibling;\n          attrs = getAttrsIfCharacter(node);\n        }\n      } // 5. If not found, try to find the first character on the right, that is in the same node.\n\n\n      if (!attrs) {\n        let node = nodeAfter;\n\n        while (node && !schema.isInline(node) && !attrs) {\n          node = node.nextSibling;\n          attrs = getAttrsIfCharacter(node);\n        }\n      } // 6. If not found, selection should retrieve attributes from parent.\n\n\n      if (!attrs) {\n        attrs = this._getStoredAttributes();\n      }\n    }\n\n    return attrs;\n  } // Fixes the selection after all its ranges got removed.\n  //\n  // @private\n  // @param {module:engine/model/position~Position} deletionPosition Position where the deletion happened.\n\n\n  _fixGraveyardSelection(deletionPosition) {\n    // Find a range that is a correct selection range and is closest to the position where the deletion happened.\n    const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition); // If nearest valid selection range has been found - add it in the place of old range.\n\n\n    if (selectionRange) {\n      // Check the range, convert it to live range, bind events, etc.\n      this._pushRange(selectionRange);\n    } // If nearest valid selection range cannot be found don't add any range. Selection will be set to the default range.\n\n  }\n\n} // Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\n\n\nfunction getAttrsIfCharacter(node) {\n  if (node instanceof TextProxy || node instanceof Text) {\n    return node.getAttributes();\n  }\n\n  return null;\n} // Removes selection attributes from element which is not empty anymore.\n//\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\n\n\nfunction clearAttributesStoredInElement(model, batch) {\n  const differ = model.document.differ;\n\n  for (const entry of differ.getChanges()) {\n    if (entry.type != 'insert') {\n      continue;\n    }\n\n    const changeParent = entry.position.parent;\n    const isNoLongerEmpty = entry.length === changeParent.maxOffset;\n\n    if (isNoLongerEmpty) {\n      model.enqueueChange(batch, writer => {\n        const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter(key => key.startsWith(storePrefix));\n\n        for (const key of storedAttributes) {\n          writer.removeAttribute(key, changeParent);\n        }\n      });\n    }\n  }\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/documentselection.js"],"names":["mix","EmitterMixin","Selection","LiveRange","Text","TextProxy","toMap","Collection","CKEditorError","uid","storePrefix","DocumentSelection","constructor","doc","_selection","LiveSelection","delegate","to","isCollapsed","anchor","focus","rangeCount","hasOwnRange","isBackward","isGravityOverridden","markers","_ranges","getRanges","getFirstPosition","getLastPosition","getFirstRange","getLastRange","getSelectedBlocks","getSelectedElement","containsEntireContent","element","destroy","getAttributeKeys","getAttributes","getAttribute","key","hasAttribute","refresh","_updateMarkers","_updateAttributes","observeMarkers","prefixOrName","is","type","_setFocus","itemOrPosition","offset","setFocus","_setTo","selectable","placeOrOffset","options","setTo","_setAttribute","value","setAttribute","_removeAttribute","removeAttribute","_getStoredAttributes","_overrideGravity","overrideGravity","_restoreGravity","restoreGravity","_getStoreAttributeKey","_isStoreAttributeKey","startsWith","idProperty","_model","model","_document","_attributePriority","Map","_selectionRestorePosition","_hasChangedRange","_overriddenGravityRegister","Set","_observedMarkers","listenTo","evt","args","operation","isDocumentOperation","length","_fixGraveyardSelection","fire","directChange","priority","on","range","_validateSelectionRange","marker","oldRange","newRange","_updateMarker","batch","clearAttributesStoredInElement","_getDefaultRange","start","end","size","i","detach","stopListening","optionsOrPlaceOrOffset","attributeKeys","overrideUid","add","has","delete","_popRange","pop","_pushRange","liveRange","_prepareRange","push","_checkRange","root","graveyard","fromRange","data","deletionPosition","index","indexOf","splice","changed","markerGroup","name","split","markerRange","getRange","selectionRange","containsRange","oldMarkers","Array","from","includes","remove","hasMarker","contained","clearAll","newAttributes","_getSurroundingAttributes","oldAttributes","_attrs","_setAttributesTo","newKey","newValue","get","oldKey","oldValue","set","attrs","gotAdded","selectionParent","parent","isEmpty","realKey","substr","position","schema","item","isObject","nodeBefore","textNode","nodeAfter","getAttrsIfCharacter","node","isInline","previousSibling","nextSibling","getNearestSelectionRange","differ","document","entry","getChanges","changeParent","isNoLongerEmpty","maxOffset","enqueueChange","writer","storedAttributes","filter"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,GAAP,MAAgB,mCAAhB;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AAEA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,KAAP,MAAkB,qCAAlB;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA,MAAMC,WAAW,GAAG,YAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,iBAAN,CAAwB;AACtC;AACD;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,GAAF,EAAQ;AAClB;AACF;AACA;AACA;AACA;AACE,SAAKC,UAAL,GAAkB,IAAIC,aAAJ,CAAmBF,GAAnB,CAAlB;;AAEA,SAAKC,UAAL,CAAgBE,QAAhB,CAA0B,cAA1B,EAA2CC,EAA3C,CAA+C,IAA/C;;AACA,SAAKH,UAAL,CAAgBE,QAAhB,CAA0B,kBAA1B,EAA+CC,EAA/C,CAAmD,IAAnD;;AACA,SAAKH,UAAL,CAAgBE,QAAhB,CAA0B,eAA1B,EAA4CC,EAA5C,CAAgD,IAAhD;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACgB,MAAXC,WAAW,GAAG;AACjB,WAAO,KAAKJ,UAAL,CAAgBI,WAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACW,MAANC,MAAM,GAAG;AACZ,WAAO,KAAKL,UAAL,CAAgBK,MAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACU,MAALC,KAAK,GAAG;AACX,WAAO,KAAKN,UAAL,CAAgBM,KAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACe,MAAVC,UAAU,GAAG;AAChB,WAAO,KAAKP,UAAL,CAAgBO,UAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACgB,MAAXC,WAAW,GAAG;AACjB,WAAO,KAAKR,UAAL,CAAgBQ,WAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACe,MAAVC,UAAU,GAAG;AAChB,WAAO,KAAKT,UAAL,CAAgBS,UAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,MAAnBC,mBAAmB,GAAG;AACzB,WAAO,KAAKV,UAAL,CAAgBU,mBAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACY,MAAPC,OAAO,GAAG;AACb,WAAO,KAAKX,UAAL,CAAgBW,OAAvB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACY,MAAPC,OAAO,GAAG;AACb,WAAO,KAAKZ,UAAL,CAAgBY,OAAvB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,SAAS,GAAG;AACX,WAAO,KAAKb,UAAL,CAAgBa,SAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,gBAAgB,GAAG;AAClB,WAAO,KAAKd,UAAL,CAAgBc,gBAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,eAAe,GAAG;AACjB,WAAO,KAAKf,UAAL,CAAgBe,eAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,aAAa,GAAG;AACf,WAAO,KAAKhB,UAAL,CAAgBgB,aAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,GAAG;AACd,WAAO,KAAKjB,UAAL,CAAgBiB,YAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,iBAAiB,GAAG;AACnB,WAAO,KAAKlB,UAAL,CAAgBkB,iBAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,kBAAkB,GAAG;AACpB,WAAO,KAAKnB,UAAL,CAAgBmB,kBAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,qBAAqB,CAAEC,OAAF,EAAY;AAChC,WAAO,KAAKrB,UAAL,CAAgBoB,qBAAhB,CAAuCC,OAAvC,CAAP;AACA;AAED;AACD;AACA;;;AACCC,EAAAA,OAAO,GAAG;AACT,SAAKtB,UAAL,CAAgBsB,OAAhB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,gBAAgB,GAAG;AAClB,WAAO,KAAKvB,UAAL,CAAgBuB,gBAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,aAAa,GAAG;AACf,WAAO,KAAKxB,UAAL,CAAgBwB,aAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAAEC,GAAF,EAAQ;AACnB,WAAO,KAAK1B,UAAL,CAAgByB,YAAhB,CAA8BC,GAA9B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAAED,GAAF,EAAQ;AACnB,WAAO,KAAK1B,UAAL,CAAgB2B,YAAhB,CAA8BD,GAA9B,CAAP;AACA;AAED;AACD;AACA;;;AACCE,EAAAA,OAAO,GAAG;AACT,SAAK5B,UAAL,CAAgB6B,cAAhB;;AACA,SAAK7B,UAAL,CAAgB8B,iBAAhB,CAAmC,KAAnC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,cAAc,CAAEC,YAAF,EAAiB;AAC9B,SAAKhC,UAAL,CAAgB+B,cAAhB,CAAgCC,YAAhC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,EAAE,CAAEC,IAAF,EAAS;AACV,WAAOA,IAAI,KAAK,WAAT,IACNA,IAAI,IAAI,iBADF,IAENA,IAAI,IAAI,mBAFF,IAGNA,IAAI,IAAI,yBAHT;AAIA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,SAAS,CAAEC,cAAF,EAAkBC,MAAlB,EAA2B;AACnC,SAAKrC,UAAL,CAAgBsC,QAAhB,CAA0BF,cAA1B,EAA0CC,MAA1C;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,MAAM,CAAEC,UAAF,EAAcC,aAAd,EAA6BC,OAA7B,EAAuC;AAC5C,SAAK1C,UAAL,CAAgB2C,KAAhB,CAAuBH,UAAvB,EAAmCC,aAAnC,EAAkDC,OAAlD;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,aAAa,CAAElB,GAAF,EAAOmB,KAAP,EAAe;AAC3B,SAAK7C,UAAL,CAAgB8C,YAAhB,CAA8BpB,GAA9B,EAAmCmB,KAAnC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,gBAAgB,CAAErB,GAAF,EAAQ;AACvB,SAAK1B,UAAL,CAAgBgD,eAAhB,CAAiCtB,GAAjC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCuB,EAAAA,oBAAoB,GAAG;AACtB,WAAO,KAAKjD,UAAL,CAAgBiD,oBAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,gBAAgB,GAAG;AAClB,WAAO,KAAKlD,UAAL,CAAgBmD,eAAhB,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,eAAe,CAAEzD,GAAF,EAAQ;AACtB,SAAKK,UAAL,CAAgBqD,cAAhB,CAAgC1D,GAAhC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AAC6B,SAArB2D,qBAAqB,CAAE5B,GAAF,EAAQ;AACnC,WAAO9B,WAAW,GAAG8B,GAArB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AAC4B,SAApB6B,oBAAoB,CAAE7B,GAAF,EAAQ;AAClC,WAAOA,GAAG,CAAC8B,UAAJ,CAAgB5D,WAAhB,CAAP;AACA;;AA9dqC;AAievCV,GAAG,CAAEW,iBAAF,EAAqBV,YAArB,CAAH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMc,aAAN,SAA4Bb,SAA5B,CAAsC;AACrC;AACA;AACAU,EAAAA,WAAW,CAAEC,GAAF,EAAQ;AAClB,YADkB,CAGlB;AACA;AACA;AACA;;AACA,SAAKY,OAAL,GAAe,IAAIlB,UAAJ,CAAgB;AAAEgE,MAAAA,UAAU,EAAE;AAAd,KAAhB,CAAf,CAPkB,CASlB;AACA;AACA;AACA;;AACA,SAAKC,MAAL,GAAc3D,GAAG,CAAC4D,KAAlB,CAbkB,CAelB;AACA;AACA;AACA;;AACA,SAAKC,SAAL,GAAiB7D,GAAjB,CAnBkB,CAqBlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAK8D,kBAAL,GAA0B,IAAIC,GAAJ,EAA1B,CA7BkB,CA+BlB;AACA;AACA;;AACA,SAAKC,yBAAL,GAAiC,IAAjC,CAlCkB,CAoClB;AACA;AACA;;AACA,SAAKC,gBAAL,GAAwB,KAA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/documentselection\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n\nimport Selection from './selection';\nimport LiveRange from './liverange';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\n\nconst storePrefix = 'selection:';\n\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class DocumentSelection {\n\t/**\n\t * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n\t *\n\t * @param {module:engine/model/document~Document} doc Document which owns this selection.\n\t */\n\tconstructor( doc ) {\n\t\t/**\n\t\t * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n\t\t *\n\t\t * @protected\n\t\t */\n\t\tthis._selection = new LiveSelection( doc );\n\n\t\tthis._selection.delegate( 'change:range' ).to( this );\n\t\tthis._selection.delegate( 'change:attribute' ).to( this );\n\t\tthis._selection.delegate( 'change:marker' ).to( this );\n\t}\n\n\t/**\n\t * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n\t * collapsed.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this._selection.isCollapsed;\n\t}\n\n\t/**\n\t * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n\t * Together with {@link #focus} they define the direction of selection, which is important\n\t * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n\t * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #focus\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget anchor() {\n\t\treturn this._selection.anchor;\n\t}\n\n\t/**\n\t * Selection focus. Focus is a position where the selection ends.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #anchor\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget focus() {\n\t\treturn this._selection.focus;\n\t}\n\n\t/**\n\t * Returns number of ranges in selection.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._selection.rangeCount;\n\t}\n\n\t/**\n\t * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n\t * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget hasOwnRange() {\n\t\treturn this._selection.hasOwnRange;\n\t}\n\n\t/**\n\t * Specifies whether the {@link #focus}\n\t * precedes {@link #anchor}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn this._selection.isBackward;\n\t}\n\n\t/**\n\t * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n\t *\n\t * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n\t *\n\t * @readonly\n\t * @returns {Boolean}\n\t */\n\tget isGravityOverridden() {\n\t\treturn this._selection.isGravityOverridden;\n\t}\n\n\t/**\n\t * A collection of selection {@link module:engine/model/markercollection~Marker markers}.\n\t * Marker is a selection marker when selection range is inside the marker range.\n\t *\n\t * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.\n\t *\n\t * @readonly\n\t * @type {module:utils/collection~Collection}\n\t */\n\tget markers() {\n\t\treturn this._selection.markers;\n\t}\n\n\t/**\n\t * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n\t *\n\t * @protected\n\t */\n\tget _ranges() {\n\t\treturn this._selection._ranges;\n\t}\n\n\t/**\n\t * Returns an iterable that iterates over copies of selection ranges.\n\t *\n\t * @returns {Iterable.<module:engine/model/range~Range>}\n\t */\n\tgetRanges() {\n\t\treturn this._selection.getRanges();\n\t}\n\n\t/**\n\t * Returns the first position in the selection.\n\t * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\treturn this._selection.getFirstPosition();\n\t}\n\n\t/**\n\t * Returns the last position in the selection.\n\t * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\treturn this._selection.getLastPosition();\n\t}\n\n\t/**\n\t * Returns a copy of the first range in the selection.\n\t * First range is the one which {@link module:engine/model/range~Range#start start} position\n\t * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n\t * (not to confuse with the first range added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\treturn this._selection.getFirstRange();\n\t}\n\n\t/**\n\t * Returns a copy of the last range in the selection.\n\t * Last range is the one which {@link module:engine/model/range~Range#end end} position\n\t * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n\t * recently added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\treturn this._selection.getLastRange();\n\t}\n\n\t/**\n\t * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n\t *\n\t * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n\t *\n\t * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n\t * but will not return blocks nested in other blocks.\n\t *\n\t * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<blockQuote>\n\t *\t\t\t<paragraph>b</paragraph>\n\t *\t\t</blockQuote>\n\t *\t\t<paragraph>c]d</paragraph>\n\t *\n\t * In this case the paragraph will also be returned, despite the collapsed selection:\n\t *\n\t *\t\t<paragraph>[]a</paragraph>\n\t *\n\t * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n\t *\n\t *\t\t[<blockA></blockA>\n\t *\t\t<blockB>\n\t *\t\t\t<blockC></blockC>\n\t *\t\t\t<blockD></blockD>\n\t *\t\t</blockB>\n\t *\t\t<blockE></blockE>]\n\t *\n\t * If the selection is inside a block all the inner blocks (A & B) are returned:\n\t *\n\t * \t\t<block>\n\t *\t\t\t<blockA>[a</blockA>\n\t * \t\t\t<blockB>b]</blockB>\n\t * \t\t</block>\n\t *\n\t * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n\t * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<paragraph>b</paragraph>\n\t *\t\t<paragraph>]c</paragraph> // this block will not be returned\n\t *\n\t * @returns {Iterable.<module:engine/model/element~Element>}\n\t */\n\tgetSelectedBlocks() {\n\t\treturn this._selection.getSelectedBlocks();\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\treturn this._selection.getSelectedElement();\n\t}\n\n\t/**\n\t * Checks whether the selection contains the entire content of the given element. This means that selection must start\n\t * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n\t * touching the element's end.\n\t *\n\t * By default, this method will check whether the entire content of the selection's current root is selected.\n\t * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n\t *\n\t * @param {module:engine/model/element~Element} [element=this.anchor.root]\n\t * @returns {Boolean}\n\t */\n\tcontainsEntireContent( element ) {\n\t\treturn this._selection.containsEntireContent( element );\n\t}\n\n\t/**\n\t * Unbinds all events previously bound by document selection.\n\t */\n\tdestroy() {\n\t\tthis._selection.destroy();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._selection.getAttributeKeys();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._selection.getAttributes();\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._selection.getAttribute( key );\n\t}\n\n\t/**\n\t * Checks if the selection has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._selection.hasAttribute( key );\n\t}\n\n\t/**\n\t * Refreshes selection attributes and markers according to the current position in the model.\n\t */\n\trefresh() {\n\t\tthis._selection._updateMarkers();\n\t\tthis._selection._updateAttributes( false );\n\t}\n\n\t/**\n\t * Registers a marker group prefix or a marker name to be collected in the\n\t * {@link ~DocumentSelection#markers selection markers collection}.\n\t *\n\t * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.\n\t *\n\t * @param {String} prefixOrName The marker group prefix or marker name.\n\t */\n\tobserveMarkers( prefixOrName ) {\n\t\tthis._selection.observeMarkers( prefixOrName );\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tselection.is( 'selection' ); // -> true\n\t *\t\tselection.is( 'documentSelection' ); // -> true\n\t *\t\tselection.is( 'model:selection' ); // -> true\n\t *\t\tselection.is( 'model:documentSelection' ); // -> true\n\t *\n\t *\t\tselection.is( 'view:selection' ); // -> false\n\t *\t\tselection.is( 'element' ); // -> false\n\t *\t\tselection.is( 'node' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'selection' ||\n\t\t\ttype == 'model:selection' ||\n\t\t\ttype == 'documentSelection' ||\n\t\t\ttype == 'model:documentSelection';\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelectionFocus\n\t * @protected\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\t_setFocus( itemOrPosition, offset ) {\n\t\tthis._selection.setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/model/selection~Selectable selectable}.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelection\n\t * @protected\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\t_setTo( selectable, placeOrOffset, options ) {\n\t\tthis._selection.setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelectionAttribute\n\t * @protected\n\t * @param {String} key Key of the attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._selection.setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the selection.\n\t * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n\t * event with removed attribute key.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n\t *\n\t * @see module:engine/model/writer~Writer#removeSelectionAttribute\n\t * @protected\n\t * @param {String} key Key of the attribute to remove.\n\t */\n\t_removeAttribute( key ) {\n\t\tthis._selection.removeAttribute( key );\n\t}\n\n\t/**\n\t * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n\t *\n\t * @protected\n\t * @returns {Iterable.<*>}\n\t */\n\t_getStoredAttributes() {\n\t\treturn this._selection._getStoredAttributes();\n\t}\n\n\t/**\n\t * Temporarily changes the gravity of the selection from the left to the right.\n\t *\n\t * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n\t * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n\t * This method allows to temporarily override this behavior by forcing the gravity to the right.\n\t *\n\t * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n\t * of the process.\n\t *\n\t * @see module:engine/model/writer~Writer#overrideSelectionGravity\n\t * @protected\n\t * @returns {String} The unique id which allows restoring the gravity.\n\t */\n\t_overrideGravity() {\n\t\treturn this._selection.overrideGravity();\n\t}\n\n\t/**\n\t * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n\t *\n\t * Restoring the gravity is only possible using the unique identifier returned by\n\t * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n\t * the same number of times it was overridden.\n\t *\n\t * @see module:engine/model/writer~Writer#restoreSelectionGravity\n\t * @protected\n\t * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n\t */\n\t_restoreGravity( uid ) {\n\t\tthis._selection.restoreGravity( uid );\n\t}\n\n\t/**\n\t * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n\t *\n\t * @protected\n\t * @param {String} key Attribute key to convert.\n\t * @returns {String} Converted attribute key, applicable for selection store.\n\t */\n\tstatic _getStoreAttributeKey( key ) {\n\t\treturn storePrefix + key;\n\t}\n\n\t/**\n\t * Checks whether the given attribute key is an attribute stored on an element.\n\t *\n\t * @protected\n\t * @param {String} key\n\t * @returns {Boolean}\n\t */\n\tstatic _isStoreAttributeKey( key ) {\n\t\treturn key.startsWith( storePrefix );\n\t}\n}\n\nmix( DocumentSelection, EmitterMixin );\n\n/**\n * Fired when selection range(s) changed.\n *\n * @event change:range\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed because the structure of the model has been changed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n */\n\n/**\n * Fired when selection attribute changed.\n *\n * @event change:attribute\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed in the model and its attributes were refreshed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n */\n\n/**\n * Fired when selection marker(s) changed.\n *\n * @event change:marker\n * @param {Boolean} directChange This is always set to `false` in case of `change:marker` event as there is no possibility\n * to change markers directly through {@link module:engine/model/documentselection~DocumentSelection} API.\n * See also {@link module:engine/model/documentselection~DocumentSelection#event:change:range} and\n * {@link module:engine/model/documentselection~DocumentSelection#event:change:attribute}.\n * @param {Array.<module:engine/model/markercollection~Marker>} oldMarkers Markers in which the selection was before the change.\n */\n\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\nclass LiveSelection extends Selection {\n\t// Creates an empty live selection for given {@link module:engine/model/document~Document}.\n\t// @param {module:engine/model/document~Document} doc Document which owns this selection.\n\tconstructor( doc ) {\n\t\tsuper();\n\n\t\t// List of selection markers.\n\t\t// Marker is a selection marker when selection range is inside the marker range.\n\t\t//\n\t\t// @type {module:utils/collection~Collection}\n\t\tthis.markers = new Collection( { idProperty: 'name' } );\n\n\t\t// Document which owns this selection.\n\t\t//\n\t\t// @protected\n\t\t// @member {module:engine/model/model~Model}\n\t\tthis._model = doc.model;\n\n\t\t// Document which owns this selection.\n\t\t//\n\t\t// @protected\n\t\t// @member {module:engine/model/document~Document}\n\t\tthis._document = doc;\n\n\t\t// Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n\t\t// last time. Possible values of priority are: `'low'` and `'normal'`.\n\t\t//\n\t\t// Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n\t\t// attributes API are set with `'normal'` priority.\n\t\t//\n\t\t// @private\n\t\t// @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n\t\tthis._attributePriority = new Map();\n\n\t\t// Position to which the selection should be set if the last selection range was moved to the graveyard.\n\t\t// @private\n\t\t// @member {module:engine/model/position~Position} module:engine/model/liveselection~LiveSelection#_selectionRestorePosition\n\t\tthis._selectionRestorePosition = null;\n\n\t\t// Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n\t\t// @private\n\t\t// @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n\t\tthis._hasChangedRange = false;\n\n\t\t// Each overriding gravity adds an UID to the set and each removal removes it.\n\t\t// Gravity is overridden when there's at least one UID in the set.\n\t\t// Gravity is restored when the set is empty.\n\t\t// This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n\t\t// @private\n\t\t// @type {Set}\n\t\tthis._overriddenGravityRegister = new Set();\n\n\t\t// Prefixes of marker names that should affect `LiveSelection#markers` collection.\n\t\t// @private\n\t\t// @type {Set}\n\t\tthis._observedMarkers = new Set();\n\n\t\t// Ensure selection is correct after each operation.\n\t\tthis.listenTo( this._model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( !operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fix selection if the last range was removed from it and we have a position to which we can restore the selection.\n\t\t\tif ( this._ranges.length == 0 && this._selectionRestorePosition ) {\n\t\t\t\tthis._fixGraveyardSelection( this._selectionRestorePosition );\n\t\t\t}\n\n\t\t\t// \"Forget\" the restore position even if it was not \"used\".\n\t\t\tthis._selectionRestorePosition = null;\n\n\t\t\tif ( this._hasChangedRange ) {\n\t\t\t\tthis._hasChangedRange = false;\n\t\t\t\tthis.fire( 'change:range', { directChange: false } );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\n\t\t// Ensure selection is correct and up to date after each range change.\n\t\tthis.on( 'change:range', () => {\n\t\t\tfor ( const range of this.getRanges() ) {\n\t\t\t\tif ( !this._document._validateSelectionRange( range ) ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n\t\t\t\t\t * starts or ends at incorrect position.\n\t\t\t\t\t *\n\t\t\t\t\t * @error document-selection-wrong-position\n\t\t\t\t\t * @param {module:engine/model/range~Range} range\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t'document-selection-wrong-position',\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t{ range }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Update markers data stored by the selection after each marker change.\n\t\t// This handles only marker changes done through marker operations (not model tree changes).\n\t\tthis.listenTo( this._model.markers, 'update', ( evt, marker, oldRange, newRange ) => {\n\t\t\tthis._updateMarker( marker, newRange );\n\t\t} );\n\n\t\t// Ensure selection is up to date after each change block.\n\t\tthis.listenTo( this._document, 'change', ( evt, batch ) => {\n\t\t\tclearAttributesStoredInElement( this._model, batch );\n\t\t} );\n\t}\n\n\tget isCollapsed() {\n\t\tconst length = this._ranges.length;\n\n\t\treturn length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;\n\t}\n\n\tget anchor() {\n\t\treturn super.anchor || this._document._getDefaultRange().start;\n\t}\n\n\tget focus() {\n\t\treturn super.focus || this._document._getDefaultRange().end;\n\t}\n\n\tget rangeCount() {\n\t\treturn this._ranges.length ? this._ranges.length : 1;\n\t}\n\n\t// Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n\t// {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n\t//\n\t// @readonly\n\t// @type {Boolean}\n\tget hasOwnRange() {\n\t\treturn this._ranges.length > 0;\n\t}\n\n\t// When set to `true` then selection attributes on node before the caret won't be taken\n\t// into consideration while updating selection attributes.\n\t//\n\t// @protected\n\t// @type {Boolean}\n\tget isGravityOverridden() {\n\t\treturn !!this._overriddenGravityRegister.size;\n\t}\n\n\t// Unbinds all events previously bound by live selection.\n\tdestroy() {\n\t\tfor ( let i = 0; i < this._ranges.length; i++ ) {\n\t\t\tthis._ranges[ i ].detach();\n\t\t}\n\n\t\tthis.stopListening();\n\t}\n\n\t* getRanges() {\n\t\tif ( this._ranges.length ) {\n\t\t\tyield* super.getRanges();\n\t\t} else {\n\t\t\tyield this._document._getDefaultRange();\n\t\t}\n\t}\n\n\tgetFirstRange() {\n\t\treturn super.getFirstRange() || this._document._getDefaultRange();\n\t}\n\n\tgetLastRange() {\n\t\treturn super.getLastRange() || this._document._getDefaultRange();\n\t}\n\n\tsetTo( selectable, optionsOrPlaceOrOffset, options ) {\n\t\tsuper.setTo( selectable, optionsOrPlaceOrOffset, options );\n\t\tthis._updateAttributes( true );\n\t\tthis._updateMarkers();\n\t}\n\n\tsetFocus( itemOrPosition, offset ) {\n\t\tsuper.setFocus( itemOrPosition, offset );\n\t\tthis._updateAttributes( true );\n\t\tthis._updateMarkers();\n\t}\n\n\tsetAttribute( key, value ) {\n\t\tif ( this._setAttribute( key, value ) ) {\n\t\t\t// Fire event with exact data.\n\t\t\tconst attributeKeys = [ key ];\n\t\t\tthis.fire( 'change:attribute', { attributeKeys, directChange: true } );\n\t\t}\n\t}\n\n\tremoveAttribute( key ) {\n\t\tif ( this._removeAttribute( key ) ) {\n\t\t\t// Fire event with exact data.\n\t\t\tconst attributeKeys = [ key ];\n\t\t\tthis.fire( 'change:attribute', { attributeKeys, directChange: true } );\n\t\t}\n\t}\n\n\toverrideGravity() {\n\t\tconst overrideUid = uid();\n\n\t\t// Remember that another overriding has been requested. It will need to be removed\n\t\t// before the gravity is to be restored.\n\t\tthis._overriddenGravityRegister.add( overrideUid );\n\n\t\tif ( this._overriddenGravityRegister.size === 1 ) {\n\t\t\tthis._updateAttributes( true );\n\t\t}\n\n\t\treturn overrideUid;\n\t}\n\n\trestoreGravity( uid ) {\n\t\tif ( !this._overriddenGravityRegister.has( uid ) ) {\n\t\t\t/**\n\t\t\t * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n\t\t\t * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n\t\t\t *\n\t\t\t * @error document-selection-gravity-wrong-restore\n\t\t\t * @param {String} uid The unique identifier returned by\n\t\t\t * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'document-selection-gravity-wrong-restore',\n\t\t\t\tthis,\n\t\t\t\t{ uid }\n\t\t\t);\n\t\t}\n\n\t\tthis._overriddenGravityRegister.delete( uid );\n\n\t\t// Restore gravity only when all overriding have been restored.\n\t\tif ( !this.isGravityOverridden ) {\n\t\t\tthis._updateAttributes( true );\n\t\t}\n\t}\n\n\tobserveMarkers( prefixOrName ) {\n\t\tthis._observedMarkers.add( prefixOrName );\n\t\tthis._updateMarkers();\n\t}\n\n\t_popRange() {\n\t\tthis._ranges.pop().detach();\n\t}\n\n\t_pushRange( range ) {\n\t\tconst liveRange = this._prepareRange( range );\n\n\t\t// `undefined` is returned when given `range` is in graveyard root.\n\t\tif ( liveRange ) {\n\t\t\tthis._ranges.push( liveRange );\n\t\t}\n\t}\n\n\t// Prepares given range to be added to selection. Checks if it is correct,\n\t// converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n\t// and sets listeners listening to the range's change event.\n\t//\n\t// @private\n\t// @param {module:engine/model/range~Range} range\n\t_prepareRange( range ) {\n\t\tthis._checkRange( range );\n\n\t\tif ( range.root == this._document.graveyard ) {\n\t\t\t// @if CK_DEBUG // console.warn( 'Trying to add a Range that is in the graveyard root. Range rejected.' );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst liveRange = LiveRange.fromRange( range );\n\n\t\t// If selection range is moved to the graveyard remove it from the selection object.\n\t\t// Also, save some data that can be used to restore selection later, on `Model#applyOperation` event.\n\t\tliveRange.on( 'change:range', ( evt, oldRange, data ) => {\n\t\t\tthis._hasChangedRange = true;\n\n\t\t\tif ( liveRange.root == this._document.graveyard ) {\n\t\t\t\tthis._selectionRestorePosition = data.deletionPosition;\n\n\t\t\t\tconst index = this._ranges.indexOf( liveRange );\n\t\t\t\tthis._ranges.splice( index, 1 );\n\t\t\t\tliveRange.detach();\n\t\t\t}\n\t\t} );\n\n\t\treturn liveRange;\n\t}\n\n\t_updateMarkers() {\n\t\tif ( !this._observedMarkers.size ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markers = [];\n\t\tlet changed = false;\n\n\t\tfor ( const marker of this._model.markers ) {\n\t\t\tconst markerGroup = marker.name.split( ':', 1 )[ 0 ];\n\n\t\t\tif ( !this._observedMarkers.has( markerGroup ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tfor ( const selectionRange of this.getRanges() ) {\n\t\t\t\tif ( markerRange.containsRange( selectionRange, !selectionRange.isCollapsed ) ) {\n\t\t\t\t\tmarkers.push( marker );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst oldMarkers = Array.from( this.markers );\n\n\t\tfor ( const marker of markers ) {\n\t\t\tif ( !this.markers.has( marker ) ) {\n\t\t\t\tthis.markers.add( marker );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tfor ( const marker of Array.from( this.markers ) ) {\n\t\t\tif ( !markers.includes( marker ) ) {\n\t\t\t\tthis.markers.remove( marker );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( changed ) {\n\t\t\tthis.fire( 'change:marker', { oldMarkers, directChange: false } );\n\t\t}\n\t}\n\n\t_updateMarker( marker, markerRange ) {\n\t\tconst markerGroup = marker.name.split( ':', 1 )[ 0 ];\n\n\t\tif ( !this._observedMarkers.has( markerGroup ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet changed = false;\n\n\t\tconst oldMarkers = Array.from( this.markers );\n\t\tconst hasMarker = this.markers.has( marker );\n\n\t\tif ( !markerRange ) {\n\t\t\tif ( hasMarker ) {\n\t\t\t\tthis.markers.remove( marker );\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\tlet contained = false;\n\n\t\t\tfor ( const selectionRange of this.getRanges() ) {\n\t\t\t\tif ( markerRange.containsRange( selectionRange, !selectionRange.isCollapsed ) ) {\n\t\t\t\t\tcontained = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( contained && !hasMarker ) {\n\t\t\t\tthis.markers.add( marker );\n\n\t\t\t\tchanged = true;\n\t\t\t} else if ( !contained && hasMarker ) {\n\t\t\t\tthis.markers.remove( marker );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( changed ) {\n\t\t\tthis.fire( 'change:marker', { oldMarkers, directChange: false } );\n\t\t}\n\t}\n\n\t// Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n\t//\n\t// @protected\n\t// @param {Boolean} clearAll\n\t// @fires change:attribute\n\t_updateAttributes( clearAll ) {\n\t\tconst newAttributes = toMap( this._getSurroundingAttributes() );\n\t\tconst oldAttributes = toMap( this.getAttributes() );\n\n\t\tif ( clearAll ) {\n\t\t\t// If `clearAll` remove all attributes and reset priorities.\n\t\t\tthis._attributePriority = new Map();\n\t\t\tthis._attrs = new Map();\n\t\t} else {\n\t\t\t// If not, remove only attributes added with `low` priority.\n\t\t\tfor ( const [ key, priority ] of this._attributePriority ) {\n\t\t\t\tif ( priority == 'low' ) {\n\t\t\t\t\tthis._attrs.delete( key );\n\t\t\t\t\tthis._attributePriority.delete( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._setAttributesTo( newAttributes );\n\n\t\t// Let's evaluate which attributes really changed.\n\t\tconst changed = [];\n\n\t\t// First, loop through all attributes that are set on selection right now.\n\t\t// Check which of them are different than old attributes.\n\t\tfor ( const [ newKey, newValue ] of this.getAttributes() ) {\n\t\t\tif ( !oldAttributes.has( newKey ) || oldAttributes.get( newKey ) !== newValue ) {\n\t\t\t\tchanged.push( newKey );\n\t\t\t}\n\t\t}\n\n\t\t// Then, check which of old attributes got removed.\n\t\tfor ( const [ oldKey ] of oldAttributes ) {\n\t\t\tif ( !this.hasAttribute( oldKey ) ) {\n\t\t\t\tchanged.push( oldKey );\n\t\t\t}\n\t\t}\n\n\t\t// Fire event with exact data (fire only if anything changed).\n\t\tif ( changed.length > 0 ) {\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: changed, directChange: false } );\n\t\t}\n\t}\n\n\t// Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n\t// parameter).\n\t//\n\t// @private\n\t// @param {String} key Attribute key.\n\t// @param {*} value Attribute value.\n\t// @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n\t// is caused by `Batch` API.\n\t// @returns {Boolean} Whether value has changed.\n\t_setAttribute( key, value, directChange = true ) {\n\t\tconst priority = directChange ? 'normal' : 'low';\n\n\t\tif ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {\n\t\t\t// Priority too low.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst oldValue = super.getAttribute( key );\n\n\t\t// Don't do anything if value has not changed.\n\t\tif ( oldValue === value ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._attrs.set( key, value );\n\n\t\t// Update priorities map.\n\t\tthis._attributePriority.set( key, priority );\n\n\t\treturn true;\n\t}\n\n\t// Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n\t// parameter).\n\t//\n\t// NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n\t// be changed according to `directChange` parameter.\n\t//\n\t// @private\n\t// @param {String} key Attribute key.\n\t// @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n\t// is caused by `Batch` API.\n\t// @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n\t// existing attribute had higher priority.\n\t_removeAttribute( key, directChange = true ) {\n\t\tconst priority = directChange ? 'normal' : 'low';\n\n\t\tif ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {\n\t\t\t// Priority too low.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Update priorities map.\n\t\tthis._attributePriority.set( key, priority );\n\n\t\t// Don't do anything if value has not changed.\n\t\tif ( !super.hasAttribute( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._attrs.delete( key );\n\n\t\treturn true;\n\t}\n\n\t// Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n\t// `directChange` parameter).\n\t//\n\t// @private\n\t// @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n\t// @returns {Set.<String>} Changed attribute keys.\n\t_setAttributesTo( attrs ) {\n\t\tconst changed = new Set();\n\n\t\tfor ( const [ oldKey, oldValue ] of this.getAttributes() ) {\n\t\t\t// Do not remove attribute if attribute with same key and value is about to be set.\n\t\t\tif ( attrs.get( oldKey ) === oldValue ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// All rest attributes will be removed so changed attributes won't change .\n\t\t\tthis._removeAttribute( oldKey, false );\n\t\t}\n\n\t\tfor ( const [ key, value ] of attrs ) {\n\t\t\t// Attribute may not be set because of attributes or because same key/value is already added.\n\t\t\tconst gotAdded = this._setAttribute( key, value, false );\n\n\t\t\tif ( gotAdded ) {\n\t\t\t\tchanged.add( key );\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\t// Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n\t//\n\t// @protected\n\t// @returns {Iterable.<*>}\n\t* _getStoredAttributes() {\n\t\tconst selectionParent = this.getFirstPosition().parent;\n\n\t\tif ( this.isCollapsed && selectionParent.isEmpty ) {\n\t\t\tfor ( const key of selectionParent.getAttributeKeys() ) {\n\t\t\t\tif ( key.startsWith( storePrefix ) ) {\n\t\t\t\t\tconst realKey = key.substr( storePrefix.length );\n\n\t\t\t\t\tyield [ realKey, selectionParent.getAttribute( key ) ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Checks model text nodes that are closest to the selection's first position and returns attributes of first\n\t// found element. If there are no text nodes in selection's first position parent, it returns selection\n\t// attributes stored in that parent.\n\t//\n\t// @private\n\t// @returns {Iterable.<*>} Collection of attributes.\n\t_getSurroundingAttributes() {\n\t\tconst position = this.getFirstPosition();\n\t\tconst schema = this._model.schema;\n\n\t\tlet attrs = null;\n\n\t\tif ( !this.isCollapsed ) {\n\t\t\t// 1. If selection is a range...\n\t\t\tconst range = this.getFirstRange();\n\n\t\t\t// ...look for a first character node in that range and take attributes from it.\n\t\t\tfor ( const value of range ) {\n\t\t\t\t// If the item is an object, we don't want to get attributes from its children.\n\t\t\t\tif ( value.item.is( 'element' ) && schema.isObject( value.item ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( value.type == 'text' ) {\n\t\t\t\t\tattrs = value.item.getAttributes();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// 2. If the selection is a caret or the range does not contain a character node...\n\n\t\t\tconst nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n\t\t\tconst nodeAfter = position.textNode ? position.textNode : position.nodeAfter;\n\n\t\t\t// When gravity is overridden then don't take node before into consideration.\n\t\t\tif ( !this.isGravityOverridden ) {\n\t\t\t\t// ...look at the node before caret and take attributes from it if it is a character node.\n\t\t\t\tattrs = getAttrsIfCharacter( nodeBefore );\n\t\t\t}\n\n\t\t\t// 3. If not, look at the node after caret...\n\t\t\tif ( !attrs ) {\n\t\t\t\tattrs = getAttrsIfCharacter( nodeAfter );\n\t\t\t}\n\n\t\t\t// 4. If not, try to find the first character on the left, that is in the same node.\n\t\t\t// When gravity is overridden then don't take node before into consideration.\n\t\t\tif ( !this.isGravityOverridden && !attrs ) {\n\t\t\t\tlet node = nodeBefore;\n\n\t\t\t\twhile ( node && !schema.isInline( node ) && !attrs ) {\n\t\t\t\t\tnode = node.previousSibling;\n\t\t\t\t\tattrs = getAttrsIfCharacter( node );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 5. If not found, try to find the first character on the right, that is in the same node.\n\t\t\tif ( !attrs ) {\n\t\t\t\tlet node = nodeAfter;\n\n\t\t\t\twhile ( node && !schema.isInline( node ) && !attrs ) {\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tattrs = getAttrsIfCharacter( node );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 6. If not found, selection should retrieve attributes from parent.\n\t\t\tif ( !attrs ) {\n\t\t\t\tattrs = this._getStoredAttributes();\n\t\t\t}\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\t// Fixes the selection after all its ranges got removed.\n\t//\n\t// @private\n\t// @param {module:engine/model/position~Position} deletionPosition Position where the deletion happened.\n\t_fixGraveyardSelection( deletionPosition ) {\n\t\t// Find a range that is a correct selection range and is closest to the position where the deletion happened.\n\t\tconst selectionRange = this._model.schema.getNearestSelectionRange( deletionPosition );\n\n\t\t// If nearest valid selection range has been found - add it in the place of old range.\n\t\tif ( selectionRange ) {\n\t\t\t// Check the range, convert it to live range, bind events, etc.\n\t\t\tthis._pushRange( selectionRange );\n\t\t}\n\t\t// If nearest valid selection range cannot be found don't add any range. Selection will be set to the default range.\n\t}\n}\n\n// Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\nfunction getAttrsIfCharacter( node ) {\n\tif ( node instanceof TextProxy || node instanceof Text ) {\n\t\treturn node.getAttributes();\n\t}\n\n\treturn null;\n}\n\n// Removes selection attributes from element which is not empty anymore.\n//\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\nfunction clearAttributesStoredInElement( model, batch ) {\n\tconst differ = model.document.differ;\n\n\tfor ( const entry of differ.getChanges() ) {\n\t\tif ( entry.type != 'insert' ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst changeParent = entry.position.parent;\n\t\tconst isNoLongerEmpty = entry.length === changeParent.maxOffset;\n\n\t\tif ( isNoLongerEmpty ) {\n\t\t\tmodel.enqueueChange( batch, writer => {\n\t\t\t\tconst storedAttributes = Array.from( changeParent.getAttributeKeys() )\n\t\t\t\t\t.filter( key => key.startsWith( storePrefix ) );\n\n\t\t\t\tfor ( const key of storedAttributes ) {\n\t\t\t\t\twriter.removeAttribute( key, changeParent );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}