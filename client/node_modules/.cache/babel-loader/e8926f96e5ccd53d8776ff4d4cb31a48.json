{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/treewalker\n */\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\n\nexport default class TreeWalker {\n  /**\n   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n   *\n   * @constructor\n   * @param {Object} options Object with configuration.\n   * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n   * @param {module:engine/view/position~Position} [options.startPosition] Starting position.\n   * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n   * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from\n   * {@link module:engine/view/text~Text} should be returned as one {@link module:engine/view/text~Text} (`false`) ore one by one as\n   * {@link module:engine/view/textproxy~TextProxy} (`true`).\n   * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n   * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n   * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n   * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n   * each {@link module:engine/view/element~Element} will be returned once, while if the option is `false` they might be returned\n   * twice: for `'elementStart'` and `'elementEnd'`.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.boundaries && !options.startPosition) {\n      /**\n       * Neither boundaries nor starting position have been defined.\n       *\n       * @error view-tree-walker-no-start-position\n       */\n      throw new CKEditorError('view-tree-walker-no-start-position', null);\n    }\n\n    if (options.direction && options.direction != 'forward' && options.direction != 'backward') {\n      /**\n       * Only `backward` and `forward` direction allowed.\n       *\n       * @error view-tree-walker-unknown-direction\n       */\n      throw new CKEditorError('view-tree-walker-unknown-direction', options.startPosition, {\n        direction: options.direction\n      });\n    }\n    /**\n     * Iterator boundaries.\n     *\n     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n     * on the start of boundary, then `{ done: true }` is returned.\n     *\n     * If boundaries are not defined they are set before first and after last child of the root node.\n     *\n     * @readonly\n     * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries\n     */\n\n\n    this.boundaries = options.boundaries || null;\n    /**\n     * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is\n     * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position\n     */\n\n    if (options.startPosition) {\n      this.position = Position._createAt(options.startPosition);\n    } else {\n      this.position = Position._createAt(options.boundaries[options.direction == 'backward' ? 'end' : 'start']);\n    }\n    /**\n     * Walking direction. Defaults `'forward'`.\n     *\n     * @readonly\n     * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction\n     */\n\n\n    this.direction = options.direction || 'forward';\n    /**\n     * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one\n     * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters\n     */\n\n    this.singleCharacters = !!options.singleCharacters;\n    /**\n     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n     * iterated node will not be returned along with `elementEnd` tag.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow\n     */\n\n    this.shallow = !!options.shallow;\n    /**\n     * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not\n     * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.\n     * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd\n     */\n\n    this.ignoreElementEnd = !!options.ignoreElementEnd;\n    /**\n     * Start boundary parent.\n     *\n     * @private\n     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent\n     */\n\n    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n    /**\n     * End boundary parent.\n     *\n     * @private\n     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent\n     */\n\n    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n   *\n   * For example:\n   *\n   * \t\twalker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n   * \t\twalker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]\n   * \t\twalker.skip( value => false ); // Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   */\n\n\n  skip(skip) {\n    let done, value, prevPosition;\n\n    do {\n      prevPosition = this.position;\n      ({\n        done,\n        value\n      } = this.next());\n    } while (!done && skip(value));\n\n    if (!done) {\n      this.position = prevPosition;\n    }\n  }\n  /**\n   * Gets the next tree walker's value.\n   *\n   * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning\n   * information about taken step.\n   */\n\n\n  next() {\n    if (this.direction == 'forward') {\n      return this._next();\n    } else {\n      return this._previous();\n    }\n  }\n  /**\n   * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.\n   * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n   */\n\n\n  _next() {\n    let position = this.position.clone();\n    const previousPosition = this.position;\n    const parent = position.parent; // We are at the end of the root.\n\n    if (parent.parent === null && position.offset === parent.childCount) {\n      return {\n        done: true\n      };\n    } // We reached the walker boundary.\n\n\n    if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n      return {\n        done: true\n      };\n    } // Get node just after current position.\n\n\n    let node; // Text is a specific parent because it contains string instead of child nodes.\n\n    if (parent instanceof Text) {\n      if (position.isAtEnd) {\n        // Prevent returning \"elementEnd\" for Text node. Skip that value and return the next walker step.\n        this.position = Position._createAfter(parent);\n        return this._next();\n      }\n\n      node = parent.data[position.offset];\n    } else {\n      node = parent.getChild(position.offset);\n    }\n\n    if (node instanceof Element) {\n      if (!this.shallow) {\n        position = new Position(node, 0);\n      } else {\n        position.offset++;\n      }\n\n      this.position = position;\n      return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n    } else if (node instanceof Text) {\n      if (this.singleCharacters) {\n        position = new Position(node, 0);\n        this.position = position;\n        return this._next();\n      } else {\n        let charactersCount = node.data.length;\n        let item; // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\n        if (node == this._boundaryEndParent) {\n          charactersCount = this.boundaries.end.offset;\n          item = new TextProxy(node, 0, charactersCount);\n          position = Position._createAfter(item);\n        } else {\n          item = new TextProxy(node, 0, node.data.length); // If not just keep moving forward.\n\n          position.offset++;\n        }\n\n        this.position = position;\n        return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n      }\n    } else if (typeof node == 'string') {\n      let textLength;\n\n      if (this.singleCharacters) {\n        textLength = 1;\n      } else {\n        // Check if text stick out of walker range.\n        const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;\n        textLength = endOffset - position.offset;\n      }\n\n      const textProxy = new TextProxy(parent, position.offset, textLength);\n      position.offset += textLength;\n      this.position = position;\n      return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n    } else {\n      // `node` is not set, we reached the end of current `parent`.\n      position = Position._createAfter(parent);\n      this.position = position;\n\n      if (this.ignoreElementEnd) {\n        return this._next();\n      } else {\n        return this._formatReturnValue('elementEnd', parent, previousPosition, position);\n      }\n    }\n  }\n  /**\n   * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done True if iterator is done.\n   * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n   */\n\n\n  _previous() {\n    let position = this.position.clone();\n    const previousPosition = this.position;\n    const parent = position.parent; // We are at the beginning of the root.\n\n    if (parent.parent === null && position.offset === 0) {\n      return {\n        done: true\n      };\n    } // We reached the walker boundary.\n\n\n    if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n      return {\n        done: true\n      };\n    } // Get node just before current position.\n\n\n    let node; // Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.\n\n    if (parent instanceof Text) {\n      if (position.isAtStart) {\n        // Prevent returning \"elementStart\" for Text node. Skip that value and return the next walker step.\n        this.position = Position._createBefore(parent);\n        return this._previous();\n      }\n\n      node = parent.data[position.offset - 1];\n    } else {\n      node = parent.getChild(position.offset - 1);\n    }\n\n    if (node instanceof Element) {\n      if (!this.shallow) {\n        position = new Position(node, node.childCount);\n        this.position = position;\n\n        if (this.ignoreElementEnd) {\n          return this._previous();\n        } else {\n          return this._formatReturnValue('elementEnd', node, previousPosition, position);\n        }\n      } else {\n        position.offset--;\n        this.position = position;\n        return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n      }\n    } else if (node instanceof Text) {\n      if (this.singleCharacters) {\n        position = new Position(node, node.data.length);\n        this.position = position;\n        return this._previous();\n      } else {\n        let charactersCount = node.data.length;\n        let item; // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\n        if (node == this._boundaryStartParent) {\n          const offset = this.boundaries.start.offset;\n          item = new TextProxy(node, offset, node.data.length - offset);\n          charactersCount = item.data.length;\n          position = Position._createBefore(item);\n        } else {\n          item = new TextProxy(node, 0, node.data.length); // If not just keep moving backward.\n\n          position.offset--;\n        }\n\n        this.position = position;\n        return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n      }\n    } else if (typeof node == 'string') {\n      let textLength;\n\n      if (!this.singleCharacters) {\n        // Check if text stick out of walker range.\n        const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;\n        textLength = position.offset - startOffset;\n      } else {\n        textLength = 1;\n      }\n\n      position.offset -= textLength;\n      const textProxy = new TextProxy(parent, position.offset, textLength);\n      this.position = position;\n      return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n    } else {\n      // `node` is not set, we reached the beginning of current `parent`.\n      position = Position._createBefore(parent);\n      this.position = position;\n      return this._formatReturnValue('elementStart', parent, previousPosition, position, 1);\n    }\n  }\n  /**\n   * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.\n   *\n   * @private\n   * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.\n   * @param {module:engine/view/item~Item} item Item between old and new position.\n   * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.\n   * @param {module:engine/view/position~Position} nextPosition Next position of iterator.\n   * @param {Number} [length] Length of the item.\n   * @returns {module:engine/view/treewalker~TreeWalkerValue}\n   */\n\n\n  _formatReturnValue(type, item, previousPosition, nextPosition, length) {\n    // Text is a specific parent, because contains string instead of children.\n    // Walker doesn't enter to the Text except situations when walker is iterating over every single character,\n    // or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text\n    // we move it just before or just after Text.\n    if (item instanceof TextProxy) {\n      // Position is at the end of Text.\n      if (item.offsetInText + item.data.length == item.textNode.data.length) {\n        if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {\n          nextPosition = Position._createAfter(item.textNode); // When we change nextPosition of returned value we need also update walker current position.\n\n          this.position = nextPosition;\n        } else {\n          previousPosition = Position._createAfter(item.textNode);\n        }\n      } // Position is at the begining ot the text.\n\n\n      if (item.offsetInText === 0) {\n        if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {\n          nextPosition = Position._createBefore(item.textNode); // When we change nextPosition of returned value we need also update walker current position.\n\n          this.position = nextPosition;\n        } else {\n          previousPosition = Position._createBefore(item.textNode);\n        }\n      }\n    }\n\n    return {\n      done: false,\n      value: {\n        type,\n        item,\n        previousPosition,\n        nextPosition,\n        length\n      }\n    };\n  }\n\n}\n/**\n * Type of the step made by {@link module:engine/view/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end\n * of node, or `'text'` if walker traversed over single and multiple characters.\n * For {@link module:engine/view/text~Text} `elementStart` and `elementEnd` is not returned.\n *\n * @typedef {String} module:engine/view/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/view/treewalker~TreeWalker} when traversing tree view.\n *\n * @typedef {Object} module:engine/view/treewalker~TreeWalkerValue\n * @property {module:engine/view/treewalker~TreeWalkerValueType} type\n * @property {module:engine/view/item~Item} item Item between the old and the new positions\n * of the tree walker.\n * @property {module:engine/view/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {module:engine/view/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {Number} [length] Length of the item. For `'elementStart'` it is `1`. For `'text'` it is\n * the length of that text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js"],"names":["Element","Text","TextProxy","Position","CKEditorError","TreeWalker","constructor","options","boundaries","startPosition","direction","position","_createAt","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","start","parent","_boundaryEndParent","end","Symbol","iterator","skip","done","value","prevPosition","next","_next","_previous","clone","previousPosition","offset","childCount","node","isAtEnd","_createAfter","data","getChild","_formatReturnValue","charactersCount","length","item","textLength","endOffset","textProxy","isAtStart","_createBefore","startOffset","type","nextPosition","offsetInText","textNode","isEqual"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/treewalker\n */\n\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n\t/**\n\t * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n\t *\n\t * @constructor\n\t * @param {Object} options Object with configuration.\n\t * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {module:engine/view/position~Position} [options.startPosition] Starting position.\n\t * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n\t * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from\n\t * {@link module:engine/view/text~Text} should be returned as one {@link module:engine/view/text~Text} (`false`) ore one by one as\n\t * {@link module:engine/view/textproxy~TextProxy} (`true`).\n\t * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n\t * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n\t * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n\t * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n\t * each {@link module:engine/view/element~Element} will be returned once, while if the option is `false` they might be returned\n\t * twice: for `'elementStart'` and `'elementEnd'`.\n\t */\n\tconstructor( options = {} ) {\n\t\tif ( !options.boundaries && !options.startPosition ) {\n\t\t\t/**\n\t\t\t * Neither boundaries nor starting position have been defined.\n\t\t\t *\n\t\t\t * @error view-tree-walker-no-start-position\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-tree-walker-no-start-position',\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tif ( options.direction && options.direction != 'forward' && options.direction != 'backward' ) {\n\t\t\t/**\n\t\t\t * Only `backward` and `forward` direction allowed.\n\t\t\t *\n\t\t\t * @error view-tree-walker-unknown-direction\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-tree-walker-unknown-direction', options.startPosition, { direction: options.direction } );\n\t\t}\n\n\t\t/**\n\t\t * Iterator boundaries.\n\t\t *\n\t\t * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n\t\t * on the start of boundary, then `{ done: true }` is returned.\n\t\t *\n\t\t * If boundaries are not defined they are set before first and after last child of the root node.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries\n\t\t */\n\t\tthis.boundaries = options.boundaries || null;\n\n\t\t/**\n\t\t * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is\n\t\t * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position\n\t\t */\n\t\tif ( options.startPosition ) {\n\t\t\tthis.position = Position._createAt( options.startPosition );\n\t\t} else {\n\t\t\tthis.position = Position._createAt( options.boundaries[ options.direction == 'backward' ? 'end' : 'start' ] );\n\t\t}\n\n\t\t/**\n\t\t * Walking direction. Defaults `'forward'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction\n\t\t */\n\t\tthis.direction = options.direction || 'forward';\n\n\t\t/**\n\t\t * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one\n\t\t * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters\n\t\t */\n\t\tthis.singleCharacters = !!options.singleCharacters;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n\t\t * iterated node will not be returned along with `elementEnd` tag.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow\n\t\t */\n\t\tthis.shallow = !!options.shallow;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not\n\t\t * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.\n\t\t * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd\n\t\t */\n\t\tthis.ignoreElementEnd = !!options.ignoreElementEnd;\n\n\t\t/**\n\t\t * Start boundary parent.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent\n\t\t */\n\t\tthis._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n\n\t\t/**\n\t\t * End boundary parent.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent\n\t\t */\n\t\tthis._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n\t *\n\t * For example:\n\t *\n\t * \t\twalker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n\t * \t\twalker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]\n\t * \t\twalker.skip( value => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t */\n\tskip( skip ) {\n\t\tlet done, value, prevPosition;\n\n\t\tdo {\n\t\t\tprevPosition = this.position;\n\n\t\t\t( { done, value } = this.next() );\n\t\t} while ( !done && skip( value ) );\n\n\t\tif ( !done ) {\n\t\t\tthis.position = prevPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the next tree walker's value.\n\t *\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning\n\t * information about taken step.\n\t */\n\tnext() {\n\t\tif ( this.direction == 'forward' ) {\n\t\t\treturn this._next();\n\t\t} else {\n\t\t\treturn this._previous();\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_next() {\n\t\tlet position = this.position.clone();\n\t\tconst previousPosition = this.position;\n\t\tconst parent = position.parent;\n\n\t\t// We are at the end of the root.\n\t\tif ( parent.parent === null && position.offset === parent.childCount ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just after current position.\n\t\tlet node;\n\n\t\t// Text is a specific parent because it contains string instead of child nodes.\n\t\tif ( parent instanceof Text ) {\n\t\t\tif ( position.isAtEnd ) {\n\t\t\t\t// Prevent returning \"elementEnd\" for Text node. Skip that value and return the next walker step.\n\t\t\t\tthis.position = Position._createAfter( parent );\n\n\t\t\t\treturn this._next();\n\t\t\t}\n\n\t\t\tnode = parent.data[ position.offset ];\n\t\t} else {\n\t\t\tnode = parent.getChild( position.offset );\n\t\t}\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition = new Position( node, 0 );\n\t\t\t} else {\n\t\t\t\tposition.offset++;\n\t\t\t}\n\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t} else if ( node instanceof Text ) {\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tposition = new Position( node, 0 );\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\tlet charactersCount = node.data.length;\n\t\t\t\tlet item;\n\n\t\t\t\t// If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\t\t\t\tif ( node == this._boundaryEndParent ) {\n\t\t\t\t\tcharactersCount = this.boundaries.end.offset;\n\t\t\t\t\titem = new TextProxy( node, 0, charactersCount );\n\t\t\t\t\tposition = Position._createAfter( item );\n\t\t\t\t} else {\n\t\t\t\t\titem = new TextProxy( node, 0, node.data.length );\n\t\t\t\t\t// If not just keep moving forward.\n\t\t\t\t\tposition.offset++;\n\t\t\t\t}\n\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t\t}\n\t\t} else if ( typeof node == 'string' ) {\n\t\t\tlet textLength;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\ttextLength = 1;\n\t\t\t} else {\n\t\t\t\t// Check if text stick out of walker range.\n\t\t\t\tconst endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;\n\n\t\t\t\ttextLength = endOffset - position.offset;\n\t\t\t}\n\n\t\t\tconst textProxy = new TextProxy( parent, position.offset, textLength );\n\n\t\t\tposition.offset += textLength;\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the end of current `parent`.\n\t\t\tposition = Position._createAfter( parent );\n\t\t\tthis.position = position;\n\n\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\treturn this._formatReturnValue( 'elementEnd', parent, previousPosition, position );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_previous() {\n\t\tlet position = this.position.clone();\n\t\tconst previousPosition = this.position;\n\t\tconst parent = position.parent;\n\n\t\t// We are at the beginning of the root.\n\t\tif ( parent.parent === null && position.offset === 0 ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just before current position.\n\t\tlet node;\n\n\t\t// Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.\n\t\tif ( parent instanceof Text ) {\n\t\t\tif ( position.isAtStart ) {\n\t\t\t\t// Prevent returning \"elementStart\" for Text node. Skip that value and return the next walker step.\n\t\t\t\tthis.position = Position._createBefore( parent );\n\n\t\t\t\treturn this._previous();\n\t\t\t}\n\n\t\t\tnode = parent.data[ position.offset - 1 ];\n\t\t} else {\n\t\t\tnode = parent.getChild( position.offset - 1 );\n\t\t}\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition = new Position( node, node.childCount );\n\t\t\t\tthis.position = position;\n\n\t\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\t\treturn this._previous();\n\t\t\t\t} else {\n\t\t\t\t\treturn this._formatReturnValue( 'elementEnd', node, previousPosition, position );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tposition.offset--;\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t\t}\n\t\t} else if ( node instanceof Text ) {\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tposition = new Position( node, node.data.length );\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._previous();\n\t\t\t} else {\n\t\t\t\tlet charactersCount = node.data.length;\n\t\t\t\tlet item;\n\n\t\t\t\t// If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\t\t\t\tif ( node == this._boundaryStartParent ) {\n\t\t\t\t\tconst offset = this.boundaries.start.offset;\n\n\t\t\t\t\titem = new TextProxy( node, offset, node.data.length - offset );\n\t\t\t\t\tcharactersCount = item.data.length;\n\t\t\t\t\tposition = Position._createBefore( item );\n\t\t\t\t} else {\n\t\t\t\t\titem = new TextProxy( node, 0, node.data.length );\n\t\t\t\t\t// If not just keep moving backward.\n\t\t\t\t\tposition.offset--;\n\t\t\t\t}\n\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t\t}\n\t\t} else if ( typeof node == 'string' ) {\n\t\t\tlet textLength;\n\n\t\t\tif ( !this.singleCharacters ) {\n\t\t\t\t// Check if text stick out of walker range.\n\t\t\t\tconst startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;\n\n\t\t\t\ttextLength = position.offset - startOffset;\n\t\t\t} else {\n\t\t\t\ttextLength = 1;\n\t\t\t}\n\n\t\t\tposition.offset -= textLength;\n\n\t\t\tconst textProxy = new TextProxy( parent, position.offset, textLength );\n\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the beginning of current `parent`.\n\t\t\tposition = Position._createBefore( parent );\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );\n\t\t}\n\t}\n\n\t/**\n\t * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.\n\t *\n\t * @private\n\t * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.\n\t * @param {module:engine/view/item~Item} item Item between old and new position.\n\t * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.\n\t * @param {module:engine/view/position~Position} nextPosition Next position of iterator.\n\t * @param {Number} [length] Length of the item.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue}\n\t */\n\t_formatReturnValue( type, item, previousPosition, nextPosition, length ) {\n\t\t// Text is a specific parent, because contains string instead of children.\n\t\t// Walker doesn't enter to the Text except situations when walker is iterating over every single character,\n\t\t// or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text\n\t\t// we move it just before or just after Text.\n\t\tif ( item instanceof TextProxy ) {\n\t\t\t// Position is at the end of Text.\n\t\t\tif ( item.offsetInText + item.data.length == item.textNode.data.length ) {\n\t\t\t\tif ( this.direction == 'forward' && !( this.boundaries && this.boundaries.end.isEqual( this.position ) ) ) {\n\t\t\t\t\tnextPosition = Position._createAfter( item.textNode );\n\t\t\t\t\t// When we change nextPosition of returned value we need also update walker current position.\n\t\t\t\t\tthis.position = nextPosition;\n\t\t\t\t} else {\n\t\t\t\t\tpreviousPosition = Position._createAfter( item.textNode );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Position is at the begining ot the text.\n\t\t\tif ( item.offsetInText === 0 ) {\n\t\t\t\tif ( this.direction == 'backward' && !( this.boundaries && this.boundaries.start.isEqual( this.position ) ) ) {\n\t\t\t\t\tnextPosition = Position._createBefore( item.textNode );\n\t\t\t\t\t// When we change nextPosition of returned value we need also update walker current position.\n\t\t\t\t\tthis.position = nextPosition;\n\t\t\t\t} else {\n\t\t\t\t\tpreviousPosition = Position._createBefore( item.textNode );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdone: false,\n\t\t\tvalue: {\n\t\t\t\ttype,\n\t\t\t\titem,\n\t\t\t\tpreviousPosition,\n\t\t\t\tnextPosition,\n\t\t\t\tlength\n\t\t\t}\n\t\t};\n\t}\n}\n\n/**\n * Type of the step made by {@link module:engine/view/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end\n * of node, or `'text'` if walker traversed over single and multiple characters.\n * For {@link module:engine/view/text~Text} `elementStart` and `elementEnd` is not returned.\n *\n * @typedef {String} module:engine/view/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/view/treewalker~TreeWalker} when traversing tree view.\n *\n * @typedef {Object} module:engine/view/treewalker~TreeWalkerValue\n * @property {module:engine/view/treewalker~TreeWalkerValueType} type\n * @property {module:engine/view/item~Item} item Item between the old and the new positions\n * of the tree walker.\n * @property {module:engine/view/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {module:engine/view/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {Number} [length] Length of the item. For `'elementStart'` it is `1`. For `'text'` it is\n * the length of that text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */\n"]},"metadata":{},"sourceType":"module"}