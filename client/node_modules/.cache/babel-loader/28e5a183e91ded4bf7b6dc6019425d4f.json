{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/dragdrop\n */\n\n/* globals setTimeout, clearTimeout */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport LiveRange from '@ckeditor/ckeditor5-engine/src/model/liverange';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport Widget from '@ckeditor/ckeditor5-widget/src/widget';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { isWidget } from '@ckeditor/ckeditor5-widget/src/utils';\nimport ClipboardPipeline from './clipboardpipeline';\nimport ClipboardObserver from './clipboardobserver';\nimport { throttle } from 'lodash-es';\nimport '../theme/clipboard.css'; // Drag and drop events overview:\n//\n//                ┌──────────────────┐\n//                │     mousedown    │   Sets the draggable attribute.\n//                └─────────┬────────┘\n//                          │\n//                          └─────────────────────┐\n//                          │                     │\n//                          │           ┌─────────V────────┐\n//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.\n//                          │           └──────────────────┘\n//                          │\n//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment\n//                │     dragstart    │   and converts it to view.DocumentFragment.\n//                └─────────┬────────┘\n//                          │\n//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain\n//                │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                └─────────┬────────┘\n//                          │\n//                          │   DOM dragover\n//                          ┌────────────┐\n//                          │            │\n//                ┌─────────V────────┐   │\n//                │     dragging     │   │   Updates the drop target marker.\n//                └─────────┬────────┘   │\n//                          │            │\n//            ┌─────────────└────────────┘\n//            │             │            │\n//            │   ┌─────────V────────┐   │\n//            │   │     dragleave    │   │   Removes the drop target marker.\n//            │   └─────────┬────────┘   │\n//            │             │            │\n//        ┌───│─────────────┘            │\n//        │   │             │            │\n//        │   │   ┌─────────V────────┐   │\n//        │   │   │     dragenter    │   │   Focuses the editor view.\n//        │   │   └─────────┬────────┘   │\n//        │   │             │            │\n//        │   │             └────────────┘\n//        │   │\n//        │   └─────────────┐\n//        │   │             │\n//        │   │   ┌─────────V────────┐\n//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.\n//            │   │  clipboardInput  │   Aborts if dropping on dragged content.\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐\n//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │ ┌───────────V───────────┐\n//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).\n//            │ └───────────┬───────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Updates the document selection to drop range.\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.\n//            │  └──────────┬──────────┘\n//            │             │\n//            └─────────────┐\n//                          │\n//                ┌─────────V────────┐\n//                │      dragend     │   Removes the drop marker and cleans the state.\n//                └──────────────────┘\n//\n\n/**\n * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.\n *\n * Read more about the clipboard integration in the {@glink framework/guides/deep-dive/clipboard clipboard deep dive guide}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class DragDrop extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'DragDrop';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [ClipboardPipeline, Widget];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    /**\n     * The live range over the original content that is being dragged.\n     *\n     * @private\n     * @type {module:engine/model/liverange~LiveRange}\n     */\n\n    this._draggedRange = null;\n    /**\n     * The UID of current dragging that is used to verify if the drop started in the same editor as the drag start.\n     *\n     * **Note**: This is a workaround for broken 'dragend' events (they are not fired if the source text node got removed).\n     *\n     * @private\n     * @type {String}\n     */\n\n    this._draggingUid = '';\n    /**\n     * The reference to the model element that currently has a `draggable` attribute set (it is set while dragging).\n     *\n     * @private\n     * @type {module:engine/model/element~Element}\n     */\n\n    this._draggableElement = null;\n    /**\n     * A throttled callback updating the drop marker.\n     *\n     * @private\n     * @type {Function}\n     */\n\n    this._updateDropMarkerThrottled = throttle(targetRange => this._updateDropMarker(targetRange), 40);\n    /**\n     * A delayed callback removing the drop marker.\n     *\n     * @private\n     * @type {Function}\n     */\n\n    this._removeDropMarkerDelayed = delay(() => this._removeDropMarker(), 40);\n    /**\n     * A delayed callback removing draggable attributes.\n     *\n     * @private\n     * @type {Function}\n     */\n\n    this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40);\n    view.addObserver(ClipboardObserver);\n    view.addObserver(MouseObserver);\n\n    this._setupDragging();\n\n    this._setupContentInsertionIntegration();\n\n    this._setupClipboardInputIntegration();\n\n    this._setupDropMarker();\n\n    this._setupDraggableAttributeHandling();\n\n    this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly) => {\n      if (isReadOnly) {\n        this.forceDisabled('readOnlyMode');\n      } else {\n        this.clearForceDisabled('readOnlyMode');\n      }\n    });\n    this.on('change:isEnabled', (evt, name, isEnabled) => {\n      if (!isEnabled) {\n        this._finalizeDragging(false);\n      }\n    });\n\n    if (env.isAndroid) {\n      this.forceDisabled('noAndroidSupport');\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    if (this._draggedRange) {\n      this._draggedRange.detach();\n\n      this._draggedRange = null;\n    }\n\n    this._updateDropMarkerThrottled.cancel();\n\n    this._removeDropMarkerDelayed.cancel();\n\n    this._clearDraggableAttributesDelayed.cancel();\n\n    return super.destroy();\n  }\n  /**\n   * Drag and drop events handling.\n   *\n   * @private\n   */\n\n\n  _setupDragging() {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelDocument = model.document;\n    const view = editor.editing.view;\n    const viewDocument = view.document; // The handler for the drag start; it is responsible for setting data transfer object.\n\n    this.listenTo(viewDocument, 'dragstart', (evt, data) => {\n      const selection = modelDocument.selection; // Don't drag the editable element itself.\n\n      if (data.target && data.target.is('editableElement')) {\n        data.preventDefault();\n        return;\n      } // TODO we could clone this node somewhere and style it to match editing view but without handles,\n      //  selection outline, WTA buttons, etc.\n      // data.dataTransfer._native.setDragImage( data.domTarget, 0, 0 );\n      // Check if this is dragstart over the widget (but not a nested editable).\n\n\n      const draggableWidget = data.target ? findDraggableWidget(data.target) : null;\n\n      if (draggableWidget) {\n        const modelElement = editor.editing.mapper.toModelElement(draggableWidget);\n        this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement)); // Disable toolbars so they won't obscure the drop area.\n\n        if (editor.plugins.has('WidgetToolbarRepository')) {\n          editor.plugins.get('WidgetToolbarRepository').forceDisabled('dragDrop');\n        }\n      } // If this was not a widget we should check if we need to drag some text content.\n      else if (!viewDocument.selection.isCollapsed) {\n        const selectedElement = viewDocument.selection.getSelectedElement();\n\n        if (!selectedElement || !isWidget(selectedElement)) {\n          this._draggedRange = LiveRange.fromRange(selection.getFirstRange());\n        }\n      }\n\n      if (!this._draggedRange) {\n        data.preventDefault();\n        return;\n      }\n\n      this._draggingUid = uid();\n      data.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy';\n      data.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid);\n      const draggedSelection = model.createSelection(this._draggedRange.toRange());\n      const content = editor.data.toView(model.getSelectedContent(draggedSelection));\n      viewDocument.fire('clipboardOutput', {\n        dataTransfer: data.dataTransfer,\n        content,\n        method: evt.name\n      });\n\n      if (!this.isEnabled) {\n        this._draggedRange.detach();\n\n        this._draggedRange = null;\n        this._draggingUid = '';\n      }\n    }, {\n      priority: 'low'\n    }); // The handler for finalizing drag and drop. It should always be triggered after dragging completes\n    // even if it was completed in a different application.\n    // Note: This is not fired if source text node got removed while downcasting a marker.\n\n    this.listenTo(viewDocument, 'dragend', (evt, data) => {\n      this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move');\n    }, {\n      priority: 'low'\n    }); // Dragging over the editable.\n\n    this.listenTo(viewDocument, 'dragenter', () => {\n      if (!this.isEnabled) {\n        return;\n      }\n\n      view.focus();\n    }); // Dragging out of the editable.\n\n    this.listenTo(viewDocument, 'dragleave', () => {\n      // We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds\n      // to check if 'dragover' is not fired.\n      this._removeDropMarkerDelayed();\n    }); // Handler for moving dragged content over the target area.\n\n    this.listenTo(viewDocument, 'dragging', (evt, data) => {\n      if (!this.isEnabled) {\n        data.dataTransfer.dropEffect = 'none';\n        return;\n      }\n\n      this._removeDropMarkerDelayed.cancel();\n\n      const targetRange = findDropTargetRange(editor, data.targetRanges, data.target); // If this is content being dragged from another editor, moving out of current editor instance\n      // is not possible until 'dragend' event case will be fixed.\n\n      if (!this._draggedRange) {\n        data.dataTransfer.dropEffect = 'copy';\n      } // In Firefox it is already set and effect allowed remains the same as originally set.\n\n\n      if (!env.isGecko) {\n        if (data.dataTransfer.effectAllowed == 'copy') {\n          data.dataTransfer.dropEffect = 'copy';\n        } else if (['all', 'copyMove'].includes(data.dataTransfer.effectAllowed)) {\n          data.dataTransfer.dropEffect = 'move';\n        }\n      }\n      /* istanbul ignore else */\n\n\n      if (targetRange) {\n        this._updateDropMarkerThrottled(targetRange);\n      }\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Integration with the `clipboardInput` event.\n   *\n   * @private\n   */\n\n\n  _setupClipboardInputIntegration() {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document; // Update the event target ranges and abort dropping if dropping over itself.\n\n    this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n      if (data.method != 'drop') {\n        return;\n      }\n\n      const targetRange = findDropTargetRange(editor, data.targetRanges, data.target); // The dragging markers must be removed after searching for the target range because sometimes\n      // the target lands on the marker itself.\n\n      this._removeDropMarker();\n      /* istanbul ignore if */\n\n\n      if (!targetRange) {\n        this._finalizeDragging(false);\n\n        evt.stop();\n        return;\n      } // Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop\n      // or it is from some previous not cleared one.\n\n\n      if (this._draggedRange && this._draggingUid != data.dataTransfer.getData('application/ckeditor5-dragging-uid')) {\n        this._draggedRange.detach();\n\n        this._draggedRange = null;\n        this._draggingUid = '';\n      } // Do not do anything if some content was dragged within the same document to the same position.\n\n\n      const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n\n      if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {\n        this._finalizeDragging(false);\n\n        evt.stop();\n        return;\n      } // Override the target ranges with the one adjusted to the best one for a drop.\n\n\n      data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Integration with the `contentInsertion` event of the clipboard pipeline.\n   *\n   * @private\n   */\n\n\n  _setupContentInsertionIntegration() {\n    const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);\n    clipboardPipeline.on('contentInsertion', (evt, data) => {\n      if (!this.isEnabled || data.method !== 'drop') {\n        return;\n      } // Update the selection to the target range in the same change block to avoid selection post-fixing\n      // and to be able to clone text attributes for plain text dropping.\n\n\n      const ranges = data.targetRanges.map(viewRange => this.editor.editing.mapper.toModelRange(viewRange));\n      this.editor.model.change(writer => writer.setSelection(ranges));\n    }, {\n      priority: 'high'\n    });\n    clipboardPipeline.on('contentInsertion', (evt, data) => {\n      if (!this.isEnabled || data.method !== 'drop') {\n        return;\n      } // Remove dragged range content, remove markers, clean after dragging.\n\n\n      const isMove = getFinalDropEffect(data.dataTransfer) == 'move'; // Whether any content was inserted (insertion might fail if the schema is disallowing some elements\n      // (for example an image caption allows only the content of a block but not blocks themselves.\n      // Some integrations might not return valid range (i.e., table pasting).\n\n      const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;\n\n      this._finalizeDragging(isSuccess && isMove);\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.\n   *\n   * @private\n   */\n\n\n  _setupDraggableAttributeHandling() {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document; // Add the 'draggable' attribute to the widget while pressing the selection handle.\n    // This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.\n\n    this.listenTo(viewDocument, 'mousedown', (evt, data) => {\n      // The lack of data can be caused by editor tests firing fake mouse events. This should not occur\n      // in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.\n      if (env.isAndroid || !data) {\n        return;\n      }\n\n      this._clearDraggableAttributesDelayed.cancel(); // Check if this is a mousedown over the widget (but not a nested editable).\n\n\n      let draggableElement = findDraggableWidget(data.target); // Note: There is a limitation that if more than a widget is selected (a widget and some text)\n      // and dragging starts on the widget, then only the widget is dragged.\n      // If this was not a widget then we should check if we need to drag some text content.\n      // In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.\n      // In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).\n      // Disabled in read-only mode because draggable=\"true\" + contenteditable=\"false\" results\n      // in not firing selectionchange event ever, which makes the selection stuck in read-only mode.\n\n      if (env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {\n        const selectedElement = viewDocument.selection.getSelectedElement();\n\n        if (!selectedElement || !isWidget(selectedElement)) {\n          draggableElement = viewDocument.selection.editableElement;\n        }\n      }\n\n      if (draggableElement) {\n        view.change(writer => {\n          writer.setAttribute('draggable', 'true', draggableElement);\n        }); // Keep the reference to the model element in case the view element gets removed while dragging.\n\n        this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);\n      }\n    }); // Remove the draggable attribute in case no dragging started (only mousedown + mouseup).\n\n    this.listenTo(viewDocument, 'mouseup', () => {\n      if (!env.isAndroid) {\n        this._clearDraggableAttributesDelayed();\n      }\n    });\n  }\n  /**\n   * Removes the `draggable` attribute from the element that was used for dragging.\n   *\n   * @private\n   */\n\n\n  _clearDraggableAttributes() {\n    const editing = this.editor.editing;\n    editing.view.change(writer => {\n      // Remove 'draggable' attribute.\n      if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {\n        writer.removeAttribute('draggable', editing.mapper.toViewElement(this._draggableElement));\n      }\n\n      this._draggableElement = null;\n    });\n  }\n  /**\n   * Creates downcast conversion for the drop target marker.\n   *\n   * @private\n   */\n\n\n  _setupDropMarker() {\n    const editor = this.editor; // Drop marker conversion for hovering over widgets.\n\n    editor.conversion.for('editingDowncast').markerToHighlight({\n      model: 'drop-target',\n      view: {\n        classes: ['ck-clipboard-drop-target-range']\n      }\n    }); // Drop marker conversion for in text drop target.\n\n    editor.conversion.for('editingDowncast').markerToElement({\n      model: 'drop-target',\n      view: (data, _ref) => {\n        let {\n          writer\n        } = _ref;\n        const inText = editor.model.schema.checkChild(data.markerRange.start, '$text');\n\n        if (!inText) {\n          return;\n        }\n\n        return writer.createUIElement('span', {\n          class: 'ck ck-clipboard-drop-target-position'\n        }, function (domDocument) {\n          const domElement = this.toDomElement(domDocument); // Using word joiner to make this marker as high as text and also making text not break on marker.\n\n          domElement.innerHTML = '&NoBreak;<span></span>&NoBreak;';\n          return domElement;\n        });\n      }\n    });\n  }\n  /**\n   * Updates the drop target marker to the provided range.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} targetRange The range to set the marker to.\n   */\n\n\n  _updateDropMarker(targetRange) {\n    const editor = this.editor;\n    const markers = editor.model.markers;\n    editor.model.change(writer => {\n      if (markers.has('drop-target')) {\n        if (!markers.get('drop-target').getRange().isEqual(targetRange)) {\n          writer.updateMarker('drop-target', {\n            range: targetRange\n          });\n        }\n      } else {\n        writer.addMarker('drop-target', {\n          range: targetRange,\n          usingOperation: false,\n          affectsData: false\n        });\n      }\n    });\n  }\n  /**\n   * Removes the drop target marker.\n   *\n   * @private\n   */\n\n\n  _removeDropMarker() {\n    const model = this.editor.model;\n\n    this._removeDropMarkerDelayed.cancel();\n\n    this._updateDropMarkerThrottled.cancel();\n\n    if (model.markers.has('drop-target')) {\n      model.change(writer => {\n        writer.removeMarker('drop-target');\n      });\n    }\n  }\n  /**\n   * Deletes the dragged content from its original range and clears the dragging state.\n   *\n   * @private\n   * @param {Boolean} moved Whether the move succeeded.\n   */\n\n\n  _finalizeDragging(moved) {\n    const editor = this.editor;\n    const model = editor.model;\n\n    this._removeDropMarker();\n\n    this._clearDraggableAttributes();\n\n    if (editor.plugins.has('WidgetToolbarRepository')) {\n      editor.plugins.get('WidgetToolbarRepository').clearForceDisabled('dragDrop');\n    }\n\n    this._draggingUid = '';\n\n    if (!this._draggedRange) {\n      return;\n    } // Delete moved content.\n\n\n    if (moved && this.isEnabled) {\n      model.deleteContent(model.createSelection(this._draggedRange), {\n        doNotAutoparagraph: true\n      });\n    }\n\n    this._draggedRange.detach();\n\n    this._draggedRange = null;\n  }\n\n} // Returns fixed selection range for given position and target element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {Array.<module:engine/view/range~Range>} targetViewRanges\n// @param {module:engine/view/element~Element} targetViewElement\n// @returns {module:engine/model/range~Range|null}\n\nfunction findDropTargetRange(editor, targetViewRanges, targetViewElement) {\n  const model = editor.model;\n  const mapper = editor.editing.mapper;\n  let range = null;\n  const targetViewPosition = targetViewRanges ? targetViewRanges[0].start : null; // A UIElement is not a valid drop element, use parent (this could be a drop marker or any other UIElement).\n\n  if (targetViewElement.is('uiElement')) {\n    targetViewElement = targetViewElement.parent;\n  } // Quick win if the target is a widget (but not a nested editable).\n\n\n  range = findDropTargetRangeOnWidget(editor, targetViewElement);\n\n  if (range) {\n    return range;\n  } // The easiest part is over, now we need to move to the model space.\n  // Find target model element and position.\n\n\n  const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);\n  const targetModelPosition = targetViewPosition ? mapper.toModelPosition(targetViewPosition) : null; // There is no target position while hovering over an empty table cell.\n  // In Safari, target position can be empty while hovering over a widget (e.g., a page-break).\n  // Find the drop position inside the element.\n\n  if (!targetModelPosition) {\n    return findDropTargetRangeInElement(editor, targetModelElement);\n  } // Check if target position is between blocks and adjust drop position to the next object.\n  // This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n\n\n  range = findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement);\n\n  if (range) {\n    return range;\n  } // Try fixing selection position.\n  // In Firefox, the target position lands before widgets but in other browsers it tends to land after a widget.\n\n\n  range = model.schema.getNearestSelectionRange(targetModelPosition, env.isGecko ? 'forward' : 'backward');\n\n  if (range) {\n    return range;\n  } // There is no valid selection position inside the current limit element so find a closest object ancestor.\n  // This happens if the model position lands directly in the <table> element itself (view target element was a `<td>`\n  // so a nested editable, but view target position was directly in the `<figure>` element).\n\n\n  return findDropTargetRangeOnAncestorObject(editor, targetModelPosition.parent);\n} // Returns fixed selection range for a given position and a target element if it is over the widget but not over its nested editable.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/view/element~Element} targetViewElement\n// @returns {module:engine/model/range~Range|null}\n\n\nfunction findDropTargetRangeOnWidget(editor, targetViewElement) {\n  const model = editor.model;\n  const mapper = editor.editing.mapper; // Quick win if the target is a widget.\n\n  if (isWidget(targetViewElement)) {\n    return model.createRangeOn(mapper.toModelElement(targetViewElement));\n  } // Check if we are deeper over a widget (but not over a nested editable).\n\n\n  if (!targetViewElement.is('editableElement')) {\n    // Find a closest ancestor that is either a widget or an editable element...\n    const ancestor = targetViewElement.findAncestor(node => isWidget(node) || node.is('editableElement')); // ...and if the widget was closer then it is a drop target.\n\n    if (isWidget(ancestor)) {\n      return model.createRangeOn(mapper.toModelElement(ancestor));\n    }\n  }\n\n  return null;\n} // Returns fixed selection range inside a model element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/element~Element} targetModelElement\n// @returns {module:engine/model/range~Range}\n\n\nfunction findDropTargetRangeInElement(editor, targetModelElement) {\n  const model = editor.model;\n  const schema = model.schema;\n  const positionAtElementStart = model.createPositionAt(targetModelElement, 0);\n  return schema.getNearestSelectionRange(positionAtElementStart, 'forward');\n} // Returns fixed selection range for a given position and a target element if the drop is between blocks.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/position~Position} targetModelPosition\n// @param {module:engine/model/element~Element} targetModelElement\n// @returns {module:engine/model/range~Range|null}\n\n\nfunction findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement) {\n  const model = editor.model; // Check if target is between blocks.\n\n  if (!model.schema.checkChild(targetModelElement, '$block')) {\n    return null;\n  } // Find position between blocks.\n\n\n  const positionAtElementStart = model.createPositionAt(targetModelElement, 0); // Get the common part of the path (inside the target element and the target position).\n\n  const commonPath = targetModelPosition.path.slice(0, positionAtElementStart.path.length); // Position between the blocks.\n\n  const betweenBlocksPosition = model.createPositionFromPath(targetModelPosition.root, commonPath);\n  const nodeAfter = betweenBlocksPosition.nodeAfter; // Adjust drop position to the next object.\n  // This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n\n  if (nodeAfter && model.schema.isObject(nodeAfter)) {\n    return model.createRangeOn(nodeAfter);\n  }\n\n  return null;\n} // Returns a selection range on the ancestor object.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/range~Range}\n\n\nfunction findDropTargetRangeOnAncestorObject(editor, element) {\n  const model = editor.model;\n\n  while (element) {\n    if (model.schema.isObject(element)) {\n      return model.createRangeOn(element);\n    }\n\n    element = element.parent;\n  }\n} // Returns the closest model element for the specified view element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/view/element~Element} element\n// @returns {module:engine/model/element~Element}\n\n\nfunction getClosestMappedModelElement(editor, element) {\n  const mapper = editor.editing.mapper;\n  const view = editor.editing.view;\n  const targetModelElement = mapper.toModelElement(element);\n\n  if (targetModelElement) {\n    return targetModelElement;\n  } // Find mapped ancestor if the target is inside not mapped element (for example inline code element).\n\n\n  const viewPosition = view.createPositionBefore(element);\n  const viewElement = mapper.findMappedViewAncestor(viewPosition);\n  return mapper.toModelElement(viewElement);\n} // Returns the drop effect that should be a result of dragging the content.\n// This function is handling a quirk when checking the effect in the 'drop' DOM event.\n\n\nfunction getFinalDropEffect(dataTransfer) {\n  if (env.isGecko) {\n    return dataTransfer.dropEffect;\n  }\n\n  return ['all', 'copyMove'].includes(dataTransfer.effectAllowed) ? 'move' : 'copy';\n} // Returns a function wrapper that will trigger a function after a specified wait time.\n// The timeout can be canceled by calling the cancel function on the returned wrapped function.\n//\n// @param {Function} func The function to wrap.\n// @param {Number} wait The timeout in ms.\n// @returns {Function}\n\n\nfunction delay(func, wait) {\n  let timer;\n\n  function delayed() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    delayed.cancel();\n    timer = setTimeout(() => func(...args), wait);\n  }\n\n  delayed.cancel = () => {\n    clearTimeout(timer);\n  };\n\n  return delayed;\n} // Returns a widget element that should be dragged.\n//\n// @param {module:engine/view/element~Element} target\n// @returns {module:engine/view/element~Element}\n\n\nfunction findDraggableWidget(target) {\n  // This is directly an editable so not a widget for sure.\n  if (target.is('editableElement')) {\n    return null;\n  } // TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.\n\n\n  if (target.hasClass('ck-widget__selection-handle')) {\n    return target.findAncestor(isWidget);\n  } // Direct hit on a widget.\n\n\n  if (isWidget(target)) {\n    return target;\n  } // Find closest ancestor that is either a widget or an editable element...\n\n\n  const ancestor = target.findAncestor(node => isWidget(node) || node.is('editableElement')); // ...and if closer was the widget then enable dragging it.\n\n  if (isWidget(ancestor)) {\n    return ancestor;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-clipboard/src/dragdrop.js"],"names":["Plugin","LiveRange","MouseObserver","Widget","uid","env","isWidget","ClipboardPipeline","ClipboardObserver","throttle","DragDrop","pluginName","requires","init","editor","view","editing","_draggedRange","_draggingUid","_draggableElement","_updateDropMarkerThrottled","targetRange","_updateDropMarker","_removeDropMarkerDelayed","delay","_removeDropMarker","_clearDraggableAttributesDelayed","_clearDraggableAttributes","addObserver","_setupDragging","_setupContentInsertionIntegration","_setupClipboardInputIntegration","_setupDropMarker","_setupDraggableAttributeHandling","listenTo","evt","name","isReadOnly","forceDisabled","clearForceDisabled","on","isEnabled","_finalizeDragging","isAndroid","destroy","detach","cancel","model","modelDocument","document","viewDocument","data","selection","target","is","preventDefault","draggableWidget","findDraggableWidget","modelElement","mapper","toModelElement","fromRange","createRangeOn","plugins","has","get","isCollapsed","selectedElement","getSelectedElement","getFirstRange","dataTransfer","effectAllowed","setData","draggedSelection","createSelection","toRange","content","toView","getSelectedContent","fire","method","priority","isCanceled","dropEffect","focus","findDropTargetRange","targetRanges","isGecko","includes","stop","getData","isMove","getFinalDropEffect","containsRange","toViewRange","clipboardPipeline","ranges","map","viewRange","toModelRange","change","writer","setSelection","isSuccess","resultRange","draggableElement","isBlink","editableElement","setAttribute","root","rootName","removeAttribute","toViewElement","conversion","for","markerToHighlight","classes","markerToElement","inText","schema","checkChild","markerRange","start","createUIElement","class","domDocument","domElement","toDomElement","innerHTML","markers","getRange","isEqual","updateMarker","range","addMarker","usingOperation","affectsData","removeMarker","moved","deleteContent","doNotAutoparagraph","targetViewRanges","targetViewElement","targetViewPosition","parent","findDropTargetRangeOnWidget","targetModelElement","getClosestMappedModelElement","targetModelPosition","toModelPosition","findDropTargetRangeInElement","findDropTargetRangeBetweenBlocks","getNearestSelectionRange","findDropTargetRangeOnAncestorObject","ancestor","findAncestor","node","positionAtElementStart","createPositionAt","commonPath","path","slice","length","betweenBlocksPosition","createPositionFromPath","nodeAfter","isObject","element","viewPosition","createPositionBefore","viewElement","findMappedViewAncestor","func","wait","timer","delayed","args","setTimeout","clearTimeout","hasClass"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA,OAAOA,MAAP,MAAmB,qCAAnB;AACA,OAAOC,SAAP,MAAsB,gDAAtB;AACA,OAAOC,aAAP,MAA0B,4DAA1B;AACA,OAAOC,MAAP,MAAmB,uCAAnB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,SAASC,QAAT,QAAyB,sCAAzB;AAEA,OAAOC,iBAAP,MAA8B,qBAA9B;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AAEA,SAASC,QAAT,QAAyB,WAAzB;AAEA,OAAO,wBAAP,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,SAAuBV,MAAvB,CAA8B;AAC5C;AACD;AACA;AACsB,aAAVW,UAAU,GAAG;AACvB,WAAO,UAAP;AACA;AAED;AACD;AACA;;;AACoB,aAARC,QAAQ,GAAG;AACrB,WAAO,CAAEL,iBAAF,EAAqBJ,MAArB,CAAP;AACA;AAED;AACD;AACA;;;AACCU,EAAAA,IAAI,GAAG;AACN,UAAMC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMC,IAAI,GAAGD,MAAM,CAACE,OAAP,CAAeD,IAA5B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKE,aAAL,GAAqB,IAArB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,YAAL,GAAoB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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/dragdrop\n */\n\n/* globals setTimeout, clearTimeout */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport LiveRange from '@ckeditor/ckeditor5-engine/src/model/liverange';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport Widget from '@ckeditor/ckeditor5-widget/src/widget';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { isWidget } from '@ckeditor/ckeditor5-widget/src/utils';\n\nimport ClipboardPipeline from './clipboardpipeline';\nimport ClipboardObserver from './clipboardobserver';\n\nimport { throttle } from 'lodash-es';\n\nimport '../theme/clipboard.css';\n\n// Drag and drop events overview:\n//\n//                ┌──────────────────┐\n//                │     mousedown    │   Sets the draggable attribute.\n//                └─────────┬────────┘\n//                          │\n//                          └─────────────────────┐\n//                          │                     │\n//                          │           ┌─────────V────────┐\n//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.\n//                          │           └──────────────────┘\n//                          │\n//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment\n//                │     dragstart    │   and converts it to view.DocumentFragment.\n//                └─────────┬────────┘\n//                          │\n//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain\n//                │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                └─────────┬────────┘\n//                          │\n//                          │   DOM dragover\n//                          ┌────────────┐\n//                          │            │\n//                ┌─────────V────────┐   │\n//                │     dragging     │   │   Updates the drop target marker.\n//                └─────────┬────────┘   │\n//                          │            │\n//            ┌─────────────└────────────┘\n//            │             │            │\n//            │   ┌─────────V────────┐   │\n//            │   │     dragleave    │   │   Removes the drop target marker.\n//            │   └─────────┬────────┘   │\n//            │             │            │\n//        ┌───│─────────────┘            │\n//        │   │             │            │\n//        │   │   ┌─────────V────────┐   │\n//        │   │   │     dragenter    │   │   Focuses the editor view.\n//        │   │   └─────────┬────────┘   │\n//        │   │             │            │\n//        │   │             └────────────┘\n//        │   │\n//        │   └─────────────┐\n//        │   │             │\n//        │   │   ┌─────────V────────┐\n//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.\n//            │   │  clipboardInput  │   Aborts if dropping on dragged content.\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐\n//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │ ┌───────────V───────────┐\n//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).\n//            │ └───────────┬───────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Updates the document selection to drop range.\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.\n//            │  └──────────┬──────────┘\n//            │             │\n//            └─────────────┐\n//                          │\n//                ┌─────────V────────┐\n//                │      dragend     │   Removes the drop marker and cleans the state.\n//                └──────────────────┘\n//\n\n/**\n * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.\n *\n * Read more about the clipboard integration in the {@glink framework/guides/deep-dive/clipboard clipboard deep dive guide}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class DragDrop extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'DragDrop';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ClipboardPipeline, Widget ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\n\t\t/**\n\t\t * The live range over the original content that is being dragged.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/liverange~LiveRange}\n\t\t */\n\t\tthis._draggedRange = null;\n\n\t\t/**\n\t\t * The UID of current dragging that is used to verify if the drop started in the same editor as the drag start.\n\t\t *\n\t\t * **Note**: This is a workaround for broken 'dragend' events (they are not fired if the source text node got removed).\n\t\t *\n\t\t * @private\n\t\t * @type {String}\n\t\t */\n\t\tthis._draggingUid = '';\n\n\t\t/**\n\t\t * The reference to the model element that currently has a `draggable` attribute set (it is set while dragging).\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/element~Element}\n\t\t */\n\t\tthis._draggableElement = null;\n\n\t\t/**\n\t\t * A throttled callback updating the drop marker.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._updateDropMarkerThrottled = throttle( targetRange => this._updateDropMarker( targetRange ), 40 );\n\n\t\t/**\n\t\t * A delayed callback removing the drop marker.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._removeDropMarkerDelayed = delay( () => this._removeDropMarker(), 40 );\n\n\t\t/**\n\t\t * A delayed callback removing draggable attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._clearDraggableAttributesDelayed = delay( () => this._clearDraggableAttributes(), 40 );\n\n\t\tview.addObserver( ClipboardObserver );\n\t\tview.addObserver( MouseObserver );\n\n\t\tthis._setupDragging();\n\t\tthis._setupContentInsertionIntegration();\n\t\tthis._setupClipboardInputIntegration();\n\t\tthis._setupDropMarker();\n\t\tthis._setupDraggableAttributeHandling();\n\n\t\tthis.listenTo( editor, 'change:isReadOnly', ( evt, name, isReadOnly ) => {\n\t\t\tif ( isReadOnly ) {\n\t\t\t\tthis.forceDisabled( 'readOnlyMode' );\n\t\t\t} else {\n\t\t\t\tthis.clearForceDisabled( 'readOnlyMode' );\n\t\t\t}\n\t\t} );\n\n\t\tthis.on( 'change:isEnabled', ( evt, name, isEnabled ) => {\n\t\t\tif ( !isEnabled ) {\n\t\t\t\tthis._finalizeDragging( false );\n\t\t\t}\n\t\t} );\n\n\t\tif ( env.isAndroid ) {\n\t\t\tthis.forceDisabled( 'noAndroidSupport' );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tif ( this._draggedRange ) {\n\t\t\tthis._draggedRange.detach();\n\t\t\tthis._draggedRange = null;\n\t\t}\n\n\t\tthis._updateDropMarkerThrottled.cancel();\n\t\tthis._removeDropMarkerDelayed.cancel();\n\t\tthis._clearDraggableAttributesDelayed.cancel();\n\n\t\treturn super.destroy();\n\t}\n\n\t/**\n\t * Drag and drop events handling.\n\t *\n\t * @private\n\t */\n\t_setupDragging() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelDocument = model.document;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t// The handler for the drag start; it is responsible for setting data transfer object.\n\t\tthis.listenTo( viewDocument, 'dragstart', ( evt, data ) => {\n\t\t\tconst selection = modelDocument.selection;\n\n\t\t\t// Don't drag the editable element itself.\n\t\t\tif ( data.target && data.target.is( 'editableElement' ) ) {\n\t\t\t\tdata.preventDefault();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO we could clone this node somewhere and style it to match editing view but without handles,\n\t\t\t//  selection outline, WTA buttons, etc.\n\t\t\t// data.dataTransfer._native.setDragImage( data.domTarget, 0, 0 );\n\n\t\t\t// Check if this is dragstart over the widget (but not a nested editable).\n\t\t\tconst draggableWidget = data.target ? findDraggableWidget( data.target ) : null;\n\n\t\t\tif ( draggableWidget ) {\n\t\t\t\tconst modelElement = editor.editing.mapper.toModelElement( draggableWidget );\n\n\t\t\t\tthis._draggedRange = LiveRange.fromRange( model.createRangeOn( modelElement ) );\n\n\t\t\t\t// Disable toolbars so they won't obscure the drop area.\n\t\t\t\tif ( editor.plugins.has( 'WidgetToolbarRepository' ) ) {\n\t\t\t\t\teditor.plugins.get( 'WidgetToolbarRepository' ).forceDisabled( 'dragDrop' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this was not a widget we should check if we need to drag some text content.\n\t\t\telse if ( !viewDocument.selection.isCollapsed ) {\n\t\t\t\tconst selectedElement = viewDocument.selection.getSelectedElement();\n\n\t\t\t\tif ( !selectedElement || !isWidget( selectedElement ) ) {\n\t\t\t\t\tthis._draggedRange = LiveRange.fromRange( selection.getFirstRange() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !this._draggedRange ) {\n\t\t\t\tdata.preventDefault();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._draggingUid = uid();\n\n\t\t\tdata.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy';\n\t\t\tdata.dataTransfer.setData( 'application/ckeditor5-dragging-uid', this._draggingUid );\n\n\t\t\tconst draggedSelection = model.createSelection( this._draggedRange.toRange() );\n\t\t\tconst content = editor.data.toView( model.getSelectedContent( draggedSelection ) );\n\n\t\t\tviewDocument.fire( 'clipboardOutput', { dataTransfer: data.dataTransfer, content, method: evt.name } );\n\n\t\t\tif ( !this.isEnabled ) {\n\t\t\t\tthis._draggedRange.detach();\n\t\t\t\tthis._draggedRange = null;\n\t\t\t\tthis._draggingUid = '';\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// The handler for finalizing drag and drop. It should always be triggered after dragging completes\n\t\t// even if it was completed in a different application.\n\t\t// Note: This is not fired if source text node got removed while downcasting a marker.\n\t\tthis.listenTo( viewDocument, 'dragend', ( evt, data ) => {\n\t\t\tthis._finalizeDragging( !data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move' );\n\t\t}, { priority: 'low' } );\n\n\t\t// Dragging over the editable.\n\t\tthis.listenTo( viewDocument, 'dragenter', () => {\n\t\t\tif ( !this.isEnabled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tview.focus();\n\t\t} );\n\n\t\t// Dragging out of the editable.\n\t\tthis.listenTo( viewDocument, 'dragleave', () => {\n\t\t\t// We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds\n\t\t\t// to check if 'dragover' is not fired.\n\t\t\tthis._removeDropMarkerDelayed();\n\t\t} );\n\n\t\t// Handler for moving dragged content over the target area.\n\t\tthis.listenTo( viewDocument, 'dragging', ( evt, data ) => {\n\t\t\tif ( !this.isEnabled ) {\n\t\t\t\tdata.dataTransfer.dropEffect = 'none';\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._removeDropMarkerDelayed.cancel();\n\n\t\t\tconst targetRange = findDropTargetRange( editor, data.targetRanges, data.target );\n\n\t\t\t// If this is content being dragged from another editor, moving out of current editor instance\n\t\t\t// is not possible until 'dragend' event case will be fixed.\n\t\t\tif ( !this._draggedRange ) {\n\t\t\t\tdata.dataTransfer.dropEffect = 'copy';\n\t\t\t}\n\n\t\t\t// In Firefox it is already set and effect allowed remains the same as originally set.\n\t\t\tif ( !env.isGecko ) {\n\t\t\t\tif ( data.dataTransfer.effectAllowed == 'copy' ) {\n\t\t\t\t\tdata.dataTransfer.dropEffect = 'copy';\n\t\t\t\t} else if ( [ 'all', 'copyMove' ].includes( data.dataTransfer.effectAllowed ) ) {\n\t\t\t\t\tdata.dataTransfer.dropEffect = 'move';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* istanbul ignore else */\n\t\t\tif ( targetRange ) {\n\t\t\t\tthis._updateDropMarkerThrottled( targetRange );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Integration with the `clipboardInput` event.\n\t *\n\t * @private\n\t */\n\t_setupClipboardInputIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t// Update the event target ranges and abort dropping if dropping over itself.\n\t\tthis.listenTo( viewDocument, 'clipboardInput', ( evt, data ) => {\n\t\t\tif ( data.method != 'drop' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst targetRange = findDropTargetRange( editor, data.targetRanges, data.target );\n\n\t\t\t// The dragging markers must be removed after searching for the target range because sometimes\n\t\t\t// the target lands on the marker itself.\n\t\t\tthis._removeDropMarker();\n\n\t\t\t/* istanbul ignore if */\n\t\t\tif ( !targetRange ) {\n\t\t\t\tthis._finalizeDragging( false );\n\t\t\t\tevt.stop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop\n\t\t\t// or it is from some previous not cleared one.\n\t\t\tif ( this._draggedRange && this._draggingUid != data.dataTransfer.getData( 'application/ckeditor5-dragging-uid' ) ) {\n\t\t\t\tthis._draggedRange.detach();\n\t\t\t\tthis._draggedRange = null;\n\t\t\t\tthis._draggingUid = '';\n\t\t\t}\n\n\t\t\t// Do not do anything if some content was dragged within the same document to the same position.\n\t\t\tconst isMove = getFinalDropEffect( data.dataTransfer ) == 'move';\n\n\t\t\tif ( isMove && this._draggedRange && this._draggedRange.containsRange( targetRange, true ) ) {\n\t\t\t\tthis._finalizeDragging( false );\n\t\t\t\tevt.stop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Override the target ranges with the one adjusted to the best one for a drop.\n\t\t\tdata.targetRanges = [ editor.editing.mapper.toViewRange( targetRange ) ];\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Integration with the `contentInsertion` event of the clipboard pipeline.\n\t *\n\t * @private\n\t */\n\t_setupContentInsertionIntegration() {\n\t\tconst clipboardPipeline = this.editor.plugins.get( ClipboardPipeline );\n\n\t\tclipboardPipeline.on( 'contentInsertion', ( evt, data ) => {\n\t\t\tif ( !this.isEnabled || data.method !== 'drop' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the selection to the target range in the same change block to avoid selection post-fixing\n\t\t\t// and to be able to clone text attributes for plain text dropping.\n\t\t\tconst ranges = data.targetRanges.map( viewRange => this.editor.editing.mapper.toModelRange( viewRange ) );\n\n\t\t\tthis.editor.model.change( writer => writer.setSelection( ranges ) );\n\t\t}, { priority: 'high' } );\n\n\t\tclipboardPipeline.on( 'contentInsertion', ( evt, data ) => {\n\t\t\tif ( !this.isEnabled || data.method !== 'drop' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remove dragged range content, remove markers, clean after dragging.\n\t\t\tconst isMove = getFinalDropEffect( data.dataTransfer ) == 'move';\n\n\t\t\t// Whether any content was inserted (insertion might fail if the schema is disallowing some elements\n\t\t\t// (for example an image caption allows only the content of a block but not blocks themselves.\n\t\t\t// Some integrations might not return valid range (i.e., table pasting).\n\t\t\tconst isSuccess = !data.resultRange || !data.resultRange.isCollapsed;\n\n\t\t\tthis._finalizeDragging( isSuccess && isMove );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.\n\t *\n\t * @private\n\t */\n\t_setupDraggableAttributeHandling() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t// Add the 'draggable' attribute to the widget while pressing the selection handle.\n\t\t// This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.\n\t\tthis.listenTo( viewDocument, 'mousedown', ( evt, data ) => {\n\t\t\t// The lack of data can be caused by editor tests firing fake mouse events. This should not occur\n\t\t\t// in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.\n\t\t\tif ( env.isAndroid || !data ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._clearDraggableAttributesDelayed.cancel();\n\n\t\t\t// Check if this is a mousedown over the widget (but not a nested editable).\n\t\t\tlet draggableElement = findDraggableWidget( data.target );\n\n\t\t\t// Note: There is a limitation that if more than a widget is selected (a widget and some text)\n\t\t\t// and dragging starts on the widget, then only the widget is dragged.\n\n\t\t\t// If this was not a widget then we should check if we need to drag some text content.\n\t\t\t// In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.\n\t\t\t// In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).\n\t\t\t// Disabled in read-only mode because draggable=\"true\" + contenteditable=\"false\" results\n\t\t\t// in not firing selectionchange event ever, which makes the selection stuck in read-only mode.\n\t\t\tif ( env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed ) {\n\t\t\t\tconst selectedElement = viewDocument.selection.getSelectedElement();\n\n\t\t\t\tif ( !selectedElement || !isWidget( selectedElement ) ) {\n\t\t\t\t\tdraggableElement = viewDocument.selection.editableElement;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( draggableElement ) {\n\t\t\t\tview.change( writer => {\n\t\t\t\t\twriter.setAttribute( 'draggable', 'true', draggableElement );\n\t\t\t\t} );\n\n\t\t\t\t// Keep the reference to the model element in case the view element gets removed while dragging.\n\t\t\t\tthis._draggableElement = editor.editing.mapper.toModelElement( draggableElement );\n\t\t\t}\n\t\t} );\n\n\t\t// Remove the draggable attribute in case no dragging started (only mousedown + mouseup).\n\t\tthis.listenTo( viewDocument, 'mouseup', () => {\n\t\t\tif ( !env.isAndroid ) {\n\t\t\t\tthis._clearDraggableAttributesDelayed();\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Removes the `draggable` attribute from the element that was used for dragging.\n\t *\n\t * @private\n\t */\n\t_clearDraggableAttributes() {\n\t\tconst editing = this.editor.editing;\n\n\t\tediting.view.change( writer => {\n\t\t\t// Remove 'draggable' attribute.\n\t\t\tif ( this._draggableElement && this._draggableElement.root.rootName != '$graveyard' ) {\n\t\t\t\twriter.removeAttribute( 'draggable', editing.mapper.toViewElement( this._draggableElement ) );\n\t\t\t}\n\n\t\t\tthis._draggableElement = null;\n\t\t} );\n\t}\n\n\t/**\n\t * Creates downcast conversion for the drop target marker.\n\t *\n\t * @private\n\t */\n\t_setupDropMarker() {\n\t\tconst editor = this.editor;\n\n\t\t// Drop marker conversion for hovering over widgets.\n\t\teditor.conversion.for( 'editingDowncast' ).markerToHighlight( {\n\t\t\tmodel: 'drop-target',\n\t\t\tview: {\n\t\t\t\tclasses: [ 'ck-clipboard-drop-target-range' ]\n\t\t\t}\n\t\t} );\n\n\t\t// Drop marker conversion for in text drop target.\n\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t\t\tmodel: 'drop-target',\n\t\t\tview: ( data, { writer } ) => {\n\t\t\t\tconst inText = editor.model.schema.checkChild( data.markerRange.start, '$text' );\n\n\t\t\t\tif ( !inText ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturn writer.createUIElement( 'span', { class: 'ck ck-clipboard-drop-target-position' }, function( domDocument ) {\n\t\t\t\t\tconst domElement = this.toDomElement( domDocument );\n\n\t\t\t\t\t// Using word joiner to make this marker as high as text and also making text not break on marker.\n\t\t\t\t\tdomElement.innerHTML = '&NoBreak;<span></span>&NoBreak;';\n\n\t\t\t\t\treturn domElement;\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Updates the drop target marker to the provided range.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} targetRange The range to set the marker to.\n\t */\n\t_updateDropMarker( targetRange ) {\n\t\tconst editor = this.editor;\n\t\tconst markers = editor.model.markers;\n\n\t\teditor.model.change( writer => {\n\t\t\tif ( markers.has( 'drop-target' ) ) {\n\t\t\t\tif ( !markers.get( 'drop-target' ).getRange().isEqual( targetRange ) ) {\n\t\t\t\t\twriter.updateMarker( 'drop-target', { range: targetRange } );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twriter.addMarker( 'drop-target', {\n\t\t\t\t\trange: targetRange,\n\t\t\t\t\tusingOperation: false,\n\t\t\t\t\taffectsData: false\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Removes the drop target marker.\n\t *\n\t * @private\n\t */\n\t_removeDropMarker() {\n\t\tconst model = this.editor.model;\n\n\t\tthis._removeDropMarkerDelayed.cancel();\n\t\tthis._updateDropMarkerThrottled.cancel();\n\n\t\tif ( model.markers.has( 'drop-target' ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.removeMarker( 'drop-target' );\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Deletes the dragged content from its original range and clears the dragging state.\n\t *\n\t * @private\n\t * @param {Boolean} moved Whether the move succeeded.\n\t */\n\t_finalizeDragging( moved ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\n\t\tthis._removeDropMarker();\n\t\tthis._clearDraggableAttributes();\n\n\t\tif ( editor.plugins.has( 'WidgetToolbarRepository' ) ) {\n\t\t\teditor.plugins.get( 'WidgetToolbarRepository' ).clearForceDisabled( 'dragDrop' );\n\t\t}\n\n\t\tthis._draggingUid = '';\n\n\t\tif ( !this._draggedRange ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Delete moved content.\n\t\tif ( moved && this.isEnabled ) {\n\t\t\tmodel.deleteContent( model.createSelection( this._draggedRange ), { doNotAutoparagraph: true } );\n\t\t}\n\n\t\tthis._draggedRange.detach();\n\t\tthis._draggedRange = null;\n\t}\n}\n\n// Returns fixed selection range for given position and target element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {Array.<module:engine/view/range~Range>} targetViewRanges\n// @param {module:engine/view/element~Element} targetViewElement\n// @returns {module:engine/model/range~Range|null}\nfunction findDropTargetRange( editor, targetViewRanges, targetViewElement ) {\n\tconst model = editor.model;\n\tconst mapper = editor.editing.mapper;\n\n\tlet range = null;\n\n\tconst targetViewPosition = targetViewRanges ? targetViewRanges[ 0 ].start : null;\n\n\t// A UIElement is not a valid drop element, use parent (this could be a drop marker or any other UIElement).\n\tif ( targetViewElement.is( 'uiElement' ) ) {\n\t\ttargetViewElement = targetViewElement.parent;\n\t}\n\n\t// Quick win if the target is a widget (but not a nested editable).\n\trange = findDropTargetRangeOnWidget( editor, targetViewElement );\n\n\tif ( range ) {\n\t\treturn range;\n\t}\n\n\t// The easiest part is over, now we need to move to the model space.\n\n\t// Find target model element and position.\n\tconst targetModelElement = getClosestMappedModelElement( editor, targetViewElement );\n\tconst targetModelPosition = targetViewPosition ? mapper.toModelPosition( targetViewPosition ) : null;\n\n\t// There is no target position while hovering over an empty table cell.\n\t// In Safari, target position can be empty while hovering over a widget (e.g., a page-break).\n\t// Find the drop position inside the element.\n\tif ( !targetModelPosition ) {\n\t\treturn findDropTargetRangeInElement( editor, targetModelElement );\n\t}\n\n\t// Check if target position is between blocks and adjust drop position to the next object.\n\t// This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n\trange = findDropTargetRangeBetweenBlocks( editor, targetModelPosition, targetModelElement );\n\n\tif ( range ) {\n\t\treturn range;\n\t}\n\n\t// Try fixing selection position.\n\t// In Firefox, the target position lands before widgets but in other browsers it tends to land after a widget.\n\trange = model.schema.getNearestSelectionRange( targetModelPosition, env.isGecko ? 'forward' : 'backward' );\n\n\tif ( range ) {\n\t\treturn range;\n\t}\n\n\t// There is no valid selection position inside the current limit element so find a closest object ancestor.\n\t// This happens if the model position lands directly in the <table> element itself (view target element was a `<td>`\n\t// so a nested editable, but view target position was directly in the `<figure>` element).\n\treturn findDropTargetRangeOnAncestorObject( editor, targetModelPosition.parent );\n}\n\n// Returns fixed selection range for a given position and a target element if it is over the widget but not over its nested editable.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/view/element~Element} targetViewElement\n// @returns {module:engine/model/range~Range|null}\nfunction findDropTargetRangeOnWidget( editor, targetViewElement ) {\n\tconst model = editor.model;\n\tconst mapper = editor.editing.mapper;\n\n\t// Quick win if the target is a widget.\n\tif ( isWidget( targetViewElement ) ) {\n\t\treturn model.createRangeOn( mapper.toModelElement( targetViewElement ) );\n\t}\n\n\t// Check if we are deeper over a widget (but not over a nested editable).\n\tif ( !targetViewElement.is( 'editableElement' ) ) {\n\t\t// Find a closest ancestor that is either a widget or an editable element...\n\t\tconst ancestor = targetViewElement.findAncestor( node => isWidget( node ) || node.is( 'editableElement' ) );\n\n\t\t// ...and if the widget was closer then it is a drop target.\n\t\tif ( isWidget( ancestor ) ) {\n\t\t\treturn model.createRangeOn( mapper.toModelElement( ancestor ) );\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Returns fixed selection range inside a model element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/element~Element} targetModelElement\n// @returns {module:engine/model/range~Range}\nfunction findDropTargetRangeInElement( editor, targetModelElement ) {\n\tconst model = editor.model;\n\tconst schema = model.schema;\n\n\tconst positionAtElementStart = model.createPositionAt( targetModelElement, 0 );\n\n\treturn schema.getNearestSelectionRange( positionAtElementStart, 'forward' );\n}\n\n// Returns fixed selection range for a given position and a target element if the drop is between blocks.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/position~Position} targetModelPosition\n// @param {module:engine/model/element~Element} targetModelElement\n// @returns {module:engine/model/range~Range|null}\nfunction findDropTargetRangeBetweenBlocks( editor, targetModelPosition, targetModelElement ) {\n\tconst model = editor.model;\n\n\t// Check if target is between blocks.\n\tif ( !model.schema.checkChild( targetModelElement, '$block' ) ) {\n\t\treturn null;\n\t}\n\n\t// Find position between blocks.\n\tconst positionAtElementStart = model.createPositionAt( targetModelElement, 0 );\n\n\t// Get the common part of the path (inside the target element and the target position).\n\tconst commonPath = targetModelPosition.path.slice( 0, positionAtElementStart.path.length );\n\n\t// Position between the blocks.\n\tconst betweenBlocksPosition = model.createPositionFromPath( targetModelPosition.root, commonPath );\n\tconst nodeAfter = betweenBlocksPosition.nodeAfter;\n\n\t// Adjust drop position to the next object.\n\t// This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n\tif ( nodeAfter && model.schema.isObject( nodeAfter ) ) {\n\t\treturn model.createRangeOn( nodeAfter );\n\t}\n\n\treturn null;\n}\n\n// Returns a selection range on the ancestor object.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/range~Range}\nfunction findDropTargetRangeOnAncestorObject( editor, element ) {\n\tconst model = editor.model;\n\n\twhile ( element ) {\n\t\tif ( model.schema.isObject( element ) ) {\n\t\t\treturn model.createRangeOn( element );\n\t\t}\n\n\t\telement = element.parent;\n\t}\n}\n\n// Returns the closest model element for the specified view element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/view/element~Element} element\n// @returns {module:engine/model/element~Element}\nfunction getClosestMappedModelElement( editor, element ) {\n\tconst mapper = editor.editing.mapper;\n\tconst view = editor.editing.view;\n\n\tconst targetModelElement = mapper.toModelElement( element );\n\n\tif ( targetModelElement ) {\n\t\treturn targetModelElement;\n\t}\n\n\t// Find mapped ancestor if the target is inside not mapped element (for example inline code element).\n\tconst viewPosition = view.createPositionBefore( element );\n\tconst viewElement = mapper.findMappedViewAncestor( viewPosition );\n\n\treturn mapper.toModelElement( viewElement );\n}\n\n// Returns the drop effect that should be a result of dragging the content.\n// This function is handling a quirk when checking the effect in the 'drop' DOM event.\nfunction getFinalDropEffect( dataTransfer ) {\n\tif ( env.isGecko ) {\n\t\treturn dataTransfer.dropEffect;\n\t}\n\n\treturn [ 'all', 'copyMove' ].includes( dataTransfer.effectAllowed ) ? 'move' : 'copy';\n}\n\n// Returns a function wrapper that will trigger a function after a specified wait time.\n// The timeout can be canceled by calling the cancel function on the returned wrapped function.\n//\n// @param {Function} func The function to wrap.\n// @param {Number} wait The timeout in ms.\n// @returns {Function}\nfunction delay( func, wait ) {\n\tlet timer;\n\n\tfunction delayed( ...args ) {\n\t\tdelayed.cancel();\n\t\ttimer = setTimeout( () => func( ...args ), wait );\n\t}\n\n\tdelayed.cancel = () => {\n\t\tclearTimeout( timer );\n\t};\n\n\treturn delayed;\n}\n\n// Returns a widget element that should be dragged.\n//\n// @param {module:engine/view/element~Element} target\n// @returns {module:engine/view/element~Element}\nfunction findDraggableWidget( target ) {\n\t// This is directly an editable so not a widget for sure.\n\tif ( target.is( 'editableElement' ) ) {\n\t\treturn null;\n\t}\n\n\t// TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.\n\tif ( target.hasClass( 'ck-widget__selection-handle' ) ) {\n\t\treturn target.findAncestor( isWidget );\n\t}\n\n\t// Direct hit on a widget.\n\tif ( isWidget( target ) ) {\n\t\treturn target;\n\t}\n\n\t// Find closest ancestor that is either a widget or an editable element...\n\tconst ancestor = target.findAncestor( node => isWidget( node ) || node.is( 'editableElement' ) );\n\n\t// ...and if closer was the widget then enable dragging it.\n\tif ( isWidget( ancestor ) ) {\n\t\treturn ancestor;\n\t}\n\n\treturn null;\n}\n"]},"metadata":{},"sourceType":"module"}