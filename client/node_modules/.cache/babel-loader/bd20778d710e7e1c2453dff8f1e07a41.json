{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/utils\n */\n\n/* global fetch, File */\nimport { global } from 'ckeditor5/src/utils';\n/**\n * Creates a regular expression used to test for image files.\n *\n *\t\tconst imageType = createImageTypeRegExp( [ 'png', 'jpeg', 'svg+xml', 'vnd.microsoft.icon' ] );\n *\n *\t\tconsole.log( 'is supported image', imageType.test( file.type ) );\n *\n * @param {Array.<String>} types\n * @returns {RegExp}\n */\n\nexport function createImageTypeRegExp(types) {\n  // Sanitize the MIME type name which may include: \"+\", \"-\" or \".\".\n  const regExpSafeNames = types.map(type => type.replace('+', '\\\\+'));\n  return new RegExp(`^image\\\\/(${regExpSafeNames.join('|')})$`);\n}\n/**\n * Creates a promise that fetches the image local source (Base64 or blob) and resolves with a `File` object.\n *\n * @param {module:engine/view/element~Element} image Image whose source to fetch.\n * @returns {Promise.<File>} A promise which resolves when an image source is fetched and converted to a `File` instance.\n * It resolves with a `File` object. If there were any errors during file processing, the promise will be rejected.\n */\n\nexport function fetchLocalImage(image) {\n  return new Promise((resolve, reject) => {\n    const imageSrc = image.getAttribute('src'); // Fetch works asynchronously and so does not block browser UI when processing data.\n\n    fetch(imageSrc).then(resource => resource.blob()).then(blob => {\n      const mimeType = getImageMimeType(blob, imageSrc);\n      const ext = mimeType.replace('image/', '');\n      const filename = `image.${ext}`;\n      const file = new File([blob], filename, {\n        type: mimeType\n      });\n      resolve(file);\n    }).catch(err => {\n      // Fetch fails only, if it can't make a request due to a network failure or if anything prevented the request\n      // from completing, i.e. the Content Security Policy rules. It is not possible to detect the exact cause of failure,\n      // so we are just trying the fallback solution, if general TypeError is thrown.\n      return err && err.name === 'TypeError' ? convertLocalImageOnCanvas(imageSrc).then(resolve).catch(reject) : reject(err);\n    });\n  });\n}\n/**\n * Checks whether a given node is an image element with a local source (Base64 or blob).\n *\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @param {module:engine/view/node~Node} node The node to check.\n * @returns {Boolean}\n */\n\nexport function isLocalImage(imageUtils, node) {\n  if (!imageUtils.isInlineImageView(node) || !node.getAttribute('src')) {\n    return false;\n  }\n\n  return node.getAttribute('src').match(/^data:image\\/\\w+;base64,/g) || node.getAttribute('src').match(/^blob:/g);\n} // Extracts an image type based on its blob representation or its source.\n//\n// @param {String} src Image `src` attribute value.\n// @param {Blob} blob Image blob representation.\n// @returns {String}\n\nfunction getImageMimeType(blob, src) {\n  if (blob.type) {\n    return blob.type;\n  } else if (src.match(/data:(image\\/\\w+);base64/)) {\n    return src.match(/data:(image\\/\\w+);base64/)[1].toLowerCase();\n  } else {\n    // Fallback to 'jpeg' as common extension.\n    return 'image/jpeg';\n  }\n} // Creates a promise that converts the image local source (Base64 or blob) to a blob using canvas and resolves\n// with a `File` object.\n//\n// @param {String} imageSrc Image `src` attribute value.\n// @returns {Promise.<File>} A promise which resolves when an image source is converted to a `File` instance.\n// It resolves with a `File` object. If there were any errors during file processing, the promise will be rejected.\n\n\nfunction convertLocalImageOnCanvas(imageSrc) {\n  return getBlobFromCanvas(imageSrc).then(blob => {\n    const mimeType = getImageMimeType(blob, imageSrc);\n    const ext = mimeType.replace('image/', '');\n    const filename = `image.${ext}`;\n    return new File([blob], filename, {\n      type: mimeType\n    });\n  });\n} // Creates a promise that resolves with a `Blob` object converted from the image source (Base64 or blob).\n//\n// @param {String} imageSrc Image `src` attribute value.\n// @returns {Promise.<Blob>}\n\n\nfunction getBlobFromCanvas(imageSrc) {\n  return new Promise((resolve, reject) => {\n    const image = global.document.createElement('img');\n    image.addEventListener('load', () => {\n      const canvas = global.document.createElement('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0);\n      canvas.toBlob(blob => blob ? resolve(blob) : reject());\n    });\n    image.addEventListener('error', () => reject());\n    image.src = imageSrc;\n  });\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-image/src/imageupload/utils.js"],"names":["global","createImageTypeRegExp","types","regExpSafeNames","map","type","replace","RegExp","join","fetchLocalImage","image","Promise","resolve","reject","imageSrc","getAttribute","fetch","then","resource","blob","mimeType","getImageMimeType","ext","filename","file","File","catch","err","name","convertLocalImageOnCanvas","isLocalImage","imageUtils","node","isInlineImageView","match","src","toLowerCase","getBlobFromCanvas","document","createElement","addEventListener","canvas","width","height","ctx","getContext","drawImage","toBlob"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/utils\n */\n\n/* global fetch, File */\n\nimport { global } from 'ckeditor5/src/utils';\n\n/**\n * Creates a regular expression used to test for image files.\n *\n *\t\tconst imageType = createImageTypeRegExp( [ 'png', 'jpeg', 'svg+xml', 'vnd.microsoft.icon' ] );\n *\n *\t\tconsole.log( 'is supported image', imageType.test( file.type ) );\n *\n * @param {Array.<String>} types\n * @returns {RegExp}\n */\nexport function createImageTypeRegExp( types ) {\n\t// Sanitize the MIME type name which may include: \"+\", \"-\" or \".\".\n\tconst regExpSafeNames = types.map( type => type.replace( '+', '\\\\+' ) );\n\n\treturn new RegExp( `^image\\\\/(${ regExpSafeNames.join( '|' ) })$` );\n}\n\n/**\n * Creates a promise that fetches the image local source (Base64 or blob) and resolves with a `File` object.\n *\n * @param {module:engine/view/element~Element} image Image whose source to fetch.\n * @returns {Promise.<File>} A promise which resolves when an image source is fetched and converted to a `File` instance.\n * It resolves with a `File` object. If there were any errors during file processing, the promise will be rejected.\n */\nexport function fetchLocalImage( image ) {\n\treturn new Promise( ( resolve, reject ) => {\n\t\tconst imageSrc = image.getAttribute( 'src' );\n\n\t\t// Fetch works asynchronously and so does not block browser UI when processing data.\n\t\tfetch( imageSrc )\n\t\t\t.then( resource => resource.blob() )\n\t\t\t.then( blob => {\n\t\t\t\tconst mimeType = getImageMimeType( blob, imageSrc );\n\t\t\t\tconst ext = mimeType.replace( 'image/', '' );\n\t\t\t\tconst filename = `image.${ ext }`;\n\t\t\t\tconst file = new File( [ blob ], filename, { type: mimeType } );\n\n\t\t\t\tresolve( file );\n\t\t\t} )\n\t\t\t.catch( err => {\n\t\t\t\t// Fetch fails only, if it can't make a request due to a network failure or if anything prevented the request\n\t\t\t\t// from completing, i.e. the Content Security Policy rules. It is not possible to detect the exact cause of failure,\n\t\t\t\t// so we are just trying the fallback solution, if general TypeError is thrown.\n\t\t\t\treturn err && err.name === 'TypeError' ?\n\t\t\t\t\tconvertLocalImageOnCanvas( imageSrc ).then( resolve ).catch( reject ) :\n\t\t\t\t\treject( err );\n\t\t\t} );\n\t} );\n}\n\n/**\n * Checks whether a given node is an image element with a local source (Base64 or blob).\n *\n * @param {module:image/imageutils~ImageUtils} imageUtils\n * @param {module:engine/view/node~Node} node The node to check.\n * @returns {Boolean}\n */\nexport function isLocalImage( imageUtils, node ) {\n\tif ( !imageUtils.isInlineImageView( node ) || !node.getAttribute( 'src' ) ) {\n\t\treturn false;\n\t}\n\n\treturn node.getAttribute( 'src' ).match( /^data:image\\/\\w+;base64,/g ) ||\n\t\tnode.getAttribute( 'src' ).match( /^blob:/g );\n}\n\n// Extracts an image type based on its blob representation or its source.\n//\n// @param {String} src Image `src` attribute value.\n// @param {Blob} blob Image blob representation.\n// @returns {String}\nfunction getImageMimeType( blob, src ) {\n\tif ( blob.type ) {\n\t\treturn blob.type;\n\t} else if ( src.match( /data:(image\\/\\w+);base64/ ) ) {\n\t\treturn src.match( /data:(image\\/\\w+);base64/ )[ 1 ].toLowerCase();\n\t} else {\n\t\t// Fallback to 'jpeg' as common extension.\n\t\treturn 'image/jpeg';\n\t}\n}\n\n// Creates a promise that converts the image local source (Base64 or blob) to a blob using canvas and resolves\n// with a `File` object.\n//\n// @param {String} imageSrc Image `src` attribute value.\n// @returns {Promise.<File>} A promise which resolves when an image source is converted to a `File` instance.\n// It resolves with a `File` object. If there were any errors during file processing, the promise will be rejected.\nfunction convertLocalImageOnCanvas( imageSrc ) {\n\treturn getBlobFromCanvas( imageSrc ).then( blob => {\n\t\tconst mimeType = getImageMimeType( blob, imageSrc );\n\t\tconst ext = mimeType.replace( 'image/', '' );\n\t\tconst filename = `image.${ ext }`;\n\n\t\treturn new File( [ blob ], filename, { type: mimeType } );\n\t} );\n}\n\n// Creates a promise that resolves with a `Blob` object converted from the image source (Base64 or blob).\n//\n// @param {String} imageSrc Image `src` attribute value.\n// @returns {Promise.<Blob>}\nfunction getBlobFromCanvas( imageSrc ) {\n\treturn new Promise( ( resolve, reject ) => {\n\t\tconst image = global.document.createElement( 'img' );\n\n\t\timage.addEventListener( 'load', () => {\n\t\t\tconst canvas = global.document.createElement( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\t\tctx.drawImage( image, 0, 0 );\n\n\t\t\tcanvas.toBlob( blob => blob ? resolve( blob ) : reject() );\n\t\t} );\n\n\t\timage.addEventListener( 'error', () => reject() );\n\n\t\timage.src = imageSrc;\n\t} );\n}\n"]},"metadata":{},"sourceType":"module"}