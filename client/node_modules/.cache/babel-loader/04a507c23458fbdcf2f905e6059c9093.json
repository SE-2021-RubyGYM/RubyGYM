{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\n/**\n * @module widget/verticalnavigationhandler\n */\n\n/**\n * Returns 'keydown' handler for up/down arrow keys that modifies the caret movement if it's in a text line next to an object.\n *\n * @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n * @returns {Function}\n */\n\nexport default function verticalNavigationHandler(editing) {\n  const model = editing.model;\n  return (evt, data) => {\n    const arrowUpPressed = data.keyCode == keyCodes.arrowup;\n    const arrowDownPressed = data.keyCode == keyCodes.arrowdown;\n    const expandSelection = data.shiftKey;\n    const selection = model.document.selection;\n\n    if (!arrowUpPressed && !arrowDownPressed) {\n      return;\n    }\n\n    const isForward = arrowDownPressed; // Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n    // Selection for sure will not approach any object.\n\n    if (expandSelection && selectionWillShrink(selection, isForward)) {\n      return;\n    } // Find a range between selection and closest limit element.\n\n\n    const range = findTextRangeFromSelection(editing, selection, isForward); // There is no selection position inside the limit element.\n\n    if (!range) {\n      return;\n    } // If already at the edge of a limit element.\n\n\n    if (range.isCollapsed) {\n      // A collapsed selection at limit edge - nothing more to do.\n      if (selection.isCollapsed) {\n        return;\n      } // A non collapsed selection is at the limit edge while expanding the selection - let others do their stuff.\n      else if (expandSelection) {\n        return;\n      }\n    } // If the range is a single line (there is no word wrapping) then move the selection to the position closest to the limit element.\n    //\n    // We can't move the selection directly to the isObject element (eg. table cell) because of dual position at the end/beginning\n    // of wrapped line (it's at the same time at the end of one line and at the start of the next line).\n\n\n    if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {\n      model.change(writer => {\n        const newPosition = isForward ? range.end : range.start;\n\n        if (expandSelection) {\n          const newSelection = model.createSelection(selection.anchor);\n          newSelection.setFocus(newPosition);\n          writer.setSelection(newSelection);\n        } else {\n          writer.setSelection(newPosition);\n        }\n      });\n      evt.stop();\n      data.preventDefault();\n      data.stopPropagation();\n    }\n  };\n} // Finds the range between selection and closest limit element (in the direction of navigation).\n// The position next to limit element is adjusted to the closest allowed `$text` position.\n//\n// Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/selection~Selection} selection The current selection.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {module:engine/model/range~Range|null}\n//\n\nfunction findTextRangeFromSelection(editing, selection, isForward) {\n  const model = editing.model;\n\n  if (isForward) {\n    const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();\n    const endPosition = getNearestNonInlineLimit(model, startPosition, 'forward'); // There is no limit element, browser should handle this.\n\n    if (!endPosition) {\n      return null;\n    }\n\n    const range = model.createRange(startPosition, endPosition);\n    const lastRangePosition = getNearestTextPosition(model.schema, range, 'backward');\n\n    if (lastRangePosition) {\n      return model.createRange(startPosition, lastRangePosition);\n    }\n\n    return null;\n  } else {\n    const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();\n    const startPosition = getNearestNonInlineLimit(model, endPosition, 'backward'); // There is no limit element, browser should handle this.\n\n    if (!startPosition) {\n      return null;\n    }\n\n    const range = model.createRange(startPosition, endPosition);\n    const firstRangePosition = getNearestTextPosition(model.schema, range, 'forward');\n\n    if (firstRangePosition) {\n      return model.createRange(firstRangePosition, endPosition);\n    }\n\n    return null;\n  }\n} // Finds the limit element position that is closest to startPosition.\n//\n// @param {module:engine/model/model~Model} model\n// @param {<module:engine/model/position~Position>} startPosition\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {<module:engine/model/position~Position>|null}\n//\n\n\nfunction getNearestNonInlineLimit(model, startPosition, direction) {\n  const schema = model.schema;\n  const range = model.createRangeIn(startPosition.root);\n  const walkerValueType = direction == 'forward' ? 'elementStart' : 'elementEnd';\n\n  for (const {\n    previousPosition,\n    item,\n    type\n  } of range.getWalker({\n    startPosition,\n    direction\n  })) {\n    if (schema.isLimit(item) && !schema.isInline(item)) {\n      return previousPosition;\n    } // Stop looking for isLimit element if the next element is a block element (it is for sure not single line).\n\n\n    if (type == walkerValueType && schema.isBlock(item)) {\n      return null;\n    }\n  }\n\n  return null;\n} // Basing on the provided range, finds the first or last (depending on `direction`) position inside the range\n// that can contain `$text` (according to schema).\n//\n// @param {module:engine/model/schema~Schema} schema The schema.\n// @param {module:engine/model/range~Range} range The range to find the position in.\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {module:engine/model/position~Position|null} The nearest selection position.\n//\n\n\nfunction getNearestTextPosition(schema, range, direction) {\n  const position = direction == 'backward' ? range.end : range.start;\n\n  if (schema.checkChild(position, '$text')) {\n    return position;\n  }\n\n  for (const {\n    nextPosition\n  } of range.getWalker({\n    direction\n  })) {\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  }\n\n  return null;\n} // Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects\n// (verifying if they visually wrap content to the next line).\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/range~Range} modelRange The current table cell content range.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {Boolean}\n//\n\n\nfunction isSingleLineRange(editing, modelRange, isForward) {\n  const model = editing.model;\n  const domConverter = editing.view.domConverter; // Wrapped lines contain exactly the same position at the end of current line\n  // and at the beginning of next line. That position's client rect is at the end\n  // of current line. In case of caret at first position of the last line that 'dual'\n  // position would be detected as it's not the last line.\n\n  if (isForward) {\n    const probe = model.createSelection(modelRange.start);\n    model.modifySelection(probe); // If the new position is at the end of the container then we can't use this position\n    // because it would provide incorrect result for eg caption of image and selection\n    // just before end of it. Also in this case there is no \"dual\" position.\n\n    if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {\n      modelRange = model.createRange(probe.focus, modelRange.end);\n    }\n  }\n\n  const viewRange = editing.mapper.toViewRange(modelRange);\n  const domRange = domConverter.viewRangeToDom(viewRange);\n  const rects = Rect.getDomRangeRects(domRange);\n  let boundaryVerticalPosition;\n\n  for (const rect of rects) {\n    if (boundaryVerticalPosition === undefined) {\n      boundaryVerticalPosition = Math.round(rect.bottom);\n      continue;\n    } // Let's check if this rect is in new line.\n\n\n    if (Math.round(rect.top) >= boundaryVerticalPosition) {\n      return false;\n    }\n\n    boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));\n  }\n\n  return true;\n}\n\nfunction selectionWillShrink(selection, isForward) {\n  return !selection.isCollapsed && selection.isBackward == isForward;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-widget/src/verticalnavigation.js"],"names":["keyCodes","Rect","verticalNavigationHandler","editing","model","evt","data","arrowUpPressed","keyCode","arrowup","arrowDownPressed","arrowdown","expandSelection","shiftKey","selection","document","isForward","selectionWillShrink","range","findTextRangeFromSelection","isCollapsed","isSingleLineRange","change","writer","newPosition","end","start","newSelection","createSelection","anchor","setFocus","setSelection","stop","preventDefault","stopPropagation","startPosition","focus","getLastPosition","endPosition","getNearestNonInlineLimit","createRange","lastRangePosition","getNearestTextPosition","schema","getFirstPosition","firstRangePosition","direction","createRangeIn","root","walkerValueType","previousPosition","item","type","getWalker","isLimit","isInline","isBlock","position","checkChild","nextPosition","modelRange","domConverter","view","probe","modifySelection","isAtEnd","isEqual","viewRange","mapper","toViewRange","domRange","viewRangeToDom","rects","getDomRangeRects","boundaryVerticalPosition","rect","undefined","Math","round","bottom","top","max","isBackward"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\n\n/**\n * @module widget/verticalnavigationhandler\n */\n\n/**\n * Returns 'keydown' handler for up/down arrow keys that modifies the caret movement if it's in a text line next to an object.\n *\n * @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n * @returns {Function}\n */\nexport default function verticalNavigationHandler( editing ) {\n\tconst model = editing.model;\n\n\treturn ( evt, data ) => {\n\t\tconst arrowUpPressed = data.keyCode == keyCodes.arrowup;\n\t\tconst arrowDownPressed = data.keyCode == keyCodes.arrowdown;\n\t\tconst expandSelection = data.shiftKey;\n\t\tconst selection = model.document.selection;\n\n\t\tif ( !arrowUpPressed && !arrowDownPressed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isForward = arrowDownPressed;\n\n\t\t// Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n\t\t// Selection for sure will not approach any object.\n\t\tif ( expandSelection && selectionWillShrink( selection, isForward ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find a range between selection and closest limit element.\n\t\tconst range = findTextRangeFromSelection( editing, selection, isForward );\n\n\t\t// There is no selection position inside the limit element.\n\t\tif ( !range ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If already at the edge of a limit element.\n\t\tif ( range.isCollapsed ) {\n\t\t\t// A collapsed selection at limit edge - nothing more to do.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// A non collapsed selection is at the limit edge while expanding the selection - let others do their stuff.\n\t\t\telse if ( expandSelection ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the range is a single line (there is no word wrapping) then move the selection to the position closest to the limit element.\n\t\t//\n\t\t// We can't move the selection directly to the isObject element (eg. table cell) because of dual position at the end/beginning\n\t\t// of wrapped line (it's at the same time at the end of one line and at the start of the next line).\n\t\tif ( range.isCollapsed || isSingleLineRange( editing, range, isForward ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\tconst newPosition = isForward ? range.end : range.start;\n\n\t\t\t\tif ( expandSelection ) {\n\t\t\t\t\tconst newSelection = model.createSelection( selection.anchor );\n\t\t\t\t\tnewSelection.setFocus( newPosition );\n\n\t\t\t\t\twriter.setSelection( newSelection );\n\t\t\t\t} else {\n\t\t\t\t\twriter.setSelection( newPosition );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tevt.stop();\n\t\t\tdata.preventDefault();\n\t\t\tdata.stopPropagation();\n\t\t}\n\t};\n}\n\n// Finds the range between selection and closest limit element (in the direction of navigation).\n// The position next to limit element is adjusted to the closest allowed `$text` position.\n//\n// Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/selection~Selection} selection The current selection.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {module:engine/model/range~Range|null}\n//\nfunction findTextRangeFromSelection( editing, selection, isForward ) {\n\tconst model = editing.model;\n\n\tif ( isForward ) {\n\t\tconst startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();\n\t\tconst endPosition = getNearestNonInlineLimit( model, startPosition, 'forward' );\n\n\t\t// There is no limit element, browser should handle this.\n\t\tif ( !endPosition ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst range = model.createRange( startPosition, endPosition );\n\t\tconst lastRangePosition = getNearestTextPosition( model.schema, range, 'backward' );\n\n\t\tif ( lastRangePosition ) {\n\t\t\treturn model.createRange( startPosition, lastRangePosition );\n\t\t}\n\n\t\treturn null;\n\t} else {\n\t\tconst endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();\n\t\tconst startPosition = getNearestNonInlineLimit( model, endPosition, 'backward' );\n\n\t\t// There is no limit element, browser should handle this.\n\t\tif ( !startPosition ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst range = model.createRange( startPosition, endPosition );\n\t\tconst firstRangePosition = getNearestTextPosition( model.schema, range, 'forward' );\n\n\t\tif ( firstRangePosition ) {\n\t\t\treturn model.createRange( firstRangePosition, endPosition );\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Finds the limit element position that is closest to startPosition.\n//\n// @param {module:engine/model/model~Model} model\n// @param {<module:engine/model/position~Position>} startPosition\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {<module:engine/model/position~Position>|null}\n//\nfunction getNearestNonInlineLimit( model, startPosition, direction ) {\n\tconst schema = model.schema;\n\tconst range = model.createRangeIn( startPosition.root );\n\n\tconst walkerValueType = direction == 'forward' ? 'elementStart' : 'elementEnd';\n\n\tfor ( const { previousPosition, item, type } of range.getWalker( { startPosition, direction } ) ) {\n\t\tif ( schema.isLimit( item ) && !schema.isInline( item ) ) {\n\t\t\treturn previousPosition;\n\t\t}\n\n\t\t// Stop looking for isLimit element if the next element is a block element (it is for sure not single line).\n\t\tif ( type == walkerValueType && schema.isBlock( item ) ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Basing on the provided range, finds the first or last (depending on `direction`) position inside the range\n// that can contain `$text` (according to schema).\n//\n// @param {module:engine/model/schema~Schema} schema The schema.\n// @param {module:engine/model/range~Range} range The range to find the position in.\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {module:engine/model/position~Position|null} The nearest selection position.\n//\nfunction getNearestTextPosition( schema, range, direction ) {\n\tconst position = direction == 'backward' ? range.end : range.start;\n\n\tif ( schema.checkChild( position, '$text' ) ) {\n\t\treturn position;\n\t}\n\n\tfor ( const { nextPosition } of range.getWalker( { direction } ) ) {\n\t\tif ( schema.checkChild( nextPosition, '$text' ) ) {\n\t\t\treturn nextPosition;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects\n// (verifying if they visually wrap content to the next line).\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/range~Range} modelRange The current table cell content range.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {Boolean}\n//\nfunction isSingleLineRange( editing, modelRange, isForward ) {\n\tconst model = editing.model;\n\tconst domConverter = editing.view.domConverter;\n\n\t// Wrapped lines contain exactly the same position at the end of current line\n\t// and at the beginning of next line. That position's client rect is at the end\n\t// of current line. In case of caret at first position of the last line that 'dual'\n\t// position would be detected as it's not the last line.\n\tif ( isForward ) {\n\t\tconst probe = model.createSelection( modelRange.start );\n\n\t\tmodel.modifySelection( probe );\n\n\t\t// If the new position is at the end of the container then we can't use this position\n\t\t// because it would provide incorrect result for eg caption of image and selection\n\t\t// just before end of it. Also in this case there is no \"dual\" position.\n\t\tif ( !probe.focus.isAtEnd && !modelRange.start.isEqual( probe.focus ) ) {\n\t\t\tmodelRange = model.createRange( probe.focus, modelRange.end );\n\t\t}\n\t}\n\n\tconst viewRange = editing.mapper.toViewRange( modelRange );\n\tconst domRange = domConverter.viewRangeToDom( viewRange );\n\tconst rects = Rect.getDomRangeRects( domRange );\n\n\tlet boundaryVerticalPosition;\n\n\tfor ( const rect of rects ) {\n\t\tif ( boundaryVerticalPosition === undefined ) {\n\t\t\tboundaryVerticalPosition = Math.round( rect.bottom );\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Let's check if this rect is in new line.\n\t\tif ( Math.round( rect.top ) >= boundaryVerticalPosition ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboundaryVerticalPosition = Math.max( boundaryVerticalPosition, Math.round( rect.bottom ) );\n\t}\n\n\treturn true;\n}\n\nfunction selectionWillShrink( selection, isForward ) {\n\treturn !selection.isCollapsed && selection.isBackward == isForward;\n}\n"]},"metadata":{},"sourceType":"module"}