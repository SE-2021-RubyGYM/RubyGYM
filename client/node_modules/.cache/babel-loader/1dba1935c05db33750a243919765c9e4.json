{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Matcher from '../view/matcher';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nexport default class UpcastHelpers extends ConversionHelpers {\n  /**\n   * View element to model element conversion helper.\n   *\n   * This conversion results in creating a model element. For example,\n   * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n   *\n   * Keep in mind that the element will be inserted only if it is allowed\n   * by {@link module:engine/model/schema~Schema schema} configuration.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   *\t\t\tview: 'p',\n   *\t\t\tmodel: 'paragraph'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   *\t\t\tview: 'p',\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'p',\n   *\t\t\t\tclasses: 'fancy'\n   *\t\t\t},\n   *\t\t\tmodel: 'fancyParagraph'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   * \t\t\tview: {\n   *\t\t\t\tname: 'p',\n   *\t\t\t\tclasses: 'heading'\n   * \t\t\t},\n   * \t\t\tmodel: ( viewElement, conversionApi ) => {\n   * \t\t\t\tconst modelWriter = conversionApi.writer;\n   *\n   * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n   * \t\t\t}\n   * \t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToElement\n   * @param {Object} config Conversion configuration.\n   * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n   * set, the converter will fire for every view element.\n   * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element instance or a\n   * function that takes a view element and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}\n   * and returns a model element. The model element will be inserted in the model.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n  elementToElement(config) {\n    return this.add(upcastElementToElement(config));\n  }\n  /**\n   * View element to model attribute conversion helper.\n   *\n   * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n   * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n   *\n   * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n   *\n   *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n   *\n   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n   * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n   *\n   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: 'strong',\n   *\t\t\tmodel: 'bold'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: 'strong',\n   *\t\t\tmodel: 'bold',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tclasses: 'bold'\n   *\t\t\t},\n   *\t\t\tmodel: 'bold'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'styled',\n   *\t\t\t\tvalue: 'dark'\n   *\t\t\t}\n   *\t\t} );\n   *\n   * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tstyles: {\n   *\t\t\t\t\t'font-size': /[\\s\\S]+/\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'fontSize',\n   *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n   *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n   *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n   *\n   *\t\t\t\t\tif ( value <= 10 ) {\n   *\t\t\t\t\t\treturn 'small';\n   *\t\t\t\t\t} else if ( value > 12 ) {\n   *\t\t\t\t\t\treturn 'big';\n   *\t\t\t\t\t}\n   *\n   *\t\t\t\t\treturn null;\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToAttribute\n   * @param {Object} config Conversion configuration.\n   * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n   * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n   * the model attribute. `value` property may be set as a function that takes a view element and\n   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n   * If `String` is given, the model attribute value will be set to `true`.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  elementToAttribute(config) {\n    return this.add(upcastElementToAttribute(config));\n  }\n  /**\n   * View attribute to model attribute conversion helper.\n   *\n   * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n   * `<imageBlock source=\"foo.jpg\"></imageBlock>` in the model.\n   *\n   * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n   * is set only on the corresponding model node:\n   *\n   *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n   *\n   * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n   * all the children in the model:\n   *\n   *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n   *\n   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n   * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n   *\n   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: 'src',\n   *\t\t\tmodel: 'source'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: { key: 'src' },\n   *\t\t\tmodel: 'source'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: { key: 'src' },\n   *\t\t\tmodel: 'source',\n   *\t\t\tconverterPriority: 'normal'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tkey: 'data-style',\n   *\t\t\t\tvalue: /[\\s\\S]+/\n   *\t\t\t},\n   *\t\t\tmodel: 'styled'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'img',\n   *\t\t\t\tkey: 'class',\n   *\t\t\t\tvalue: 'styled-dark'\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'styled',\n   *\t\t\t\tvalue: 'dark'\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tkey: 'class',\n   *\t\t\t\tvalue: /styled-[\\S]+/\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'styled'\n   *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n   *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n   *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n   *\n   *\t\t\t\t\treturn match[ 1 ];\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n   * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n   * callback that returns the desired value.\n   *\n   *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tstyles: {\n   *\t\t\t\t\t'font-weight': 'bold'\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: 'bold'\n   *\t\t} );\n   *\n   *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tstyles: {\n   *\t\t\t\t\t'line-height': /[\\s\\S]+/\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'lineHeight',\n   *\t\t\t\tvalue: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToAttribute\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n   * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n   * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n   * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n   * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n   * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n   * the model attribute. `value` property may be set as a function that takes a view element and\n   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n   * If `String` is given, the model attribute value will be same as view attribute value.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  attributeToAttribute(config) {\n    return this.add(upcastAttributeToAttribute(config));\n  }\n  /**\n   * View element to model marker conversion helper.\n   *\n   * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n   * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n   * after the conversion is done, the marker will be available in\n   * {@link module:engine/model/model~Model#markers model document markers}.\n   *\n   * **Note**: When this helper is used in the data upcast in combination with\n   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,\n   * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.\n   *\n   * In most of the cases, the {@link #dataToMarker} should be used instead.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: 'marker-search',\n   *\t\t\tmodel: 'search'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: 'marker-search',\n   *\t\t\tmodel: 'search',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: 'marker-search',\n   *\t\t\tmodel: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tattributes: {\n   *\t\t\t\t\t'data-marker': 'search'\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: 'search'\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToMarker\n   * @param {Object} config Conversion configuration.\n   * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n   * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n   * a model marker name.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  elementToMarker(config) {\n    return this.add(upcastElementToMarker(config));\n  }\n  /**\n   * View-to-model marker conversion helper.\n   *\n   * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}\n   * back to a model marker.\n   *\n   * This converter looks for specific view elements and view attributes that mark marker boundaries. See\n   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data\n   * is expected by this converter.\n   *\n   * The `config.view` property is equal to the marker group name to convert.\n   *\n   * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).\n   *\n   * The conversion configuration can take a function that will generate a marker name.\n   * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is\n   * expected to return a string with the marker name.\n   *\n   * Basic usage:\n   *\n   *\t\t// Using the default conversion.\n   *\t\t// In this case, all markers from the `comment` group will be converted.\n   *\t\t// The conversion will look for `<comment-start>` and `<comment-end>` tags and\n   *\t\t// `data-comment-start-before`, `data-comment-start-after`,\n   *\t\t// `data-comment-end-before` and `data-comment-end-after` attributes.\n   *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n   *\t\t\tview: 'comment'\n   *\t\t} );\n   *\n   * An example of a model that may be generated by this conversion:\n   *\n   *\t\t// View:\n   *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n   *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n   *\n   *\t\t// Model:\n   *\t\t<paragraph>Foo[bar</paragraph>\n   *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n   *\n   * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.\n   *\n   * Other examples of usage:\n   *\n   *\t\t// Using a custom function which is the same as the default conversion:\n   *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n   *\t\t\tview: 'comment',\n   *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n   *\t\t} );\n   *\n   *\t\t// Using the converter priority:\n   *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n   *\t\t\tview: 'comment',\n   *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #dataToMarker\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.view The marker group name to convert.\n   * @param {Function} [config.model] A function that takes the `name` part from the view element or attribute and\n   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  dataToMarker(config) {\n    return this.add(upcastDataToMarker(config));\n  }\n\n}\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\n\nexport function convertToModelFragment() {\n  return (evt, data, conversionApi) => {\n    // Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {\n      name: true\n    })) {\n      const {\n        modelRange,\n        modelCursor\n      } = conversionApi.convertChildren(data.viewItem, data.modelCursor);\n      data.modelRange = modelRange;\n      data.modelCursor = modelCursor;\n    }\n  };\n}\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\n\nexport function convertText() {\n  return (evt, data, _ref) => {\n    let {\n      schema,\n      consumable,\n      writer\n    } = _ref;\n    let position = data.modelCursor; // When node is already converted then do nothing.\n\n    if (!consumable.test(data.viewItem)) {\n      return;\n    }\n\n    if (!schema.checkChild(position, '$text')) {\n      if (!isParagraphable(position, '$text', schema)) {\n        return;\n      }\n\n      position = wrapInParagraph(position, writer);\n    }\n\n    consumable.consume(data.viewItem);\n    const text = writer.createText(data.viewItem.data);\n    writer.insert(text, position);\n    data.modelRange = writer.createRange(position, position.getShiftedBy(text.offsetSize));\n    data.modelCursor = data.modelRange.end;\n  };\n}\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\n\nexport function convertSelectionChange(model, mapper) {\n  return (evt, data) => {\n    const viewSelection = data.newSelection;\n    const ranges = [];\n\n    for (const viewRange of viewSelection.getRanges()) {\n      ranges.push(mapper.toModelRange(viewRange));\n    }\n\n    const modelSelection = model.createSelection(ranges, {\n      backward: viewSelection.isBackward\n    });\n\n    if (!modelSelection.isEqual(model.document.selection)) {\n      model.change(writer => {\n        writer.setSelection(modelSelection);\n      });\n    }\n  };\n} // View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\nfunction upcastElementToElement(config) {\n  config = cloneDeep(config);\n  const converter = prepareToElementConverter(config);\n  const elementName = getViewElementNameFromConfig(config.view);\n  const eventName = elementName ? 'element:' + elementName : 'element';\n  return dispatcher => {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToAttribute(config) {\n  config = cloneDeep(config);\n  normalizeModelAttributeConfig(config);\n  const converter = prepareToAttributeConverter(config, false);\n  const elementName = getViewElementNameFromConfig(config.view);\n  const eventName = elementName ? 'element:' + elementName : 'element';\n  return dispatcher => {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  let viewKey = null;\n\n  if (typeof config.view == 'string' || config.view.key) {\n    viewKey = normalizeViewAttributeKeyValueConfig(config);\n  }\n\n  normalizeModelAttributeConfig(config, viewKey);\n  const converter = prepareToAttributeConverter(config, true);\n  return dispatcher => {\n    dispatcher.on('element', converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToMarker(config) {\n  config = cloneDeep(config);\n  normalizeElementToMarkerConfig(config);\n  return upcastElementToElement(config);\n} // View data to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#dataToMarker} to learn more.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\n\n\nfunction upcastDataToMarker(config) {\n  config = cloneDeep(config); // Default conversion.\n\n  if (!config.model) {\n    config.model = name => {\n      return name ? config.view + ':' + name : config.view;\n    };\n  }\n\n  const converterStart = prepareToElementConverter(normalizeDataToMarkerConfig(config, 'start'));\n  const converterEnd = prepareToElementConverter(normalizeDataToMarkerConfig(config, 'end'));\n  return dispatcher => {\n    dispatcher.on('element:' + config.view + '-start', converterStart, {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('element:' + config.view + '-end', converterEnd, {\n      priority: config.converterPriority || 'normal'\n    }); // Below is a hack that is needed to properly handle `converterPriority` for both elements and attributes.\n    // Attribute conversion needs to be performed *after* element conversion.\n    // This converter handles both element conversion and attribute conversion, which means that if a single\n    // `config.converterPriority` is used, it will lead to problems. For example, if the `'high'` priority is used,\n    // the attribute conversion will be performed before a lot of element upcast converters.\n    // On the other hand, we want to support `config.converterPriority` and converter overwriting.\n    //\n    // To make it work, we need to do some extra processing for priority for attribute converter.\n    // Priority `'low'` value should be the base value and then we will change it depending on `config.converterPriority` value.\n    //\n    // This hack probably would not be needed if attributes are upcasted separately.\n    //\n\n    const basePriority = priorities.get('low');\n    const maxPriority = priorities.get('highest');\n    const priorityFactor = priorities.get(config.converterPriority) / maxPriority; // Number in range [ -1, 1 ].\n\n    dispatcher.on('element', upcastAttributeToMarker(config), {\n      priority: basePriority + priorityFactor\n    });\n  };\n} // Function factory, returns a callback function which converts view attributes to a model marker.\n//\n// The converter looks for elements with `data-group-start-before`, `data-group-start-after`, `data-group-end-before`\n// and `data-group-end-after` attributes and inserts `$marker` model elements before/after those elements.\n// `group` part is specified in `config.view`.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @returns {Function} Marker converter.\n\n\nfunction upcastAttributeToMarker(config) {\n  return (evt, data, conversionApi) => {\n    const attrName = `data-${config.view}`; // Check if any attribute for the given view item can be consumed before changing the conversion data\n    // and consuming view items with these attributes.\n\n    if (!conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-end-after'\n    }) && !conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-start-after'\n    }) && !conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-end-before'\n    }) && !conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-start-before'\n    })) {\n      return;\n    } // This converter wants to add a model element, marking a marker, before/after an element (or maybe even group of elements).\n    // To do that, we can use `data.modelRange` which is set on an element (or a group of elements) that has been upcasted.\n    // But, if the processed view element has not been upcasted yet (it does not have been converted), we need to\n    // fire conversion for its children first, then we will have `data.modelRange` available.\n\n\n    if (!data.modelRange) {\n      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-end-after'\n    })) {\n      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + '-end-after').split(','));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-start-after'\n    })) {\n      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + '-start-after').split(','));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-end-before'\n    })) {\n      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + '-end-before').split(','));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-start-before'\n    })) {\n      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + '-start-before').split(','));\n    }\n\n    function addMarkerElements(position, markerViewNames) {\n      for (const markerViewName of markerViewNames) {\n        const markerName = config.model(markerViewName, conversionApi);\n        const element = conversionApi.writer.createElement('$marker', {\n          'data-name': markerName\n        });\n        conversionApi.writer.insert(element, position);\n\n        if (data.modelCursor.isEqual(position)) {\n          data.modelCursor = data.modelCursor.getShiftedBy(1);\n        } else {\n          data.modelCursor = data.modelCursor._getTransformedByInsertion(position, 1);\n        }\n\n        data.modelRange = data.modelRange._getTransformedByInsertion(position, 1)[0];\n      }\n    }\n  };\n} // Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\n\n\nfunction getViewElementNameFromConfig(viewConfig) {\n  if (typeof viewConfig == 'string') {\n    return viewConfig;\n  }\n\n  if (typeof viewConfig == 'object' && typeof viewConfig.name == 'string') {\n    return viewConfig.name;\n  }\n\n  return null;\n} // Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\n\n\nfunction prepareToElementConverter(config) {\n  const matcher = new Matcher(config.view);\n  return (evt, data, conversionApi) => {\n    const matcherResult = matcher.match(data.viewItem);\n\n    if (!matcherResult) {\n      return;\n    }\n\n    const match = matcherResult.match; // Force consuming element's name.\n\n    match.name = true;\n\n    if (!conversionApi.consumable.test(data.viewItem, match)) {\n      return;\n    }\n\n    const modelElement = getModelElement(config.model, data.viewItem, conversionApi);\n\n    if (!modelElement) {\n      return;\n    }\n\n    if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {\n      return;\n    }\n\n    conversionApi.consumable.consume(data.viewItem, match);\n    conversionApi.convertChildren(data.viewItem, modelElement);\n    conversionApi.updateConversionResult(modelElement, data);\n  };\n} // Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi The upcast conversion API.\n\n\nfunction getModelElement(model, input, conversionApi) {\n  if (model instanceof Function) {\n    return model(input, conversionApi);\n  } else {\n    return conversionApi.writer.createElement(model);\n  }\n} // Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\n\n\nfunction normalizeViewAttributeKeyValueConfig(config) {\n  if (typeof config.view == 'string') {\n    config.view = {\n      key: config.view\n    };\n  }\n\n  const key = config.view.key;\n  let normalized;\n\n  if (key == 'class' || key == 'style') {\n    const keyName = key == 'class' ? 'classes' : 'styles';\n    normalized = {\n      [keyName]: config.view.value\n    };\n  } else {\n    const value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n    normalized = {\n      attributes: {\n        [key]: value\n      }\n    };\n  }\n\n  if (config.view.name) {\n    normalized.name = config.view.name;\n  }\n\n  config.view = normalized;\n  return key;\n} // Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\n\n\nfunction normalizeModelAttributeConfig(config) {\n  let viewAttributeKeyToCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute(viewAttributeKeyToCopy);\n  const key = typeof config.model != 'object' ? config.model : config.model.key;\n  const value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n  config.model = {\n    key,\n    value\n  };\n} // Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n\n\nfunction prepareToAttributeConverter(config, shallow) {\n  const matcher = new Matcher(config.view);\n  return (evt, data, conversionApi) => {\n    const match = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.\n\n    if (!match) {\n      return;\n    }\n\n    if (onlyViewNameIsDefined(config.view, data.viewItem)) {\n      match.match.name = true;\n    } else {\n      // Do not test or consume `name` consumable.\n      delete match.match.name;\n    } // Try to consume appropriate values from consumable values list.\n\n\n    if (!conversionApi.consumable.test(data.viewItem, match.match)) {\n      return;\n    }\n\n    const modelKey = config.model.key;\n    const modelValue = typeof config.model.value == 'function' ? config.model.value(data.viewItem, conversionApi) : config.model.value; // Do not convert if attribute building function returned falsy value.\n\n    if (modelValue === null) {\n      return;\n    } // Since we are converting to attribute we need a range on which we will set the attribute.\n    // If the range is not created yet, let's create it by converting children of the current node first.\n\n\n    if (!data.modelRange) {\n      // Convert children and set conversion result as a current data.\n      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n    } // Set attribute on current `output`. `Schema` is checked inside this helper function.\n\n\n    const attributeWasSet = setAttributeOn(data.modelRange, {\n      key: modelKey,\n      value: modelValue\n    }, shallow, conversionApi); // It may happen that a converter will try to set an attribute that is not allowed in the given context.\n    // In such a situation we cannot consume the attribute. See: https://github.com/ckeditor/ckeditor5/pull/9249#issuecomment-815658459.\n\n    if (attributeWasSet) {\n      conversionApi.consumable.consume(data.viewItem, match.match);\n    }\n  };\n} // Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\n\n\nfunction onlyViewNameIsDefined(viewConfig, viewItem) {\n  // https://github.com/ckeditor/ckeditor5-engine/issues/1786\n  const configToTest = typeof viewConfig == 'function' ? viewConfig(viewItem) : viewConfig;\n\n  if (typeof configToTest == 'object' && !getViewElementNameFromConfig(configToTest)) {\n    return false;\n  }\n\n  return !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n} // Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// If any node on the given range has already defined an attribute with the same name, its value will not be updated.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\n\n\nfunction setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {\n  let result = false; // Set attribute on each item in range according to Schema.\n\n  for (const node of Array.from(modelRange.getItems({\n    shallow\n  }))) {\n    // Skip if not allowed.\n    if (!conversionApi.schema.checkAttribute(node, modelAttribute.key)) {\n      continue;\n    } // Mark the node as consumed even if the attribute will not be updated because it's in a valid context (schema)\n    // and would be converted if the attribute wouldn't be present. See #8921.\n\n\n    result = true; // Do not override the attribute if it's already present.\n\n    if (node.hasAttribute(modelAttribute.key)) {\n      continue;\n    }\n\n    conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);\n  }\n\n  return result;\n} // Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\n\n\nfunction normalizeElementToMarkerConfig(config) {\n  const oldModel = config.model;\n\n  config.model = (viewElement, conversionApi) => {\n    const markerName = typeof oldModel == 'string' ? oldModel : oldModel(viewElement, conversionApi);\n    return conversionApi.writer.createElement('$marker', {\n      'data-name': markerName\n    });\n  };\n} // Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastDataToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\n\n\nfunction normalizeDataToMarkerConfig(config, type) {\n  const configForElements = {}; // Upcast <markerGroup-start> and <markerGroup-end> elements.\n\n  configForElements.view = config.view + '-' + type;\n\n  configForElements.model = (viewElement, conversionApi) => {\n    const viewName = viewElement.getAttribute('name');\n    const markerName = config.model(viewName, conversionApi);\n    return conversionApi.writer.createElement('$marker', {\n      'data-name': markerName\n    });\n  };\n\n  return configForElements;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js"],"names":["Matcher","ConversionHelpers","cloneDeep","priorities","isParagraphable","wrapInParagraph","UpcastHelpers","elementToElement","config","add","upcastElementToElement","elementToAttribute","upcastElementToAttribute","attributeToAttribute","upcastAttributeToAttribute","elementToMarker","upcastElementToMarker","dataToMarker","upcastDataToMarker","convertToModelFragment","evt","data","conversionApi","modelRange","consumable","consume","viewItem","name","modelCursor","convertChildren","convertText","schema","writer","position","test","checkChild","text","createText","insert","createRange","getShiftedBy","offsetSize","end","convertSelectionChange","model","mapper","viewSelection","newSelection","ranges","viewRange","getRanges","push","toModelRange","modelSelection","createSelection","backward","isBackward","isEqual","document","selection","change","setSelection","converter","prepareToElementConverter","elementName","getViewElementNameFromConfig","view","eventName","dispatcher","on","priority","converterPriority","normalizeModelAttributeConfig","prepareToAttributeConverter","viewKey","key","normalizeViewAttributeKeyValueConfig","normalizeElementToMarkerConfig","converterStart","normalizeDataToMarkerConfig","converterEnd","basePriority","get","maxPriority","priorityFactor","upcastAttributeToMarker","attrName","attributes","Object","assign","addMarkerElements","getAttribute","split","start","markerViewNames","markerViewName","markerName","element","createElement","_getTransformedByInsertion","viewConfig","matcher","matcherResult","match","modelElement","getModelElement","safeInsert","updateConversionResult","input","Function","normalized","keyName","value","viewAttributeKeyToCopy","defaultModelValue","viewElement","shallow","onlyViewNameIsDefined","modelKey","modelValue","attributeWasSet","setAttributeOn","configToTest","classes","styles","modelAttribute","result","node","Array","from","getItems","checkAttribute","hasAttribute","setAttribute","oldModel","type","configForElements","viewName"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,OAAOA,OAAP,MAAoB,iBAApB;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AAEA,SAASC,SAAT,QAA0B,WAA1B;AAEA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,SAASC,eAAT,EAA0BC,eAA1B,QAAiD,iCAAjD;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,aAAN,SAA4BL,iBAA5B,CAA8C;AAC5D;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCM,EAAAA,gBAAgB,CAAEC,MAAF,EAAW;AAC1B,WAAO,KAAKC,GAAL,CAAUC,sBAAsB,CAAEF,MAAF,CAAhC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,kBAAkB,CAAEH,MAAF,EAAW;AAC5B,WAAO,KAAKC,GAAL,CAAUG,wBAAwB,CAAEJ,MAAF,CAAlC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCK,EAAAA,oBAAoB,CAAEL,MAAF,EAAW;AAC9B,WAAO,KAAKC,GAAL,CAAUK,0BAA0B,CAAEN,MAAF,CAApC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCO,EAAAA,eAAe,CAAEP,MAAF,EAAW;AACzB,WAAO,KAAKC,GAAL,CAAUO,qBAAqB,CAAER,MAAF,CAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport Matcher from '../view/matcher';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\n\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\n\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class UpcastHelpers extends ConversionHelpers {\n\t/**\n\t * View element to model element conversion helper.\n\t *\n\t * This conversion results in creating a model element. For example,\n\t * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n\t *\n\t * Keep in mind that the element will be inserted only if it is allowed\n\t * by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'fancyParagraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t * \t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'heading'\n\t * \t\t\t},\n\t * \t\t\tmodel: ( viewElement, conversionApi ) => {\n\t * \t\t\t\tconst modelWriter = conversionApi.writer;\n\t *\n\t * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n\t * \t\t\t}\n\t * \t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n\t * set, the converter will fire for every view element.\n\t * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element instance or a\n\t * function that takes a view element and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}\n\t * and returns a model element. The model element will be inserted in the model.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( upcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * View element to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n\t * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n\t *\n\t * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-size': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n\t *\n\t *\t\t\t\t\tif ( value <= 10 ) {\n\t *\t\t\t\t\t\treturn 'small';\n\t *\t\t\t\t\t} else if ( value > 12 ) {\n\t *\t\t\t\t\t\treturn 'big';\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and\n\t * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n\t * If `String` is given, the model attribute value will be set to `true`.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToAttribute( config ) {\n\t\treturn this.add( upcastElementToAttribute( config ) );\n\t}\n\n\t/**\n\t * View attribute to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n\t * `<imageBlock source=\"foo.jpg\"></imageBlock>` in the model.\n\t *\n\t * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n\t * is set only on the corresponding model node:\n\t *\n\t *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n\t *\n\t * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n\t * all the children in the model:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: 'src',\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tconverterPriority: 'normal'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'data-style',\n\t *\t\t\t\tvalue: /[\\s\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: 'styled'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'img',\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: 'styled-dark'\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: /styled-[\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled'\n\t *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n\t *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n\t *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n\t *\n\t *\t\t\t\t\treturn match[ 1 ];\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n\t * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n\t * callback that returns the desired value.\n\t *\n\t *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'line-height': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'lineHeight',\n\t *\t\t\t\tvalue: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n\t * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n\t * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n\t * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n\t * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and\n\t * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n\t * If `String` is given, the model attribute value will be same as view attribute value.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( upcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * View element to model marker conversion helper.\n\t *\n\t * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n\t * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n\t * after the conversion is done, the marker will be available in\n\t * {@link module:engine/model/model~Model#markers model document markers}.\n\t *\n\t * **Note**: When this helper is used in the data upcast in combination with\n\t * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,\n\t * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.\n\t *\n\t * In most of the cases, the {@link #dataToMarker} should be used instead.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToMarker\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n\t * a model marker name.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToMarker( config ) {\n\t\treturn this.add( upcastElementToMarker( config ) );\n\t}\n\n\t/**\n\t * View-to-model marker conversion helper.\n\t *\n\t * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}\n\t * back to a model marker.\n\t *\n\t * This converter looks for specific view elements and view attributes that mark marker boundaries. See\n\t * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data\n\t * is expected by this converter.\n\t *\n\t * The `config.view` property is equal to the marker group name to convert.\n\t *\n\t * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).\n\t *\n\t * The conversion configuration can take a function that will generate a marker name.\n\t * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is\n\t * expected to return a string with the marker name.\n\t *\n\t * Basic usage:\n\t *\n\t *\t\t// Using the default conversion.\n\t *\t\t// In this case, all markers from the `comment` group will be converted.\n\t *\t\t// The conversion will look for `<comment-start>` and `<comment-end>` tags and\n\t *\t\t// `data-comment-start-before`, `data-comment-start-after`,\n\t *\t\t// `data-comment-end-before` and `data-comment-end-after` attributes.\n\t *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n\t *\t\t\tview: 'comment'\n\t *\t\t} );\n\t *\n\t * An example of a model that may be generated by this conversion:\n\t *\n\t *\t\t// View:\n\t *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n\t *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n\t *\n\t *\t\t// Model:\n\t *\t\t<paragraph>Foo[bar</paragraph>\n\t *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n\t *\n\t * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.\n\t *\n\t * Other examples of usage:\n\t *\n\t *\t\t// Using a custom function which is the same as the default conversion:\n\t *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n\t *\t\t\tview: 'comment',\n\t *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n\t *\t\t} );\n\t *\n\t *\t\t// Using the converter priority:\n\t *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n\t *\t\t\tview: 'comment',\n\t *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #dataToMarker\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.view The marker group name to convert.\n\t * @param {Function} [config.model] A function that takes the `name` part from the view element or attribute and\n\t * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tdataToMarker( config ) {\n\t\treturn this.add( upcastDataToMarker( config ) );\n\t}\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\nexport function convertToModelFragment() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n\t\tif ( !data.modelRange && conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\t\tconst { modelRange, modelCursor } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n\n\t\t\tdata.modelRange = modelRange;\n\t\t\tdata.modelCursor = modelCursor;\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\nexport function convertText() {\n\treturn ( evt, data, { schema, consumable, writer } ) => {\n\t\tlet position = data.modelCursor;\n\n\t\t// When node is already converted then do nothing.\n\t\tif ( !consumable.test( data.viewItem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !schema.checkChild( position, '$text' ) ) {\n\t\t\tif ( !isParagraphable( position, '$text', schema ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tposition = wrapInParagraph( position, writer );\n\t\t}\n\n\t\tconsumable.consume( data.viewItem );\n\n\t\tconst text = writer.createText( data.viewItem.data );\n\n\t\twriter.insert( text, position );\n\n\t\tdata.modelRange = writer.createRange(\n\t\t\tposition,\n\t\t\tposition.getShiftedBy( text.offsetSize )\n\t\t);\n\t\tdata.modelCursor = data.modelRange.end;\n\t};\n}\n\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\nexport function convertSelectionChange( model, mapper ) {\n\treturn ( evt, data ) => {\n\t\tconst viewSelection = data.newSelection;\n\n\t\tconst ranges = [];\n\n\t\tfor ( const viewRange of viewSelection.getRanges() ) {\n\t\t\tranges.push( mapper.toModelRange( viewRange ) );\n\t\t}\n\n\t\tconst modelSelection = model.createSelection( ranges, { backward: viewSelection.isBackward } );\n\n\t\tif ( !modelSelection.isEqual( model.document.selection ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( modelSelection );\n\t\t\t} );\n\t\t}\n\t};\n}\n\n// View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst converter = prepareToElementConverter( config );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeModelAttributeConfig( config );\n\n\tconst converter = prepareToAttributeConverter( config, false );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tlet viewKey = null;\n\n\tif ( typeof config.view == 'string' || config.view.key ) {\n\t\tviewKey = normalizeViewAttributeKeyValueConfig( config );\n\t}\n\n\tnormalizeModelAttributeConfig( config, viewKey );\n\n\tconst converter = prepareToAttributeConverter( config, true );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element', converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeElementToMarkerConfig( config );\n\n\treturn upcastElementToElement( config );\n}\n\n// View data to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#dataToMarker} to learn more.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\nfunction upcastDataToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\t// Default conversion.\n\tif ( !config.model ) {\n\t\tconfig.model = name => {\n\t\t\treturn name ? config.view + ':' + name : config.view;\n\t\t};\n\t}\n\n\tconst converterStart = prepareToElementConverter( normalizeDataToMarkerConfig( config, 'start' ) );\n\tconst converterEnd = prepareToElementConverter( normalizeDataToMarkerConfig( config, 'end' ) );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:' + config.view + '-start', converterStart, { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'element:' + config.view + '-end', converterEnd, { priority: config.converterPriority || 'normal' } );\n\n\t\t// Below is a hack that is needed to properly handle `converterPriority` for both elements and attributes.\n\t\t// Attribute conversion needs to be performed *after* element conversion.\n\t\t// This converter handles both element conversion and attribute conversion, which means that if a single\n\t\t// `config.converterPriority` is used, it will lead to problems. For example, if the `'high'` priority is used,\n\t\t// the attribute conversion will be performed before a lot of element upcast converters.\n\t\t// On the other hand, we want to support `config.converterPriority` and converter overwriting.\n\t\t//\n\t\t// To make it work, we need to do some extra processing for priority for attribute converter.\n\t\t// Priority `'low'` value should be the base value and then we will change it depending on `config.converterPriority` value.\n\t\t//\n\t\t// This hack probably would not be needed if attributes are upcasted separately.\n\t\t//\n\t\tconst basePriority = priorities.get( 'low' );\n\t\tconst maxPriority = priorities.get( 'highest' );\n\t\tconst priorityFactor = priorities.get( config.converterPriority ) / maxPriority; // Number in range [ -1, 1 ].\n\n\t\tdispatcher.on( 'element', upcastAttributeToMarker( config ), { priority: basePriority + priorityFactor } );\n\t};\n}\n\n// Function factory, returns a callback function which converts view attributes to a model marker.\n//\n// The converter looks for elements with `data-group-start-before`, `data-group-start-after`, `data-group-end-before`\n// and `data-group-end-after` attributes and inserts `$marker` model elements before/after those elements.\n// `group` part is specified in `config.view`.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @returns {Function} Marker converter.\nfunction upcastAttributeToMarker( config ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst attrName = `data-${ config.view }`;\n\n\t\t// Check if any attribute for the given view item can be consumed before changing the conversion data\n\t\t// and consuming view items with these attributes.\n\t\tif (\n\t\t\t!conversionApi.consumable.test( data.viewItem, { attributes: attrName + '-end-after' } ) &&\n\t\t\t!conversionApi.consumable.test( data.viewItem, { attributes: attrName + '-start-after' } ) &&\n\t\t\t!conversionApi.consumable.test( data.viewItem, { attributes: attrName + '-end-before' } ) &&\n\t\t\t!conversionApi.consumable.test( data.viewItem, { attributes: attrName + '-start-before' } )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// This converter wants to add a model element, marking a marker, before/after an element (or maybe even group of elements).\n\t\t// To do that, we can use `data.modelRange` which is set on an element (or a group of elements) that has been upcasted.\n\t\t// But, if the processed view element has not been upcasted yet (it does not have been converted), we need to\n\t\t// fire conversion for its children first, then we will have `data.modelRange` available.\n\t\tif ( !data.modelRange ) {\n\t\t\tObject.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-end-after' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.end, data.viewItem.getAttribute( attrName + '-end-after' ).split( ',' ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-start-after' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.end, data.viewItem.getAttribute( attrName + '-start-after' ).split( ',' ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-end-before' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.start, data.viewItem.getAttribute( attrName + '-end-before' ).split( ',' ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-start-before' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.start, data.viewItem.getAttribute( attrName + '-start-before' ).split( ',' ) );\n\t\t}\n\n\t\tfunction addMarkerElements( position, markerViewNames ) {\n\t\t\tfor ( const markerViewName of markerViewNames ) {\n\t\t\t\tconst markerName = config.model( markerViewName, conversionApi );\n\t\t\t\tconst element = conversionApi.writer.createElement( '$marker', { 'data-name': markerName } );\n\n\t\t\t\tconversionApi.writer.insert( element, position );\n\n\t\t\t\tif ( data.modelCursor.isEqual( position ) ) {\n\t\t\t\t\tdata.modelCursor = data.modelCursor.getShiftedBy( 1 );\n\t\t\t\t} else {\n\t\t\t\t\tdata.modelCursor = data.modelCursor._getTransformedByInsertion( position, 1 );\n\t\t\t\t}\n\n\t\t\t\tdata.modelRange = data.modelRange._getTransformedByInsertion( position, 1 )[ 0 ];\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\nfunction getViewElementNameFromConfig( viewConfig ) {\n\tif ( typeof viewConfig == 'string' ) {\n\t\treturn viewConfig;\n\t}\n\n\tif ( typeof viewConfig == 'object' && typeof viewConfig.name == 'string' ) {\n\t\treturn viewConfig.name;\n\t}\n\n\treturn null;\n}\n\n// Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\nfunction prepareToElementConverter( config ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst matcherResult = matcher.match( data.viewItem );\n\n\t\tif ( !matcherResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = matcherResult.match;\n\n\t\t// Force consuming element's name.\n\t\tmatch.name = true;\n\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelElement = getModelElement( config.model, data.viewItem, conversionApi );\n\n\t\tif ( !modelElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.safeInsert( modelElement, data.modelCursor ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconversionApi.consumable.consume( data.viewItem, match );\n\t\tconversionApi.convertChildren( data.viewItem, modelElement );\n\t\tconversionApi.updateConversionResult( modelElement, data );\n\t};\n}\n\n// Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi The upcast conversion API.\nfunction getModelElement( model, input, conversionApi ) {\n\tif ( model instanceof Function ) {\n\t\treturn model( input, conversionApi );\n\t} else {\n\t\treturn conversionApi.writer.createElement( model );\n\t}\n}\n\n// Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\nfunction normalizeViewAttributeKeyValueConfig( config ) {\n\tif ( typeof config.view == 'string' ) {\n\t\tconfig.view = { key: config.view };\n\t}\n\n\tconst key = config.view.key;\n\tlet normalized;\n\n\tif ( key == 'class' || key == 'style' ) {\n\t\tconst keyName = key == 'class' ? 'classes' : 'styles';\n\n\t\tnormalized = {\n\t\t\t[ keyName ]: config.view.value\n\t\t};\n\t} else {\n\t\tconst value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n\n\t\tnormalized = {\n\t\t\tattributes: {\n\t\t\t\t[ key ]: value\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( config.view.name ) {\n\t\tnormalized.name = config.view.name;\n\t}\n\n\tconfig.view = normalized;\n\n\treturn key;\n}\n\n// Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\nfunction normalizeModelAttributeConfig( config, viewAttributeKeyToCopy = null ) {\n\tconst defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute( viewAttributeKeyToCopy );\n\n\tconst key = typeof config.model != 'object' ? config.model : config.model.key;\n\tconst value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n\n\tconfig.model = { key, value };\n}\n\n// Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\nfunction prepareToAttributeConverter( config, shallow ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst match = matcher.match( data.viewItem );\n\n\t\t// If there is no match, this callback should not do anything.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( onlyViewNameIsDefined( config.view, data.viewItem ) ) {\n\t\t\tmatch.match.name = true;\n\t\t} else {\n\t\t\t// Do not test or consume `name` consumable.\n\t\t\tdelete match.match.name;\n\t\t}\n\n\t\t// Try to consume appropriate values from consumable values list.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match.match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelKey = config.model.key;\n\t\tconst modelValue = typeof config.model.value == 'function' ?\n\t\t\tconfig.model.value( data.viewItem, conversionApi ) : config.model.value;\n\n\t\t// Do not convert if attribute building function returned falsy value.\n\t\tif ( modelValue === null ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Since we are converting to attribute we need a range on which we will set the attribute.\n\t\t// If the range is not created yet, let's create it by converting children of the current node first.\n\t\tif ( !data.modelRange ) {\n\t\t\t// Convert children and set conversion result as a current data.\n\t\t\tObject.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\t// Set attribute on current `output`. `Schema` is checked inside this helper function.\n\t\tconst attributeWasSet = setAttributeOn( data.modelRange, { key: modelKey, value: modelValue }, shallow, conversionApi );\n\n\t\t// It may happen that a converter will try to set an attribute that is not allowed in the given context.\n\t\t// In such a situation we cannot consume the attribute. See: https://github.com/ckeditor/ckeditor5/pull/9249#issuecomment-815658459.\n\t\tif ( attributeWasSet ) {\n\t\t\tconversionApi.consumable.consume( data.viewItem, match.match );\n\t\t}\n\t};\n}\n\n// Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\nfunction onlyViewNameIsDefined( viewConfig, viewItem ) {\n\t// https://github.com/ckeditor/ckeditor5-engine/issues/1786\n\tconst configToTest = typeof viewConfig == 'function' ? viewConfig( viewItem ) : viewConfig;\n\n\tif ( typeof configToTest == 'object' && !getViewElementNameFromConfig( configToTest ) ) {\n\t\treturn false;\n\t}\n\n\treturn !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n}\n\n// Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// If any node on the given range has already defined an attribute with the same name, its value will not be updated.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\nfunction setAttributeOn( modelRange, modelAttribute, shallow, conversionApi ) {\n\tlet result = false;\n\n\t// Set attribute on each item in range according to Schema.\n\tfor ( const node of Array.from( modelRange.getItems( { shallow } ) ) ) {\n\t\t// Skip if not allowed.\n\t\tif ( !conversionApi.schema.checkAttribute( node, modelAttribute.key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Mark the node as consumed even if the attribute will not be updated because it's in a valid context (schema)\n\t\t// and would be converted if the attribute wouldn't be present. See #8921.\n\t\tresult = true;\n\n\t\t// Do not override the attribute if it's already present.\n\t\tif ( node.hasAttribute( modelAttribute.key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversionApi.writer.setAttribute( modelAttribute.key, modelAttribute.value, node );\n\t}\n\n\treturn result;\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction normalizeElementToMarkerConfig( config ) {\n\tconst oldModel = config.model;\n\n\tconfig.model = ( viewElement, conversionApi ) => {\n\t\tconst markerName = typeof oldModel == 'string' ? oldModel : oldModel( viewElement, conversionApi );\n\n\t\treturn conversionApi.writer.createElement( '$marker', { 'data-name': markerName } );\n\t};\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastDataToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction normalizeDataToMarkerConfig( config, type ) {\n\tconst configForElements = {};\n\n\t// Upcast <markerGroup-start> and <markerGroup-end> elements.\n\tconfigForElements.view = config.view + '-' + type;\n\n\tconfigForElements.model = ( viewElement, conversionApi ) => {\n\t\tconst viewName = viewElement.getAttribute( 'name' );\n\t\tconst markerName = config.model( viewName, conversionApi );\n\n\t\treturn conversionApi.writer.createElement( '$marker', { 'data-name': markerName } );\n\t};\n\n\treturn configForElements;\n}\n"]},"metadata":{},"sourceType":"module"}