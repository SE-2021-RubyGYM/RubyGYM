{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/panel/sticky/stickypanelview\n */\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport View from '../../view';\nimport Template from '../../template';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\nimport '../../../theme/components/panel/stickypanel.css';\nconst toPx = toUnit('px');\n/**\n * The sticky panel view class.\n */\n\nexport default class StickyPanelView extends View {\n  /**\n   * @inheritDoc\n   */\n  constructor(locale) {\n    super(locale);\n    const bind = this.bindTemplate;\n    /**\n     * Controls whether the sticky panel should be active.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isActive\n     */\n\n    this.set('isActive', false);\n    /**\n     * Controls whether the sticky panel is in the \"sticky\" state.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isSticky\n     */\n\n    this.set('isSticky', false);\n    /**\n     * The limiter element for the sticky panel instance. Its bounding rect limits\n     * the \"stickyness\" of the panel, i.e. when the panel reaches the bottom\n     * edge of the limiter, it becomes sticky to that edge and does not float\n     * off the limiter. It is mandatory for the panel to work properly and once\n     * set, it cannot be changed.\n     *\n     * @readonly\n     * @observable\n     * @member {HTMLElement} #limiterElement\n     */\n\n    this.set('limiterElement', null);\n    /**\n     * The offset from the bottom edge of {@link #limiterElement}\n     * which stops the panel from stickying any further to prevent limiter's content\n     * from being completely covered.\n     *\n     * @readonly\n     * @observable\n     * @default 50\n     * @member {Number} #limiterBottomOffset\n     */\n\n    this.set('limiterBottomOffset', 50);\n    /**\n     * The offset from the top edge of the web browser's viewport which makes the\n     * panel become sticky. The default value is `0`, which means the panel becomes\n     * sticky when it's upper edge touches the top of the page viewport.\n     *\n     * This attribute is useful when the web page has UI elements positioned to the top\n     * either using `position: fixed` or `position: sticky`, which would cover the\n     * sticky panel or vice–versa (depending on the `z-index` hierarchy).\n     *\n     * Bound to {@link module:core/editor/editorui~EditorUI#viewportOffset `EditorUI#viewportOffset`}.\n     *\n     * If {@link module:core/editor/editorconfig~EditorConfig#ui `EditorConfig#ui.viewportOffset.top`} is defined, then\n     * it will override the default value.\n     *\n     * @observable\n     * @default 0\n     * @member {Number} #viewportTopOffset\n     */\n\n    this.set('viewportTopOffset', 0);\n    /**\n     * Controls the `margin-left` CSS style of the panel.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {String} #_marginLeft\n     */\n\n    this.set('_marginLeft', null);\n    /**\n     * Set `true` if the sticky panel reached the bottom edge of the\n     * {@link #limiterElement}.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_isStickyToTheLimiter\n     */\n\n    this.set('_isStickyToTheLimiter', false);\n    /**\n     * Set `true` if the sticky panel uses the {@link #viewportTopOffset},\n     * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}\n     * is not `0`.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_hasViewportTopOffset\n     */\n\n    this.set('_hasViewportTopOffset', false);\n    /**\n     * Collection of the child views which creates balloon panel contents.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    this.content = this.createCollection();\n    /**\n     * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.\n     *\n     * @protected\n     * @member {Object} #_panelRect\n     */\n\n    /**\n     * The DOM bounding client rect of the {@link #limiterElement}\n     * of the panel.\n     *\n     * @protected\n     * @member {Object} #_limiterRect\n     */\n\n    /**\n     * A dummy element which visually fills the space as long as the\n     * actual panel is sticky. It prevents flickering of the UI.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n\n    this._contentPanelPlaceholder = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__placeholder'],\n        style: {\n          display: bind.to('isSticky', isSticky => isSticky ? 'block' : 'none'),\n          height: bind.to('isSticky', isSticky => {\n            return isSticky ? toPx(this._panelRect.height) : null;\n          })\n        }\n      }\n    }).render();\n    /**\n     * The panel which accepts children into {@link #content} collection.\n     * Also an element which is positioned when {@link #isSticky}.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n\n    this._contentPanel = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__content', // Toggle class of the panel when \"sticky\" state changes in the view.\n        bind.if('isSticky', 'ck-sticky-panel__content_sticky'), bind.if('_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit')],\n        style: {\n          width: bind.to('isSticky', isSticky => {\n            return isSticky ? toPx(this._contentPanelPlaceholder.getBoundingClientRect().width) : null;\n          }),\n          top: bind.to('_hasViewportTopOffset', _hasViewportTopOffset => {\n            return _hasViewportTopOffset ? toPx(this.viewportTopOffset) : null;\n          }),\n          bottom: bind.to('_isStickyToTheLimiter', _isStickyToTheLimiter => {\n            return _isStickyToTheLimiter ? toPx(this.limiterBottomOffset) : null;\n          }),\n          marginLeft: bind.to('_marginLeft')\n        }\n      },\n      children: this.content\n    }).render();\n    this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel']\n      },\n      children: [this._contentPanelPlaceholder, this._contentPanel]\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  render() {\n    super.render(); // Check if the panel should go into the sticky state immediately.\n\n    this._checkIfShouldBeSticky(); // Update sticky state of the panel as the window is being scrolled.\n\n\n    this.listenTo(global.window, 'scroll', () => {\n      this._checkIfShouldBeSticky();\n    }); // Synchronize with `model.isActive` because sticking an inactive panel is pointless.\n\n    this.listenTo(this, 'change:isActive', () => {\n      this._checkIfShouldBeSticky();\n    });\n  }\n  /**\n   * Analyzes the environment to decide whether the panel should\n   * be sticky or not.\n   *\n   * @protected\n   */\n\n\n  _checkIfShouldBeSticky() {\n    const panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();\n\n    let limiterRect;\n\n    if (!this.limiterElement) {\n      this.isSticky = false;\n    } else {\n      limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect(); // The panel must be active to become sticky.\n\n      this.isSticky = this.isActive && // The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).\n      limiterRect.top < this.viewportTopOffset && // The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.\n      // There's no point in entering the sticky mode if the model#limiterElement is very, very small, because\n      // it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel\n      // would be positioned before the model#limiterElement.\n      this._panelRect.height + this.limiterBottomOffset < limiterRect.height;\n    } // Stick the panel to the top edge of the viewport simulating CSS position:sticky.\n    // TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky\n\n\n    if (this.isSticky) {\n      this._isStickyToTheLimiter = limiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;\n      this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;\n      this._marginLeft = this._isStickyToTheLimiter ? null : toPx(-global.window.scrollX);\n    } // Detach the panel from the top edge of the viewport.\n    else {\n      this._isStickyToTheLimiter = false;\n      this._hasViewportTopOffset = false;\n      this._marginLeft = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js"],"names":["global","View","Template","toUnit","toPx","StickyPanelView","constructor","locale","bind","bindTemplate","set","content","createCollection","_contentPanelPlaceholder","tag","attributes","class","style","display","to","isSticky","height","_panelRect","render","_contentPanel","if","width","getBoundingClientRect","top","_hasViewportTopOffset","viewportTopOffset","bottom","_isStickyToTheLimiter","limiterBottomOffset","marginLeft","children","setTemplate","_checkIfShouldBeSticky","listenTo","window","panelRect","limiterRect","limiterElement","_limiterRect","isActive","_marginLeft","scrollX"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,MAAP,MAAmB,0CAAnB;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,OAAOC,QAAP,MAAqB,gBAArB;AACA,OAAOC,MAAP,MAAmB,0CAAnB;AAEA,OAAO,iDAAP;AAEA,MAAMC,IAAI,GAAGD,MAAM,CAAE,IAAF,CAAnB;AAEA;AACA;AACA;;AACA,eAAe,MAAME,eAAN,SAA8BJ,IAA9B,CAAmC;AACjD;AACD;AACA;AACCK,EAAAA,WAAW,CAAEC,MAAF,EAAW;AACrB,UAAOA,MAAP;AAEA,UAAMC,IAAI,GAAG,KAAKC,YAAlB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,GAAL,CAAU,UAAV,EAAsB,KAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,UAAV,EAAsB,KAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,gBAAV,EAA4B,IAA5B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,qBAAV,EAAiC,EAAjC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,mBAAV,EAA+B,CAA/B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,aAAV,EAAyB,IAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,uBAAV,EAAmC,KAAnC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,uBAAV,EAAmC,KAAnC;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,OAAL,GAAe,KAAKC,gBAAL,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AAC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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/panel/sticky/stickypanelview\n */\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport View from '../../view';\nimport Template from '../../template';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\n\nimport '../../../theme/components/panel/stickypanel.css';\n\nconst toPx = toUnit( 'px' );\n\n/**\n * The sticky panel view class.\n */\nexport default class StickyPanelView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\t/**\n\t\t * Controls whether the sticky panel should be active.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #isActive\n\t\t */\n\t\tthis.set( 'isActive', false );\n\n\t\t/**\n\t\t * Controls whether the sticky panel is in the \"sticky\" state.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #isSticky\n\t\t */\n\t\tthis.set( 'isSticky', false );\n\n\t\t/**\n\t\t * The limiter element for the sticky panel instance. Its bounding rect limits\n\t\t * the \"stickyness\" of the panel, i.e. when the panel reaches the bottom\n\t\t * edge of the limiter, it becomes sticky to that edge and does not float\n\t\t * off the limiter. It is mandatory for the panel to work properly and once\n\t\t * set, it cannot be changed.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {HTMLElement} #limiterElement\n\t\t */\n\t\tthis.set( 'limiterElement', null );\n\n\t\t/**\n\t\t * The offset from the bottom edge of {@link #limiterElement}\n\t\t * which stops the panel from stickying any further to prevent limiter's content\n\t\t * from being completely covered.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @default 50\n\t\t * @member {Number} #limiterBottomOffset\n\t\t */\n\t\tthis.set( 'limiterBottomOffset', 50 );\n\n\t\t/**\n\t\t * The offset from the top edge of the web browser's viewport which makes the\n\t\t * panel become sticky. The default value is `0`, which means the panel becomes\n\t\t * sticky when it's upper edge touches the top of the page viewport.\n\t\t *\n\t\t * This attribute is useful when the web page has UI elements positioned to the top\n\t\t * either using `position: fixed` or `position: sticky`, which would cover the\n\t\t * sticky panel or vice–versa (depending on the `z-index` hierarchy).\n\t\t *\n\t\t * Bound to {@link module:core/editor/editorui~EditorUI#viewportOffset `EditorUI#viewportOffset`}.\n\t\t *\n\t\t * If {@link module:core/editor/editorconfig~EditorConfig#ui `EditorConfig#ui.viewportOffset.top`} is defined, then\n\t\t * it will override the default value.\n\t\t *\n\t\t * @observable\n\t\t * @default 0\n\t\t * @member {Number} #viewportTopOffset\n\t\t */\n\t\tthis.set( 'viewportTopOffset', 0 );\n\n\t\t/**\n\t\t * Controls the `margin-left` CSS style of the panel.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {String} #_marginLeft\n\t\t */\n\t\tthis.set( '_marginLeft', null );\n\n\t\t/**\n\t\t * Set `true` if the sticky panel reached the bottom edge of the\n\t\t * {@link #limiterElement}.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #_isStickyToTheLimiter\n\t\t */\n\t\tthis.set( '_isStickyToTheLimiter', false );\n\n\t\t/**\n\t\t * Set `true` if the sticky panel uses the {@link #viewportTopOffset},\n\t\t * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}\n\t\t * is not `0`.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #_hasViewportTopOffset\n\t\t */\n\t\tthis.set( '_hasViewportTopOffset', false );\n\n\t\t/**\n\t\t * Collection of the child views which creates balloon panel contents.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/viewcollection~ViewCollection}\n\t\t */\n\t\tthis.content = this.createCollection();\n\n\t\t/**\n\t\t * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.\n\t\t *\n\t\t * @protected\n\t\t * @member {Object} #_panelRect\n\t\t */\n\n\t\t/**\n\t\t * The DOM bounding client rect of the {@link #limiterElement}\n\t\t * of the panel.\n\t\t *\n\t\t * @protected\n\t\t * @member {Object} #_limiterRect\n\t\t */\n\n\t\t/**\n\t\t * A dummy element which visually fills the space as long as the\n\t\t * actual panel is sticky. It prevents flickering of the UI.\n\t\t *\n\t\t * @protected\n\t\t * @property {HTMLElement}\n\t\t */\n\t\tthis._contentPanelPlaceholder = new Template( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-sticky-panel__placeholder'\n\t\t\t\t],\n\t\t\t\tstyle: {\n\t\t\t\t\tdisplay: bind.to( 'isSticky', isSticky => isSticky ? 'block' : 'none' ),\n\t\t\t\t\theight: bind.to( 'isSticky', isSticky => {\n\t\t\t\t\t\treturn isSticky ? toPx( this._panelRect.height ) : null;\n\t\t\t\t\t} )\n\t\t\t\t}\n\t\t\t}\n\t\t} ).render();\n\n\t\t/**\n\t\t * The panel which accepts children into {@link #content} collection.\n\t\t * Also an element which is positioned when {@link #isSticky}.\n\t\t *\n\t\t * @protected\n\t\t * @property {HTMLElement}\n\t\t */\n\t\tthis._contentPanel = new Template( {\n\t\t\ttag: 'div',\n\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-sticky-panel__content',\n\t\t\t\t\t// Toggle class of the panel when \"sticky\" state changes in the view.\n\t\t\t\t\tbind.if( 'isSticky', 'ck-sticky-panel__content_sticky' ),\n\t\t\t\t\tbind.if( '_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit' )\n\t\t\t\t],\n\t\t\t\tstyle: {\n\t\t\t\t\twidth: bind.to( 'isSticky', isSticky => {\n\t\t\t\t\t\treturn isSticky ? toPx( this._contentPanelPlaceholder.getBoundingClientRect().width ) : null;\n\t\t\t\t\t} ),\n\n\t\t\t\t\ttop: bind.to( '_hasViewportTopOffset', _hasViewportTopOffset => {\n\t\t\t\t\t\treturn _hasViewportTopOffset ? toPx( this.viewportTopOffset ) : null;\n\t\t\t\t\t} ),\n\n\t\t\t\t\tbottom: bind.to( '_isStickyToTheLimiter', _isStickyToTheLimiter => {\n\t\t\t\t\t\treturn _isStickyToTheLimiter ? toPx( this.limiterBottomOffset ) : null;\n\t\t\t\t\t} ),\n\n\t\t\t\t\tmarginLeft: bind.to( '_marginLeft' )\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tchildren: this.content\n\t\t} ).render();\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-sticky-panel'\n\t\t\t\t]\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\tthis._contentPanelPlaceholder,\n\t\t\t\tthis._contentPanel\n\t\t\t]\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trender() {\n\t\tsuper.render();\n\n\t\t// Check if the panel should go into the sticky state immediately.\n\t\tthis._checkIfShouldBeSticky();\n\n\t\t// Update sticky state of the panel as the window is being scrolled.\n\t\tthis.listenTo( global.window, 'scroll', () => {\n\t\t\tthis._checkIfShouldBeSticky();\n\t\t} );\n\n\t\t// Synchronize with `model.isActive` because sticking an inactive panel is pointless.\n\t\tthis.listenTo( this, 'change:isActive', () => {\n\t\t\tthis._checkIfShouldBeSticky();\n\t\t} );\n\t}\n\n\t/**\n\t * Analyzes the environment to decide whether the panel should\n\t * be sticky or not.\n\t *\n\t * @protected\n\t */\n\t_checkIfShouldBeSticky() {\n\t\tconst panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();\n\t\tlet limiterRect;\n\n\t\tif ( !this.limiterElement ) {\n\t\t\tthis.isSticky = false;\n\t\t} else {\n\t\t\tlimiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect();\n\n\t\t\t// The panel must be active to become sticky.\n\t\t\tthis.isSticky = this.isActive &&\n\t\t\t\t// The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).\n\t\t\t\tlimiterRect.top < this.viewportTopOffset &&\n\t\t\t\t// The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.\n\t\t\t\t// There's no point in entering the sticky mode if the model#limiterElement is very, very small, because\n\t\t\t\t// it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel\n\t\t\t\t// would be positioned before the model#limiterElement.\n\t\t\t\tthis._panelRect.height + this.limiterBottomOffset < limiterRect.height;\n\t\t}\n\n\t\t// Stick the panel to the top edge of the viewport simulating CSS position:sticky.\n\t\t// TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky\n\t\tif ( this.isSticky ) {\n\t\t\tthis._isStickyToTheLimiter =\n\t\t\t\tlimiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;\n\t\t\tthis._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;\n\t\t\tthis._marginLeft = this._isStickyToTheLimiter ? null : toPx( -global.window.scrollX );\n\t\t}\n\t\t// Detach the panel from the top edge of the viewport.\n\t\telse {\n\t\t\tthis._isStickyToTheLimiter = false;\n\t\t\tthis._hasViewportTopOffset = false;\n\t\t\tthis._marginLeft = null;\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}