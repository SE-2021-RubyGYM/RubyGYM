{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/getselectedcontent\n */\n\n/**\n * Gets a clone of the selected content.\n *\n * For example, for the following selection:\n *\n * ```html\n * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n * ```\n *\n * It will return a document fragment with such a content:\n *\n * ```html\n * <quote><h>st</h></quote><p>se</p>\n * ```\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection of which content will be returned.\n * @returns {module:engine/model/documentfragment~DocumentFragment}\n */\nexport default function getSelectedContent(model, selection) {\n  return model.change(writer => {\n    const frag = writer.createDocumentFragment();\n    const range = selection.getFirstRange();\n\n    if (!range || range.isCollapsed) {\n      return frag;\n    }\n\n    const root = range.start.root;\n    const commonPath = range.start.getCommonPath(range.end);\n    const commonParent = root.getNodeByPath(commonPath); // ## 1st step\n    //\n    // First, we'll clone a fragment represented by a minimal flat range\n    // containing the original range to be cloned.\n    // E.g. let's consider such a range:\n    //\n    // <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n    //\n    // A minimal flat range containing this one is:\n    //\n    // <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>\n    //\n    // We can easily clone this structure, preserving e.g. the <quote> element.\n\n    let flatSubtreeRange;\n\n    if (range.start.parent == range.end.parent) {\n      // The original range is flat, so take it.\n      flatSubtreeRange = range;\n    } else {\n      flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));\n    }\n\n    const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset; // Clone the whole contents.\n\n    for (const item of flatSubtreeRange.getItems({\n      shallow: true\n    })) {\n      if (item.is('$textProxy')) {\n        writer.appendText(item.data, item.getAttributes(), frag);\n      } else {\n        writer.append(writer.cloneElement(item, true), frag);\n      }\n    } // ## 2nd step\n    //\n    // If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.\n    //\n    // For example, for the range shown in the 1st step comment, we need to remove these pieces:\n    //\n    // <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>\n    //\n    // So this will be the final copied content:\n    //\n    // <quote><h>st</h></quote><p>se</p>\n    //\n    // In order to do that, we remove content from these two ranges:\n    //\n    // [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]\n\n\n    if (flatSubtreeRange != range) {\n      // Find the position of the original range in the cloned fragment.\n      const newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];\n\n      const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);\n      const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, 'end'));\n      removeRangeContent(rightExcessRange, writer);\n      removeRangeContent(leftExcessRange, writer);\n    }\n\n    return frag;\n  });\n} // After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,\n// this function will, most likely, be able to rewritten using getMinimalFlatRanges().\n\nfunction removeRangeContent(range, writer) {\n  const parentsToCheck = [];\n  Array.from(range.getItems({\n    direction: 'backward'\n  })) // We should better store ranges because text proxies will lose integrity\n  // with the text nodes when we'll start removing content.\n  .map(item => writer.createRangeOn(item)) // Filter only these items which are fully contained in the passed range.\n  //\n  // E.g. for the following range: [<quote><p>y</p><h>fir]st</h>\n  // the walker will return the entire <h> element, when only the \"fir\" item inside it is fully contained.\n  .filter(itemRange => {\n    // We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.\n    const contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) && (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));\n    return contained;\n  }).forEach(itemRange => {\n    parentsToCheck.push(itemRange.start.parent);\n    writer.remove(itemRange);\n  }); // Remove ancestors of the removed items if they turned to be empty now\n  // (their whole content was contained in the range).\n\n  parentsToCheck.forEach(parentToCheck => {\n    let parent = parentToCheck;\n\n    while (parent.parent && parent.isEmpty) {\n      const removeRange = writer.createRangeOn(parent);\n      parent = parent.parent;\n      writer.remove(removeRange);\n    }\n  });\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/getselectedcontent.js"],"names":["getSelectedContent","model","selection","change","writer","frag","createDocumentFragment","range","getFirstRange","isCollapsed","root","start","commonPath","getCommonPath","end","commonParent","getNodeByPath","flatSubtreeRange","parent","createRange","createPositionAt","path","length","howMany","offset","item","getItems","shallow","is","appendText","data","getAttributes","append","cloneElement","newRange","_getTransformedByMove","leftExcessRange","rightExcessRange","removeRangeContent","parentsToCheck","Array","from","direction","map","createRangeOn","filter","itemRange","contained","isAfter","isEqual","isBefore","forEach","push","remove","parentToCheck","isEmpty","removeRange"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/getselectedcontent\n */\n\n/**\n * Gets a clone of the selected content.\n *\n * For example, for the following selection:\n *\n * ```html\n * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n * ```\n *\n * It will return a document fragment with such a content:\n *\n * ```html\n * <quote><h>st</h></quote><p>se</p>\n * ```\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection of which content will be returned.\n * @returns {module:engine/model/documentfragment~DocumentFragment}\n */\nexport default function getSelectedContent( model, selection ) {\n\treturn model.change( writer => {\n\t\tconst frag = writer.createDocumentFragment();\n\t\tconst range = selection.getFirstRange();\n\n\t\tif ( !range || range.isCollapsed ) {\n\t\t\treturn frag;\n\t\t}\n\n\t\tconst root = range.start.root;\n\t\tconst commonPath = range.start.getCommonPath( range.end );\n\t\tconst commonParent = root.getNodeByPath( commonPath );\n\n\t\t// ## 1st step\n\t\t//\n\t\t// First, we'll clone a fragment represented by a minimal flat range\n\t\t// containing the original range to be cloned.\n\t\t// E.g. let's consider such a range:\n\t\t//\n\t\t// <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n\t\t//\n\t\t// A minimal flat range containing this one is:\n\t\t//\n\t\t// <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>\n\t\t//\n\t\t// We can easily clone this structure, preserving e.g. the <quote> element.\n\t\tlet flatSubtreeRange;\n\n\t\tif ( range.start.parent == range.end.parent ) {\n\t\t\t// The original range is flat, so take it.\n\t\t\tflatSubtreeRange = range;\n\t\t} else {\n\t\t\tflatSubtreeRange = writer.createRange(\n\t\t\t\twriter.createPositionAt( commonParent, range.start.path[ commonPath.length ] ),\n\t\t\t\twriter.createPositionAt( commonParent, range.end.path[ commonPath.length ] + 1 )\n\t\t\t);\n\t\t}\n\n\t\tconst howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;\n\n\t\t// Clone the whole contents.\n\t\tfor ( const item of flatSubtreeRange.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( '$textProxy' ) ) {\n\t\t\t\twriter.appendText( item.data, item.getAttributes(), frag );\n\t\t\t} else {\n\t\t\t\twriter.append( writer.cloneElement( item, true ), frag );\n\t\t\t}\n\t\t}\n\n\t\t// ## 2nd step\n\t\t//\n\t\t// If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.\n\t\t//\n\t\t// For example, for the range shown in the 1st step comment, we need to remove these pieces:\n\t\t//\n\t\t// <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>\n\t\t//\n\t\t// So this will be the final copied content:\n\t\t//\n\t\t// <quote><h>st</h></quote><p>se</p>\n\t\t//\n\t\t// In order to do that, we remove content from these two ranges:\n\t\t//\n\t\t// [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]\n\t\tif ( flatSubtreeRange != range ) {\n\t\t\t// Find the position of the original range in the cloned fragment.\n\t\t\tconst newRange = range._getTransformedByMove( flatSubtreeRange.start, writer.createPositionAt( frag, 0 ), howMany )[ 0 ];\n\n\t\t\tconst leftExcessRange = writer.createRange( writer.createPositionAt( frag, 0 ), newRange.start );\n\t\t\tconst rightExcessRange = writer.createRange( newRange.end, writer.createPositionAt( frag, 'end' ) );\n\n\t\t\tremoveRangeContent( rightExcessRange, writer );\n\t\t\tremoveRangeContent( leftExcessRange, writer );\n\t\t}\n\n\t\treturn frag;\n\t} );\n}\n\n// After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,\n// this function will, most likely, be able to rewritten using getMinimalFlatRanges().\nfunction removeRangeContent( range, writer ) {\n\tconst parentsToCheck = [];\n\n\tArray.from( range.getItems( { direction: 'backward' } ) )\n\t\t// We should better store ranges because text proxies will lose integrity\n\t\t// with the text nodes when we'll start removing content.\n\t\t.map( item => writer.createRangeOn( item ) )\n\t\t// Filter only these items which are fully contained in the passed range.\n\t\t//\n\t\t// E.g. for the following range: [<quote><p>y</p><h>fir]st</h>\n\t\t// the walker will return the entire <h> element, when only the \"fir\" item inside it is fully contained.\n\t\t.filter( itemRange => {\n\t\t\t// We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.\n\t\t\tconst contained =\n\t\t\t\t( itemRange.start.isAfter( range.start ) || itemRange.start.isEqual( range.start ) ) &&\n\t\t\t\t( itemRange.end.isBefore( range.end ) || itemRange.end.isEqual( range.end ) );\n\n\t\t\treturn contained;\n\t\t} )\n\t\t.forEach( itemRange => {\n\t\t\tparentsToCheck.push( itemRange.start.parent );\n\n\t\t\twriter.remove( itemRange );\n\t\t} );\n\n\t// Remove ancestors of the removed items if they turned to be empty now\n\t// (their whole content was contained in the range).\n\tparentsToCheck.forEach( parentToCheck => {\n\t\tlet parent = parentToCheck;\n\n\t\twhile ( parent.parent && parent.isEmpty ) {\n\t\t\tconst removeRange = writer.createRangeOn( parent );\n\n\t\t\tparent = parent.parent;\n\n\t\t\twriter.remove( removeRange );\n\t\t}\n\t} );\n}\n"]},"metadata":{},"sourceType":"module"}