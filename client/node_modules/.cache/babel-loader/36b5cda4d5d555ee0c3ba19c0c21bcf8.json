{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/scroll\n */\nimport isRange from './isrange';\nimport Rect from './rect';\nimport isText from './istext';\nconst utils = {};\n/**\n * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.\n * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to\n * the user. If the `target` is already visible, nothing will happen.\n *\n * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.\n * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)\n * the `target` will be moved by when the viewport is scrolled. It enhances the user experience\n * by keeping the `target` some distance from the edge of the viewport and thus making it easier to\n * read or edit by the user.\n */\n\nexport function scrollViewportToShowTarget(_ref) {\n  let {\n    target,\n    viewportOffset = 0\n  } = _ref;\n  const targetWindow = getWindow(target);\n  let currentWindow = targetWindow;\n  let currentFrame = null; // Iterate over all windows, starting from target's parent window up to window#top.\n\n  while (currentWindow) {\n    let firstAncestorToScroll; // Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls\n    // settled down, the algorithm can eventually scroll the viewport of the current window.\n    //\n    // Note: If the current window is target's **original** window (e.g. the first one),\n    // start scrolling the closest parent of the target. If not, scroll the closest parent\n    // of an iframe that resides in the current window.\n\n    if (currentWindow == targetWindow) {\n      firstAncestorToScroll = getParentElement(target);\n    } else {\n      firstAncestorToScroll = getParentElement(currentFrame);\n    } // Scroll the target's ancestors first. Once done, scrolling the viewport is easy.\n\n\n    scrollAncestorsToShowRect(firstAncestorToScroll, () => {\n      // Note: If the target does not belong to the current window **directly**,\n      // i.e. it resides in an iframe belonging to the window, obtain the target's rect\n      // in the coordinates of the current window. By default, a Rect returns geometry\n      // relative to the current window's viewport. To make it work in a parent window,\n      // it must be shifted.\n      return getRectRelativeToWindow(target, currentWindow);\n    }); // Obtain the rect of the target after it has been scrolled within its ancestors.\n    // It's time to scroll the viewport.\n\n    const targetRect = getRectRelativeToWindow(target, currentWindow);\n    scrollWindowToShowRect(currentWindow, targetRect, viewportOffset);\n\n    if (currentWindow.parent != currentWindow) {\n      // Keep the reference to the <iframe> element the \"previous current window\" was\n      // rendered within. It will be useful to re–calculate the rect of the target\n      // in the parent window's relative geometry. The target's rect must be shifted\n      // by it's iframe's position.\n      currentFrame = currentWindow.frameElement;\n      currentWindow = currentWindow.parent; // If the current window has some parent but frameElement is inaccessible, then they have\n      // different domains/ports and, due to security reasons, accessing and scrolling\n      // the parent window won't be possible.\n      // See https://github.com/ckeditor/ckeditor5/issues/930.\n\n      if (!currentFrame) {\n        return;\n      }\n    } else {\n      currentWindow = null;\n    }\n  }\n}\n/**\n * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,\n * e.g. if they have `overflow: scroll` CSS style.\n *\n * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.\n */\n\nexport function scrollAncestorsToShowTarget(target) {\n  const targetParent = getParentElement(target);\n  scrollAncestorsToShowRect(targetParent, () => {\n    return new Rect(target);\n  });\n} // TODO: Using a property value shorthand in the top of the file\n// causes JSDoc to throw errors. See https://github.com/cksource/docs-builder/issues/75.\n\nObject.assign(utils, {\n  scrollViewportToShowTarget,\n  scrollAncestorsToShowTarget\n}); // Makes a given rect visible within its parent window.\n//\n// Note: Avoid the situation where the caret is still in the viewport, but totally\n// at the edge of it. In such situation, if it moved beyond the viewport in the next\n// action e.g. after paste, the scrolling would move it to the viewportOffset level\n// and it all would look like the caret visually moved up/down:\n//\n// 1.\n//\t\t| foo[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// 2. *paste*\n// 3.\n//\t\t|\n//\t\t|\n//\t\t+-foo-----------------------------...\n//\t\t  bar[]                              <--- caret below viewport, scrolling...\n//\n// 4. *scrolling*\n// 5.\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]                              <--- caret precisely at the edge\n//\t\t+---------------------------------...\n//\n// To prevent this, this method checks the rects moved by the viewportOffset to cover\n// the upper/lower edge of the viewport. It makes sure if the action repeats, there's\n// no twitching – it's a purely visual improvement:\n//\n// 5. (after fix)\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// @private\n// @param {Window} window A window which is scrolled to reveal the rect.\n// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.\n// @param {Number} viewportOffset See scrollViewportToShowTarget.\n\nfunction scrollWindowToShowRect(window, rect, viewportOffset) {\n  const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset);\n  const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset);\n  const viewportRect = new Rect(window).excludeScrollbarsAndBorders();\n  const rects = [targetShiftedUpRect, targetShiftedDownRect];\n\n  if (!rects.every(rect => viewportRect.contains(rect))) {\n    let {\n      scrollX,\n      scrollY\n    } = window;\n\n    if (isAbove(targetShiftedUpRect, viewportRect)) {\n      scrollY -= viewportRect.top - rect.top + viewportOffset;\n    } else if (isBelow(targetShiftedDownRect, viewportRect)) {\n      scrollY += rect.bottom - viewportRect.bottom + viewportOffset;\n    } // TODO: Web browsers scroll natively to place the target in the middle\n    // of the viewport. It's not a very popular case, though.\n\n\n    if (isLeftOf(rect, viewportRect)) {\n      scrollX -= viewportRect.left - rect.left + viewportOffset;\n    } else if (isRightOf(rect, viewportRect)) {\n      scrollX += rect.right - viewportRect.right + viewportOffset;\n    }\n\n    window.scrollTo(scrollX, scrollY);\n  }\n} // Recursively scrolls element ancestors to visually reveal a rect.\n//\n// @private\n// @param {HTMLElement} A parent The first ancestors to start scrolling.\n// @param {Function} getRect A function which returns the Rect, which is to be revealed.\n\n\nfunction scrollAncestorsToShowRect(parent, getRect) {\n  const parentWindow = getWindow(parent);\n  let parentRect, targetRect;\n\n  while (parent != parentWindow.document.body) {\n    targetRect = getRect();\n    parentRect = new Rect(parent).excludeScrollbarsAndBorders();\n\n    if (!parentRect.contains(targetRect)) {\n      if (isAbove(targetRect, parentRect)) {\n        parent.scrollTop -= parentRect.top - targetRect.top;\n      } else if (isBelow(targetRect, parentRect)) {\n        parent.scrollTop += targetRect.bottom - parentRect.bottom;\n      }\n\n      if (isLeftOf(targetRect, parentRect)) {\n        parent.scrollLeft -= parentRect.left - targetRect.left;\n      } else if (isRightOf(targetRect, parentRect)) {\n        parent.scrollLeft += targetRect.right - parentRect.right;\n      }\n    }\n\n    parent = parent.parentNode;\n  }\n} // Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isBelow(firstRect, secondRect) {\n  return firstRect.bottom > secondRect.bottom;\n} // Determines if a given `Rect` extends beyond the top edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isAbove(firstRect, secondRect) {\n  return firstRect.top < secondRect.top;\n} // Determines if a given `Rect` extends beyond the left edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isLeftOf(firstRect, secondRect) {\n  return firstRect.left < secondRect.left;\n} // Determines if a given `Rect` extends beyond the right edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isRightOf(firstRect, secondRect) {\n  return firstRect.right > secondRect.right;\n} // Returns the closest window of an element or range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {Window}\n\n\nfunction getWindow(elementOrRange) {\n  if (isRange(elementOrRange)) {\n    return elementOrRange.startContainer.ownerDocument.defaultView;\n  } else {\n    return elementOrRange.ownerDocument.defaultView;\n  }\n} // Returns the closest parent of an element or DOM range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {HTMLelement}\n\n\nfunction getParentElement(elementOrRange) {\n  if (isRange(elementOrRange)) {\n    let parent = elementOrRange.commonAncestorContainer; // If a Range is attached to the Text, use the closest element ancestor.\n\n    if (isText(parent)) {\n      parent = parent.parentNode;\n    }\n\n    return parent;\n  } else {\n    return elementOrRange.parentNode;\n  }\n} // Returns the rect of an element or range residing in an iframe.\n// The result rect is relative to the geometry of the passed window instance.\n//\n// @private\n// @param {HTMLElement|Range} target Element or range which rect should be returned.\n// @param {Window} relativeWindow A window the rect should be relative to.\n// @returns {module:utils/dom/rect~Rect}\n\n\nfunction getRectRelativeToWindow(target, relativeWindow) {\n  const targetWindow = getWindow(target);\n  const rect = new Rect(target);\n\n  if (targetWindow === relativeWindow) {\n    return rect;\n  } else {\n    let currentWindow = targetWindow;\n\n    while (currentWindow != relativeWindow) {\n      const frame = currentWindow.frameElement;\n      const frameRect = new Rect(frame).excludeScrollbarsAndBorders();\n      rect.moveBy(frameRect.left, frameRect.top);\n      currentWindow = currentWindow.parent;\n    }\n  }\n\n  return rect;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js"],"names":["isRange","Rect","isText","utils","scrollViewportToShowTarget","target","viewportOffset","targetWindow","getWindow","currentWindow","currentFrame","firstAncestorToScroll","getParentElement","scrollAncestorsToShowRect","getRectRelativeToWindow","targetRect","scrollWindowToShowRect","parent","frameElement","scrollAncestorsToShowTarget","targetParent","Object","assign","window","rect","targetShiftedDownRect","clone","moveBy","targetShiftedUpRect","viewportRect","excludeScrollbarsAndBorders","rects","every","contains","scrollX","scrollY","isAbove","top","isBelow","bottom","isLeftOf","left","isRightOf","right","scrollTo","getRect","parentWindow","parentRect","document","body","scrollTop","scrollLeft","parentNode","firstRect","secondRect","elementOrRange","startContainer","ownerDocument","defaultView","commonAncestorContainer","relativeWindow","frame","frameRect"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/scroll\n */\n\nimport isRange from './isrange';\nimport Rect from './rect';\nimport isText from './istext';\n\nconst utils = {};\n\n/**\n * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.\n * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to\n * the user. If the `target` is already visible, nothing will happen.\n *\n * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.\n * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)\n * the `target` will be moved by when the viewport is scrolled. It enhances the user experience\n * by keeping the `target` some distance from the edge of the viewport and thus making it easier to\n * read or edit by the user.\n */\nexport function scrollViewportToShowTarget( { target, viewportOffset = 0 } ) {\n\tconst targetWindow = getWindow( target );\n\tlet currentWindow = targetWindow;\n\tlet currentFrame = null;\n\n\t// Iterate over all windows, starting from target's parent window up to window#top.\n\twhile ( currentWindow ) {\n\t\tlet firstAncestorToScroll;\n\n\t\t// Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls\n\t\t// settled down, the algorithm can eventually scroll the viewport of the current window.\n\t\t//\n\t\t// Note: If the current window is target's **original** window (e.g. the first one),\n\t\t// start scrolling the closest parent of the target. If not, scroll the closest parent\n\t\t// of an iframe that resides in the current window.\n\t\tif ( currentWindow == targetWindow ) {\n\t\t\tfirstAncestorToScroll = getParentElement( target );\n\t\t} else {\n\t\t\tfirstAncestorToScroll = getParentElement( currentFrame );\n\t\t}\n\n\t\t// Scroll the target's ancestors first. Once done, scrolling the viewport is easy.\n\t\tscrollAncestorsToShowRect( firstAncestorToScroll, () => {\n\t\t\t// Note: If the target does not belong to the current window **directly**,\n\t\t\t// i.e. it resides in an iframe belonging to the window, obtain the target's rect\n\t\t\t// in the coordinates of the current window. By default, a Rect returns geometry\n\t\t\t// relative to the current window's viewport. To make it work in a parent window,\n\t\t\t// it must be shifted.\n\t\t\treturn getRectRelativeToWindow( target, currentWindow );\n\t\t} );\n\n\t\t// Obtain the rect of the target after it has been scrolled within its ancestors.\n\t\t// It's time to scroll the viewport.\n\t\tconst targetRect = getRectRelativeToWindow( target, currentWindow );\n\n\t\tscrollWindowToShowRect( currentWindow, targetRect, viewportOffset );\n\n\t\tif ( currentWindow.parent != currentWindow ) {\n\t\t\t// Keep the reference to the <iframe> element the \"previous current window\" was\n\t\t\t// rendered within. It will be useful to re–calculate the rect of the target\n\t\t\t// in the parent window's relative geometry. The target's rect must be shifted\n\t\t\t// by it's iframe's position.\n\t\t\tcurrentFrame = currentWindow.frameElement;\n\t\t\tcurrentWindow = currentWindow.parent;\n\n\t\t\t// If the current window has some parent but frameElement is inaccessible, then they have\n\t\t\t// different domains/ports and, due to security reasons, accessing and scrolling\n\t\t\t// the parent window won't be possible.\n\t\t\t// See https://github.com/ckeditor/ckeditor5/issues/930.\n\t\t\tif ( !currentFrame ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentWindow = null;\n\t\t}\n\t}\n}\n\n/**\n * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,\n * e.g. if they have `overflow: scroll` CSS style.\n *\n * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.\n */\nexport function scrollAncestorsToShowTarget( target ) {\n\tconst targetParent = getParentElement( target );\n\n\tscrollAncestorsToShowRect( targetParent, () => {\n\t\treturn new Rect( target );\n\t} );\n}\n\n// TODO: Using a property value shorthand in the top of the file\n// causes JSDoc to throw errors. See https://github.com/cksource/docs-builder/issues/75.\nObject.assign( utils, {\n\tscrollViewportToShowTarget,\n\tscrollAncestorsToShowTarget\n} );\n\n// Makes a given rect visible within its parent window.\n//\n// Note: Avoid the situation where the caret is still in the viewport, but totally\n// at the edge of it. In such situation, if it moved beyond the viewport in the next\n// action e.g. after paste, the scrolling would move it to the viewportOffset level\n// and it all would look like the caret visually moved up/down:\n//\n// 1.\n//\t\t| foo[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// 2. *paste*\n// 3.\n//\t\t|\n//\t\t|\n//\t\t+-foo-----------------------------...\n//\t\t  bar[]                              <--- caret below viewport, scrolling...\n//\n// 4. *scrolling*\n// 5.\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]                              <--- caret precisely at the edge\n//\t\t+---------------------------------...\n//\n// To prevent this, this method checks the rects moved by the viewportOffset to cover\n// the upper/lower edge of the viewport. It makes sure if the action repeats, there's\n// no twitching – it's a purely visual improvement:\n//\n// 5. (after fix)\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// @private\n// @param {Window} window A window which is scrolled to reveal the rect.\n// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.\n// @param {Number} viewportOffset See scrollViewportToShowTarget.\nfunction scrollWindowToShowRect( window, rect, viewportOffset ) {\n\tconst targetShiftedDownRect = rect.clone().moveBy( 0, viewportOffset );\n\tconst targetShiftedUpRect = rect.clone().moveBy( 0, -viewportOffset );\n\tconst viewportRect = new Rect( window ).excludeScrollbarsAndBorders();\n\n\tconst rects = [ targetShiftedUpRect, targetShiftedDownRect ];\n\n\tif ( !rects.every( rect => viewportRect.contains( rect ) ) ) {\n\t\tlet { scrollX, scrollY } = window;\n\n\t\tif ( isAbove( targetShiftedUpRect, viewportRect ) ) {\n\t\t\tscrollY -= viewportRect.top - rect.top + viewportOffset;\n\t\t} else if ( isBelow( targetShiftedDownRect, viewportRect ) ) {\n\t\t\tscrollY += rect.bottom - viewportRect.bottom + viewportOffset;\n\t\t}\n\n\t\t// TODO: Web browsers scroll natively to place the target in the middle\n\t\t// of the viewport. It's not a very popular case, though.\n\t\tif ( isLeftOf( rect, viewportRect ) ) {\n\t\t\tscrollX -= viewportRect.left - rect.left + viewportOffset;\n\t\t} else if ( isRightOf( rect, viewportRect ) ) {\n\t\t\tscrollX += rect.right - viewportRect.right + viewportOffset;\n\t\t}\n\n\t\twindow.scrollTo( scrollX, scrollY );\n\t}\n}\n\n// Recursively scrolls element ancestors to visually reveal a rect.\n//\n// @private\n// @param {HTMLElement} A parent The first ancestors to start scrolling.\n// @param {Function} getRect A function which returns the Rect, which is to be revealed.\nfunction scrollAncestorsToShowRect( parent, getRect ) {\n\tconst parentWindow = getWindow( parent );\n\tlet parentRect, targetRect;\n\n\twhile ( parent != parentWindow.document.body ) {\n\t\ttargetRect = getRect();\n\t\tparentRect = new Rect( parent ).excludeScrollbarsAndBorders();\n\n\t\tif ( !parentRect.contains( targetRect ) ) {\n\t\t\tif ( isAbove( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollTop -= parentRect.top - targetRect.top;\n\t\t\t} else if ( isBelow( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollTop += targetRect.bottom - parentRect.bottom;\n\t\t\t}\n\n\t\t\tif ( isLeftOf( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollLeft -= parentRect.left - targetRect.left;\n\t\t\t} else if ( isRightOf( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollLeft += targetRect.right - parentRect.right;\n\t\t\t}\n\t\t}\n\n\t\tparent = parent.parentNode;\n\t}\n}\n\n// Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isBelow( firstRect, secondRect ) {\n\treturn firstRect.bottom > secondRect.bottom;\n}\n\n// Determines if a given `Rect` extends beyond the top edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isAbove( firstRect, secondRect ) {\n\treturn firstRect.top < secondRect.top;\n}\n\n// Determines if a given `Rect` extends beyond the left edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isLeftOf( firstRect, secondRect ) {\n\treturn firstRect.left < secondRect.left;\n}\n\n// Determines if a given `Rect` extends beyond the right edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isRightOf( firstRect, secondRect ) {\n\treturn firstRect.right > secondRect.right;\n}\n\n// Returns the closest window of an element or range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {Window}\nfunction getWindow( elementOrRange ) {\n\tif ( isRange( elementOrRange ) ) {\n\t\treturn elementOrRange.startContainer.ownerDocument.defaultView;\n\t} else {\n\t\treturn elementOrRange.ownerDocument.defaultView;\n\t}\n}\n\n// Returns the closest parent of an element or DOM range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {HTMLelement}\nfunction getParentElement( elementOrRange ) {\n\tif ( isRange( elementOrRange ) ) {\n\t\tlet parent = elementOrRange.commonAncestorContainer;\n\n\t\t// If a Range is attached to the Text, use the closest element ancestor.\n\t\tif ( isText( parent ) ) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\treturn parent;\n\t} else {\n\t\treturn elementOrRange.parentNode;\n\t}\n}\n\n// Returns the rect of an element or range residing in an iframe.\n// The result rect is relative to the geometry of the passed window instance.\n//\n// @private\n// @param {HTMLElement|Range} target Element or range which rect should be returned.\n// @param {Window} relativeWindow A window the rect should be relative to.\n// @returns {module:utils/dom/rect~Rect}\nfunction getRectRelativeToWindow( target, relativeWindow ) {\n\tconst targetWindow = getWindow( target );\n\tconst rect = new Rect( target );\n\n\tif ( targetWindow === relativeWindow ) {\n\t\treturn rect;\n\t} else {\n\t\tlet currentWindow = targetWindow;\n\n\t\twhile ( currentWindow != relativeWindow ) {\n\t\t\tconst frame = currentWindow.frameElement;\n\t\t\tconst frameRect = new Rect( frame ).excludeScrollbarsAndBorders();\n\n\t\t\trect.moveBy( frameRect.left, frameRect.top );\n\n\t\t\tcurrentWindow = currentWindow.parent;\n\t\t}\n\t}\n\n\treturn rect;\n}\n"]},"metadata":{},"sourceType":"module"}