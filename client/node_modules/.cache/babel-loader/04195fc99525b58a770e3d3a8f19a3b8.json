{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/keystrokehandler\n */\nimport DomEmitterMixin from './dom/emittermixin';\nimport { getCode, parseKeystroke } from './keyboard';\n/**\n * Keystroke handler allows registering callbacks for given keystrokes.\n *\n * The most frequent use of this class is through the {@link module:core/editor/editor~Editor#keystrokes `editor.keystrokes`}\n * property. It allows listening to keystrokes executed in the editing view:\n *\n *\t\teditor.keystrokes.set( 'Ctrl+A', ( keyEvtData, cancel ) => {\n *\t\t\tconsole.log( 'Ctrl+A has been pressed' );\n *\t\t\tcancel();\n *\t\t} );\n *\n * However, this utility class can be used in various part of the UI. For instance, a certain {@link module:ui/view~View}\n * can use it like this:\n *\n *\t\tclass MyView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.keystrokes = new KeystrokeHandler();\n *\n * \t\t\t\tthis.keystrokes.set( 'tab', handleTabKey );\n *\t\t\t}\n *\n *\t\t\trender() {\n *\t\t\t\tsuper.render();\n *\n *\t\t\t\tthis.keystrokes.listenTo( this.element );\n *\t\t\t}\n *\t\t}\n *\n * That keystroke handler will listen to `keydown` events fired in this view's main element.\n *\n */\n\nexport default class KeystrokeHandler {\n  /**\n   * Creates an instance of the keystroke handler.\n   */\n  constructor() {\n    /**\n     * Listener used to listen to events for easier keystroke handler destruction.\n     *\n     * @protected\n     * @member {module:utils/dom/emittermixin~Emitter}\n     */\n    this._listener = Object.create(DomEmitterMixin);\n  }\n  /**\n   * Starts listening for `keydown` events from a given emitter.\n   *\n   * @param {module:utils/emittermixin~Emitter} emitter\n   */\n\n\n  listenTo(emitter) {\n    // The #_listener works here as a kind of dispatcher. It groups the events coming from the same\n    // keystroke so the listeners can be attached to them with different priorities.\n    //\n    // E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated\n    // as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`\n    // method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts\n    // only with other listeners of this particular event, thus making it possible to prioritize\n    // the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,\n    // the KeystrokeHandler re–uses it to do its job.\n    this._listener.listenTo(emitter, 'keydown', (evt, keyEvtData) => {\n      this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n    });\n  }\n  /**\n   * Registers a handler for the specified keystroke.\n   *\n   * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n   * the {@link module:utils/keyboard~parseKeystroke} function.\n   * @param {Function} callback A function called with the\n   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n   * a helper funcion to call both `preventDefault()` and `stopPropagation()` on the underlying event.\n   * @param {Object} [options={}] Additional options.\n   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n   * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n   * are called in the order they were added.\n   */\n\n\n  set(keystroke, callback) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const keyCode = parseKeystroke(keystroke);\n    const priority = options.priority; // Execute the passed callback on KeystrokeHandler#_keydown.\n    // TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144\n\n    this._listener.listenTo(this._listener, '_keydown:' + keyCode, (evt, keyEvtData) => {\n      callback(keyEvtData, () => {\n        // Stop the event in the DOM: no listener in the web page\n        // will be triggered by this event.\n        keyEvtData.preventDefault();\n        keyEvtData.stopPropagation(); // Stop the event in the KeystrokeHandler: no more callbacks\n        // will be executed for this keystroke.\n\n        evt.stop();\n      }); // Mark this keystroke as handled by the callback. See: #press.\n\n      evt.return = true;\n    }, {\n      priority\n    });\n  }\n  /**\n   * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.\n   *\n   * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.\n   * @returns {Boolean} Whether the keystroke was handled.\n   */\n\n\n  press(keyEvtData) {\n    return !!this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n  }\n  /**\n   * Destroys the keystroke handler.\n   */\n\n\n  destroy() {\n    this._listener.stopListening();\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/keystrokehandler.js"],"names":["DomEmitterMixin","getCode","parseKeystroke","KeystrokeHandler","constructor","_listener","Object","create","listenTo","emitter","evt","keyEvtData","fire","set","keystroke","callback","options","keyCode","priority","preventDefault","stopPropagation","stop","return","press","destroy","stopListening"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,eAAP,MAA4B,oBAA5B;AACA,SAASC,OAAT,EAAkBC,cAAlB,QAAwC,YAAxC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,gBAAN,CAAuB;AACrC;AACD;AACA;AACCC,EAAAA,WAAW,GAAG;AACb;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,SAAL,GAAiBC,MAAM,CAACC,MAAP,CAAeP,eAAf,CAAjB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCQ,EAAAA,QAAQ,CAAEC,OAAF,EAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAKJ,SAAL,CAAeG,QAAf,CAAyBC,OAAzB,EAAkC,SAAlC,EAA6C,CAAEC,GAAF,EAAOC,UAAP,KAAuB;AACnE,WAAKN,SAAL,CAAeO,IAAf,CAAqB,cAAcX,OAAO,CAAEU,UAAF,CAA1C,EAA0DA,UAA1D;AACA,KAFD;AAGA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,GAAG,CAAEC,SAAF,EAAaC,QAAb,EAAsC;AAAA,QAAfC,OAAe,uEAAL,EAAK;AACxC,UAAMC,OAAO,GAAGf,cAAc,CAAEY,SAAF,CAA9B;AACA,UAAMI,QAAQ,GAAGF,OAAO,CAACE,QAAzB,CAFwC,CAIxC;AACA;;AACA,SAAKb,SAAL,CAAeG,QAAf,CAAyB,KAAKH,SAA9B,EAAyC,cAAcY,OAAvD,EAAgE,CAAEP,GAAF,EAAOC,UAAP,KAAuB;AACtFI,MAAAA,QAAQ,CAAEJ,UAAF,EAAc,MAAM;AAC3B;AACA;AACAA,QAAAA,UAAU,CAACQ,cAAX;AACAR,QAAAA,UAAU,CAACS,eAAX,GAJ2B,CAM3B;AACA;;AACAV,QAAAA,GAAG,CAACW,IAAJ;AACA,OATO,CAAR,CADsF,CAYtF;;AACAX,MAAAA,GAAG,CAACY,MAAJ,GAAa,IAAb;AACA,KAdD,EAcG;AAAEJ,MAAAA;AAAF,KAdH;AAeA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCK,EAAAA,KAAK,CAAEZ,UAAF,EAAe;AACnB,WAAO,CAAC,CAAC,KAAKN,SAAL,CAAeO,IAAf,CAAqB,cAAcX,OAAO,CAAEU,UAAF,CAA1C,EAA0DA,UAA1D,CAAT;AACA;AAED;AACD;AACA;;;AACCa,EAAAA,OAAO,GAAG;AACT,SAAKnB,SAAL,CAAeoB,aAAf;AACA;;AArFoC","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/keystrokehandler\n */\n\nimport DomEmitterMixin from './dom/emittermixin';\nimport { getCode, parseKeystroke } from './keyboard';\n\n/**\n * Keystroke handler allows registering callbacks for given keystrokes.\n *\n * The most frequent use of this class is through the {@link module:core/editor/editor~Editor#keystrokes `editor.keystrokes`}\n * property. It allows listening to keystrokes executed in the editing view:\n *\n *\t\teditor.keystrokes.set( 'Ctrl+A', ( keyEvtData, cancel ) => {\n *\t\t\tconsole.log( 'Ctrl+A has been pressed' );\n *\t\t\tcancel();\n *\t\t} );\n *\n * However, this utility class can be used in various part of the UI. For instance, a certain {@link module:ui/view~View}\n * can use it like this:\n *\n *\t\tclass MyView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.keystrokes = new KeystrokeHandler();\n *\n * \t\t\t\tthis.keystrokes.set( 'tab', handleTabKey );\n *\t\t\t}\n *\n *\t\t\trender() {\n *\t\t\t\tsuper.render();\n *\n *\t\t\t\tthis.keystrokes.listenTo( this.element );\n *\t\t\t}\n *\t\t}\n *\n * That keystroke handler will listen to `keydown` events fired in this view's main element.\n *\n */\nexport default class KeystrokeHandler {\n\t/**\n\t * Creates an instance of the keystroke handler.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Listener used to listen to events for easier keystroke handler destruction.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:utils/dom/emittermixin~Emitter}\n\t\t */\n\t\tthis._listener = Object.create( DomEmitterMixin );\n\t}\n\n\t/**\n\t * Starts listening for `keydown` events from a given emitter.\n\t *\n\t * @param {module:utils/emittermixin~Emitter} emitter\n\t */\n\tlistenTo( emitter ) {\n\t\t// The #_listener works here as a kind of dispatcher. It groups the events coming from the same\n\t\t// keystroke so the listeners can be attached to them with different priorities.\n\t\t//\n\t\t// E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated\n\t\t// as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`\n\t\t// method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts\n\t\t// only with other listeners of this particular event, thus making it possible to prioritize\n\t\t// the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,\n\t\t// the KeystrokeHandler re–uses it to do its job.\n\t\tthis._listener.listenTo( emitter, 'keydown', ( evt, keyEvtData ) => {\n\t\t\tthis._listener.fire( '_keydown:' + getCode( keyEvtData ), keyEvtData );\n\t\t} );\n\t}\n\n\t/**\n\t * Registers a handler for the specified keystroke.\n\t *\n\t * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n\t * the {@link module:utils/keyboard~parseKeystroke} function.\n\t * @param {Function} callback A function called with the\n\t * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n\t * a helper funcion to call both `preventDefault()` and `stopPropagation()` on the underlying event.\n\t * @param {Object} [options={}] Additional options.\n\t * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n\t * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n\t * are called in the order they were added.\n\t */\n\tset( keystroke, callback, options = {} ) {\n\t\tconst keyCode = parseKeystroke( keystroke );\n\t\tconst priority = options.priority;\n\n\t\t// Execute the passed callback on KeystrokeHandler#_keydown.\n\t\t// TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144\n\t\tthis._listener.listenTo( this._listener, '_keydown:' + keyCode, ( evt, keyEvtData ) => {\n\t\t\tcallback( keyEvtData, () => {\n\t\t\t\t// Stop the event in the DOM: no listener in the web page\n\t\t\t\t// will be triggered by this event.\n\t\t\t\tkeyEvtData.preventDefault();\n\t\t\t\tkeyEvtData.stopPropagation();\n\n\t\t\t\t// Stop the event in the KeystrokeHandler: no more callbacks\n\t\t\t\t// will be executed for this keystroke.\n\t\t\t\tevt.stop();\n\t\t\t} );\n\n\t\t\t// Mark this keystroke as handled by the callback. See: #press.\n\t\t\tevt.return = true;\n\t\t}, { priority } );\n\t}\n\n\t/**\n\t * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.\n\t *\n\t * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.\n\t * @returns {Boolean} Whether the keystroke was handled.\n\t */\n\tpress( keyEvtData ) {\n\t\treturn !!this._listener.fire( '_keydown:' + getCode( keyEvtData ), keyEvtData );\n\t}\n\n\t/**\n\t * Destroys the keystroke handler.\n\t */\n\tdestroy() {\n\t\tthis._listener.stopListening();\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}