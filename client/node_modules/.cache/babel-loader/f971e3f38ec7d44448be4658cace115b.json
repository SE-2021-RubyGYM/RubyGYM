{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/mergeoperation\n */\nimport Operation from './operation';\nimport SplitOperation from './splitoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to merge two {@link module:engine/model/element~Element elements}.\n *\n * The merged element is the parent of {@link ~MergeOperation#sourcePosition} and it is merged into the parent of\n * {@link ~MergeOperation#targetPosition}. All nodes from the merged element are moved to {@link ~MergeOperation#targetPosition}.\n *\n * The merged element is moved to the graveyard at {@link ~MergeOperation#graveyardPosition}.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\n\nexport default class MergeOperation extends Operation {\n  /**\n   * Creates a merge operation.\n   *\n   * @param {module:engine/model/position~Position} sourcePosition Position inside the merged element. All nodes from that\n   * element after that position will be moved to {@link ~#targetPosition}.\n   * @param {Number} howMany Summary offset size of nodes which will be moved from the merged element to the new parent.\n   * @param {module:engine/model/position~Position} targetPosition Position which the nodes from the merged elements will be moved to.\n   * @param {module:engine/model/position~Position} graveyardPosition Position in graveyard to which the merged element will be moved.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {\n    super(baseVersion);\n    /**\n     * Position inside the merged element. All nodes from that element after that position will be moved to {@link ~#targetPosition}.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#sourcePosition\n     */\n\n    this.sourcePosition = sourcePosition.clone(); // This is, and should always remain, the first position in its parent.\n\n    this.sourcePosition.stickiness = 'toPrevious';\n    /**\n     * Summary offset size of nodes which will be moved from the merged element to the new parent.\n     *\n     * @member {Number} module:engine/model/operation/mergeoperation~MergeOperation#howMany\n     */\n\n    this.howMany = howMany;\n    /**\n     * Position which the nodes from the merged elements will be moved to.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#targetPosition\n     */\n\n    this.targetPosition = targetPosition.clone(); // Except of a rare scenario in `MergeOperation` x `MergeOperation` transformation,\n    // this is, and should always remain, the last position in its parent.\n\n    this.targetPosition.stickiness = 'toNext';\n    /**\n     * Position in graveyard to which the merged element will be moved.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#graveyardPosition\n     */\n\n    this.graveyardPosition = graveyardPosition.clone();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  get type() {\n    return 'merge';\n  }\n  /**\n   * Position before the merged element (which will be deleted).\n   *\n   * @readonly\n   * @type {module:engine/model/position~Position}\n   */\n\n\n  get deletionPosition() {\n    return new Position(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));\n  }\n  /**\n   * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.\n   * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n   *\n   * @readonly\n   * @type {module:engine/model/range~Range}\n   */\n\n\n  get movedRange() {\n    const end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);\n    return new Range(this.sourcePosition, end);\n  }\n  /**\n   * Creates and returns an operation that has the same parameters as this operation.\n   *\n   * @returns {module:engine/model/operation/mergeoperation~MergeOperation} Clone of this operation.\n   */\n\n\n  clone() {\n    return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);\n  }\n  /**\n   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n   *\n   * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n   */\n\n\n  getReversed() {\n    // Positions in this method are transformed by this merge operation because the split operation bases on\n    // the context after this merge operation happened (because split operation reverses it).\n    // So we need to acknowledge that the merge operation happened and those positions changed a little.\n    const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);\n\n    const path = this.sourcePosition.path.slice(0, -1);\n\n    const insertionPosition = new Position(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);\n\n    return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _validate() {\n    const sourceElement = this.sourcePosition.parent;\n    const targetElement = this.targetPosition.parent; // Validate whether merge operation has correct parameters.\n\n    if (!sourceElement.parent) {\n      /**\n       * Merge source position is invalid. The element to be merged must have a parent node.\n       *\n       * @error merge-operation-source-position-invalid\n       */\n      throw new CKEditorError('merge-operation-source-position-invalid', this);\n    } else if (!targetElement.parent) {\n      /**\n       * Merge target position is invalid. The element to be merged must have a parent node.\n       *\n       * @error merge-operation-target-position-invalid\n       */\n      throw new CKEditorError('merge-operation-target-position-invalid', this);\n    } else if (this.howMany != sourceElement.maxOffset) {\n      /**\n       * Merge operation specifies wrong number of nodes to move.\n       *\n       * @error merge-operation-how-many-invalid\n       */\n      throw new CKEditorError('merge-operation-how-many-invalid', this);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _execute() {\n    const mergedElement = this.sourcePosition.parent;\n\n    const sourceRange = Range._createIn(mergedElement);\n\n    _move(sourceRange, this.targetPosition);\n\n    _move(Range._createOn(mergedElement), this.graveyardPosition);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  toJSON() {\n    const json = super.toJSON();\n    json.sourcePosition = json.sourcePosition.toJSON();\n    json.targetPosition = json.targetPosition.toJSON();\n    json.graveyardPosition = json.graveyardPosition.toJSON();\n    return json;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get className() {\n    return 'MergeOperation';\n  }\n  /**\n   * Creates `MergeOperation` object from deserilized object, i.e. from parsed JSON string.\n   *\n   * @param {Object} json Deserialized JSON object.\n   * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n   * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n   */\n\n\n  static fromJSON(json, document) {\n    const sourcePosition = Position.fromJSON(json.sourcePosition, document);\n    const targetPosition = Position.fromJSON(json.targetPosition, document);\n    const graveyardPosition = Position.fromJSON(json.graveyardPosition, document);\n    return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn `MergeOperation( ${ this.baseVersion } ): ` +\n  // @if CK_DEBUG_ENGINE //\t\t`${ this.sourcePosition } -> ${ this.targetPosition }` +\n  // @if CK_DEBUG_ENGINE //\t\t` ( ${ this.howMany } ), ${ this.graveyardPosition }`;\n  // @if CK_DEBUG_ENGINE // }\n\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/mergeoperation.js"],"names":["Operation","SplitOperation","Position","Range","_move","CKEditorError","MergeOperation","constructor","sourcePosition","howMany","targetPosition","graveyardPosition","baseVersion","clone","stickiness","type","deletionPosition","root","path","slice","movedRange","end","getShiftedBy","Number","POSITIVE_INFINITY","getReversed","_getTransformedByMergeOperation","insertionPosition","_validate","sourceElement","parent","targetElement","maxOffset","_execute","mergedElement","sourceRange","_createIn","_createOn","toJSON","json","className","fromJSON","document"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/mergeoperation\n */\n\nimport Operation from './operation';\nimport SplitOperation from './splitoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _move } from './utils';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Operation to merge two {@link module:engine/model/element~Element elements}.\n *\n * The merged element is the parent of {@link ~MergeOperation#sourcePosition} and it is merged into the parent of\n * {@link ~MergeOperation#targetPosition}. All nodes from the merged element are moved to {@link ~MergeOperation#targetPosition}.\n *\n * The merged element is moved to the graveyard at {@link ~MergeOperation#graveyardPosition}.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class MergeOperation extends Operation {\n\t/**\n\t * Creates a merge operation.\n\t *\n\t * @param {module:engine/model/position~Position} sourcePosition Position inside the merged element. All nodes from that\n\t * element after that position will be moved to {@link ~#targetPosition}.\n\t * @param {Number} howMany Summary offset size of nodes which will be moved from the merged element to the new parent.\n\t * @param {module:engine/model/position~Position} targetPosition Position which the nodes from the merged elements will be moved to.\n\t * @param {module:engine/model/position~Position} graveyardPosition Position in graveyard to which the merged element will be moved.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Position inside the merged element. All nodes from that element after that position will be moved to {@link ~#targetPosition}.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#sourcePosition\n\t\t */\n\t\tthis.sourcePosition = sourcePosition.clone();\n\t\t// This is, and should always remain, the first position in its parent.\n\t\tthis.sourcePosition.stickiness = 'toPrevious';\n\n\t\t/**\n\t\t * Summary offset size of nodes which will be moved from the merged element to the new parent.\n\t\t *\n\t\t * @member {Number} module:engine/model/operation/mergeoperation~MergeOperation#howMany\n\t\t */\n\t\tthis.howMany = howMany;\n\n\t\t/**\n\t\t * Position which the nodes from the merged elements will be moved to.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#targetPosition\n\t\t */\n\t\tthis.targetPosition = targetPosition.clone();\n\t\t// Except of a rare scenario in `MergeOperation` x `MergeOperation` transformation,\n\t\t// this is, and should always remain, the last position in its parent.\n\t\tthis.targetPosition.stickiness = 'toNext';\n\n\t\t/**\n\t\t * Position in graveyard to which the merged element will be moved.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#graveyardPosition\n\t\t */\n\t\tthis.graveyardPosition = graveyardPosition.clone();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'merge';\n\t}\n\n\t/**\n\t * Position before the merged element (which will be deleted).\n\t *\n\t * @readonly\n\t * @type {module:engine/model/position~Position}\n\t */\n\tget deletionPosition() {\n\t\treturn new Position( this.sourcePosition.root, this.sourcePosition.path.slice( 0, -1 ) );\n\t}\n\n\t/**\n\t * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.\n\t * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/range~Range}\n\t */\n\tget movedRange() {\n\t\tconst end = this.sourcePosition.getShiftedBy( Number.POSITIVE_INFINITY );\n\n\t\treturn new Range( this.sourcePosition, end );\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/mergeoperation~MergeOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n\t */\n\tgetReversed() {\n\t\t// Positions in this method are transformed by this merge operation because the split operation bases on\n\t\t// the context after this merge operation happened (because split operation reverses it).\n\t\t// So we need to acknowledge that the merge operation happened and those positions changed a little.\n\t\tconst targetPosition = this.targetPosition._getTransformedByMergeOperation( this );\n\n\t\tconst path = this.sourcePosition.path.slice( 0, -1 );\n\t\tconst insertionPosition = new Position( this.sourcePosition.root, path )._getTransformedByMergeOperation( this );\n\n\t\treturn new SplitOperation( targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tconst sourceElement = this.sourcePosition.parent;\n\t\tconst targetElement = this.targetPosition.parent;\n\n\t\t// Validate whether merge operation has correct parameters.\n\t\tif ( !sourceElement.parent ) {\n\t\t\t/**\n\t\t\t * Merge source position is invalid. The element to be merged must have a parent node.\n\t\t\t *\n\t\t\t * @error merge-operation-source-position-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'merge-operation-source-position-invalid', this );\n\t\t} else if ( !targetElement.parent ) {\n\t\t\t/**\n\t\t\t * Merge target position is invalid. The element to be merged must have a parent node.\n\t\t\t *\n\t\t\t * @error merge-operation-target-position-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'merge-operation-target-position-invalid', this );\n\t\t} else if ( this.howMany != sourceElement.maxOffset ) {\n\t\t\t/**\n\t\t\t * Merge operation specifies wrong number of nodes to move.\n\t\t\t *\n\t\t\t * @error merge-operation-how-many-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'merge-operation-how-many-invalid', this );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\tconst mergedElement = this.sourcePosition.parent;\n\t\tconst sourceRange = Range._createIn( mergedElement );\n\n\t\t_move( sourceRange, this.targetPosition );\n\t\t_move( Range._createOn( mergedElement ), this.graveyardPosition );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tjson.sourcePosition = json.sourcePosition.toJSON();\n\t\tjson.targetPosition = json.targetPosition.toJSON();\n\t\tjson.graveyardPosition = json.graveyardPosition.toJSON();\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'MergeOperation';\n\t}\n\n\t/**\n\t * Creates `MergeOperation` object from deserilized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\tconst sourcePosition = Position.fromJSON( json.sourcePosition, document );\n\t\tconst targetPosition = Position.fromJSON( json.targetPosition, document );\n\t\tconst graveyardPosition = Position.fromJSON( json.graveyardPosition, document );\n\n\t\treturn new this( sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `MergeOperation( ${ this.baseVersion } ): ` +\n\t// @if CK_DEBUG_ENGINE //\t\t`${ this.sourcePosition } -> ${ this.targetPosition }` +\n\t// @if CK_DEBUG_ENGINE //\t\t` ( ${ this.howMany } ), ${ this.graveyardPosition }`;\n\t// @if CK_DEBUG_ENGINE // }\n}\n"]},"metadata":{},"sourceType":"module"}