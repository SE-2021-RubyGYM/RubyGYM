{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/range\n */\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\n\nexport default class Range {\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * @param {module:engine/model/position~Position} start The start position.\n   * @param {module:engine/model/position~Position} [end] The end position. If not set,\n   * the range will be collapsed at the `start` position.\n   */\n  constructor(start) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    /**\n     * Start position.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position}\n     */\n    this.start = Position._createAt(start);\n    /**\n     * End position.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position}\n     */\n\n    this.end = end ? Position._createAt(end) : Position._createAt(start); // If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n    // In other case, make the boundaries stick to the \"inside\" of the range.\n\n    this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n    this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n   * them together with additional information like length or {@link module:engine/model/position~Position positions},\n   * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n   * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n   * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n   *\n   * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n   * and `ignoreElementEnd` option set to `true`.\n   *\n   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n   */\n\n\n  *[Symbol.iterator]() {\n    yield* new TreeWalker({\n      boundaries: this,\n      ignoreElementEnd: true\n    });\n  }\n  /**\n   * Returns whether the range is collapsed, that is if {@link #start} and\n   * {@link #end} positions are equal.\n   *\n   * @type {Boolean}\n   */\n\n\n  get isCollapsed() {\n    return this.start.isEqual(this.end);\n  }\n  /**\n   * Returns whether this range is flat, that is if {@link #start} position and\n   * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n   *\n   * @type {Boolean}\n   */\n\n\n  get isFlat() {\n    const startParentPath = this.start.getParentPath();\n    const endParentPath = this.end.getParentPath();\n    return compareArrays(startParentPath, endParentPath) == 'same';\n  }\n  /**\n   * Range root element.\n   *\n   * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  get root() {\n    return this.start.root;\n  }\n  /**\n   * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n   *\n   * @param {module:engine/model/position~Position} position Position to check.\n   * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n   * in this range,`false` otherwise.\n   */\n\n\n  containsPosition(position) {\n    return position.isAfter(this.start) && position.isBefore(this.end);\n  }\n  /**\n   * Checks whether this range contains given {@link ~Range range}.\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to check.\n   * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n   * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n   */\n\n\n  containsRange(otherRange) {\n    let loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (otherRange.isCollapsed) {\n      loose = false;\n    }\n\n    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);\n    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);\n    return containsStart && containsEnd;\n  }\n  /**\n   * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n   *\n   * @param {module:engine/model/item~Item} item Model item to check.\n   */\n\n\n  containsItem(item) {\n    const pos = Position._createBefore(item);\n\n    return this.containsPosition(pos) || this.start.isEqual(pos);\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\trange.is( 'range' ); // -> true\n   *\t\trange.is( 'model:range' ); // -> true\n   *\n   *\t\trange.is( 'view:range' ); // -> false\n   *\t\trange.is( 'documentSelection' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'range' || type === 'model:range';\n  }\n  /**\n   * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n   */\n\n\n  isEqual(otherRange) {\n    return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);\n  }\n  /**\n   * Checks and returns whether this range intersects with given range.\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n   */\n\n\n  isIntersecting(otherRange) {\n    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n  }\n  /**\n   * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n   * Returned array contains zero, one or two {@link ~Range ranges}.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n   *\t\tlet transformed = range.getDifference( otherRange );\n   *\t\t// transformed array has no ranges because `otherRange` contains `range`\n   *\n   *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n   *\n   *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n   * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n   */\n\n\n  getDifference(otherRange) {\n    const ranges = [];\n\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect.\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means that we have to\n        // add shrunken range - from the start to the middle of this range.\n        ranges.push(new Range(this.start, otherRange.start));\n      }\n\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // add shrunken range - from the middle of this range to the end.\n        ranges.push(new Range(otherRange.end, this.end));\n      }\n    } else {\n      // Ranges do not intersect, return the original range.\n      ranges.push(new Range(this.start, this.end));\n    }\n\n    return ranges;\n  }\n  /**\n   * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n   *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n   *\n   *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n   *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n   * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n   */\n\n\n  getIntersection(otherRange) {\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect, so a common range will be returned.\n      // At most, it will be same as this range.\n      let commonRangeStart = this.start;\n      let commonRangeEnd = this.end;\n\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means thaNt we have to\n        // shrink common range to the given range start.\n        commonRangeStart = otherRange.start;\n      }\n\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // shrink common range to the given range end.\n        commonRangeEnd = otherRange.end;\n      }\n\n      return new Range(commonRangeStart, commonRangeEnd);\n    } // Ranges do not intersect, so they do not have common part.\n\n\n    return null;\n  }\n  /**\n   * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.\n   * If ranges have no common part, returns `null`.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet otherRange = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 1 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 2 ] )\n  \t *\t\t);\n   *\t\tlet transformed = range.getJoined( otherRange ); // null - ranges have no common part\n   *\n   *\t\totherRange = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 3 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 5 ] )\n   *\t\t);\n   *\t\ttransformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]\n   *\n   * @param {module:engine/model/range~Range} otherRange Range to be joined.\n   * @param {Boolean} [loose=false] Whether the intersection check is loose or strict. If the check is strict (`false`),\n   * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),\n   * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.\n   * @returns {module:engine/model/range~Range|null} A sum of given ranges or `null` if ranges have no common part.\n   */\n\n\n  getJoined(otherRange) {\n    let loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let shouldJoin = this.isIntersecting(otherRange);\n\n    if (!shouldJoin) {\n      if (this.start.isBefore(otherRange.start)) {\n        shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);\n      } else {\n        shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);\n      }\n    }\n\n    if (!shouldJoin) {\n      return null;\n    }\n\n    let startPosition = this.start;\n    let endPosition = this.end;\n\n    if (otherRange.start.isBefore(startPosition)) {\n      startPosition = otherRange.start;\n    }\n\n    if (otherRange.end.isAfter(endPosition)) {\n      endPosition = otherRange.end;\n    }\n\n    return new Range(startPosition, endPosition);\n  }\n  /**\n   * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n   *\n   * See an example of a model structure (`[` and `]` are range boundaries):\n   *\n   *\t\troot                                                            root\n   *\t\t |- element DIV                         DIV             P2              P3             DIV\n   *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n   *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n   *\t\t |   |- element P1\n   *\t\t |   |   |- \"lorem\"                                              ||\n   *\t\t |- element P2                                                   ||\n   *\t\t |   |- \"foo\"                                                    VV\n   *\t\t |- element P3\n   *\t\t |   |- \"bar\"                                                   root\n   *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n   *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n   *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n   *\t\t |   |- element P4\n   *\t\t |   |   |- \"ipsum\"\n   *\n   * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n   * We are looking for minimal set of flat ranges that contains the same nodes.\n   *\n   * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n   *\n   *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n   *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n   *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n   *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n   *\n   * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n   * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n   * were omitted. Only their parts that were wholly in the range were returned.\n   *\n   * **Note:** this method is not returning flat ranges that contain no nodes.\n   *\n   * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n   */\n\n\n  getMinimalFlatRanges() {\n    const ranges = [];\n    const diffAt = this.start.getCommonPath(this.end).length;\n\n    const pos = Position._createAt(this.start);\n\n    let posParent = pos.parent; // Go up.\n\n    while (pos.path.length > diffAt + 1) {\n      const howMany = posParent.maxOffset - pos.offset;\n\n      if (howMany !== 0) {\n        ranges.push(new Range(pos, pos.getShiftedBy(howMany)));\n      }\n\n      pos.path = pos.path.slice(0, -1);\n      pos.offset++;\n      posParent = posParent.parent;\n    } // Go down.\n\n\n    while (pos.path.length <= this.end.path.length) {\n      const offset = this.end.path[pos.path.length - 1];\n      const howMany = offset - pos.offset;\n\n      if (howMany !== 0) {\n        ranges.push(new Range(pos, pos.getShiftedBy(howMany)));\n      }\n\n      pos.offset = offset;\n      pos.path.push(0);\n    }\n\n    return ranges;\n  }\n  /**\n   * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n   *\n   * For example, to iterate over all items in the entire document root:\n   *\n   *\t\t// Create a range spanning over the entire root content:\n   *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n   *\n   *\t\t// Iterate over all items in this range:\n   *\t\tfor ( const value of range.getWalker() ) {\n   *\t\t\tconsole.log( value.item );\n   *\t\t}\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   * @param {module:engine/model/position~Position} [options.startPosition]\n   * @param {Boolean} [options.singleCharacters=false]\n   * @param {Boolean} [options.shallow=false]\n   * @param {Boolean} [options.ignoreElementEnd=false]\n   * @returns {module:engine/model/treewalker~TreeWalker}\n   */\n\n\n  getWalker() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    return new TreeWalker(options);\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n   * them.\n   *\n   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n   * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n   * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} [options] Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/model/item~Item>}\n   */\n\n\n  *getItems() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    options.ignoreElementEnd = true;\n    const treeWalker = new TreeWalker(options);\n\n    for (const value of treeWalker) {\n      yield value.item;\n    }\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n   * contained in this range.\n   *\n   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n   * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/model/position~Position>}\n   */\n\n\n  *getPositions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    const treeWalker = new TreeWalker(options);\n    yield treeWalker.position;\n\n    for (const value of treeWalker) {\n      yield value.nextPosition;\n    }\n  }\n  /**\n   * Returns a range that is a result of transforming this range by given `operation`.\n   *\n   * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n   * moved to a different part of document tree). For this reason, an array is returned by this method and it\n   * may contain one or more `Range` instances.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n   * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n   */\n\n\n  getTransformedByOperation(operation) {\n    switch (operation.type) {\n      case 'insert':\n        return this._getTransformedByInsertOperation(operation);\n\n      case 'move':\n      case 'remove':\n      case 'reinsert':\n        return this._getTransformedByMoveOperation(operation);\n\n      case 'split':\n        return [this._getTransformedBySplitOperation(operation)];\n\n      case 'merge':\n        return [this._getTransformedByMergeOperation(operation)];\n    }\n\n    return [new Range(this.start, this.end)];\n  }\n  /**\n   * Returns a range that is a result of transforming this range by multiple `operations`.\n   *\n   * @see ~Range#getTransformedByOperation\n   * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n   * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n   */\n\n\n  getTransformedByOperations(operations) {\n    const ranges = [new Range(this.start, this.end)];\n\n    for (const operation of operations) {\n      for (let i = 0; i < ranges.length; i++) {\n        const result = ranges[i].getTransformedByOperation(operation);\n        ranges.splice(i, 1, ...result);\n        i += result.length - 1;\n      }\n    } // It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n    // \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n    // because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n    // are inside other ranges and we simply remove them.\n\n\n    for (let i = 0; i < ranges.length; i++) {\n      const range = ranges[i];\n\n      for (let j = i + 1; j < ranges.length; j++) {\n        const next = ranges[j];\n\n        if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {\n          ranges.splice(j, 1);\n        }\n      }\n    }\n\n    return ranges;\n  }\n  /**\n   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n   * which is a common ancestor of the range's both ends (in which the entire range is contained).\n   *\n   * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n\n\n  getCommonAncestor() {\n    return this.start.getCommonAncestor(this.end);\n  }\n  /**\n   * Returns an {@link module:engine/model/element~Element Element} contained by the range.\n   * The element will be returned when it is the **only** node within the range and **fully–contained**\n   * at the same time.\n   *\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  getContainedElement() {\n    if (this.isCollapsed) {\n      return null;\n    }\n\n    const nodeAfterStart = this.start.nodeAfter;\n    const nodeBeforeEnd = this.end.nodeBefore;\n\n    if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n      return nodeAfterStart;\n    }\n\n    return null;\n  }\n  /**\n   * Converts `Range` to plain object and returns it.\n   *\n   * @returns {Object} `Node` converted to plain object.\n   */\n\n\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n  /**\n   * Returns a new range that is equal to current range.\n   *\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  clone() {\n    return new this.constructor(this.start, this.end);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by insert operation.\n   *\n   * One or more ranges may be returned as a result of this transformation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n   * @returns {Array.<module:engine/model/range~Range>}\n   */\n\n\n  _getTransformedByInsertOperation(operation) {\n    let spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._getTransformedByInsertion(operation.position, operation.howMany, spread);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by move operation.\n   *\n   * One or more ranges may be returned as a result of this transformation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n   * @returns {Array.<module:engine/model/range~Range>}\n   */\n\n\n  _getTransformedByMoveOperation(operation) {\n    let spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const sourcePosition = operation.sourcePosition;\n    const howMany = operation.howMany;\n    const targetPosition = operation.targetPosition;\n    return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by split operation.\n   *\n   * Always one range is returned. The transformation is done in a way to not break the range.\n   *\n   * @protected\n   * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  _getTransformedBySplitOperation(operation) {\n    const start = this.start._getTransformedBySplitOperation(operation);\n\n    let end = this.end._getTransformedBySplitOperation(operation);\n\n    if (this.end.isEqual(operation.insertionPosition)) {\n      end = this.end.getShiftedBy(1);\n    } // Below may happen when range contains graveyard element used by split operation.\n\n\n    if (start.root != end.root) {\n      // End position was next to the moved graveyard element and was moved with it.\n      // Fix it by using old `end` which has proper `root`.\n      end = this.end.getShiftedBy(-1);\n    }\n\n    return new Range(start, end);\n  }\n  /**\n   * Returns a result of transforming a copy of this range by merge operation.\n   *\n   * Always one range is returned. The transformation is done in a way to not break the range.\n   *\n   * @protected\n   * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  _getTransformedByMergeOperation(operation) {\n    // Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n    // transformations, especially when a content of a few block elements were removed. For example:\n    //\n    // {} is the transformed range, [] is the removed range.\n    // <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n    //\n    // <p>Fo{o</p><p>B}ar</p><p>z</p>\n    // <p>F{</p><p>B}ar</p><p>z</p>\n    // <p>F{</p>}<p>z</p>\n    // <p>F{}z</p>\n    //\n    if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {\n      return new Range(this.start);\n    }\n\n    let start = this.start._getTransformedByMergeOperation(operation);\n\n    let end = this.end._getTransformedByMergeOperation(operation);\n\n    if (start.root != end.root) {\n      // This happens when the end position was next to the merged (deleted) element.\n      // Then, the end position was moved to the graveyard root. In this case we need to fix\n      // the range cause its boundaries would be in different roots.\n      end = this.end.getShiftedBy(-1);\n    }\n\n    if (start.isAfter(end)) {\n      // This happens in three following cases:\n      //\n      // Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n      //         This means that start can be moved before the end of the range.\n      //\n      // Before: <p>a{a</p><p>b}b</p><p>cc</p>\n      // Merge:  <p>b}b</p><p>cca{a</p>\n      // Fix:    <p>{b}b</p><p>ccaa</p>\n      //\n      // Case 2: Range start is before merged node but not directly.\n      //         Result should include all nodes that were in the original range.\n      //\n      // Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n      // Merge:  <p>aab}b</p>{<p>cc</p>\n      // Fix:    <p>aa{bb</p><p>cc</p>}\n      //\n      //         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n      //\n      // Case 3: Range start is directly before merged node.\n      //         Resulting range should include only nodes from the merged element:\n      //\n      // Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n      // Merge:  <p>aab}b</p>{<p>cc</p>\n      // Fix:    <p>aa{b}b</p><p>cc</p>\n      //\n      if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n        // Case 1.\n        start = Position._createAt(end);\n        start.offset = 0;\n      } else {\n        if (!operation.deletionPosition.isEqual(start)) {\n          // Case 2.\n          end = operation.deletionPosition;\n        } // In both case 2 and 3 start is at the end of the merge-to element.\n\n\n        start = operation.targetPosition;\n      }\n\n      return new Range(start, end);\n    }\n\n    return new Range(start, end);\n  }\n  /**\n   * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n   * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n   * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n   *\n   * Examples:\n   *\n   *\t\tlet range = model.createRange(\n   *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n   *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n   *\t\t);\n   *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n   *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n   *\n   *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n   *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n   *\n   *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n   *\t\t// transformed array has one range, which is equal to original range\n   *\n   *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n   *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n   * @param {Number} howMany How many nodes are inserted.\n   * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n   * was inside the range. Defaults to `false`.\n   * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n   */\n\n\n  _getTransformedByInsertion(insertPosition, howMany) {\n    let spread = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (spread && this.containsPosition(insertPosition)) {\n      // Range has to be spread. The first part is from original start to the spread point.\n      // The other part is from spread point to the original end, but transformed by\n      // insertion to reflect insertion changes.\n      return [new Range(this.start, insertPosition), new Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))];\n    } else {\n      const range = new Range(this.start, this.end);\n      range.start = range.start._getTransformedByInsertion(insertPosition, howMany);\n      range.end = range.end._getTransformedByInsertion(insertPosition, howMany);\n      return [range];\n    }\n  }\n  /**\n   * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n   * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n   * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n   * @param {Number} howMany How many nodes are moved.\n   * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n   * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n   */\n\n\n  _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n    let spread = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    // Special case for transforming a collapsed range. Just transform it like a position.\n    if (this.isCollapsed) {\n      const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n\n      return [new Range(newPos)];\n    } // Special case for transformation when a part of the range is moved towards the range.\n    //\n    // Examples:\n    //\n    // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n    // <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n    //\n    // Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n    //\n    // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n    //\n    // This special case is applied only if the range is to be kept together (not spread).\n\n\n    const moveRange = Range._createFromPositionAndShift(sourcePosition, howMany);\n\n    const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n\n    if (this.containsPosition(targetPosition) && !spread) {\n      if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {\n        const start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n\n        const end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);\n\n        return [new Range(start, end)];\n      }\n    } // Default algorithm.\n\n\n    let result;\n    const differenceSet = this.getDifference(moveRange);\n    let difference = null;\n    const common = this.getIntersection(moveRange);\n\n    if (differenceSet.length == 1) {\n      // `moveRange` and this range may intersect but may be separate.\n      difference = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));\n    } else if (differenceSet.length == 2) {\n      // `moveRange` is inside this range.\n      difference = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));\n    } // else, `moveRange` contains this range.\n\n\n    if (difference) {\n      result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);\n    } else {\n      result = [];\n    }\n\n    if (common) {\n      const transformedCommon = new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));\n\n      if (result.length == 2) {\n        result.splice(1, 0, transformedCommon);\n      } else {\n        result.push(transformedCommon);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n   *\n   * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n   *\n   * If the deleted range contains transformed range, `null` will be returned.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n   * @param {Number} howMany How many nodes are removed.\n   * @returns {module:engine/model/range~Range|null} Result of the transformation.\n   */\n\n\n  _getTransformedByDeletion(deletePosition, howMany) {\n    let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);\n\n    let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);\n\n    if (newStart == null && newEnd == null) {\n      return null;\n    }\n\n    if (newStart == null) {\n      newStart = deletePosition;\n    }\n\n    if (newEnd == null) {\n      newEnd = deletePosition;\n    }\n\n    return new Range(newStart, newEnd);\n  }\n  /**\n   * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} position Beginning of the range.\n   * @param {Number} shift How long the range should be.\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  static _createFromPositionAndShift(position, shift) {\n    const start = position;\n    const end = position.getShiftedBy(shift);\n    return shift > 0 ? new this(start, end) : new this(end, start);\n  }\n  /**\n   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  static _createIn(element) {\n    return new this(Position._createAt(element, 0), Position._createAt(element, element.maxOffset));\n  }\n  /**\n   * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n   *\n   * @protected\n   * @param {module:engine/model/item~Item} item\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  static _createOn(item) {\n    return this._createFromPositionAndShift(Position._createBefore(item), item.offsetSize);\n  }\n  /**\n   * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n   * Passed ranges must not have common parts.\n   *\n   * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n   * the reference range, they get combined into one range.\n   *\n   *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n   *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n   *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n   *\t                                           [  ]  // The result of the function if the last range was a reference range.\n   *\n   * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n   * @returns {module:engine/model/range~Range} Combined range.\n   */\n\n\n  static _createFromRanges(ranges) {\n    if (ranges.length === 0) {\n      /**\n       * At least one range has to be passed to\n       * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n       *\n       * @error range-create-from-ranges-empty-array\n       */\n      throw new CKEditorError('range-create-from-ranges-empty-array', null);\n    } else if (ranges.length == 1) {\n      return ranges[0].clone();\n    } // 1. Set the first range in `ranges` array as a reference range.\n    // If we are going to return just a one range, one of the ranges need to be the reference one.\n    // Other ranges will be stuck to that range, if possible.\n\n\n    const ref = ranges[0]; // 2. Sort all the ranges so it's easier to process them.\n\n    ranges.sort((a, b) => {\n      return a.start.isAfter(b.start) ? 1 : -1;\n    }); // 3. Check at which index the reference range is now.\n\n    const refIndex = ranges.indexOf(ref); // 4. At this moment we don't need the original range.\n    // We are going to modify the result and we need to return a new instance of Range.\n    // We have to create a copy of the reference range.\n\n    const result = new this(ref.start, ref.end); // 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n    // Since ranges are sorted, start with the range with index that is closest to reference range index.\n\n    if (refIndex > 0) {\n      for (let i = refIndex - 1; true; i++) {\n        if (ranges[i].end.isEqual(result.start)) {\n          result.start = Position._createAt(ranges[i].start);\n        } else {\n          // If ranges are not starting/ending at the same position there is no point in looking further.\n          break;\n        }\n      }\n    } // 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n    // Since ranges are sorted, start with the range with index that is closest to reference range index.\n\n\n    for (let i = refIndex + 1; i < ranges.length; i++) {\n      if (ranges[i].start.isEqual(result.end)) {\n        result.end = Position._createAt(ranges[i].end);\n      } else {\n        // If ranges are not starting/ending at the same position there is no point in looking further.\n        break;\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n   *\n   * @param {Object} json Plain object to be converted to `Range`.\n   * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n   * @returns {module:engine/model/range~Range} `Range` instance created using given plain object.\n   */\n\n\n  static fromJSON(json, doc) {\n    return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.start.path.join( ', ' ) } ] - [ ${ this.end.path.join( ', ' ) } ]`;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // log() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n  // @if CK_DEBUG_ENGINE // }\n\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js"],"names":["Position","TreeWalker","CKEditorError","compareArrays","Range","constructor","start","end","_createAt","stickiness","isCollapsed","Symbol","iterator","boundaries","ignoreElementEnd","isEqual","isFlat","startParentPath","getParentPath","endParentPath","root","containsPosition","position","isAfter","isBefore","containsRange","otherRange","loose","containsStart","containsEnd","containsItem","item","pos","_createBefore","is","type","isIntersecting","getDifference","ranges","push","getIntersection","commonRangeStart","commonRangeEnd","getJoined","shouldJoin","isTouching","startPosition","endPosition","getMinimalFlatRanges","diffAt","getCommonPath","length","posParent","parent","path","howMany","maxOffset","offset","getShiftedBy","slice","getWalker","options","getItems","treeWalker","value","getPositions","nextPosition","getTransformedByOperation","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","getTransformedByOperations","operations","i","result","splice","range","j","next","getCommonAncestor","getContainedElement","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","toJSON","clone","spread","_getTransformedByInsertion","sourcePosition","targetPosition","_getTransformedByMove","insertionPosition","deletionPosition","insertPosition","newPos","moveRange","_createFromPositionAndShift","_getTransformedByDeletion","differenceSet","difference","common","transformedCommon","_getCombined","deletePosition","newStart","newEnd","shift","_createIn","element","_createOn","offsetSize","_createFromRanges","ref","sort","a","b","refIndex","indexOf","fromJSON","json","doc"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * @param {module:engine/model/position~Position} start The start position.\n\t * @param {module:engine/model/position~Position} [end] The end position. If not set,\n\t * the range will be collapsed at the `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.start = Position._createAt( start );\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.end = end ? Position._createAt( end ) : Position._createAt( start );\n\n\t\t// If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n\t\t// In other case, make the boundaries stick to the \"inside\" of the range.\n\t\tthis.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n\t\tthis.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/model/position~Position positions},\n\t * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n\t * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n\t *\n\t * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n\t * and `ignoreElementEnd` option set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is if {@link #start} and\n\t * {@link #end} positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link #start} position and\n\t * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\tconst startParentPath = this.start.getParentPath();\n\t\tconst endParentPath = this.end.getParentPath();\n\n\t\treturn compareArrays( startParentPath, endParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n\t * in this range,`false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link ~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n\t *\n\t * @param {module:engine/model/item~Item} item Model item to check.\n\t */\n\tcontainsItem( item ) {\n\t\tconst pos = Position._createBefore( item );\n\n\t\treturn this.containsPosition( pos ) || this.start.isEqual( pos );\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'model:range' ); // -> true\n\t *\n\t *\t\trange.is( 'view:range' ); // -> false\n\t *\t\trange.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'range' || type === 'model:range';\n\t}\n\n\t/**\n\t * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end );\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with given range.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n\t * Returned array contains zero, one or two {@link ~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( new Range( this.start, this.end ) );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.\n\t * If ranges have no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 1 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2 ] )\n \t *\t\t);\n\t *\t\tlet transformed = range.getJoined( otherRange ); // null - ranges have no common part\n\t *\n\t *\t\totherRange = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 3 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 5 ] )\n\t *\t\t);\n\t *\t\ttransformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to be joined.\n\t * @param {Boolean} [loose=false] Whether the intersection check is loose or strict. If the check is strict (`false`),\n\t * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),\n\t * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.\n\t * @returns {module:engine/model/range~Range|null} A sum of given ranges or `null` if ranges have no common part.\n\t */\n\tgetJoined( otherRange, loose = false ) {\n\t\tlet shouldJoin = this.isIntersecting( otherRange );\n\n\t\tif ( !shouldJoin ) {\n\t\t\tif ( this.start.isBefore( otherRange.start ) ) {\n\t\t\t\tshouldJoin = loose ? this.end.isTouching( otherRange.start ) : this.end.isEqual( otherRange.start );\n\t\t\t} else {\n\t\t\t\tshouldJoin = loose ? otherRange.end.isTouching( this.start ) : otherRange.end.isEqual( this.start );\n\t\t\t}\n\t\t}\n\n\t\tif ( !shouldJoin ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet startPosition = this.start;\n\t\tlet endPosition = this.end;\n\n\t\tif ( otherRange.start.isBefore( startPosition ) ) {\n\t\t\tstartPosition = otherRange.start;\n\t\t}\n\n\t\tif ( otherRange.end.isAfter( endPosition ) ) {\n\t\t\tendPosition = otherRange.end;\n\t\t}\n\n\t\treturn new Range( startPosition, endPosition );\n\t}\n\n\t/**\n\t * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n\t *\n\t * See an example of a model structure (`[` and `]` are range boundaries):\n\t *\n\t *\t\troot                                                            root\n\t *\t\t |- element DIV                         DIV             P2              P3             DIV\n\t *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n\t *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n\t *\t\t |   |- element P1\n\t *\t\t |   |   |- \"lorem\"                                              ||\n\t *\t\t |- element P2                                                   ||\n\t *\t\t |   |- \"foo\"                                                    VV\n\t *\t\t |- element P3\n\t *\t\t |   |- \"bar\"                                                   root\n\t *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n\t *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n\t *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n\t *\t\t |   |- element P4\n\t *\t\t |   |   |- \"ipsum\"\n\t *\n\t * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n\t * We are looking for minimal set of flat ranges that contains the same nodes.\n\t *\n\t * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n\t *\n\t *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n\t *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n\t *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n\t *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n\t *\n\t * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n\t * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n\t * were omitted. Only their parts that were wholly in the range were returned.\n\t *\n\t * **Note:** this method is not returning flat ranges that contain no nodes.\n\t *\n\t * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n\t */\n\tgetMinimalFlatRanges() {\n\t\tconst ranges = [];\n\t\tconst diffAt = this.start.getCommonPath( this.end ).length;\n\n\t\tconst pos = Position._createAt( this.start );\n\t\tlet posParent = pos.parent;\n\n\t\t// Go up.\n\t\twhile ( pos.path.length > diffAt + 1 ) {\n\t\t\tconst howMany = posParent.maxOffset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.path = pos.path.slice( 0, -1 );\n\t\t\tpos.offset++;\n\t\t\tposParent = posParent.parent;\n\t\t}\n\n\t\t// Go down.\n\t\twhile ( pos.path.length <= this.end.path.length ) {\n\t\t\tconst offset = this.end.path[ pos.path.length - 1 ];\n\t\t\tconst howMany = offset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.offset = offset;\n\t\t\tpos.path.push( 0 );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * For example, to iterate over all items in the entire document root:\n\t *\n\t *\t\t// Create a range spanning over the entire root content:\n\t *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n\t *\n\t *\t\t// Iterate over all items in this range:\n\t *\t\tfor ( const value of range.getWalker() ) {\n\t *\t\t\tconsole.log( value.item );\n\t *\t\t}\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @param {module:engine/model/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t * @returns {module:engine/model/treewalker~TreeWalker}\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n\t * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} [options] Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by given `operation`.\n\t *\n\t * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n\t * moved to a different part of document tree). For this reason, an array is returned by this method and it\n\t * may contain one or more `Range` instances.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\treturn this._getTransformedByInsertOperation( operation );\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\treturn this._getTransformedByMoveOperation( operation );\n\t\t\tcase 'split':\n\t\t\t\treturn [ this._getTransformedBySplitOperation( operation ) ];\n\t\t\tcase 'merge':\n\t\t\t\treturn [ this._getTransformedByMergeOperation( operation ) ];\n\t\t}\n\n\t\treturn [ new Range( this.start, this.end ) ];\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by multiple `operations`.\n\t *\n\t * @see ~Range#getTransformedByOperation\n\t * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperations( operations ) {\n\t\tconst ranges = [ new Range( this.start, this.end ) ];\n\n\t\tfor ( const operation of operations ) {\n\t\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\t\tconst result = ranges[ i ].getTransformedByOperation( operation );\n\n\t\t\t\tranges.splice( i, 1, ...result );\n\t\t\t\ti += result.length - 1;\n\t\t\t}\n\t\t}\n\n\t\t// It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n\t\t// \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n\t\t// because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n\t\t// are inside other ranges and we simply remove them.\n\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\tconst range = ranges[ i ];\n\n\t\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t\tconst next = ranges[ j ];\n\n\t\t\t\tif ( range.containsRange( next ) || next.containsRange( range ) || range.isEqual( next ) ) {\n\t\t\t\t\tranges.splice( j, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of the range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element Element} contained by the range.\n\t * The element will be returned when it is the **only** node within the range and **fully–contained**\n\t * at the same time.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetContainedElement() {\n\t\tif ( this.isCollapsed ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nodeAfterStart = this.start.nodeAfter;\n\t\tconst nodeBeforeEnd = this.end.nodeBefore;\n\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'element' ) && nodeAfterStart === nodeBeforeEnd ) {\n\t\t\treturn nodeAfterStart;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts `Range` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\tstart: this.start.toJSON(),\n\t\t\tend: this.end.toJSON()\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new range that is equal to current range.\n\t *\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by insert operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByInsertOperation( operation, spread = false ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by move operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByMoveOperation( operation, spread = false ) {\n\t\tconst sourcePosition = operation.sourcePosition;\n\t\tconst howMany = operation.howMany;\n\t\tconst targetPosition = operation.targetPosition;\n\n\t\treturn this._getTransformedByMove( sourcePosition, targetPosition, howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by split operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst start = this.start._getTransformedBySplitOperation( operation );\n\t\tlet end = this.end._getTransformedBySplitOperation( operation );\n\n\t\tif ( this.end.isEqual( operation.insertionPosition ) ) {\n\t\t\tend = this.end.getShiftedBy( 1 );\n\t\t}\n\n\t\t// Below may happen when range contains graveyard element used by split operation.\n\t\tif ( start.root != end.root ) {\n\t\t\t// End position was next to the moved graveyard element and was moved with it.\n\t\t\t// Fix it by using old `end` which has proper `root`.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by merge operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\t// Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n\t\t// transformations, especially when a content of a few block elements were removed. For example:\n\t\t//\n\t\t// {} is the transformed range, [] is the removed range.\n\t\t// <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n\t\t//\n\t\t// <p>Fo{o</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p>}<p>z</p>\n\t\t// <p>F{}z</p>\n\t\t//\n\t\tif ( this.start.isEqual( operation.targetPosition ) && this.end.isEqual( operation.deletionPosition ) ) {\n\t\t\treturn new Range( this.start );\n\t\t}\n\n\t\tlet start = this.start._getTransformedByMergeOperation( operation );\n\t\tlet end = this.end._getTransformedByMergeOperation( operation );\n\n\t\tif ( start.root != end.root ) {\n\t\t\t// This happens when the end position was next to the merged (deleted) element.\n\t\t\t// Then, the end position was moved to the graveyard root. In this case we need to fix\n\t\t\t// the range cause its boundaries would be in different roots.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\tif ( start.isAfter( end ) ) {\n\t\t\t// This happens in three following cases:\n\t\t\t//\n\t\t\t// Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n\t\t\t//         This means that start can be moved before the end of the range.\n\t\t\t//\n\t\t\t// Before: <p>a{a</p><p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>b}b</p><p>cca{a</p>\n\t\t\t// Fix:    <p>{b}b</p><p>ccaa</p>\n\t\t\t//\n\t\t\t// Case 2: Range start is before merged node but not directly.\n\t\t\t//         Result should include all nodes that were in the original range.\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{bb</p><p>cc</p>}\n\t\t\t//\n\t\t\t//         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n\t\t\t//\n\t\t\t// Case 3: Range start is directly before merged node.\n\t\t\t//         Resulting range should include only nodes from the merged element:\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{b}b</p><p>cc</p>\n\t\t\t//\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Case 1.\n\t\t\t\tstart = Position._createAt( end );\n\t\t\t\tstart.offset = 0;\n\t\t\t} else {\n\t\t\t\tif ( !operation.deletionPosition.isEqual( start ) ) {\n\t\t\t\t\t// Case 2.\n\t\t\t\t\tend = operation.deletionPosition;\n\t\t\t\t}\n\n\t\t\t\t// In both case 2 and 3 start is at the end of the merge-to element.\n\t\t\t\tstart = operation.targetPosition;\n\t\t\t}\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n\t * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n\t *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n\t *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n\t *\t\t// transformed array has one range, which is equal to original range\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n\t * was inside the range. Defaults to `false`.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany, spread = false ) {\n\t\tif ( spread && this.containsPosition( insertPosition ) ) {\n\t\t\t// Range has to be spread. The first part is from original start to the spread point.\n\t\t\t// The other part is from spread point to the original end, but transformed by\n\t\t\t// insertion to reflect insertion changes.\n\n\t\t\treturn [\n\t\t\t\tnew Range( this.start, insertPosition ),\n\t\t\t\tnew Range(\n\t\t\t\t\tinsertPosition.getShiftedBy( howMany ),\n\t\t\t\t\tthis.end._getTransformedByInsertion( insertPosition, howMany )\n\t\t\t\t)\n\t\t\t];\n\t\t} else {\n\t\t\tconst range = new Range( this.start, this.end );\n\n\t\t\trange.start = range.start._getTransformedByInsertion( insertPosition, howMany );\n\t\t\trange.end = range.end._getTransformedByInsertion( insertPosition, howMany );\n\n\t\t\treturn [ range ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n\t * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n\t * @param {Number} howMany How many nodes are moved.\n\t * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany, spread = false ) {\n\t\t// Special case for transforming a collapsed range. Just transform it like a position.\n\t\tif ( this.isCollapsed ) {\n\t\t\tconst newPos = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\treturn [ new Range( newPos ) ];\n\t\t}\n\n\t\t// Special case for transformation when a part of the range is moved towards the range.\n\t\t//\n\t\t// Examples:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n\t\t// <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n\t\t//\n\t\t// Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n\t\t//\n\t\t// This special case is applied only if the range is to be kept together (not spread).\n\t\tconst moveRange = Range._createFromPositionAndShift( sourcePosition, howMany );\n\t\tconst insertPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( this.containsPosition( targetPosition ) && !spread ) {\n\t\t\tif ( moveRange.containsPosition( this.start ) || moveRange.containsPosition( this.end ) ) {\n\t\t\t\tconst start = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\t\t\t\tconst end = this.end._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\t\treturn [ new Range( start, end ) ];\n\t\t\t}\n\t\t}\n\n\t\t// Default algorithm.\n\t\tlet result;\n\n\t\tconst differenceSet = this.getDifference( moveRange );\n\t\tlet difference = null;\n\n\t\tconst common = this.getIntersection( moveRange );\n\n\t\tif ( differenceSet.length == 1 ) {\n\t\t\t// `moveRange` and this range may intersect but may be separate.\n\t\t\tdifference = new Range(\n\t\t\t\tdifferenceSet[ 0 ].start._getTransformedByDeletion( sourcePosition, howMany ),\n\t\t\t\tdifferenceSet[ 0 ].end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} else if ( differenceSet.length == 2 ) {\n\t\t\t// `moveRange` is inside this range.\n\t\t\tdifference = new Range(\n\t\t\t\tthis.start,\n\t\t\t\tthis.end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} // else, `moveRange` contains this range.\n\n\t\tif ( difference ) {\n\t\t\tresult = difference._getTransformedByInsertion( insertPosition, howMany, common !== null || spread );\n\t\t} else {\n\t\t\tresult = [];\n\t\t}\n\n\t\tif ( common ) {\n\t\t\tconst transformedCommon = new Range(\n\t\t\t\tcommon.start._getCombined( moveRange.start, insertPosition ),\n\t\t\t\tcommon.end._getCombined( moveRange.start, insertPosition )\n\t\t\t);\n\n\t\t\tif ( result.length == 2 ) {\n\t\t\t\tresult.splice( 1, 0, transformedCommon );\n\t\t\t} else {\n\t\t\t\tresult.push( transformedCommon );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n\t *\n\t * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n\t *\n\t * If the deleted range contains transformed range, `null` will be returned.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/range~Range|null} Result of the transformation.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tlet newStart = this.start._getTransformedByDeletion( deletePosition, howMany );\n\t\tlet newEnd = this.end._getTransformedByDeletion( deletePosition, howMany );\n\n\t\tif ( newStart == null && newEnd == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( newStart == null ) {\n\t\t\tnewStart = deletePosition;\n\t\t}\n\n\t\tif ( newEnd == null ) {\n\t\t\tnewEnd = deletePosition;\n\t\t}\n\n\t\treturn new Range( newStart, newEnd );\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn new this( Position._createAt( element, 0 ), Position._createAt( element, element.maxOffset ) );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), item.offsetSize );\n\t}\n\n\t/**\n\t * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n\t * Passed ranges must not have common parts.\n\t *\n\t * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n\t * the reference range, they get combined into one range.\n\t *\n\t *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n\t *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n\t *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n\t *\t                                           [  ]  // The result of the function if the last range was a reference range.\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n\t * @returns {module:engine/model/range~Range} Combined range.\n\t */\n\tstatic _createFromRanges( ranges ) {\n\t\tif ( ranges.length === 0 ) {\n\t\t\t/**\n\t\t\t * At least one range has to be passed to\n\t\t\t * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n\t\t\t *\n\t\t\t * @error range-create-from-ranges-empty-array\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'range-create-from-ranges-empty-array',\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if ( ranges.length == 1 ) {\n\t\t\treturn ranges[ 0 ].clone();\n\t\t}\n\n\t\t// 1. Set the first range in `ranges` array as a reference range.\n\t\t// If we are going to return just a one range, one of the ranges need to be the reference one.\n\t\t// Other ranges will be stuck to that range, if possible.\n\t\tconst ref = ranges[ 0 ];\n\n\t\t// 2. Sort all the ranges so it's easier to process them.\n\t\tranges.sort( ( a, b ) => {\n\t\t\treturn a.start.isAfter( b.start ) ? 1 : -1;\n\t\t} );\n\n\t\t// 3. Check at which index the reference range is now.\n\t\tconst refIndex = ranges.indexOf( ref );\n\n\t\t// 4. At this moment we don't need the original range.\n\t\t// We are going to modify the result and we need to return a new instance of Range.\n\t\t// We have to create a copy of the reference range.\n\t\tconst result = new this( ref.start, ref.end );\n\n\t\t// 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tif ( refIndex > 0 ) {\n\t\t\tfor ( let i = refIndex - 1; true; i++ ) {\n\t\t\t\tif ( ranges[ i ].end.isEqual( result.start ) ) {\n\t\t\t\t\tresult.start = Position._createAt( ranges[ i ].start );\n\t\t\t\t} else {\n\t\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tfor ( let i = refIndex + 1; i < ranges.length; i++ ) {\n\t\t\tif ( ranges[ i ].start.isEqual( result.end ) ) {\n\t\t\t\tresult.end = Position._createAt( ranges[ i ].end );\n\t\t\t} else {\n\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Range`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n\t * @returns {module:engine/model/range~Range} `Range` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\treturn new this( Position.fromJSON( json.start, doc ), Position.fromJSON( json.end, doc ) );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.start.path.join( ', ' ) } ] - [ ${ this.end.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n"]},"metadata":{},"sourceType":"module"}