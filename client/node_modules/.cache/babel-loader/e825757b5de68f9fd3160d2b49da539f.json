{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport RawElement from './rawelement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\n\nexport default class DowncastWriter {\n  /**\n   * @param {module:engine/view/document~Document} document The view document instance.\n   */\n  constructor(document) {\n    /**\n     * The view document instance in which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n     *\n     * @private\n     * @type {Map.<String,Set>}\n     */\n\n    this._cloneGroups = new Map();\n  }\n  /**\n   * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n   * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n   *\n   * Usage:\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets backward selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\twriter.setSelection( otherSelection );\n   *\n   * \t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\twriter.setSelection( position );\n   *\n   * \t\t// Sets collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'p' );\n   *\t\twriter.setSelection( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n  \t * that element and ends after the last child of that element.\n   *\n   * \t\twriter.setSelection( paragraph, 'in' );\n   *\n   * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\twriter.setSelection( paragraph, 'on' );\n   *\n   * \t\t// Removes all ranges.\n   *\t\twriter.setSelection( null );\n   *\n   * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\twriter.setSelection( range, { backward: true } );\n   *\n   *\t\t// Sets selection as fake.\n   *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * \t\t// represented in other way, for example by applying proper CSS class.\n   *\t\twriter.setSelection( range, { fake: true } );\n   *\n   * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * \t\t// (and be  properly handled by screen readers).\n   *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n\n\n  setSelection(selectable, placeOrOffset, options) {\n    this.document.selection._setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n   *\n   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n   * parameters.\n   *\n   * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n\n\n  setSelectionFocus(itemOrPosition, offset) {\n    this.document.selection._setFocus(itemOrPosition, offset);\n  }\n  /**\n   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.\n   *\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into the created document fragment.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.\n   */\n\n\n  createDocumentFragment(children) {\n    return new DocumentFragment(this.document, children);\n  }\n  /**\n   * Creates a new {@link module:engine/view/text~Text text node}.\n   *\n   *\t\twriter.createText( 'foo' );\n   *\n   * @param {String} data The text's data.\n   * @returns {module:engine/view/text~Text} The created text node.\n   */\n\n\n  createText(data) {\n    return new Text(this.document, data);\n  }\n  /**\n   * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.\n   *\n   *\t\twriter.createAttributeElement( 'strong' );\n   *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n   *\n   *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n   *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n   *\n   *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n   *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n   *\n   * **Note:** By default an `AttributeElement` is split by a\n   * {@link module:engine/view/containerelement~ContainerElement `ContainerElement`} but this behavior can be modified\n   * with `isAllowedInsideAttributeElement` option set while {@link #createContainerElement creating the element}.\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Element's attributes.\n   * @param {Object} [options] Element's options.\n   * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n   * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n   */\n\n\n  createAttributeElement(name, attributes) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const attributeElement = new AttributeElement(this.document, name, attributes);\n\n    if (typeof options.priority === 'number') {\n      attributeElement._priority = options.priority;\n    }\n\n    if (options.id) {\n      attributeElement._id = options.id;\n    }\n\n    return attributeElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/containerelement~ContainerElement}.\n   *\n   *\t\twriter.createContainerElement( 'p' );\n   *\n   *\t\t// Create element with custom attributes.\n   *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n   *\n   *\t\t// Create element with custom styles.\n   *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n   *\n   *\t\t// Create element with custom classes.\n   *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {Object} [options] Element's options.\n   * @param {Boolean} [options.isAllowedInsideAttributeElement=false] Whether an element is\n   * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n   * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n   * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n   */\n\n\n  createContainerElement(name, attributes) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const containerElement = new ContainerElement(this.document, name, attributes);\n\n    if (options.isAllowedInsideAttributeElement !== undefined) {\n      containerElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n    }\n\n    return containerElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/editableelement~EditableElement}.\n   *\n   *\t\twriter.createEditableElement( 'div' );\n   *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n   *\n   * Note: The editable element is to be used in the editing pipeline. Usually, together with\n   * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @returns {module:engine/view/editableelement~EditableElement} Created element.\n   */\n\n\n  createEditableElement(name, attributes) {\n    const editableElement = new EditableElement(this.document, name, attributes);\n    editableElement._document = this.document;\n    return editableElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.\n   *\n   *\t\twriter.createEmptyElement( 'img' );\n   *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {Object} [options] Element's options.\n   * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n   * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n   * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n   * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n   */\n\n\n  createEmptyElement(name, attributes) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const emptyElement = new EmptyElement(this.document, name, attributes);\n\n    if (options.isAllowedInsideAttributeElement !== undefined) {\n      emptyElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n    }\n\n    return emptyElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/uielement~UIElement}.\n   *\n   *\t\twriter.createUIElement( 'span' );\n   *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n   *\n   * A custom render function can be provided as the third parameter:\n   *\n   *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n   *\t\t\tconst domElement = this.toDomElement( domDocument );\n   *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n   *\n   *\t\t\treturn domElement;\n   *\t\t} );\n   *\n   * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,\n   * they are ignored by the editor selection system.\n   *\n   * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.\n   *\n   * @param {String} name The name of the element.\n   * @param {Object} [attributes] Element attributes.\n   * @param {Function} [renderFunction] A custom render function.\n   * @param {Object} [options] Element's options.\n   * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n   * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n   * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n   * @returns {module:engine/view/uielement~UIElement} The created element.\n   */\n\n\n  createUIElement(name, attributes, renderFunction) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const uiElement = new UIElement(this.document, name, attributes);\n\n    if (renderFunction) {\n      uiElement.render = renderFunction;\n    }\n\n    if (options.isAllowedInsideAttributeElement !== undefined) {\n      uiElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n    }\n\n    return uiElement;\n  }\n  /**\n   * Creates a new {@link module:engine/view/rawelement~RawElement}.\n   *\n   *\t\twriter.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {\n   *\t\t\tdomElement.innerHTML = '<b>This is the raw content of the raw element.</b>';\n   *\t\t} );\n   *\n   * Raw elements work as data containers (\"wrappers\", \"sandboxes\") but their children are not managed or\n   * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures\n   * in the editor content without, for instance, worrying about compatibility with other editor features.\n   * Raw elements are a perfect tool for integration with external frameworks and data sources.\n   *\n   * Unlike {@link #createUIElement UI elements}, raw elements act like \"real\" editor content (similar to\n   * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),\n   * and they are considered by the editor selection.\n   *\n   * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}\n   * instead.\n   *\n   * @param {String} name The name of the element.\n   * @param {Object} [attributes] Element attributes.\n   * @param {Function} [renderFunction] A custom render function.\n   * @param {Object} [options] Element's options.\n   * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n   * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n   * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n   * @returns {module:engine/view/rawelement~RawElement} The created element.\n   */\n\n\n  createRawElement(name, attributes, renderFunction) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const rawElement = new RawElement(this.document, name, attributes);\n\n    rawElement.render = renderFunction || (() => {});\n\n    if (options.isAllowedInsideAttributeElement !== undefined) {\n      rawElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n    }\n\n    return rawElement;\n  }\n  /**\n   * Adds or overwrites the element's attribute with a specified key and value.\n   *\n   *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n   *\n   * @param {String} key The attribute key.\n   * @param {String} value The attribute value.\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  setAttribute(key, value, element) {\n    element._setAttribute(key, value);\n  }\n  /**\n   * Removes attribute from the element.\n   *\n   *\t\twriter.removeAttribute( 'href', linkElement );\n   *\n   * @param {String} key Attribute key.\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  removeAttribute(key, element) {\n    element._removeAttribute(key);\n  }\n  /**\n   * Adds specified class to the element.\n   *\n   *\t\twriter.addClass( 'foo', linkElement );\n   *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n   *\n   * @param {Array.<String>|String} className\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  addClass(className, element) {\n    element._addClass(className);\n  }\n  /**\n   * Removes specified class from the element.\n   *\n   *\t\twriter.removeClass( 'foo', linkElement );\n   *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n   *\n   * @param {Array.<String>|String} className\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  removeClass(className, element) {\n    element._removeClass(className);\n  }\n  /**\n   * Adds style to the element.\n   *\n   *\t\twriter.setStyle( 'color', 'red', element );\n   *\t\twriter.setStyle( {\n   *\t\t\tcolor: 'red',\n   *\t\t\tposition: 'fixed'\n   *\t\t}, element );\n   *\n   * **Note**: The passed style can be normalized if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n   *\n   * @param {String|Object} property Property name or object with key - value pairs.\n   * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n   * @param {module:engine/view/element~Element} element Element to set styles on.\n   */\n\n\n  setStyle(property, value, element) {\n    if (isPlainObject(property) && element === undefined) {\n      element = value;\n    }\n\n    element._setStyle(property, value);\n  }\n  /**\n   * Removes specified style from the element.\n   *\n   *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n   *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n   *\n   * @param {Array.<String>|String} property\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  removeStyle(property, element) {\n    element._removeStyle(property);\n  }\n  /**\n   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n   * so they can be used to add special data to elements.\n   *\n   * @param {String|Symbol} key\n   * @param {*} value\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  setCustomProperty(key, value, element) {\n    element._setCustomProperty(key, value);\n  }\n  /**\n   * Removes a custom property stored under the given key.\n   *\n   * @param {String|Symbol} key\n   * @param {module:engine/view/element~Element} element\n   * @returns {Boolean} Returns true if property was removed.\n   */\n\n\n  removeCustomProperty(key, element) {\n    return element._removeCustomProperty(key);\n  }\n  /**\n   * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements\n   * up to their first ancestor that is a container element.\n   *\n   * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:\n   *\n   *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n   *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n   *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n   *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n   *\n   * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n   *\n   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n   * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.\n   *\n   * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * when the {@link module:engine/view/range~Range#start start}\n   * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n   *\n   * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n   *\n   * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n   * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n   * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange The position where\n   * to break attribute elements.\n   * @returns {module:engine/view/position~Position|module:engine/view/range~Range} The new position or range, after breaking the\n   * attribute elements.\n   */\n\n\n  breakAttributes(positionOrRange) {\n    if (positionOrRange instanceof Position) {\n      return this._breakAttributes(positionOrRange);\n    } else {\n      return this._breakAttributesRange(positionOrRange);\n    }\n  }\n  /**\n   * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.\n   * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element\n   * if the position is at the beginning or at the end of its parent element.\n   *\n   *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n   *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n   *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n   *\t\t<p>foobar^</p> -> <p>foobar</p>^\n   *\n   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n   * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n   * @param {module:engine/view/position~Position} position The position where to break the element.\n   * @returns {module:engine/view/position~Position} The position between broken elements. If an element has not been broken,\n   * the returned position is placed either before or after it.\n   */\n\n\n  breakContainer(position) {\n    const element = position.parent;\n\n    if (!element.is('containerElement')) {\n      /**\n       * Trying to break an element which is not a container element.\n       *\n       * @error view-writer-break-non-container-element\n       */\n      throw new CKEditorError('view-writer-break-non-container-element', this.document);\n    }\n\n    if (!element.parent) {\n      /**\n       * Trying to break root element.\n       *\n       * @error view-writer-break-root\n       */\n      throw new CKEditorError('view-writer-break-root', this.document);\n    }\n\n    if (position.isAtStart) {\n      return Position._createBefore(element);\n    } else if (!position.isAtEnd) {\n      const newElement = element._clone(false);\n\n      this.insert(Position._createAfter(element), newElement);\n      const sourceRange = new Range(position, Position._createAt(element, 'end'));\n      const targetPosition = new Position(newElement, 0);\n      this.move(sourceRange, targetPosition);\n    }\n\n    return Position._createAfter(element);\n  }\n  /**\n   * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n   * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n   *\n   * In following examples `<p>` is a container and `<b>` is an attribute element:\n   *\n   *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n   *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n   *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n   *\n   * It will also take care about empty attributes when merging:\n   *\n   *\t\t<p><b>[]</b></p> -> <p>[]</p>\n   *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n   * @param {module:engine/view/position~Position} position Merge position.\n   * @returns {module:engine/view/position~Position} Position after merge.\n   */\n\n\n  mergeAttributes(position) {\n    const positionOffset = position.offset;\n    const positionParent = position.parent; // When inside text node - nothing to merge.\n\n    if (positionParent.is('$text')) {\n      return position;\n    } // When inside empty attribute - remove it.\n\n\n    if (positionParent.is('attributeElement') && positionParent.childCount === 0) {\n      const parent = positionParent.parent;\n      const offset = positionParent.index;\n\n      positionParent._remove();\n\n      this._removeFromClonedElementsGroup(positionParent);\n\n      return this.mergeAttributes(new Position(parent, offset));\n    }\n\n    const nodeBefore = positionParent.getChild(positionOffset - 1);\n    const nodeAfter = positionParent.getChild(positionOffset); // Position should be placed between two nodes.\n\n    if (!nodeBefore || !nodeAfter) {\n      return position;\n    } // When position is between two text nodes.\n\n\n    if (nodeBefore.is('$text') && nodeAfter.is('$text')) {\n      return mergeTextNodes(nodeBefore, nodeAfter);\n    } // When position is between two same attribute elements.\n    else if (nodeBefore.is('attributeElement') && nodeAfter.is('attributeElement') && nodeBefore.isSimilar(nodeAfter)) {\n      // Move all children nodes from node placed after selection and remove that node.\n      const count = nodeBefore.childCount;\n\n      nodeBefore._appendChild(nodeAfter.getChildren());\n\n      nodeAfter._remove();\n\n      this._removeFromClonedElementsGroup(nodeAfter); // New position is located inside the first node, before new nodes.\n      // Call this method recursively to merge again if needed.\n\n\n      return this.mergeAttributes(new Position(nodeBefore, count));\n    }\n\n    return position;\n  }\n  /**\n   * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n   * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n   *\n   *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n   *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n   * @param {module:engine/view/position~Position} position Merge position.\n   * @returns {module:engine/view/position~Position} Position after merge.\n   */\n\n\n  mergeContainers(position) {\n    const prev = position.nodeBefore;\n    const next = position.nodeAfter;\n\n    if (!prev || !next || !prev.is('containerElement') || !next.is('containerElement')) {\n      /**\n       * Element before and after given position cannot be merged.\n       *\n       * @error view-writer-merge-containers-invalid-position\n       */\n      throw new CKEditorError('view-writer-merge-containers-invalid-position', this.document);\n    }\n\n    const lastChild = prev.getChild(prev.childCount - 1);\n    const newPosition = lastChild instanceof Text ? Position._createAt(lastChild, 'end') : Position._createAt(prev, 'end');\n    this.move(Range._createIn(next), Position._createAt(prev, 'end'));\n    this.remove(Range._createOn(next));\n    return newPosition;\n  }\n  /**\n   * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion\n   * and merging them afterwards.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n   * contains instances that are not {@link module:engine/view/text~Text Texts},\n   * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n   * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n   * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n   * {@link module:engine/view/rawelement~RawElement RawElements} or\n   * {@link module:engine/view/uielement~UIElement UIElements}.\n   *\n   * @param {module:engine/view/position~Position} position Insertion position.\n   * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n   * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n   * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n   * Iterable.<module:engine/view/text~Text|\n   * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n   * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n   * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n   * @returns {module:engine/view/range~Range} Range around inserted nodes.\n   */\n\n\n  insert(position, nodes) {\n    nodes = isIterable(nodes) ? [...nodes] : [nodes]; // Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\n    validateNodesToInsert(nodes, this.document); // Group nodes in batches of nodes that require or do not require breaking an AttributeElements.\n\n    const nodeGroups = nodes.reduce((groups, node) => {\n      const lastGroup = groups[groups.length - 1]; // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n      // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\n      const breakAttributes = !(node.is('uiElement') && node.isAllowedInsideAttributeElement);\n\n      if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {\n        groups.push({\n          breakAttributes,\n          nodes: [node]\n        });\n      } else {\n        lastGroup.nodes.push(node);\n      }\n\n      return groups;\n    }, []); // Insert nodes in batches.\n\n    let start = null;\n    let end = position;\n\n    for (const {\n      nodes,\n      breakAttributes\n    } of nodeGroups) {\n      const range = this._insertNodes(end, nodes, breakAttributes);\n\n      if (!start) {\n        start = range.start;\n      }\n\n      end = range.end;\n    } // When no nodes were inserted - return collapsed range.\n\n\n    if (!start) {\n      return new Range(position);\n    }\n\n    return new Range(start, end);\n  }\n  /**\n   * Removes provided range from the container.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n   * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n   * to a collapsed range showing the new position.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n   */\n\n\n  remove(rangeOrItem) {\n    const range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn(rangeOrItem);\n    validateRangeContainer(range, this.document); // If range is collapsed - nothing to remove.\n\n    if (range.isCollapsed) {\n      return new DocumentFragment(this.document);\n    } // Break attributes at range start and end.\n\n\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n\n    const parentContainer = breakStart.parent;\n    const count = breakEnd.offset - breakStart.offset; // Remove nodes in range.\n\n    const removed = parentContainer._removeChildren(breakStart.offset, count);\n\n    for (const node of removed) {\n      this._removeFromClonedElementsGroup(node);\n    } // Merge after removing.\n\n\n    const mergePosition = this.mergeAttributes(breakStart);\n    range.start = mergePosition;\n    range.end = mergePosition.clone(); // Return removed nodes.\n\n    return new DocumentFragment(this.document, removed);\n  }\n  /**\n   * Removes matching elements from given range.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} range Range to clear.\n   * @param {module:engine/view/element~Element} element Element to remove.\n   */\n\n\n  clear(range, element) {\n    validateRangeContainer(range, this.document); // Create walker on given range.\n    // We walk backward because when we remove element during walk it modifies range end position.\n\n    const walker = range.getWalker({\n      direction: 'backward',\n      ignoreElementEnd: true\n    }); // Let's walk.\n\n    for (const current of walker) {\n      const item = current.item;\n      let rangeToRemove; // When current item matches to the given element.\n\n      if (item.is('element') && element.isSimilar(item)) {\n        // Create range on this element.\n        rangeToRemove = Range._createOn(item); // When range starts inside Text or TextProxy element.\n      } else if (!current.nextPosition.isAfter(range.start) && item.is('$textProxy')) {\n        // We need to check if parent of this text matches to given element.\n        const parentElement = item.getAncestors().find(ancestor => {\n          return ancestor.is('element') && element.isSimilar(ancestor);\n        }); // If it is then create range inside this element.\n\n        if (parentElement) {\n          rangeToRemove = Range._createIn(parentElement);\n        }\n      } // If we have found element to remove.\n\n\n      if (rangeToRemove) {\n        // We need to check if element range stick out of the given range and truncate if it is.\n        if (rangeToRemove.end.isAfter(range.end)) {\n          rangeToRemove.end = range.end;\n        }\n\n        if (rangeToRemove.start.isBefore(range.start)) {\n          rangeToRemove.start = range.start;\n        } // At the end we remove range with found element.\n\n\n        this.remove(rangeToRemove);\n      }\n    }\n  }\n  /**\n   * Moves nodes from provided range to target position.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n   * @param {module:engine/view/position~Position} targetPosition Position to insert.\n   * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n   */\n\n\n  move(sourceRange, targetPosition) {\n    let nodes;\n\n    if (targetPosition.isAfter(sourceRange.end)) {\n      targetPosition = this._breakAttributes(targetPosition, true);\n      const parent = targetPosition.parent;\n      const countBefore = parent.childCount;\n      sourceRange = this._breakAttributesRange(sourceRange, true);\n      nodes = this.remove(sourceRange);\n      targetPosition.offset += parent.childCount - countBefore;\n    } else {\n      nodes = this.remove(sourceRange);\n    }\n\n    return this.insert(targetPosition, nodes);\n  }\n  /**\n   * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n   *\n   * If a collapsed range was passed and is same as selection, the selection\n   * will be moved to the inside of the wrapped attribute element.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n   * when {@link module:engine/view/range~Range#start}\n   * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n   * is collapsed and different than view selection.\n   *\n   * **Note:** Attribute elements by default can wrap {@link module:engine/view/text~Text},\n   * {@link module:engine/view/emptyelement~EmptyElement}, {@link module:engine/view/uielement~UIElement},\n   * {@link module:engine/view/rawelement~RawElement} and other attribute elements with higher priority. Other elements while placed\n   * inside an attribute element will split it (or nest it in case of an `AttributeElement`). This behavior can be modified by changing\n   * the `isAllowedInsideAttributeElement` option while using\n   * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement},\n   * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement},\n   * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement} or\n   * {@link module:engine/view/downcastwriter~DowncastWriter#createRawElement}.\n   *\n   * @param {module:engine/view/range~Range} range Range to wrap.\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n   * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n   */\n\n\n  wrap(range, attribute) {\n    if (!(attribute instanceof AttributeElement)) {\n      throw new CKEditorError('view-writer-wrap-invalid-attribute', this.document);\n    }\n\n    validateRangeContainer(range, this.document);\n\n    if (!range.isCollapsed) {\n      // Non-collapsed range. Wrap it with the attribute element.\n      return this._wrapRange(range, attribute);\n    } else {\n      // Collapsed range. Wrap position.\n      let position = range.start;\n\n      if (position.parent.is('element') && !_hasNonUiChildren(position.parent)) {\n        position = position.getLastMatchingPosition(value => value.item.is('uiElement'));\n      }\n\n      position = this._wrapPosition(position, attribute);\n      const viewSelection = this.document.selection; // If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\n      if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {\n        this.setSelection(position);\n      }\n\n      return new Range(position);\n    }\n  }\n  /**\n   * Unwraps nodes within provided range from attribute element.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} range\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   */\n\n\n  unwrap(range, attribute) {\n    if (!(attribute instanceof AttributeElement)) {\n      /**\n       * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#unwrap `DowncastWriter#unwrap()`}\n       * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n       *\n       * @error view-writer-unwrap-invalid-attribute\n       */\n      throw new CKEditorError('view-writer-unwrap-invalid-attribute', this.document);\n    }\n\n    validateRangeContainer(range, this.document); // If range is collapsed - nothing to unwrap.\n\n    if (range.isCollapsed) {\n      return range;\n    } // Break attributes at range start and end.\n\n\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n\n    const parentContainer = breakStart.parent; // Unwrap children located between break points.\n\n    const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.\n\n\n    const start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.\n\n    if (!start.isEqual(newRange.start)) {\n      newRange.end.offset--;\n    }\n\n    const end = this.mergeAttributes(newRange.end);\n    return new Range(start, end);\n  }\n  /**\n   * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n   * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n   * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n   *\n   * New element has to be created because `Element#tagName` property in DOM is readonly.\n   *\n   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n   *\n   * @param {String} newName New name for element.\n   * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n   * @returns {module:engine/view/containerelement~ContainerElement} Element created due to rename.\n   */\n\n\n  rename(newName, viewElement) {\n    const newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());\n    this.insert(Position._createAfter(viewElement), newElement);\n    this.move(Range._createIn(viewElement), Position._createAt(newElement, 0));\n    this.remove(Range._createOn(viewElement));\n    return newElement;\n  }\n  /**\n   * Cleans up memory by removing obsolete cloned elements group from the writer.\n   *\n   * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n   * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n   * the group will no longer be needed.\n   *\n   * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n   * were removed from the view.\n   *\n   * Keep in mind that group names are equal to the `id` property of the attribute element.\n   *\n   * @param {String} groupName Name of the group to clear.\n   */\n\n\n  clearClonedElementsGroup(groupName) {\n    this._cloneGroups.delete(groupName);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/view/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n   *\n   * This method is a shortcut to other constructors such as:\n   *\n   * * {@link #createPositionBefore},\n   * * {@link #createPositionAfter},\n   *\n   * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  createPositionAt(itemOrPosition, offset) {\n    return Position._createAt(itemOrPosition, offset);\n  }\n  /**\n   * Creates a new position after given view item.\n   *\n   * @param {module:engine/view/item~Item} item View item after which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  createPositionAfter(item) {\n    return Position._createAfter(item);\n  }\n  /**\n   * Creates a new position before given view item.\n   *\n   * @param {module:engine/view/item~Item} item View item before which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  createPositionBefore(item) {\n    return Position._createBefore(item);\n  }\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n   *\n   * @param {module:engine/view/position~Position} start Start position.\n   * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  createRange(start, end) {\n    return new Range(start, end);\n  }\n  /**\n   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n   *\n   * @param {module:engine/view/item~Item} item\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  createRangeOn(item) {\n    return Range._createOn(item);\n  }\n  /**\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  createRangeIn(element) {\n    return Range._createIn(element);\n  }\n  /**\n   Creates new {@link module:engine/view/selection~Selection} instance.\n   *\n   * \t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the document selection.\n   *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n   *\n   * \t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'p' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} [selectable=null]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   * @returns {module:engine/view/selection~Selection}\n   */\n\n\n  createSelection(selectable, placeOrOffset, options) {\n    return new Selection(selectable, placeOrOffset, options);\n  }\n  /**\n   * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion\n   * and merging them afterwards if requested by the breakAttributes param.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position Insertion position.\n   * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n   * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n   * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n   * Iterable.<module:engine/view/text~Text|\n   * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n   * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n   * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n   * @param {Boolean} breakAttributes Whether attributes should be broken.\n   * @returns {module:engine/view/range~Range} Range around inserted nodes.\n   */\n\n\n  _insertNodes(position, nodes, breakAttributes) {\n    let parentElement; // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n    // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\n    if (breakAttributes) {\n      parentElement = getParentContainer(position);\n    } else {\n      parentElement = position.parent.is('$text') ? position.parent.parent : position.parent;\n    }\n\n    if (!parentElement) {\n      /**\n       * Position's parent container cannot be found.\n       *\n       * @error view-writer-invalid-position-container\n       */\n      throw new CKEditorError('view-writer-invalid-position-container', this.document);\n    }\n\n    let insertionPosition;\n\n    if (breakAttributes) {\n      insertionPosition = this._breakAttributes(position, true);\n    } else {\n      insertionPosition = position.parent.is('$text') ? breakTextNode(position) : position;\n    }\n\n    const length = parentElement._insertChild(insertionPosition.offset, nodes);\n\n    for (const node of nodes) {\n      this._addToClonedElementsGroup(node);\n    }\n\n    const endPosition = insertionPosition.getShiftedBy(length);\n    const start = this.mergeAttributes(insertionPosition); // If start position was merged - move end position.\n\n    if (!start.isEqual(insertionPosition)) {\n      endPosition.offset--;\n    }\n\n    const end = this.mergeAttributes(endPosition);\n    return new Range(start, end);\n  }\n  /**\n   * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n   * `startOffset` and `endOffset` will be wrapped.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} parent\n   * @param {Number} startOffset\n   * @param {Number} endOffset\n   * @param {module:engine/view/element~Element} wrapElement\n   */\n\n\n  _wrapChildren(parent, startOffset, endOffset, wrapElement) {\n    let i = startOffset;\n    const wrapPositions = [];\n\n    while (i < endOffset) {\n      const child = parent.getChild(i);\n      const isText = child.is('$text');\n      const isAttribute = child.is('attributeElement');\n      const isAllowedInsideAttributeElement = child.isAllowedInsideAttributeElement; //\n      // (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n      //\n      // Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n      // If possible, join elements.\n      //\n      // <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n      //\n\n      if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {\n        wrapPositions.push(new Position(parent, i));\n      } //\n      // Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n      // `wrapElement` (due to priority).\n      //\n      // <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n      // <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n      else if (isText || isAllowedInsideAttributeElement || isAttribute && shouldABeOutsideB(wrapElement, child)) {\n        // Clone attribute.\n        const newAttribute = wrapElement._clone(); // Wrap current node with new attribute.\n\n\n        child._remove();\n\n        newAttribute._appendChild(child);\n\n        parent._insertChild(i, newAttribute);\n\n        this._addToClonedElementsGroup(newAttribute);\n\n        wrapPositions.push(new Position(parent, i));\n      } //\n      // If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n      //\n      // <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n      //\n      else if (isAttribute) {\n        this._wrapChildren(child, 0, child.childCount, wrapElement);\n      }\n\n      i++;\n    } // Merge at each wrap.\n\n\n    let offsetChange = 0;\n\n    for (const position of wrapPositions) {\n      position.offset -= offsetChange; // Do not merge with elements outside selected children.\n\n      if (position.offset == startOffset) {\n        continue;\n      }\n\n      const newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.\n\n      if (!newPosition.isEqual(position)) {\n        offsetChange++;\n        endOffset--;\n      }\n    }\n\n    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n  }\n  /**\n   * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n   * `startOffset` and `endOffset` will be unwrapped.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} parent\n   * @param {Number} startOffset\n   * @param {Number} endOffset\n   * @param {module:engine/view/element~Element} unwrapElement\n   */\n\n\n  _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {\n    let i = startOffset;\n    const unwrapPositions = []; // Iterate over each element between provided offsets inside parent.\n    // We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n    // so it could get messy. It is safer to it manually in this case.\n\n    while (i < endOffset) {\n      const child = parent.getChild(i); // Skip all text nodes. There should be no container element's here either.\n\n      if (!child.is('attributeElement')) {\n        i++;\n        continue;\n      } //\n      // (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n      //\n      // If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n      //\n      // <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n      //\n\n\n      if (child.isSimilar(unwrapElement)) {\n        const unwrapped = child.getChildren();\n        const count = child.childCount; // Replace wrapper element with its children\n\n        child._remove();\n\n        parent._insertChild(i, unwrapped);\n\n        this._removeFromClonedElementsGroup(child); // Save start and end position of moved items.\n\n\n        unwrapPositions.push(new Position(parent, i), new Position(parent, i + count)); // Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\n        i += count;\n        endOffset += count - 1;\n        continue;\n      } //\n      // If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n      // Partial unwrapping will happen only if the elements have the same name.\n      //\n      // <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n      // <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n      //\n\n\n      if (this._unwrapAttributeElement(unwrapElement, child)) {\n        unwrapPositions.push(new Position(parent, i), new Position(parent, i + 1));\n        i++;\n        continue;\n      } //\n      // If other nested attribute is found, look through it's children for elements to unwrap.\n      //\n      // <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n      //\n\n\n      this._unwrapChildren(child, 0, child.childCount, unwrapElement);\n\n      i++;\n    } // Merge at each unwrap.\n\n\n    let offsetChange = 0;\n\n    for (const position of unwrapPositions) {\n      position.offset -= offsetChange; // Do not merge with elements outside selected children.\n\n      if (position.offset == startOffset || position.offset == endOffset) {\n        continue;\n      }\n\n      const newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.\n\n      if (!newPosition.isEqual(position)) {\n        offsetChange++;\n        endOffset--;\n      }\n    }\n\n    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n  }\n  /**\n   * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n   * This method will also merge newly added attribute element with its siblings whenever possible.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n   */\n\n\n  _wrapRange(range, attribute) {\n    // Break attributes at range start and end.\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n\n    const parentContainer = breakStart.parent; // Wrap all children with attribute.\n\n    const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.\n\n\n    const start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.\n\n    if (!start.isEqual(newRange.start)) {\n      newRange.end.offset--;\n    }\n\n    const end = this.mergeAttributes(newRange.end);\n    return new Range(start, end);\n  }\n  /**\n   * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n   * This method will also merge newly added attribute element with its siblings whenever possible.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   * @returns {module:engine/view/position~Position} New position after wrapping.\n   */\n\n\n  _wrapPosition(position, attribute) {\n    // Return same position when trying to wrap with attribute similar to position parent.\n    if (attribute.isSimilar(position.parent)) {\n      return movePositionToTextNode(position.clone());\n    } // When position is inside text node - break it and place new position between two text nodes.\n\n\n    if (position.parent.is('$text')) {\n      position = breakTextNode(position);\n    } // Create fake element that will represent position, and will not be merged with other attributes.\n\n\n    const fakePosition = this.createAttributeElement();\n    fakePosition._priority = Number.POSITIVE_INFINITY;\n\n    fakePosition.isSimilar = () => false; // Insert fake element in position location.\n\n\n    position.parent._insertChild(position.offset, fakePosition); // Range around inserted fake attribute element.\n\n\n    const wrapRange = new Range(position, position.getShiftedBy(1)); // Wrap fake element with attribute (it will also merge if possible).\n\n    this.wrap(wrapRange, attribute); // Remove fake element and place new position there.\n\n    const newPosition = new Position(fakePosition.parent, fakePosition.index);\n\n    fakePosition._remove(); // If position is placed between text nodes - merge them and return position inside.\n\n\n    const nodeBefore = newPosition.nodeBefore;\n    const nodeAfter = newPosition.nodeAfter;\n\n    if (nodeBefore instanceof Text && nodeAfter instanceof Text) {\n      return mergeTextNodes(nodeBefore, nodeAfter);\n    } // If position is next to text node - move position inside.\n\n\n    return movePositionToTextNode(newPosition);\n  }\n  /**\n   * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n   * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n   * \telement to element being wrapped.\n   *\n   * \t@private\n   * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n   * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n   * \t@returns {Boolean} Returns `true` if elements are merged.\n   */\n\n\n  _wrapAttributeElement(wrapper, toWrap) {\n    if (!canBeJoined(wrapper, toWrap)) {\n      return false;\n    } // Can't merge if name or priority differs.\n\n\n    if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {\n      return false;\n    } // Check if attributes can be merged.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      } // If some attributes are different we cannot wrap.\n\n\n      if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n        return false;\n      }\n    } // Check if styles can be merged.\n\n\n    for (const key of wrapper.getStyleNames()) {\n      if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {\n        return false;\n      }\n    } // Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      } // Move only these attributes that are not present - other are similar.\n\n\n      if (!toWrap.hasAttribute(key)) {\n        this.setAttribute(key, wrapper.getAttribute(key), toWrap);\n      }\n    }\n\n    for (const key of wrapper.getStyleNames()) {\n      if (!toWrap.hasStyle(key)) {\n        this.setStyle(key, wrapper.getStyle(key), toWrap);\n      }\n    }\n\n    for (const key of wrapper.getClassNames()) {\n      if (!toWrap.hasClass(key)) {\n        this.addClass(key, toWrap);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n   * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n   * inside element being unwrapped.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n   * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n   * @returns {Boolean} Returns `true` if elements are unwrapped.\n   **/\n\n\n  _unwrapAttributeElement(wrapper, toUnwrap) {\n    if (!canBeJoined(wrapper, toUnwrap)) {\n      return false;\n    } // Can't unwrap if name or priority differs.\n\n\n    if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {\n      return false;\n    } // Check if AttributeElement has all wrapper attributes.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      } // If some attributes are missing or different we cannot unwrap.\n\n\n      if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n        return false;\n      }\n    } // Check if AttributeElement has all wrapper classes.\n\n\n    if (!toUnwrap.hasClass(...wrapper.getClassNames())) {\n      return false;\n    } // Check if AttributeElement has all wrapper styles.\n\n\n    for (const key of wrapper.getStyleNames()) {\n      // If some styles are missing or different we cannot unwrap.\n      if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {\n        return false;\n      }\n    } // Remove all wrapper's attributes from unwrapped element.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      }\n\n      this.removeAttribute(key, toUnwrap);\n    } // Remove all wrapper's classes from unwrapped element.\n\n\n    this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap); // Remove all wrapper's styles from unwrapped element.\n\n    this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);\n    return true;\n  }\n  /**\n   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n   * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n   * @returns {module:engine/view/range~Range} New range with located at break positions.\n   */\n\n\n  _breakAttributesRange(range) {\n    let forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const rangeStart = range.start;\n    const rangeEnd = range.end;\n    validateRangeContainer(range, this.document); // Break at the collapsed position. Return new collapsed range.\n\n    if (range.isCollapsed) {\n      const position = this._breakAttributes(range.start, forceSplitText);\n\n      return new Range(position, position);\n    }\n\n    const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);\n\n    const count = breakEnd.parent.childCount;\n\n    const breakStart = this._breakAttributes(rangeStart, forceSplitText); // Calculate new break end offset.\n\n\n    breakEnd.offset += breakEnd.parent.childCount - count;\n    return new Range(breakStart, breakEnd);\n  }\n  /**\n   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n   * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n   * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position Position where to break attributes.\n   * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n   * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n   */\n\n\n  _breakAttributes(position) {\n    let forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const positionOffset = position.offset;\n    const positionParent = position.parent; // If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\n    if (position.parent.is('emptyElement')) {\n      /**\n       * Cannot break an `EmptyElement` instance.\n       *\n       * This error is thrown if\n       * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n       * was executed in an incorrect position.\n       *\n       * @error view-writer-cannot-break-empty-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-empty-element', this.document);\n    } // If position is placed inside UIElement - throw an exception as we cannot break inside.\n\n\n    if (position.parent.is('uiElement')) {\n      /**\n       * Cannot break a `UIElement` instance.\n       *\n       * This error is thrown if\n       * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n       * was executed in an incorrect position.\n       *\n       * @error view-writer-cannot-break-ui-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-ui-element', this.document);\n    } // If position is placed inside RawElement - throw an exception as we cannot break inside.\n\n\n    if (position.parent.is('rawElement')) {\n      /**\n       * Cannot break a `RawElement` instance.\n       *\n       * This error is thrown if\n       * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n       * was executed in an incorrect position.\n       *\n       * @error view-writer-cannot-break-raw-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-raw-element', this.document);\n    } // There are no attributes to break and text nodes breaking is not forced.\n\n\n    if (!forceSplitText && positionParent.is('$text') && isContainerOrFragment(positionParent.parent)) {\n      return position.clone();\n    } // Position's parent is container, so no attributes to break.\n\n\n    if (isContainerOrFragment(positionParent)) {\n      return position.clone();\n    } // Break text and start again in new position.\n\n\n    if (positionParent.is('$text')) {\n      return this._breakAttributes(breakTextNode(position), forceSplitText);\n    }\n\n    const length = positionParent.childCount; // <p>foo<b><u>bar{}</u></b></p>\n    // <p>foo<b><u>bar</u>[]</b></p>\n    // <p>foo<b><u>bar</u></b>[]</p>\n\n    if (positionOffset == length) {\n      const newPosition = new Position(positionParent.parent, positionParent.index + 1);\n      return this._breakAttributes(newPosition, forceSplitText);\n    } else {\n      // <p>foo<b><u>{}bar</u></b></p>\n      // <p>foo<b>[]<u>bar</u></b></p>\n      // <p>foo{}<b><u>bar</u></b></p>\n      if (positionOffset === 0) {\n        const newPosition = new Position(positionParent.parent, positionParent.index);\n        return this._breakAttributes(newPosition, forceSplitText);\n      } // <p>foo<b><u>b{}ar</u></b></p>\n      // <p>foo<b><u>b[]ar</u></b></p>\n      // <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n      // <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n      else {\n        const offsetAfter = positionParent.index + 1; // Break element.\n\n        const clonedNode = positionParent._clone(); // Insert cloned node to position's parent node.\n\n\n        positionParent.parent._insertChild(offsetAfter, clonedNode);\n\n        this._addToClonedElementsGroup(clonedNode); // Get nodes to move.\n\n\n        const count = positionParent.childCount - positionOffset;\n\n        const nodesToMove = positionParent._removeChildren(positionOffset, count); // Move nodes to cloned node.\n\n\n        clonedNode._appendChild(nodesToMove); // Create new position to work on.\n\n\n        const newPosition = new Position(positionParent.parent, offsetAfter);\n        return this._breakAttributes(newPosition, forceSplitText);\n      }\n    }\n  }\n  /**\n   * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n   * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n   * from the group now keep a reference to the given attribute element.\n   *\n   * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n   *\n   * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n   */\n\n\n  _addToClonedElementsGroup(element) {\n    // Add only if the element is in document tree.\n    if (!element.root.is('rootElement')) {\n      return;\n    } // Traverse the element's children recursively to find other attribute elements that also might got inserted.\n    // The loop is at the beginning so we can make fast returns later in the code.\n\n\n    if (element.is('element')) {\n      for (const child of element.getChildren()) {\n        this._addToClonedElementsGroup(child);\n      }\n    }\n\n    const id = element.id;\n\n    if (!id) {\n      return;\n    }\n\n    let group = this._cloneGroups.get(id);\n\n    if (!group) {\n      group = new Set();\n\n      this._cloneGroups.set(id, group);\n    }\n\n    group.add(element);\n    element._clonesGroup = group;\n  }\n  /**\n   * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n   * from its clones group.\n   *\n   * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n   * This allows to reference the whole group even if the element was already removed from the tree.\n   *\n   * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n   */\n\n\n  _removeFromClonedElementsGroup(element) {\n    // Traverse the element's children recursively to find other attribute elements that also got removed.\n    // The loop is at the beginning so we can make fast returns later in the code.\n    if (element.is('element')) {\n      for (const child of element.getChildren()) {\n        this._removeFromClonedElementsGroup(child);\n      }\n    }\n\n    const id = element.id;\n\n    if (!id) {\n      return;\n    }\n\n    const group = this._cloneGroups.get(id);\n\n    if (!group) {\n      return;\n    }\n\n    group.delete(element); // Not removing group from element on purpose!\n    // If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n  }\n\n} // Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\n\nfunction _hasNonUiChildren(parent) {\n  return Array.from(parent.getChildren()).some(child => !child.is('uiElement'));\n}\n/**\n * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`}\n * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\n\n\nfunction getParentContainer(position) {\n  let parent = position.parent;\n\n  while (!isContainerOrFragment(parent)) {\n    if (!parent) {\n      return undefined;\n    }\n\n    parent = parent.parent;\n  }\n\n  return parent;\n} // Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped outside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\n\n\nfunction shouldABeOutsideB(a, b) {\n  if (a.priority < b.priority) {\n    return true;\n  } else if (a.priority > b.priority) {\n    return false;\n  } // When priorities are equal and names are different - use identities.\n\n\n  return a.getIdentity() < b.getIdentity();\n} // Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\n\n\nfunction movePositionToTextNode(position) {\n  const nodeBefore = position.nodeBefore;\n\n  if (nodeBefore && nodeBefore.is('$text')) {\n    return new Position(nodeBefore, nodeBefore.data.length);\n  }\n\n  const nodeAfter = position.nodeAfter;\n\n  if (nodeAfter && nodeAfter.is('$text')) {\n    return new Position(nodeAfter, 0);\n  }\n\n  return position;\n} // Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\n\n\nfunction breakTextNode(position) {\n  if (position.offset == position.parent.data.length) {\n    return new Position(position.parent.parent, position.parent.index + 1);\n  }\n\n  if (position.offset === 0) {\n    return new Position(position.parent.parent, position.parent.index);\n  } // Get part of the text that need to be moved.\n\n\n  const textToMove = position.parent.data.slice(position.offset); // Leave rest of the text in position's parent.\n\n  position.parent._data = position.parent.data.slice(0, position.offset); // Insert new text node after position's parent text node.\n\n  position.parent.parent._insertChild(position.parent.index + 1, new Text(position.root.document, textToMove)); // Return new position between two newly created text nodes.\n\n\n  return new Position(position.parent.parent, position.parent.index + 1);\n} // Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\n\n\nfunction mergeTextNodes(t1, t2) {\n  // Merge text data into first text node and remove second one.\n  const nodeBeforeLength = t1.data.length;\n  t1._data += t2.data;\n\n  t2._remove();\n\n  return new Position(t1, nodeBeforeLength);\n} // Checks if provided nodes are valid to insert.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not supported ones (see error description for valid ones.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/element~Element> nodes\n// @param {Object} errorContext\n\n\nfunction validateNodesToInsert(nodes, errorContext) {\n  for (const node of nodes) {\n    if (!validNodesToInsert.some(validNode => node instanceof validNode)) {\n      // eslint-disable-line no-use-before-define\n\n      /**\n       * One of the nodes to be inserted is of an invalid type.\n       *\n       * Nodes to be inserted with {@link module:engine/view/downcastwriter~DowncastWriter#insert `DowncastWriter#insert()`} should be\n       * of the following types:\n       *\n       * * {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n       * * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n       * * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n       * * {@link module:engine/view/uielement~UIElement UIElement},\n       * * {@link module:engine/view/rawelement~RawElement RawElement},\n       * * {@link module:engine/view/text~Text Text}.\n       *\n       * @error view-writer-insert-invalid-node-type\n       */\n      throw new CKEditorError('view-writer-insert-invalid-node-type', errorContext);\n    }\n\n    if (!node.is('$text')) {\n      validateNodesToInsert(node.getChildren(), errorContext);\n    }\n  }\n}\n\nconst validNodesToInsert = [Text, AttributeElement, ContainerElement, EmptyElement, RawElement, UIElement]; // Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\n\nfunction isContainerOrFragment(node) {\n  return node && (node.is('containerElement') || node.is('documentFragment'));\n} // Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\n\n\nfunction validateRangeContainer(range, errorContext) {\n  const startContainer = getParentContainer(range.start);\n  const endContainer = getParentContainer(range.end);\n\n  if (!startContainer || !endContainer || startContainer !== endContainer) {\n    /**\n     * The container of the given range is invalid.\n     *\n     * This may happen if {@link module:engine/view/range~Range#start range start} and\n     * {@link module:engine/view/range~Range#end range end} positions are not placed inside the same container element or\n     * a parent container for these positions cannot be found.\n     *\n     * Methods like {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#remove()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#clean()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#unwrap()`} need to be called\n     * on a range that has its start and end positions located in the same container element. Both positions can be\n     * nested within other elements (e.g. an attribute element) but the closest container ancestor must be the same.\n     *\n     * @error view-writer-invalid-range-container\n     */\n    throw new CKEditorError('view-writer-invalid-range-container', errorContext);\n  }\n} // Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\n\n\nfunction canBeJoined(a, b) {\n  return a.id === null && b.id === null;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js"],"names":["Position","Range","Selection","ContainerElement","AttributeElement","EmptyElement","UIElement","RawElement","CKEditorError","DocumentFragment","isIterable","Text","EditableElement","isPlainObject","DowncastWriter","constructor","document","_cloneGroups","Map","setSelection","selectable","placeOrOffset","options","selection","_setTo","setSelectionFocus","itemOrPosition","offset","_setFocus","createDocumentFragment","children","createText","data","createAttributeElement","name","attributes","attributeElement","priority","_priority","id","_id","createContainerElement","containerElement","isAllowedInsideAttributeElement","undefined","_isAllowedInsideAttributeElement","createEditableElement","editableElement","_document","createEmptyElement","emptyElement","createUIElement","renderFunction","uiElement","render","createRawElement","rawElement","setAttribute","key","value","element","_setAttribute","removeAttribute","_removeAttribute","addClass","className","_addClass","removeClass","_removeClass","setStyle","property","_setStyle","removeStyle","_removeStyle","setCustomProperty","_setCustomProperty","removeCustomProperty","_removeCustomProperty","breakAttributes","positionOrRange","_breakAttributes","_breakAttributesRange","breakContainer","position","parent","is","isAtStart","_createBefore","isAtEnd","newElement","_clone","insert","_createAfter","sourceRange","_createAt","targetPosition","move","mergeAttributes","positionOffset","positionParent","childCount","index","_remove","_removeFromClonedElementsGroup","nodeBefore","getChild","nodeAfter","mergeTextNodes","isSimilar","count","_appendChild","getChildren","mergeContainers","prev","next","lastChild","newPosition","_createIn","remove","_createOn","nodes","validateNodesToInsert","nodeGroups","reduce","groups","node","lastGroup","length","push","start","end","range","_insertNodes","rangeOrItem","validateRangeContainer","isCollapsed","breakStart","breakEnd","parentContainer","removed","_removeChildren","mergePosition","clone","clear","walker","getWalker","direction","ignoreElementEnd","current","item","rangeToRemove","nextPosition","isAfter","parentElement","getAncestors","find","ancestor","isBefore","countBefore","wrap","attribute","_wrapRange","_hasNonUiChildren","getLastMatchingPosition","_wrapPosition","viewSelection","getFirstPosition","isEqual","unwrap","newRange","_unwrapChildren","rename","newName","viewElement","getAttributes","clearClonedElementsGroup","groupName","delete","createPositionAt","createPositionAfter","createPositionBefore","createRange","createRangeOn","createRangeIn","createSelection","getParentContainer","insertionPosition","breakTextNode","_insertChild","_addToClonedElementsGroup","endPosition","getShiftedBy","_wrapChildren","startOffset","endOffset","wrapElement","i","wrapPositions","child","isText","isAttribute","_wrapAttributeElement","shouldABeOutsideB","newAttribute","offsetChange","_createFromParentsAndOffsets","unwrapElement","unwrapPositions","unwrapped","_unwrapAttributeElement","movePositionToTextNode","fakePosition","Number","POSITIVE_INFINITY","wrapRange","wrapper","toWrap","canBeJoined","getAttributeKeys","hasAttribute","getAttribute","getStyleNames","hasStyle","getStyle","getClassNames","hasClass","toUnwrap","Array","from","forceSplitText","rangeStart","rangeEnd","isContainerOrFragment","offsetAfter","clonedNode","nodesToMove","root","group","get","Set","set","add","_clonesGroup","some","a","b","getIdentity","textToMove","slice","_data","t1","t2","nodeBeforeLength","errorContext","validNodesToInsert","validNode","startContainer","endContainer"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,SAASC,aAAT,QAA8B,WAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,cAAN,CAAqB;AACnC;AACD;AACA;AACCC,EAAAA,WAAW,CAAEC,QAAF,EAAa;AACvB;AACF;AACA;AACA;AACA;AACA;AACE,SAAKA,QAAL,GAAgBA,QAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,YAAL,GAAoB,IAAIC,GAAJ,EAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAAEC,UAAF,EAAcC,aAAd,EAA6BC,OAA7B,EAAuC;AAClD,SAAKN,QAAL,CAAcO,SAAd,CAAwBC,MAAxB,CAAgCJ,UAAhC,EAA4CC,aAA5C,EAA2DC,OAA3D;AACA;AAED;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YAAR,CAAsBH,SAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCI,EAAAA,QAAQ,CAAEC,QAAF,EAAYX,KAAZ,EAAmBC,OAAnB,EAA6B;AACpC,QAAK/C,aAAa,CAAEyD,QAAF,CAAb,IAA6BV,OAAO,KAAKhB,SAA9C,EAA0D;AACzDgB,MAAAA,OAAO,GAAGD,KAAV;AACA;;AAEDC,IAAAA,OAAO,CAACW,SAAR,CAAmBD,QAAnB,EAA6BX,KAA7B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCa,EAAAA,WAAW,CAAEF,QAAF,EAAYV,OAAZ,EAAsB;AAChCA,IAAAA,OAAO,CAACa,YAAR,CAAsBH,QAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCI,EAAAA,iBAAiB,CAAEhB,GAAF,EAAOC,KAAP,EAAcC,OAAd,EAAwB;AACxCA,IAAAA,OAAO,CAACe,kBAAR,CAA4BjB,GAA5B,EAAiCC,KAAjC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCiB,EAAAA,oBAAoB,CAAElB,GAAF,EAAOE,OAAP,EAAiB;AACpC,WAAOA,OAAO,CAACiB,qBAAR,CAA+BnB,GAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCoB,EAAAA,eAAe,CAAEC,eAAF,EAAoB;AAClC,QAAKA,eAAe,YAAY/E,QAAhC,EAA2C;AAC1C,aAAO,KAAKgF,gBAAL,CAAuBD,eAAvB,CAAP;AACA,KAFD,MAEO;AACN,aAAO,KAAKE,qBAAL,CAA4BF,eAA5B,CAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA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F,aAAT,CAAwB8D,IAAxB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCgC,EAAAA,WAAW,CAAEpD,KAAF,EAASC,GAAT,EAAe;AACzB,WAAO,IAAIjI,KAAJ,CAAWgI,KAAX,EAAkBC,GAAlB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCoD,EAAAA,aAAa,CAAEjC,IAAF,EAAS;AACrB,WAAOpJ,KAAK,CAACsH,SAAN,CAAiB8B,IAAjB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCkC,EAAAA,aAAa,CAAE3H,OAAF,EAAY;AACxB,WAAO3D,KAAK,CAACoH,SAAN,CAAiBzD,OAAjB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC4H,EAAAA,eAAe,CAAEpK,UAAF,EAAcC,aAAd,EAA6BC,OAA7B,EAAuC;AACrD,WAAO,IAAIpB,SAAJ,CAAekB,UAAf,EAA2BC,aAA3B,EAA0CC,OAA1C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC8G,EAAAA,YAAY,CAAEjD,QAAF,EAAYqC,KAAZ,EAAmB1C,eAAnB,EAAqC;AAChD,QAAI2E,aAAJ,CADgD,CAGhD;AACA;;AACA,QAAK3E,eAAL,EAAuB;AACtB2E,MAAAA,aAAa,GAAGgC,kBAAkB,CAAEtG,QAAF,CAAlC;AACA,KAFD,MAEO;AACNsE,MAAAA,aAAa,GAAGtE,QAAQ,CAACC,MAAT,CAAgBC,EAAhB,CAAoB,OAApB,IAA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\n\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport RawElement from './rawelement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\nexport default class DowncastWriter {\n\t/**\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t */\n\tconstructor( document ) {\n\t\t/**\n\t\t * The view document instance in which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t\t * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<String,Set>}\n\t\t */\n\t\tthis._cloneGroups = new Map();\n\t}\n\n\t/**\n\t * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n\t * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n\t *\n\t * Usage:\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets backward selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t * \t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t * \t\t// Removes all ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t *\t\t// Sets selection as fake.\n\t *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * \t\t// represented in other way, for example by applying proper CSS class.\n\t *\t\twriter.setSelection( range, { fake: true } );\n\t *\n\t * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * \t\t// (and be  properly handled by screen readers).\n\t *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n\t * parameters.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.\n\t *\n\t * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n\t * A list of nodes to be inserted into the created document fragment.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.\n\t */\n\tcreateDocumentFragment( children ) {\n\t\treturn new DocumentFragment( this.document, children );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\n\t * @param {String} data The text's data.\n\t * @returns {module:engine/view/text~Text} The created text node.\n\t */\n\tcreateText( data ) {\n\t\treturn new Text( this.document, data );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.\n\t *\n\t *\t\twriter.createAttributeElement( 'strong' );\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n\t *\n\t *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n\t *\n\t *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n\t *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n\t *\n\t * **Note:** By default an `AttributeElement` is split by a\n\t * {@link module:engine/view/containerelement~ContainerElement `ContainerElement`} but this behavior can be modified\n\t * with `isAllowedInsideAttributeElement` option set while {@link #createContainerElement creating the element}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Element's attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n\t * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n\t */\n\tcreateAttributeElement( name, attributes, options = {} ) {\n\t\tconst attributeElement = new AttributeElement( this.document, name, attributes );\n\n\t\tif ( typeof options.priority === 'number' ) {\n\t\t\tattributeElement._priority = options.priority;\n\t\t}\n\n\t\tif ( options.id ) {\n\t\t\tattributeElement._id = options.id;\n\t\t}\n\n\t\treturn attributeElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/containerelement~ContainerElement}.\n\t *\n\t *\t\twriter.createContainerElement( 'p' );\n\t *\n\t *\t\t// Create element with custom attributes.\n\t *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n\t *\n\t *\t\t// Create element with custom styles.\n\t *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n\t *\n\t *\t\t// Create element with custom classes.\n\t *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=false] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n\t */\n\tcreateContainerElement( name, attributes, options = {} ) {\n\t\tconst containerElement = new ContainerElement( this.document, name, attributes );\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\tcontainerElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn containerElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t *\t\twriter.createEditableElement( 'div' );\n\t *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n\t *\n\t * Note: The editable element is to be used in the editing pipeline. Usually, together with\n\t * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/editableelement~EditableElement} Created element.\n\t */\n\tcreateEditableElement( name, attributes ) {\n\t\tconst editableElement = new EditableElement( this.document, name, attributes );\n\t\teditableElement._document = this.document;\n\n\t\treturn editableElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.\n\t *\n\t *\t\twriter.createEmptyElement( 'img' );\n\t *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n\t */\n\tcreateEmptyElement( name, attributes, options = {} ) {\n\t\tconst emptyElement = new EmptyElement( this.document, name, attributes );\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\temptyElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn emptyElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/uielement~UIElement}.\n\t *\n\t *\t\twriter.createUIElement( 'span' );\n\t *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n\t *\n\t * A custom render function can be provided as the third parameter:\n\t *\n\t *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t} );\n\t *\n\t * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,\n\t * they are ignored by the editor selection system.\n\t *\n\t * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.\n\t *\n\t * @param {String} name The name of the element.\n\t * @param {Object} [attributes] Element attributes.\n\t * @param {Function} [renderFunction] A custom render function.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/uielement~UIElement} The created element.\n\t */\n\tcreateUIElement( name, attributes, renderFunction, options = {} ) {\n\t\tconst uiElement = new UIElement( this.document, name, attributes );\n\n\t\tif ( renderFunction ) {\n\t\t\tuiElement.render = renderFunction;\n\t\t}\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\tuiElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn uiElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/rawelement~RawElement}.\n\t *\n\t *\t\twriter.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {\n\t *\t\t\tdomElement.innerHTML = '<b>This is the raw content of the raw element.</b>';\n\t *\t\t} );\n\t *\n\t * Raw elements work as data containers (\"wrappers\", \"sandboxes\") but their children are not managed or\n\t * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures\n\t * in the editor content without, for instance, worrying about compatibility with other editor features.\n\t * Raw elements are a perfect tool for integration with external frameworks and data sources.\n\t *\n\t * Unlike {@link #createUIElement UI elements}, raw elements act like \"real\" editor content (similar to\n\t * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),\n\t * and they are considered by the editor selection.\n\t *\n\t * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}\n\t * instead.\n\t *\n\t * @param {String} name The name of the element.\n\t * @param {Object} [attributes] Element attributes.\n\t * @param {Function} [renderFunction] A custom render function.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/rawelement~RawElement} The created element.\n\t */\n\tcreateRawElement( name, attributes, renderFunction, options = {} ) {\n\t\tconst rawElement = new RawElement( this.document, name, attributes );\n\n\t\trawElement.render = renderFunction || ( () => {} );\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\trawElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn rawElement;\n\t}\n\n\t/**\n\t * Adds or overwrites the element's attribute with a specified key and value.\n\t *\n\t *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n\t *\n\t * @param {String} key The attribute key.\n\t * @param {String} value The attribute value.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetAttribute( key, value, element ) {\n\t\telement._setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t *\t\twriter.removeAttribute( 'href', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveAttribute( key, element ) {\n\t\telement._removeAttribute( key );\n\t}\n\n\t/**\n\t * Adds specified class to the element.\n\t *\n\t *\t\twriter.addClass( 'foo', linkElement );\n\t *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\taddClass( className, element ) {\n\t\telement._addClass( className );\n\t}\n\n\t/**\n\t * Removes specified class from the element.\n\t *\n\t *\t\twriter.removeClass( 'foo', linkElement );\n\t *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveClass( className, element ) {\n\t\telement._removeClass( className );\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\twriter.setStyle( 'color', 'red', element );\n\t *\t\twriter.setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t}, element );\n\t *\n\t * **Note**: The passed style can be normalized if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n\t *\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @param {module:engine/view/element~Element} element Element to set styles on.\n\t */\n\tsetStyle( property, value, element ) {\n\t\tif ( isPlainObject( property ) && element === undefined ) {\n\t\t\telement = value;\n\t\t}\n\n\t\telement._setStyle( property, value );\n\t}\n\n\t/**\n\t * Removes specified style from the element.\n\t *\n\t *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n\t *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * **Note**: This method can work with normalized style names if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n\t *\n\t * @param {Array.<String>|String} property\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveStyle( property, element ) {\n\t\telement._removeStyle( property );\n\t}\n\n\t/**\n\t * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetCustomProperty( key, value, element ) {\n\t\telement._setCustomProperty( key, value );\n\t}\n\n\t/**\n\t * Removes a custom property stored under the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\tremoveCustomProperty( key, element ) {\n\t\treturn element._removeCustomProperty( key );\n\t}\n\n\t/**\n\t * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements\n\t * up to their first ancestor that is a container element.\n\t *\n\t * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:\n\t *\n\t *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n\t *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n\t *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n\t *\n\t * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n\t *\n\t * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.\n\t *\n\t * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * when the {@link module:engine/view/range~Range#start start}\n\t * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n\t *\n\t * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n\t * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange The position where\n\t * to break attribute elements.\n\t * @returns {module:engine/view/position~Position|module:engine/view/range~Range} The new position or range, after breaking the\n\t * attribute elements.\n\t */\n\tbreakAttributes( positionOrRange ) {\n\t\tif ( positionOrRange instanceof Position ) {\n\t\t\treturn this._breakAttributes( positionOrRange );\n\t\t} else {\n\t\t\treturn this._breakAttributesRange( positionOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.\n\t * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element\n\t * if the position is at the beginning or at the end of its parent element.\n\t *\n\t *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n\t *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n\t *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n\t *\t\t<p>foobar^</p> -> <p>foobar</p>^\n\t *\n\t * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n\t * @param {module:engine/view/position~Position} position The position where to break the element.\n\t * @returns {module:engine/view/position~Position} The position between broken elements. If an element has not been broken,\n\t * the returned position is placed either before or after it.\n\t */\n\tbreakContainer( position ) {\n\t\tconst element = position.parent;\n\n\t\tif ( !( element.is( 'containerElement' ) ) ) {\n\t\t\t/**\n\t\t\t * Trying to break an element which is not a container element.\n\t\t\t *\n\t\t\t * @error view-writer-break-non-container-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-non-container-element', this.document );\n\t\t}\n\n\t\tif ( !element.parent ) {\n\t\t\t/**\n\t\t\t * Trying to break root element.\n\t\t\t *\n\t\t\t * @error view-writer-break-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-root', this.document );\n\t\t}\n\n\t\tif ( position.isAtStart ) {\n\t\t\treturn Position._createBefore( element );\n\t\t} else if ( !position.isAtEnd ) {\n\t\t\tconst newElement = element._clone( false );\n\n\t\t\tthis.insert( Position._createAfter( element ), newElement );\n\n\t\t\tconst sourceRange = new Range( position, Position._createAt( element, 'end' ) );\n\t\t\tconst targetPosition = new Position( newElement, 0 );\n\n\t\t\tthis.move( sourceRange, targetPosition );\n\t\t}\n\n\t\treturn Position._createAfter( element );\n\t}\n\n\t/**\n\t * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n\t * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n\t *\n\t * In following examples `<p>` is a container and `<b>` is an attribute element:\n\t *\n\t *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n\t *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n\t *\n\t * It will also take care about empty attributes when merging:\n\t *\n\t *\t\t<p><b>[]</b></p> -> <p>[]</p>\n\t *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeAttributes( position ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// When inside text node - nothing to merge.\n\t\tif ( positionParent.is( '$text' ) ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When inside empty attribute - remove it.\n\t\tif ( positionParent.is( 'attributeElement' ) && positionParent.childCount === 0 ) {\n\t\t\tconst parent = positionParent.parent;\n\t\t\tconst offset = positionParent.index;\n\n\t\t\tpositionParent._remove();\n\t\t\tthis._removeFromClonedElementsGroup( positionParent );\n\n\t\t\treturn this.mergeAttributes( new Position( parent, offset ) );\n\t\t}\n\n\t\tconst nodeBefore = positionParent.getChild( positionOffset - 1 );\n\t\tconst nodeAfter = positionParent.getChild( positionOffset );\n\n\t\t// Position should be placed between two nodes.\n\t\tif ( !nodeBefore || !nodeAfter ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When position is between two text nodes.\n\t\tif ( nodeBefore.is( '$text' ) && nodeAfter.is( '$text' ) ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\t\t// When position is between two same attribute elements.\n\t\telse if ( nodeBefore.is( 'attributeElement' ) && nodeAfter.is( 'attributeElement' ) && nodeBefore.isSimilar( nodeAfter ) ) {\n\t\t\t// Move all children nodes from node placed after selection and remove that node.\n\t\t\tconst count = nodeBefore.childCount;\n\t\t\tnodeBefore._appendChild( nodeAfter.getChildren() );\n\n\t\t\tnodeAfter._remove();\n\t\t\tthis._removeFromClonedElementsGroup( nodeAfter );\n\n\t\t\t// New position is located inside the first node, before new nodes.\n\t\t\t// Call this method recursively to merge again if needed.\n\t\t\treturn this.mergeAttributes( new Position( nodeBefore, count ) );\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n\t * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n\t *\n\t *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n\t *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeContainers( position ) {\n\t\tconst prev = position.nodeBefore;\n\t\tconst next = position.nodeAfter;\n\n\t\tif ( !prev || !next || !prev.is( 'containerElement' ) || !next.is( 'containerElement' ) ) {\n\t\t\t/**\n\t\t\t * Element before and after given position cannot be merged.\n\t\t\t *\n\t\t\t * @error view-writer-merge-containers-invalid-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-merge-containers-invalid-position', this.document );\n\t\t}\n\n\t\tconst lastChild = prev.getChild( prev.childCount - 1 );\n\t\tconst newPosition = lastChild instanceof Text ? Position._createAt( lastChild, 'end' ) : Position._createAt( prev, 'end' );\n\n\t\tthis.move( Range._createIn( next ), Position._createAt( prev, 'end' ) );\n\t\tthis.remove( Range._createOn( next ) );\n\n\t\treturn newPosition;\n\t}\n\n\t/**\n\t * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion\n\t * and merging them afterwards.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n\t * contains instances that are not {@link module:engine/view/text~Text Texts},\n\t * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n\t * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n\t * {@link module:engine/view/rawelement~RawElement RawElements} or\n\t * {@link module:engine/view/uielement~UIElement UIElements}.\n\t *\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n\t * Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n\t * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\tinsert( position, nodes ) {\n\t\tnodes = isIterable( nodes ) ? [ ...nodes ] : [ nodes ];\n\n\t\t// Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\t\tvalidateNodesToInsert( nodes, this.document );\n\n\t\t// Group nodes in batches of nodes that require or do not require breaking an AttributeElements.\n\t\tconst nodeGroups = nodes.reduce( ( groups, node ) => {\n\t\t\tconst lastGroup = groups[ groups.length - 1 ];\n\n\t\t\t// Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n\t\t\t// can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\t\t\tconst breakAttributes = !( node.is( 'uiElement' ) && node.isAllowedInsideAttributeElement );\n\n\t\t\tif ( !lastGroup || lastGroup.breakAttributes != breakAttributes ) {\n\t\t\t\tgroups.push( {\n\t\t\t\t\tbreakAttributes,\n\t\t\t\t\tnodes: [ node ]\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tlastGroup.nodes.push( node );\n\t\t\t}\n\n\t\t\treturn groups;\n\t\t}, [] );\n\n\t\t// Insert nodes in batches.\n\t\tlet start = null;\n\t\tlet end = position;\n\n\t\tfor ( const { nodes, breakAttributes } of nodeGroups ) {\n\t\t\tconst range = this._insertNodes( end, nodes, breakAttributes );\n\n\t\t\tif ( !start ) {\n\t\t\t\tstart = range.start;\n\t\t\t}\n\n\t\t\tend = range.end;\n\t\t}\n\n\t\t// When no nodes were inserted - return collapsed range.\n\t\tif ( !start ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Removes provided range from the container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n\t * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n\t * to a collapsed range showing the new position.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n\t */\n\tremove( rangeOrItem ) {\n\t\tconst range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn( rangeOrItem );\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to remove.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn new DocumentFragment( this.document );\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\tconst count = breakEnd.offset - breakStart.offset;\n\n\t\t// Remove nodes in range.\n\t\tconst removed = parentContainer._removeChildren( breakStart.offset, count );\n\n\t\tfor ( const node of removed ) {\n\t\t\tthis._removeFromClonedElementsGroup( node );\n\t\t}\n\n\t\t// Merge after removing.\n\t\tconst mergePosition = this.mergeAttributes( breakStart );\n\t\trange.start = mergePosition;\n\t\trange.end = mergePosition.clone();\n\n\t\t// Return removed nodes.\n\t\treturn new DocumentFragment( this.document, removed );\n\t}\n\n\t/**\n\t * Removes matching elements from given range.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to clear.\n\t * @param {module:engine/view/element~Element} element Element to remove.\n\t */\n\tclear( range, element ) {\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Create walker on given range.\n\t\t// We walk backward because when we remove element during walk it modifies range end position.\n\t\tconst walker = range.getWalker( {\n\t\t\tdirection: 'backward',\n\t\t\tignoreElementEnd: true\n\t\t} );\n\n\t\t// Let's walk.\n\t\tfor ( const current of walker ) {\n\t\t\tconst item = current.item;\n\t\t\tlet rangeToRemove;\n\n\t\t\t// When current item matches to the given element.\n\t\t\tif ( item.is( 'element' ) && element.isSimilar( item ) ) {\n\t\t\t\t// Create range on this element.\n\t\t\t\trangeToRemove = Range._createOn( item );\n\t\t\t\t// When range starts inside Text or TextProxy element.\n\t\t\t} else if ( !current.nextPosition.isAfter( range.start ) && item.is( '$textProxy' ) ) {\n\t\t\t\t// We need to check if parent of this text matches to given element.\n\t\t\t\tconst parentElement = item.getAncestors().find( ancestor => {\n\t\t\t\t\treturn ancestor.is( 'element' ) && element.isSimilar( ancestor );\n\t\t\t\t} );\n\n\t\t\t\t// If it is then create range inside this element.\n\t\t\t\tif ( parentElement ) {\n\t\t\t\t\trangeToRemove = Range._createIn( parentElement );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have found element to remove.\n\t\t\tif ( rangeToRemove ) {\n\t\t\t\t// We need to check if element range stick out of the given range and truncate if it is.\n\t\t\t\tif ( rangeToRemove.end.isAfter( range.end ) ) {\n\t\t\t\t\trangeToRemove.end = range.end;\n\t\t\t\t}\n\n\t\t\t\tif ( rangeToRemove.start.isBefore( range.start ) ) {\n\t\t\t\t\trangeToRemove.start = range.start;\n\t\t\t\t}\n\n\t\t\t\t// At the end we remove range with found element.\n\t\t\t\tthis.remove( rangeToRemove );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves nodes from provided range to target position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n\t * @param {module:engine/view/position~Position} targetPosition Position to insert.\n\t * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n\t */\n\tmove( sourceRange, targetPosition ) {\n\t\tlet nodes;\n\n\t\tif ( targetPosition.isAfter( sourceRange.end ) ) {\n\t\t\ttargetPosition = this._breakAttributes( targetPosition, true );\n\n\t\t\tconst parent = targetPosition.parent;\n\t\t\tconst countBefore = parent.childCount;\n\n\t\t\tsourceRange = this._breakAttributesRange( sourceRange, true );\n\n\t\t\tnodes = this.remove( sourceRange );\n\n\t\t\ttargetPosition.offset += ( parent.childCount - countBefore );\n\t\t} else {\n\t\t\tnodes = this.remove( sourceRange );\n\t\t}\n\n\t\treturn this.insert( targetPosition, nodes );\n\t}\n\n\t/**\n\t * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n\t *\n\t * If a collapsed range was passed and is same as selection, the selection\n\t * will be moved to the inside of the wrapped attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start}\n\t * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n\t * is collapsed and different than view selection.\n\t *\n\t * **Note:** Attribute elements by default can wrap {@link module:engine/view/text~Text},\n\t * {@link module:engine/view/emptyelement~EmptyElement}, {@link module:engine/view/uielement~UIElement},\n\t * {@link module:engine/view/rawelement~RawElement} and other attribute elements with higher priority. Other elements while placed\n\t * inside an attribute element will split it (or nest it in case of an `AttributeElement`). This behavior can be modified by changing\n\t * the `isAllowedInsideAttributeElement` option while using\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement},\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement},\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement} or\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createRawElement}.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to wrap.\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n\t * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n\t */\n\twrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-wrap-invalid-attribute',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\t// Non-collapsed range. Wrap it with the attribute element.\n\t\t\treturn this._wrapRange( range, attribute );\n\t\t} else {\n\t\t\t// Collapsed range. Wrap position.\n\t\t\tlet position = range.start;\n\n\t\t\tif ( position.parent.is( 'element' ) && !_hasNonUiChildren( position.parent ) ) {\n\t\t\t\tposition = position.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );\n\t\t\t}\n\n\t\t\tposition = this._wrapPosition( position, attribute );\n\t\t\tconst viewSelection = this.document.selection;\n\n\t\t\t// If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\t\t\tif ( viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual( range.start ) ) {\n\t\t\t\tthis.setSelection( position );\n\t\t\t}\n\n\t\t\treturn new Range( position );\n\t\t}\n\t}\n\n\t/**\n\t * Unwraps nodes within provided range from attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t */\n\tunwrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\t/**\n\t\t\t * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#unwrap `DowncastWriter#unwrap()`}\n\t\t\t * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n\t\t\t *\n\t\t\t * @error view-writer-unwrap-invalid-attribute\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-unwrap-invalid-attribute',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to unwrap.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn range;\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Unwrap children located between break points.\n\t\tconst newRange = this._unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n\t * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n\t * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n\t *\n\t * New element has to be created because `Element#tagName` property in DOM is readonly.\n\t *\n\t * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n\t *\n\t * @param {String} newName New name for element.\n\t * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Element created due to rename.\n\t */\n\trename( newName, viewElement ) {\n\t\tconst newElement = new ContainerElement( this.document, newName, viewElement.getAttributes() );\n\n\t\tthis.insert( Position._createAfter( viewElement ), newElement );\n\t\tthis.move( Range._createIn( viewElement ), Position._createAt( newElement, 0 ) );\n\t\tthis.remove( Range._createOn( viewElement ) );\n\n\t\treturn newElement;\n\t}\n\n\t/**\n\t * Cleans up memory by removing obsolete cloned elements group from the writer.\n\t *\n\t * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n\t * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n\t * the group will no longer be needed.\n\t *\n\t * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n\t * were removed from the view.\n\t *\n\t * Keep in mind that group names are equal to the `id` property of the attribute element.\n\t *\n\t * @param {String} groupName Name of the group to clear.\n\t */\n\tclearClonedElementsGroup( groupName ) {\n\t\tthis._cloneGroups.delete( groupName );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/view/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link #createPositionBefore},\n\t * * {@link #createPositionAfter},\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn Position._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item after which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn Position._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item before which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn Position._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn Range._createOn( item );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn Range._createIn( element );\n\t}\n\n\t/**\n\t Creates new {@link module:engine/view/selection~Selection} instance.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the document selection.\n\t *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t * @returns {module:engine/view/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new Selection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion\n\t * and merging them afterwards if requested by the breakAttributes param.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n\t * Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n\t * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @param {Boolean} breakAttributes Whether attributes should be broken.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\t_insertNodes( position, nodes, breakAttributes ) {\n\t\tlet parentElement;\n\n\t\t// Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n\t\t// can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\t\tif ( breakAttributes ) {\n\t\t\tparentElement = getParentContainer( position );\n\t\t} else {\n\t\t\tparentElement = position.parent.is( '$text' ) ? position.parent.parent : position.parent;\n\t\t}\n\n\t\tif ( !parentElement ) {\n\t\t\t/**\n\t\t\t * Position's parent container cannot be found.\n\t\t\t *\n\t\t\t * @error view-writer-invalid-position-container\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-invalid-position-container',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tlet insertionPosition;\n\n\t\tif ( breakAttributes ) {\n\t\t\tinsertionPosition = this._breakAttributes( position, true );\n\t\t} else {\n\t\t\tinsertionPosition = position.parent.is( '$text' ) ? breakTextNode( position ) : position;\n\t\t}\n\n\t\tconst length = parentElement._insertChild( insertionPosition.offset, nodes );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tthis._addToClonedElementsGroup( node );\n\t\t}\n\n\t\tconst endPosition = insertionPosition.getShiftedBy( length );\n\t\tconst start = this.mergeAttributes( insertionPosition );\n\n\t\t// If start position was merged - move end position.\n\t\tif ( !start.isEqual( insertionPosition ) ) {\n\t\t\tendPosition.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( endPosition );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be wrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} wrapElement\n\t */\n\t_wrapChildren( parent, startOffset, endOffset, wrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst wrapPositions = [];\n\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\t\t\tconst isText = child.is( '$text' );\n\t\t\tconst isAttribute = child.is( 'attributeElement' );\n\t\t\tconst isAllowedInsideAttributeElement = child.isAllowedInsideAttributeElement;\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n\t\t\t// If possible, join elements.\n\t\t\t//\n\t\t\t// <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n\t\t\t//\n\t\t\tif ( isAttribute && this._wrapAttributeElement( wrapElement, child ) ) {\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n\t\t\t// `wrapElement` (due to priority).\n\t\t\t//\n\t\t\t// <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n\t\t\t// <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n\t\t\telse if ( isText || isAllowedInsideAttributeElement || ( isAttribute && shouldABeOutsideB( wrapElement, child ) ) ) {\n\t\t\t\t// Clone attribute.\n\t\t\t\tconst newAttribute = wrapElement._clone();\n\n\t\t\t\t// Wrap current node with new attribute.\n\t\t\t\tchild._remove();\n\t\t\t\tnewAttribute._appendChild( child );\n\n\t\t\t\tparent._insertChild( i, newAttribute );\n\t\t\t\tthis._addToClonedElementsGroup( newAttribute );\n\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n\t\t\t//\n\t\t\t// <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n\t\t\t//\n\t\t\telse if ( isAttribute ) {\n\t\t\t\tthis._wrapChildren( child, 0, child.childCount, wrapElement );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each wrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of wrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} unwrapElement\n\t */\n\t_unwrapChildren( parent, startOffset, endOffset, unwrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst unwrapPositions = [];\n\n\t\t// Iterate over each element between provided offsets inside parent.\n\t\t// We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n\t\t// so it could get messy. It is safer to it manually in this case.\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\n\t\t\t// Skip all text nodes. There should be no container element's here either.\n\t\t\tif ( !child.is( 'attributeElement' ) ) {\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n\t\t\t//\n\t\t\t// <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n\t\t\t//\n\t\t\tif ( child.isSimilar( unwrapElement ) ) {\n\t\t\t\tconst unwrapped = child.getChildren();\n\t\t\t\tconst count = child.childCount;\n\n\t\t\t\t// Replace wrapper element with its children\n\t\t\t\tchild._remove();\n\t\t\t\tparent._insertChild( i, unwrapped );\n\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\n\t\t\t\t// Save start and end position of moved items.\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + count )\n\t\t\t\t);\n\n\t\t\t\t// Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\t\t\t\ti += count;\n\t\t\t\tendOffset += count - 1;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n\t\t\t// Partial unwrapping will happen only if the elements have the same name.\n\t\t\t//\n\t\t\t// <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n\t\t\t// <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n\t\t\t//\n\t\t\tif ( this._unwrapAttributeElement( unwrapElement, child ) ) {\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + 1 )\n\t\t\t\t);\n\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If other nested attribute is found, look through it's children for elements to unwrap.\n\t\t\t//\n\t\t\t// <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n\t\t\t//\n\t\t\tthis._unwrapChildren( child, 0, child.childCount, unwrapElement );\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each unwrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of unwrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset || position.offset == endOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n\t */\n\t_wrapRange( range, attribute ) {\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Wrap all children with attribute.\n\t\tconst newRange = this._wrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/position~Position} New position after wrapping.\n\t */\n\t_wrapPosition( position, attribute ) {\n\t\t// Return same position when trying to wrap with attribute similar to position parent.\n\t\tif ( attribute.isSimilar( position.parent ) ) {\n\t\t\treturn movePositionToTextNode( position.clone() );\n\t\t}\n\n\t\t// When position is inside text node - break it and place new position between two text nodes.\n\t\tif ( position.parent.is( '$text' ) ) {\n\t\t\tposition = breakTextNode( position );\n\t\t}\n\n\t\t// Create fake element that will represent position, and will not be merged with other attributes.\n\t\tconst fakePosition = this.createAttributeElement();\n\t\tfakePosition._priority = Number.POSITIVE_INFINITY;\n\t\tfakePosition.isSimilar = () => false;\n\n\t\t// Insert fake element in position location.\n\t\tposition.parent._insertChild( position.offset, fakePosition );\n\n\t\t// Range around inserted fake attribute element.\n\t\tconst wrapRange = new Range( position, position.getShiftedBy( 1 ) );\n\n\t\t// Wrap fake element with attribute (it will also merge if possible).\n\t\tthis.wrap( wrapRange, attribute );\n\n\t\t// Remove fake element and place new position there.\n\t\tconst newPosition = new Position( fakePosition.parent, fakePosition.index );\n\t\tfakePosition._remove();\n\n\t\t// If position is placed between text nodes - merge them and return position inside.\n\t\tconst nodeBefore = newPosition.nodeBefore;\n\t\tconst nodeAfter = newPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof Text && nodeAfter instanceof Text ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\n\t\t// If position is next to text node - move position inside.\n\t\treturn movePositionToTextNode( newPosition );\n\t}\n\n\t/**\n\t * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n\t * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n\t * \telement to element being wrapped.\n\t *\n\t * \t@private\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n\t * \t@returns {Boolean} Returns `true` if elements are merged.\n\t */\n\t_wrapAttributeElement( wrapper, toWrap ) {\n\t\tif ( !canBeJoined( wrapper, toWrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't merge if name or priority differs.\n\t\tif ( wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes can be merged.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are different we cannot wrap.\n\t\t\tif ( toWrap.hasAttribute( key ) && toWrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles can be merged.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( toWrap.hasStyle( key ) && toWrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Move only these attributes that are not present - other are similar.\n\t\t\tif ( !toWrap.hasAttribute( key ) ) {\n\t\t\t\tthis.setAttribute( key, wrapper.getAttribute( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( !toWrap.hasStyle( key ) ) {\n\t\t\t\tthis.setStyle( key, wrapper.getStyle( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getClassNames() ) {\n\t\t\tif ( !toWrap.hasClass( key ) ) {\n\t\t\t\tthis.addClass( key, toWrap );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n\t * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n\t * inside element being unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n\t * @returns {Boolean} Returns `true` if elements are unwrapped.\n\t **/\n\t_unwrapAttributeElement( wrapper, toUnwrap ) {\n\t\tif ( !canBeJoined( wrapper, toUnwrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't unwrap if name or priority differs.\n\t\tif ( wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper attributes.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasAttribute( key ) || toUnwrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper classes.\n\t\tif ( !toUnwrap.hasClass( ...wrapper.getClassNames() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper styles.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\t// If some styles are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasStyle( key ) || toUnwrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Remove all wrapper's attributes from unwrapped element.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.removeAttribute( key, toUnwrap );\n\t\t}\n\n\t\t// Remove all wrapper's classes from unwrapped element.\n\t\tthis.removeClass( Array.from( wrapper.getClassNames() ), toUnwrap );\n\n\t\t// Remove all wrapper's styles from unwrapped element.\n\t\tthis.removeStyle( Array.from( wrapper.getStyleNames() ), toUnwrap );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/range~Range} New range with located at break positions.\n\t */\n\t_breakAttributesRange( range, forceSplitText = false ) {\n\t\tconst rangeStart = range.start;\n\t\tconst rangeEnd = range.end;\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Break at the collapsed position. Return new collapsed range.\n\t\tif ( range.isCollapsed ) {\n\t\t\tconst position = this._breakAttributes( range.start, forceSplitText );\n\n\t\t\treturn new Range( position, position );\n\t\t}\n\n\t\tconst breakEnd = this._breakAttributes( rangeEnd, forceSplitText );\n\t\tconst count = breakEnd.parent.childCount;\n\t\tconst breakStart = this._breakAttributes( rangeStart, forceSplitText );\n\n\t\t// Calculate new break end offset.\n\t\tbreakEnd.offset += breakEnd.parent.childCount - count;\n\n\t\treturn new Range( breakStart, breakEnd );\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n\t * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n\t * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Position where to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n\t */\n\t_breakAttributes( position, forceSplitText = false ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'emptyElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break an `EmptyElement` instance.\n\t\t\t *\n\t\t\t * This error is thrown if\n\t\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n\t\t\t * was executed in an incorrect position.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-empty-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-empty-element', this.document );\n\t\t}\n\n\t\t// If position is placed inside UIElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'uiElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break a `UIElement` instance.\n\t\t\t *\n\t\t\t * This error is thrown if\n\t\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n\t\t\t * was executed in an incorrect position.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-ui-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-ui-element', this.document );\n\t\t}\n\n\t\t// If position is placed inside RawElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'rawElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break a `RawElement` instance.\n\t\t\t *\n\t\t\t * This error is thrown if\n\t\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n\t\t\t * was executed in an incorrect position.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-raw-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-raw-element', this.document );\n\t\t}\n\n\t\t// There are no attributes to break and text nodes breaking is not forced.\n\t\tif ( !forceSplitText && positionParent.is( '$text' ) && isContainerOrFragment( positionParent.parent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Position's parent is container, so no attributes to break.\n\t\tif ( isContainerOrFragment( positionParent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Break text and start again in new position.\n\t\tif ( positionParent.is( '$text' ) ) {\n\t\t\treturn this._breakAttributes( breakTextNode( position ), forceSplitText );\n\t\t}\n\n\t\tconst length = positionParent.childCount;\n\n\t\t// <p>foo<b><u>bar{}</u></b></p>\n\t\t// <p>foo<b><u>bar</u>[]</b></p>\n\t\t// <p>foo<b><u>bar</u></b>[]</p>\n\t\tif ( positionOffset == length ) {\n\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index + 1 );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t} else {\n\t\t\t// <p>foo<b><u>{}bar</u></b></p>\n\t\t\t// <p>foo<b>[]<u>bar</u></b></p>\n\t\t\t// <p>foo{}<b><u>bar</u></b></p>\n\t\t\tif ( positionOffset === 0 ) {\n\t\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t\t// <p>foo<b><u>b{}ar</u></b></p>\n\t\t\t// <p>foo<b><u>b[]ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t\t\telse {\n\t\t\t\tconst offsetAfter = positionParent.index + 1;\n\n\t\t\t\t// Break element.\n\t\t\t\tconst clonedNode = positionParent._clone();\n\n\t\t\t\t// Insert cloned node to position's parent node.\n\t\t\t\tpositionParent.parent._insertChild( offsetAfter, clonedNode );\n\t\t\t\tthis._addToClonedElementsGroup( clonedNode );\n\n\t\t\t\t// Get nodes to move.\n\t\t\t\tconst count = positionParent.childCount - positionOffset;\n\t\t\t\tconst nodesToMove = positionParent._removeChildren( positionOffset, count );\n\n\t\t\t\t// Move nodes to cloned node.\n\t\t\t\tclonedNode._appendChild( nodesToMove );\n\n\t\t\t\t// Create new position to work on.\n\t\t\t\tconst newPosition = new Position( positionParent.parent, offsetAfter );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n\t * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n\t * from the group now keep a reference to the given attribute element.\n\t *\n\t * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n\t *\n\t * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n\t */\n\t_addToClonedElementsGroup( element ) {\n\t\t// Add only if the element is in document tree.\n\t\tif ( !element.root.is( 'rootElement' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Traverse the element's children recursively to find other attribute elements that also might got inserted.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._addToClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\tgroup = new Set();\n\t\t\tthis._cloneGroups.set( id, group );\n\t\t}\n\n\t\tgroup.add( element );\n\t\telement._clonesGroup = group;\n\t}\n\n\t/**\n\t * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n\t * from its clones group.\n\t *\n\t * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n\t * This allows to reference the whole group even if the element was already removed from the tree.\n\t *\n\t * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n\t */\n\t_removeFromClonedElementsGroup( element ) {\n\t\t// Traverse the element's children recursively to find other attribute elements that also got removed.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\treturn;\n\t\t}\n\n\t\tgroup.delete( element );\n\t\t// Not removing group from element on purpose!\n\t\t// If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n\t}\n}\n\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren( parent ) {\n\treturn Array.from( parent.getChildren() ).some( child => !child.is( 'uiElement' ) );\n}\n\n/**\n * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`}\n * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer( position ) {\n\tlet parent = position.parent;\n\n\twhile ( !isContainerOrFragment( parent ) ) {\n\t\tif ( !parent ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped outside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB( a, b ) {\n\tif ( a.priority < b.priority ) {\n\t\treturn true;\n\t} else if ( a.priority > b.priority ) {\n\t\treturn false;\n\t}\n\n\t// When priorities are equal and names are different - use identities.\n\treturn a.getIdentity() < b.getIdentity();\n}\n\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode( position ) {\n\tconst nodeBefore = position.nodeBefore;\n\n\tif ( nodeBefore && nodeBefore.is( '$text' ) ) {\n\t\treturn new Position( nodeBefore, nodeBefore.data.length );\n\t}\n\n\tconst nodeAfter = position.nodeAfter;\n\n\tif ( nodeAfter && nodeAfter.is( '$text' ) ) {\n\t\treturn new Position( nodeAfter, 0 );\n\t}\n\n\treturn position;\n}\n\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode( position ) {\n\tif ( position.offset == position.parent.data.length ) {\n\t\treturn new Position( position.parent.parent, position.parent.index + 1 );\n\t}\n\n\tif ( position.offset === 0 ) {\n\t\treturn new Position( position.parent.parent, position.parent.index );\n\t}\n\n\t// Get part of the text that need to be moved.\n\tconst textToMove = position.parent.data.slice( position.offset );\n\n\t// Leave rest of the text in position's parent.\n\tposition.parent._data = position.parent.data.slice( 0, position.offset );\n\n\t// Insert new text node after position's parent text node.\n\tposition.parent.parent._insertChild( position.parent.index + 1, new Text( position.root.document, textToMove ) );\n\n\t// Return new position between two newly created text nodes.\n\treturn new Position( position.parent.parent, position.parent.index + 1 );\n}\n\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes( t1, t2 ) {\n\t// Merge text data into first text node and remove second one.\n\tconst nodeBeforeLength = t1.data.length;\n\tt1._data += t2.data;\n\tt2._remove();\n\n\treturn new Position( t1, nodeBeforeLength );\n}\n\n// Checks if provided nodes are valid to insert.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not supported ones (see error description for valid ones.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/element~Element> nodes\n// @param {Object} errorContext\nfunction validateNodesToInsert( nodes, errorContext ) {\n\tfor ( const node of nodes ) {\n\t\tif ( !validNodesToInsert.some( ( validNode => node instanceof validNode ) ) ) { // eslint-disable-line no-use-before-define\n\t\t\t/**\n\t\t\t * One of the nodes to be inserted is of an invalid type.\n\t\t\t *\n\t\t\t * Nodes to be inserted with {@link module:engine/view/downcastwriter~DowncastWriter#insert `DowncastWriter#insert()`} should be\n\t\t\t * of the following types:\n\t\t\t *\n\t\t\t * * {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n\t\t\t * * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n\t\t\t * * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n\t\t\t * * {@link module:engine/view/uielement~UIElement UIElement},\n\t\t\t * * {@link module:engine/view/rawelement~RawElement RawElement},\n\t\t\t * * {@link module:engine/view/text~Text Text}.\n\t\t\t *\n\t\t\t * @error view-writer-insert-invalid-node-type\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-insert-invalid-node-type', errorContext );\n\t\t}\n\n\t\tif ( !node.is( '$text' ) ) {\n\t\t\tvalidateNodesToInsert( node.getChildren(), errorContext );\n\t\t}\n\t}\n}\n\nconst validNodesToInsert = [ Text, AttributeElement, ContainerElement, EmptyElement, RawElement, UIElement ];\n\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment( node ) {\n\treturn node && ( node.is( 'containerElement' ) || node.is( 'documentFragment' ) );\n}\n\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\nfunction validateRangeContainer( range, errorContext ) {\n\tconst startContainer = getParentContainer( range.start );\n\tconst endContainer = getParentContainer( range.end );\n\n\tif ( !startContainer || !endContainer || startContainer !== endContainer ) {\n\t\t/**\n\t\t * The container of the given range is invalid.\n\t\t *\n\t\t * This may happen if {@link module:engine/view/range~Range#start range start} and\n\t\t * {@link module:engine/view/range~Range#end range end} positions are not placed inside the same container element or\n\t\t * a parent container for these positions cannot be found.\n\t\t *\n\t\t * Methods like {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#remove()`},\n\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#clean()`},\n\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`},\n\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#unwrap()`} need to be called\n\t\t * on a range that has its start and end positions located in the same container element. Both positions can be\n\t\t * nested within other elements (e.g. an attribute element) but the closest container ancestor must be the same.\n\t\t *\n\t\t * @error view-writer-invalid-range-container\n\t\t */\n\t\tthrow new CKEditorError( 'view-writer-invalid-range-container', errorContext );\n\t}\n}\n\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined( a, b ) {\n\treturn a.id === null && b.id === null;\n}\n"]},"metadata":{},"sourceType":"module"}