{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class PluginCollection {\n  /**\n   * Creates an instance of the plugin collection class.\n   * Allows loading and initializing plugins and their dependencies.\n   * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.\n   *\n   * @param {module:core/editor/editor~Editor|module:core/context~Context} context\n   * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n   * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).\n   * Usually, the editor will pass its built-in plugins to the collection so they can later be\n   * used in `config.plugins` or `config.removePlugins` by names.\n   * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a\n   * `[ PluginConstructor, pluginInstance ]` pair.\n   */\n  constructor(context) {\n    let availablePlugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let contextPlugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    /**\n     * @protected\n     * @type {module:core/editor/editor~Editor|module:core/context~Context}\n     */\n    this._context = context;\n    /**\n     * @protected\n     * @type {Map}\n     */\n\n    this._plugins = new Map();\n    /**\n     * A map of plugin constructors that can be retrieved by their names.\n     *\n     * @protected\n     * @type {Map.<String|Function,Function>}\n     */\n\n    this._availablePlugins = new Map();\n\n    for (const PluginConstructor of availablePlugins) {\n      if (PluginConstructor.pluginName) {\n        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n      }\n    }\n    /**\n     * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.\n     *\n     * @protected\n     * @type {Map<Function,Function>}\n     */\n\n\n    this._contextPlugins = new Map();\n\n    for (const [PluginConstructor, pluginInstance] of contextPlugins) {\n      this._contextPlugins.set(PluginConstructor, pluginInstance);\n\n      this._contextPlugins.set(pluginInstance, PluginConstructor); // To make it possible to require a plugin by its name.\n\n\n      if (PluginConstructor.pluginName) {\n        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n      }\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n   *\n   * @returns {Iterable.<Array>}\n   */\n\n\n  *[Symbol.iterator]() {\n    for (const entry of this._plugins) {\n      if (typeof entry[0] == 'function') {\n        yield entry;\n      }\n    }\n  }\n  /**\n   * Gets the plugin instance by its constructor or name.\n   *\n   *\t\t// Check if 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n   *\t\t\t// Get clipboard plugin instance\n   *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n   *\n   *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n   *\t\t\t\t// Do something on clipboard input.\n   *\t\t\t} );\n   *\t\t}\n   *\n   * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n   * to check if a plugin is available.\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {module:core/plugin~PluginInterface}\n   */\n\n\n  get(key) {\n    const plugin = this._plugins.get(key);\n\n    if (!plugin) {\n      let pluginName = key;\n\n      if (typeof key == 'function') {\n        pluginName = key.pluginName || key.name;\n      }\n      /**\n       * The plugin is not loaded and could not be obtained.\n       *\n       * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n       * the plugin collection.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n       * to check if a plugin was loaded.\n       *\n       * @error plugincollection-plugin-not-loaded\n       * @param {String} plugin The name of the plugin which is not loaded.\n       */\n\n\n      throw new CKEditorError('plugincollection-plugin-not-loaded', this._context, {\n        plugin: pluginName\n      });\n    }\n\n    return plugin;\n  }\n  /**\n   * Checks if a plugin is loaded.\n   *\n   *\t\t// Check if the 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n   *\t\t\t// Now use the clipboard plugin instance:\n   *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n   *\n   *\t\t\t// ...\n   *\t\t}\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {Boolean}\n   */\n\n\n  has(key) {\n    return this._plugins.has(key);\n  }\n  /**\n   * Initializes a set of plugins and adds them to the collection.\n   *\n   * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n   * or {@link module:core/plugin~PluginInterface.pluginName plugin names}.\n   * @param {Array.<String|Function>} [pluginsToRemove] Names of the plugins or plugin constructors\n   * that should not be loaded (despite being specified in the `plugins` array).\n   * @param {Array.<Function>} [pluginsSubstitutions] An array of {@link module:core/plugin~PluginInterface plugin constructors}\n   * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.\n   * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced\n   * must follow these rules:\n   *   * The new plugin must be a class.\n   *   * The new plugin must be named.\n   *   * Both plugins must not depend on other plugins.\n   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n   * and available in the collection.\n   */\n\n\n  init(plugins) {\n    let pluginsToRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let pluginsSubstitutions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // Plugin initialization procedure consists of 2 main steps:\n    // 1) collecting all available plugin constructors,\n    // 2) verification whether all required plugins can be instantiated.\n    //\n    // In the first step, all plugin constructors, available in the provided `plugins` array and inside\n    // plugin's dependencies (from the `Plugin.requires` array), are recursively collected and added to the existing\n    // `this._availablePlugins` map, but without any verification at the given moment. Performing the verification\n    // at this point (during the plugin constructor searching) would cause false errors to occur, that some plugin\n    // is missing but in fact it may be defined further in the array as the dependency of other plugin. After\n    // traversing the entire dependency tree, it will be checked if all required \"top level\" plugins are available.\n    //\n    // In the second step, the list of plugins that have not been explicitly removed is traversed to get all the\n    // plugin constructors to be instantiated in the correct order and to validate against some rules. Finally, if\n    // no plugin is missing and no other error has been found, they all will be instantiated.\n    const that = this;\n    const context = this._context;\n    findAvailablePluginConstructors(plugins);\n    validatePlugins(plugins);\n    const pluginsToLoad = plugins.filter(plugin => !isPluginRemoved(plugin, pluginsToRemove));\n    const pluginConstructors = [...getPluginConstructors(pluginsToLoad)];\n    substitutePlugins(pluginConstructors, pluginsSubstitutions);\n    const pluginInstances = loadPlugins(pluginConstructors);\n    return initPlugins(pluginInstances, 'init').then(() => initPlugins(pluginInstances, 'afterInit')).then(() => pluginInstances);\n\n    function isPluginConstructor(plugin) {\n      return typeof plugin === 'function';\n    }\n\n    function isContextPlugin(plugin) {\n      return isPluginConstructor(plugin) && plugin.isContextPlugin;\n    }\n\n    function isPluginRemoved(plugin, pluginsToRemove) {\n      return pluginsToRemove.some(removedPlugin => {\n        if (removedPlugin === plugin) {\n          return true;\n        }\n\n        if (getPluginName(plugin) === removedPlugin) {\n          return true;\n        }\n\n        if (getPluginName(removedPlugin) === plugin) {\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    function getPluginName(plugin) {\n      return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;\n    }\n\n    function findAvailablePluginConstructors(plugins) {\n      let processed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n      plugins.forEach(plugin => {\n        if (!isPluginConstructor(plugin)) {\n          return;\n        }\n\n        if (processed.has(plugin)) {\n          return;\n        }\n\n        processed.add(plugin);\n\n        if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {\n          that._availablePlugins.set(plugin.pluginName, plugin);\n        }\n\n        if (plugin.requires) {\n          findAvailablePluginConstructors(plugin.requires, processed);\n        }\n      });\n    }\n\n    function getPluginConstructors(plugins) {\n      let processed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n      return plugins.map(plugin => {\n        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);\n      }).reduce((result, plugin) => {\n        if (processed.has(plugin)) {\n          return result;\n        }\n\n        processed.add(plugin);\n\n        if (plugin.requires) {\n          validatePlugins(plugin.requires, plugin);\n          getPluginConstructors(plugin.requires, processed).forEach(plugin => result.add(plugin));\n        }\n\n        return result.add(plugin);\n      }, new Set());\n    }\n\n    function validatePlugins(plugins) {\n      let parentPluginConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      plugins.map(plugin => {\n        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;\n      }).forEach(plugin => {\n        checkMissingPlugin(plugin, parentPluginConstructor);\n        checkContextPlugin(plugin, parentPluginConstructor);\n        checkRemovedPlugin(plugin, parentPluginConstructor);\n      });\n    }\n\n    function checkMissingPlugin(plugin, parentPluginConstructor) {\n      if (isPluginConstructor(plugin)) {\n        return;\n      }\n\n      if (parentPluginConstructor) {\n        /**\n         * A required \"soft\" dependency was not found on the plugin list.\n         *\n         * When configuring the editor, either prior to building (via\n         * {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}) or when\n         * creating a new instance of the editor (e.g. via\n         * {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`}), you need to provide\n         * some of the dependencies for other plugins that you used.\n         *\n         * This error is thrown when one of these dependencies was not provided. The name of the missing plugin\n         * can be found in `missingPlugin` and the plugin that required it in `requiredBy`.\n         *\n         * In order to resolve it, you need to import the missing plugin and add it to the\n         * current list of plugins (`Editor.builtinPlugins` or `config.plugins`/`config.extraPlugins`).\n         *\n         * Soft requirements were introduced in version 26.0.0. If you happen to stumble upon this error\n         * when upgrading to version 26.0.0, read also the\n         * {@glink builds/guides/migration/migration-to-26 Migration to 26.0.0} guide.\n         *\n         * @error plugincollection-soft-required\n         * @param {String} missingPlugin The name of the required plugin.\n         * @param {String} requiredBy The name of the plugin that requires the other plugin.\n         */\n        throw new CKEditorError('plugincollection-soft-required', context, {\n          missingPlugin: plugin,\n          requiredBy: getPluginName(parentPluginConstructor)\n        });\n      }\n      /**\n       * A plugin is not available and could not be loaded.\n       *\n       * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n       * that you try to enable a plugin which was not included in that build. This may be due to a typo\n       * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n       * read more about {@glink builds/guides/development/custom-builds custom builds}.\n       *\n       * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n       * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n       * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n       * provide each plugin through a reference (as a constructor function). Check out the examples in\n       * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n       *\n       * @error plugincollection-plugin-not-found\n       * @param {String} plugin The name of the plugin which could not be loaded.\n       */\n\n\n      throw new CKEditorError('plugincollection-plugin-not-found', context, {\n        plugin\n      });\n    }\n\n    function checkContextPlugin(plugin, parentPluginConstructor) {\n      if (!isContextPlugin(parentPluginConstructor)) {\n        return;\n      }\n\n      if (isContextPlugin(plugin)) {\n        return;\n      }\n      /**\n       * If a plugin is a context plugin, all plugins it requires should also be context plugins\n       * instead of plugins. In other words, if one plugin can be used in the context,\n       * all its requirements should also be ready to be used in the context. Note that the context\n       * provides only a part of the API provided by the editor. If one plugin needs a full\n       * editor API, all plugins which require it are considered as plugins that need a full\n       * editor API.\n       *\n       * @error plugincollection-context-required\n       * @param {String} plugin The name of the required plugin.\n       * @param {String} requiredBy The name of the parent plugin.\n       */\n\n\n      throw new CKEditorError('plugincollection-context-required', context, {\n        plugin: getPluginName(plugin),\n        requiredBy: getPluginName(parentPluginConstructor)\n      });\n    }\n\n    function checkRemovedPlugin(plugin, parentPluginConstructor) {\n      if (!parentPluginConstructor) {\n        return;\n      }\n\n      if (!isPluginRemoved(plugin, pluginsToRemove)) {\n        return;\n      }\n      /**\n       * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n       *\n       * @error plugincollection-required\n       * @param {String} plugin The name of the required plugin.\n       * @param {String} requiredBy The name of the parent plugin.\n       */\n\n\n      throw new CKEditorError('plugincollection-required', context, {\n        plugin: getPluginName(plugin),\n        requiredBy: getPluginName(parentPluginConstructor)\n      });\n    }\n\n    function loadPlugins(pluginConstructors) {\n      return pluginConstructors.map(PluginConstructor => {\n        const pluginInstance = that._contextPlugins.get(PluginConstructor) || new PluginConstructor(context);\n\n        that._add(PluginConstructor, pluginInstance);\n\n        return pluginInstance;\n      });\n    }\n\n    function initPlugins(pluginInstances, method) {\n      return pluginInstances.reduce((promise, plugin) => {\n        if (!plugin[method]) {\n          return promise;\n        }\n\n        if (that._contextPlugins.has(plugin)) {\n          return promise;\n        }\n\n        return promise.then(plugin[method].bind(plugin));\n      }, Promise.resolve());\n    } // Replaces plugin constructors with the specified set of plugins.\n    //\n    // @param {Array.<Function>} pluginConstructors\n    // @param {Array.<Function>} pluginsSubstitutions\n\n\n    function substitutePlugins(pluginConstructors, pluginsSubstitutions) {\n      for (const pluginItem of pluginsSubstitutions) {\n        if (typeof pluginItem != 'function') {\n          /**\n           * The plugin replacing an existing plugin must be a function.\n           *\n           * @error plugincollection-replace-plugin-invalid-type\n           */\n          throw new CKEditorError('plugincollection-replace-plugin-invalid-type', null, {\n            pluginItem\n          });\n        }\n\n        const pluginName = pluginItem.pluginName;\n\n        if (!pluginName) {\n          /**\n           * The plugin replacing an existing plugin must have a name.\n           *\n           * @error plugincollection-replace-plugin-missing-name\n           */\n          throw new CKEditorError('plugincollection-replace-plugin-missing-name', null, {\n            pluginItem\n          });\n        }\n\n        if (pluginItem.requires && pluginItem.requires.length) {\n          /**\n           * The plugin replacing an existing plugin cannot depend on other plugins.\n           *\n           * @error plugincollection-plugin-for-replacing-cannot-have-dependencies\n           */\n          throw new CKEditorError('plugincollection-plugin-for-replacing-cannot-have-dependencies', null, {\n            pluginName\n          });\n        }\n\n        const pluginToReplace = that._availablePlugins.get(pluginName);\n\n        if (!pluginToReplace) {\n          /**\n           * The replaced plugin does not exist in the\n           * {@link module:core/plugincollection~PluginCollection available plugins} collection.\n           *\n           * @error plugincollection-plugin-for-replacing-not-exist\n           */\n          throw new CKEditorError('plugincollection-plugin-for-replacing-not-exist', null, {\n            pluginName\n          });\n        }\n\n        const indexInPluginConstructors = pluginConstructors.indexOf(pluginToReplace);\n\n        if (indexInPluginConstructors === -1) {\n          // The Context feature can substitute plugins as well.\n          // It may happen that the editor will be created with the given context, where the plugin for substitute\n          // was already replaced. In such a case, we don't want to do it again.\n          if (that._contextPlugins.has(pluginToReplace)) {\n            return;\n          }\n          /**\n           * The replaced plugin will not be loaded so it cannot be replaced.\n           *\n           * @error plugincollection-plugin-for-replacing-not-loaded\n           */\n\n\n          throw new CKEditorError('plugincollection-plugin-for-replacing-not-loaded', null, {\n            pluginName\n          });\n        }\n\n        if (pluginToReplace.requires && pluginToReplace.requires.length) {\n          /**\n           * The replaced plugin cannot depend on other plugins.\n           *\n           * @error plugincollection-replaced-plugin-cannot-have-dependencies\n           */\n          throw new CKEditorError('plugincollection-replaced-plugin-cannot-have-dependencies', null, {\n            pluginName\n          });\n        }\n\n        pluginConstructors.splice(indexInPluginConstructors, 1, pluginItem);\n\n        that._availablePlugins.set(pluginName, pluginItem);\n      }\n    }\n  }\n  /**\n   * Destroys all loaded plugins.\n   *\n   * @returns {Promise}\n   */\n\n\n  destroy() {\n    const promises = [];\n\n    for (const [, pluginInstance] of this) {\n      if (typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has(pluginInstance)) {\n        promises.push(pluginInstance.destroy());\n      }\n    }\n\n    return Promise.all(promises);\n  }\n  /**\n   * Adds the plugin to the collection. Exposed mainly for testing purposes.\n   *\n   * @protected\n   * @param {Function} PluginConstructor The plugin constructor.\n   * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n   */\n\n\n  _add(PluginConstructor, plugin) {\n    this._plugins.set(PluginConstructor, plugin);\n\n    const pluginName = PluginConstructor.pluginName;\n\n    if (!pluginName) {\n      return;\n    }\n\n    if (this._plugins.has(pluginName)) {\n      /**\n       * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n       * This will lead to runtime conflicts between these plugins.\n       *\n       * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n       * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n       * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n       *\n       * Check your import paths and the list of plugins passed to\n       * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n       * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n       *\n       * The second option is that your `node_modules/` directory contains duplicated versions of the same\n       * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n       * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n       * of some packages, their dependencies may need to be installed in more than one version which may lead to this\n       * warning.\n       *\n       * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n       * the dependencies of this plugin are being duplicated.\n       * They are already built into that editor build and now get added for the second time as dependencies\n       * of the plugin you are installing.\n       *\n       * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.\n       *\n       * @error plugincollection-plugin-name-conflict\n       * @param {String} pluginName The duplicated plugin name.\n       * @param {Function} plugin1 The first plugin constructor.\n       * @param {Function} plugin2 The second plugin constructor.\n       */\n      throw new CKEditorError('plugincollection-plugin-name-conflict', null, {\n        pluginName,\n        plugin1: this._plugins.get(pluginName).constructor,\n        plugin2: PluginConstructor\n      });\n    }\n\n    this._plugins.set(pluginName, plugin);\n  }\n\n}\nmix(PluginCollection, EmitterMixin);","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js"],"names":["CKEditorError","EmitterMixin","mix","PluginCollection","constructor","context","availablePlugins","contextPlugins","_context","_plugins","Map","_availablePlugins","PluginConstructor","pluginName","set","_contextPlugins","pluginInstance","Symbol","iterator","entry","get","key","plugin","name","has","init","plugins","pluginsToRemove","pluginsSubstitutions","that","findAvailablePluginConstructors","validatePlugins","pluginsToLoad","filter","isPluginRemoved","pluginConstructors","getPluginConstructors","substitutePlugins","pluginInstances","loadPlugins","initPlugins","then","isPluginConstructor","isContextPlugin","some","removedPlugin","getPluginName","processed","Set","forEach","add","requires","map","reduce","result","parentPluginConstructor","checkMissingPlugin","checkContextPlugin","checkRemovedPlugin","missingPlugin","requiredBy","_add","method","promise","bind","Promise","resolve","pluginItem","length","pluginToReplace","indexInPluginConstructors","indexOf","splice","destroy","promises","push","all","plugin1","plugin2"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,aAAP,MAA0B,6CAA1B;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,gBAAN,CAAuB;AACrC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,OAAF,EAAwD;AAAA,QAA7CC,gBAA6C,uEAA1B,EAA0B;AAAA,QAAtBC,cAAsB,uEAAL,EAAK;;AAClE;AACF;AACA;AACA;AACE,SAAKC,QAAL,GAAgBH,OAAhB;AAEA;AACF;AACA;AACA;;AACE,SAAKI,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,iBAAL,GAAyB,IAAID,GAAJ,EAAzB;;AAEA,SAAM,MAAME,iBAAZ,IAAiCN,gBAAjC,EAAoD;AACnD,UAAKM,iBAAiB,CAACC,UAAvB,EAAoC;AACnC,aAAKF,iBAAL,CAAuBG,GAAvB,CAA4BF,iBAAiB,CAACC,UAA9C,EAA0DD,iBAA1D;AACA;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE,SAAKG,eAAL,GAAuB,IAAIL,GAAJ,EAAvB;;AAEA,SAAM,MAAM,CAAEE,iBAAF,EAAqBI,cAArB,CAAZ,IAAqDT,cAArD,EAAsE;AACrE,WAAKQ,eAAL,CAAqBD,GAArB,CAA0BF,iBAA1B,EAA6CI,cAA7C;;AACA,WAAKD,eAAL,CAAqBD,GAArB,CAA0BE,cAA1B,EAA0CJ,iBAA1C,EAFqE,CAIrE;;;AACA,UAAKA,iBAAiB,CAACC,UAAvB,EAAoC;AACnC,aAAKF,iBAAL,CAAuBG,GAAvB,CAA4BF,iBAAiB,CAACC,UAA9C,EAA0DD,iBAA1D;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACoB,IAAfK,MAAM,CAACC,QAAQ,IAAK;AACvB,SAAM,MAAMC,KAAZ,IAAqB,KAAKV,QAA1B,EAAqC;AACpC,UAAK,OAAOU,KAAK,CAAE,CAAF,CAAZ,IAAqB,UAA1B,EAAuC;AACtC,cAAMA,KAAN;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,GAAG,CAAEC,GAAF,EAAQ;AACV,UAAMC,MAAM,GAAG,KAAKb,QAAL,CAAcW,GAAd,CAAmBC,GAAnB,CAAf;;AAEA,QAAK,CAACC,MAAN,EAAe;AACd,UAAIT,UAAU,GAAGQ,GAAjB;;AAEA,UAAK,OAAOA,GAAP,IAAc,UAAnB,EAAgC;AAC/BR,QAAAA,UAAU,GAAGQ,GAAG,CAACR,UAAJ,IAAkBQ,GAAG,CAACE,IAAnC;AACA;AAED;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACG,YAAM,IAAIvB,aAAJ,CAAmB,oCAAnB,EAAyD,KAAKQ,QAA9D,EAAwE;AAAEc,QAAAA,MAAM,EAAET;AAAV,OAAxE,CAAN;AACA;;AAED,WAAOS,MAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,GAAG,CAAEH,GAAF,EAAQ;AACV,WAAO,KAAKZ,QAAL,CAAce,GAAd,CAAmBH,GAAnB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCI,EAAAA,IAAI,CAAEC,OAAF,EAA6D;AAAA,QAAlDC,eAAkD,uEAAhC,EAAgC;AAAA,QAA5BC,oBAA4B,uEAAL,EAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMC,IAAI,GAAG,IAAb;AACA,UAAMxB,OAAO,GAAG,KAAKG,QAArB;AAEAsB,IAAAA,+BAA+B,CAAEJ,OAAF,CAA/B;AAEAK,IAAAA,eAAe,CAAEL,OAAF,CAAf;AAEA,UAAMM,aAAa,GAAGN,OAAO,CAACO,MAAR,CAAgBX,MAAM,IAAI,CAACY,eAAe,CAAEZ,MAAF,EAAUK,eAAV,CAA1C,CAAtB;AAEA,UAAMQ,kBAAkB,GAAG,CAAE,GAAGC,qBAAqB,CAAEJ,aAAF,CAA1B,CAA3B;AAEAK,IAAAA,iBAAiB,CAAEF,kBAAF,EAAsBP,oBAAtB,CAAjB;AAEA,UAAMU,eAAe,GAAGC,WAAW,CAAEJ,kBAAF,CAAnC;AAEA,WAAOK,WAAW,CAAEF,eAAF,EAAmB,MAAnB,CAAX,CACLG,IADK,CACC,MAAMD,WAAW,CAAEF,eAAF,EAAmB,WAAnB,CADlB,EAELG,IAFK,CAEC,MAAMH,eAFP,CAAP;;AAIA,aAASI,mBAAT,CAA8BpB,MAA9B,EAAuC;AACtC,aAAO,OAAOA,MAAP,KAAkB,UAAzB;AACA;;AAED,aAASqB,eAAT,CAA0BrB,MAA1B,EAAmC;AAClC,aAAOoB,mBAAmB,CAAEpB,MAAF,CAAnB,IAAiCA,MAAM,CAACqB,eAA/C;AACA;;AAED,aAAST,eAAT,CAA0BZ,MAA1B,EAAkCK,eAAlC,EAAoD;AACnD,aAAOA,eAAe,CAACiB,IAAhB,CAAsBC,aAAa,IAAI;AAC7C,YAAKA,aAAa,KAAKvB,MAAvB,EAAgC;AAC/B,iBAAO,IAAP;AACA;;AAED,YAAKwB,aAAa,CAAExB,MAAF,CAAb,KAA4BuB,aAAjC,EAAiD;AAChD,iBAAO,IAAP;AACA;;AAED,YAAKC,aAAa,CAAED,aAAF,CAAb,KAAmCvB,MAAxC,EAAiD;AAChD,iBAAO,IAAP;AACA;;AAED,eAAO,KAAP;AACA,OAdM,CAAP;AAeA;;AAED,aAASwB,aAAT,CAAwBxB,MAAxB,EAAiC;AAChC,aAAOoB,mBAAmB,CAAEpB,MAAF,CAAnB,GACNA,MAAM,CAACT,UAAP,IAAqBS,MAAM,CAACC,IADtB,GAEND,MAFD;AAGA;;AAED,aAASQ,+BAAT,CAA0CJ,OAA1C,EAA2E;AAAA,UAAxBqB,SAAwB,uEAAZ,IAAIC,GAAJ,EAAY;AAC1EtB,MAAAA,OAAO,CAACuB,OAAR,CAAiB3B,MAAM,IAAI;AAC1B,YAAK,CAACoB,mBAAmB,CAAEpB,MAAF,CAAzB,EAAsC;AACrC;AACA;;AAED,YAAKyB,SAAS,CAACvB,GAAV,CAAeF,MAAf,CAAL,EAA+B;AAC9B;AACA;;AAEDyB,QAAAA,SAAS,CAACG,GAAV,CAAe5B,MAAf;;AAEA,YAAKA,MAAM,CAACT,UAAP,IAAqB,CAACgB,IAAI,CAAClB,iBAAL,CAAuBa,GAAvB,CAA4BF,MAAM,CAACT,UAAnC,CAA3B,EAA6E;AAC5EgB,UAAAA,IAAI,CAAClB,iBAAL,CAAuBG,GAAvB,CAA4BQ,MAAM,CAACT,UAAnC,EAA+CS,MAA/C;AACA;;AAED,YAAKA,MAAM,CAAC6B,QAAZ,EAAuB;AACtBrB,UAAAA,+BAA+B,CAAER,MAAM,CAAC6B,QAAT,EAAmBJ,SAAnB,CAA/B;AACA;AACD,OAlBD;AAmBA;;AAED,aAASX,qBAAT,CAAgCV,OAAhC,EAAiE;AAAA,UAAxBqB,SAAwB,uEAAZ,IAAIC,GAAJ,EAAY;AAChE,aAAOtB,OAAO,CACZ0B,GADK,CACA9B,MAAM,IAAI;AACf,eAAOoB,mBAAmB,CAAEpB,MAAF,CAAnB,GACNA,MADM,GAENO,IAAI,CAAClB,iBAAL,CAAuBS,GAAvB,CAA4BE,MAA5B,CAFD;AAGA,OALK,EAML+B,MANK,CAMG,CAAEC,MAAF,EAAUhC,MAAV,KAAsB;AAC9B,YAAKyB,SAAS,CAACvB,GAAV,CAAeF,MAAf,CAAL,EAA+B;AAC9B,iBAAOgC,MAAP;AACA;;AAEDP,QAAAA,SAAS,CAACG,GAAV,CAAe5B,MAAf;;AAEA,YAAKA,MAAM,CAAC6B,QAAZ,EAAuB;AACtBpB,UAAAA,eAAe,CAAET,MAAM,CAAC6B,QAAT,EAAmB7B,MAAnB,CAAf;AAEAc,UAAAA,qBAAqB,CAAEd,MAAM,CAAC6B,QAAT,EAAmBJ,SAAnB,CAArB,CAAoDE,OAApD,CAA6D3B,MAAM,IAAIgC,MAAM,CAACJ,GAAP,CAAY5B,MAAZ,CAAvE;AACA;;AAED,eAAOgC,MAAM,CAACJ,GAAP,CAAY5B,MAAZ,CAAP;AACA,OApBK,EAoBH,IAAI0B,GAAJ,EApBG,CAAP;AAqBA;;AAED,aAASjB,eAAT,CAA0BL,OAA1B,EAAoE;AAAA,UAAjC6B,uBAAiC,uEAAP,IAAO;AACnE7B,MAAAA,OAAO,CACL0B,GADF,CACO9B,MAAM,IAAI;AACf,eAAOoB,mBAAmB,CAAEpB,MAAF,CAAnB,GACNA,MADM,GAENO,IAAI,CAAClB,iBAAL,CAAuBS,GAAvB,CAA4BE,MAA5B,KAAwCA,MAFzC;AAGA,OALF,EAME2B,OANF,CAMW3B,MAAM,IAAI;AACnBkC,QAAAA,kBAAkB,CAAElC,MAAF,EAAUiC,uBAAV,CAAlB;AACAE,QAAAA,kBAAkB,CAAEnC,MAAF,EAAUiC,uBAAV,CAAlB;AACAG,QAAAA,kBAAkB,CAAEpC,MAAF,EAAUiC,uBAAV,CAAlB;AACA,OAVF;AAWA;;AAED,aAASC,kBAAT,CAA6BlC,MAA7B,EAAqCiC,uBAArC,EAA+D;AAC9D,UAAKb,mBAAmB,CAAEpB,MAAF,CAAxB,EAAqC;AACpC;AACA;;AAED,UAAKiC,uBAAL,EAA+B;AAC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,cAAM,IAAIvD,aAAJ,CACL,gCADK,EAELK,OAFK,EAGL;AAAEsD,UAAAA,aAAa,EAAErC,MAAjB;AAAyBsC,UAAAA,UAAU,EAAEd,aAAa,CAAES,uBAAF;AAAlD,SAHK,CAAN;AAKA;AAED;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACG,YAAM,IAAIvD,aAAJ,CACL,mCADK,EAELK,OAFK,EAGL;AAAEiB,QAAAA;AAAF,OAHK,CAAN;AAKA;;AAED,aAASmC,kBAAT,CAA6BnC,MAA7B,EAAqCiC,uBAArC,EAA+D;AAC9D,UAAK,CAACZ,eAAe,CAAEY,uBAAF,CAArB,EAAmD;AAClD;AACA;;AAED,UAAKZ,eAAe,CAAErB,MAAF,CAApB,EAAiC;AAChC;AACA;AAED;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACG,YAAM,IAAItB,aAAJ,CACL,mCADK,EAELK,OAFK,EAGL;AAAEiB,QAAAA,MAAM,EAAEwB,aAAa,CAAExB,MAAF,CAAvB;AAAmCsC,QAAAA,UAAU,EAAEd,aAAa,CAAES,uBAAF;AAA5D,OAHK,CAAN;AAKA;;AAED,aAASG,kBAAT,CAA6BpC,MAA7B,EAAqCiC,uBAArC,EAA+D;AAC9D,UAAK,CAACA,uBAAN,EAAgC;AAC/B;AACA;;AAED,UAAK,CAACrB,eAAe,CAAEZ,MAAF,EAAUK,eAAV,CAArB,EAAmD;AAClD;AACA;AAED;AACH;AACA;AACA;AACA;AACA;AACA;;;AACG,YAAM,IAAI3B,aAAJ,CACL,2BADK,EAELK,OAFK,EAGL;AAAEiB,QAAAA,MAAM,EAAEwB,aAAa,CAAExB,MAAF,CAAvB;AAAmCsC,QAAAA,UAAU,EAAEd,aAAa,CAAES,uBAAF;AAA5D,OAHK,CAAN;AAKA;;AAED,aAAShB,WAAT,CAAsBJ,kBAAtB,EAA2C;AAC1C,aAAOA,kBAAkB,CAACiB,GAAnB,CAAwBxC,iBAAiB,IAAI;AACnD,cAAMI,cAAc,GAAGa,IAAI,CAACd,eAAL,CAAqBK,GAArB,CAA0BR,iBAA1B,KAAiD,IAAIA,iBAAJ,CAAuBP,OAAvB,CAAxE;;AAEAwB,QAAAA,IAAI,CAACgC,IAAL,CAAWjD,iBAAX,EAA8BI,cAA9B;;AAEA,eAAOA,cAAP;AACA,OANM,CAAP;AAOA;;AAED,aAASwB,WAAT,CAAsBF,eAAtB,EAAuCwB,MAAvC,EAAgD;AAC/C,aAAOxB,eAAe,CAACe,MAAhB,CAAwB,CAAEU,OAAF,EAAWzC,MAAX,KAAuB;AACrD,YAAK,CAACA,MAAM,CAAEwC,MAAF,CAAZ,EAAyB;AACxB,iBAAOC,OAAP;AACA;;AAED,YAAKlC,IAAI,CAACd,eAAL,CAAqBS,GAArB,CAA0BF,MAA1B,CAAL,EAA0C;AACzC,iBAAOyC,OAAP;AACA;;AAED,eAAOA,OAAO,CAACtB,IAAR,CAAcnB,MAAM,CAAEwC,MAAF,CAAN,CAAiBE,IAAjB,CAAuB1C,MAAvB,CAAd,CAAP;AACA,OAVM,EAUJ2C,OAAO,CAACC,OAAR,EAVI,CAAP;AAWA,KAvQ+D,CAyQhE;AACA;AACA;AACA;;;AACA,aAAS7B,iBAAT,CAA4BF,kBAA5B,EAAgDP,oBAAhD,EAAuE;AACtE,WAAM,MAAMuC,UAAZ,IAA0BvC,oBAA1B,EAAiD;AAChD,YAAK,OAAOuC,UAAP,IAAqB,UAA1B,EAAuC;AACtC;AACL;AACA;AACA;AACA;AACK,gBAAM,IAAInE,aAAJ,CAAmB,8CAAnB,EAAmE,IAAnE,EAAyE;AAAEmE,YAAAA;AAAF,WAAzE,CAAN;AACA;;AACD,cAAMtD,UAAU,GAAGsD,UAAU,CAACtD,UAA9B;;AAEA,YAAK,CAACA,UAAN,EAAmB;AAClB;AACL;AACA;AACA;AACA;AACK,gBAAM,IAAIb,aAAJ,CAAmB,8CAAnB,EAAmE,IAAnE,EAAyE;AAAEmE,YAAAA;AAAF,WAAzE,CAAN;AACA;;AAED,YAAKA,UAAU,CAAChB,QAAX,IAAuBgB,UAAU,CAAChB,QAAX,CAAoBiB,MAAhD,EAAyD;AACxD;AACL;AACA;AACA;AACA;AACK,gBAAM,IAAIpE,aAAJ,CAAmB,gEAAnB,EAAqF,IAArF,EAA2F;AAAEa,YAAAA;AAAF,WAA3F,CAAN;AACA;;AAED,cAAMwD,eAAe,GAAGxC,IAAI,CAAClB,iBAAL,CAAuBS,GAAvB,CAA4BP,UAA5B,CAAxB;;AAEA,YAAK,CAACwD,eAAN,EAAwB;AACvB;AACL;AACA;AACA;AACA;AACA;AACK,gBAAM,IAAIrE,aAAJ,CAAmB,iDAAnB,EAAsE,IAAtE,EAA4E;AAAEa,YAAAA;AAAF,WAA5E,CAAN;AACA;;AAED,cAAMyD,yBAAyB,GAAGnC,kBAAkB,CAACoC,OAAnB,CAA4BF,eAA5B,CAAlC;;AAEA,YAAKC,yBAAyB,KAAK,CAAC,CAApC,EAAwC;AACvC;AACA;AACA;AACA,cAAKzC,IAAI,CAACd,eAAL,CAAqBS,GAArB,CAA0B6C,eAA1B,CAAL,EAAmD;AAClD;AACA;AAED;AACL;AACA;AACA;AACA;;;AACK,gBAAM,IAAIrE,aAAJ,CAAmB,kDAAnB,EAAuE,IAAvE,EAA6E;AAAEa,YAAAA;AAAF,WAA7E,CAAN;AACA;;AAED,YAAKwD,eAAe,CAAClB,QAAhB,IAA4BkB,eAAe,CAAClB,QAAhB,CAAyBiB,MAA1D,EAAmE;AAClE;AACL;AACA;AACA;AACA;AACK,gBAAM,IAAIpE,aAAJ,CAAmB,2DAAnB,EAAgF,IAAhF,EAAsF;AAAEa,YAAAA;AAAF,WAAtF,CAAN;AACA;;AAEDsB,QAAAA,kBAAkB,CAACqC,MAAnB,CAA2BF,yBAA3B,EAAsD,CAAtD,EAAyDH,UAAzD;;AACAtC,QAAAA,IAAI,CAAClB,iBAAL,CAAuBG,GAAvB,CAA4BD,UAA5B,EAAwCsD,UAAxC;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;;;AACCM,EAAAA,OAAO,GAAG;AACT,UAAMC,QAAQ,GAAG,EAAjB;;AAEA,SAAM,MAAM,GAAI1D,cAAJ,CAAZ,IAAoC,IAApC,EAA2C;AAC1C,UAAK,OAAOA,cAAc,CAACyD,OAAtB,IAAiC,UAAjC,IAA+C,CAAC,KAAK1D,eAAL,CAAqBS,GAArB,CAA0BR,cAA1B,CAArD,EAAkG;AACjG0D,QAAAA,QAAQ,CAACC,IAAT,CAAe3D,cAAc,CAACyD,OAAf,EAAf;AACA;AACD;;AAED,WAAOR,OAAO,CAACW,GAAR,CAAaF,QAAb,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCb,EAAAA,IAAI,CAAEjD,iBAAF,EAAqBU,MAArB,EAA8B;AACjC,SAAKb,QAAL,CAAcK,GAAd,CAAmBF,iBAAnB,EAAsCU,MAAtC;;AAEA,UAAMT,UAAU,GAAGD,iBAAiB,CAACC,UAArC;;AAEA,QAAK,CAACA,UAAN,EAAmB;AAClB;AACA;;AAED,QAAK,KAAKJ,QAAL,CAAce,GAAd,CAAmBX,UAAnB,CAAL,EAAuC;AACtC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG,YAAM,IAAIb,aAAJ,CACL,uCADK,EAEL,IAFK,EAGL;AAAEa,QAAAA,UAAF;AAAcgE,QAAAA,OAAO,EAAE,KAAKpE,QAAL,CAAcW,GAAd,CAAmBP,UAAnB,EAAgCT,WAAvD;AAAoE0E,QAAAA,OAAO,EAAElE;AAA7E,OAHK,CAAN;AAKA;;AAED,SAAKH,QAAL,CAAcK,GAAd,CAAmBD,UAAnB,EAA+BS,MAA/B;AACA;;AA/jBoC;AAkkBtCpB,GAAG,CAAEC,gBAAF,EAAoBF,YAApB,CAAH","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class PluginCollection {\n\t/**\n\t * Creates an instance of the plugin collection class.\n\t * Allows loading and initializing plugins and their dependencies.\n\t * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.\n\t *\n\t * @param {module:core/editor/editor~Editor|module:core/context~Context} context\n\t * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n\t * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).\n\t * Usually, the editor will pass its built-in plugins to the collection so they can later be\n\t * used in `config.plugins` or `config.removePlugins` by names.\n\t * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a\n\t * `[ PluginConstructor, pluginInstance ]` pair.\n\t */\n\tconstructor( context, availablePlugins = [], contextPlugins = [] ) {\n\t\t/**\n\t\t * @protected\n\t\t * @type {module:core/editor/editor~Editor|module:core/context~Context}\n\t\t */\n\t\tthis._context = context;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Map}\n\t\t */\n\t\tthis._plugins = new Map();\n\n\t\t/**\n\t\t * A map of plugin constructors that can be retrieved by their names.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map.<String|Function,Function>}\n\t\t */\n\t\tthis._availablePlugins = new Map();\n\n\t\tfor ( const PluginConstructor of availablePlugins ) {\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map<Function,Function>}\n\t\t */\n\t\tthis._contextPlugins = new Map();\n\n\t\tfor ( const [ PluginConstructor, pluginInstance ] of contextPlugins ) {\n\t\t\tthis._contextPlugins.set( PluginConstructor, pluginInstance );\n\t\t\tthis._contextPlugins.set( pluginInstance, PluginConstructor );\n\n\t\t\t// To make it possible to require a plugin by its name.\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n\t *\n\t * @returns {Iterable.<Array>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tfor ( const entry of this._plugins ) {\n\t\t\tif ( typeof entry[ 0 ] == 'function' ) {\n\t\t\t\tyield entry;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the plugin instance by its constructor or name.\n\t *\n\t *\t\t// Check if 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n\t *\t\t\t// Get clipboard plugin instance\n\t *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n\t *\n\t *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n\t *\t\t\t\t// Do something on clipboard input.\n\t *\t\t\t} );\n\t *\t\t}\n\t *\n\t * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n\t * to check if a plugin is available.\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {module:core/plugin~PluginInterface}\n\t */\n\tget( key ) {\n\t\tconst plugin = this._plugins.get( key );\n\n\t\tif ( !plugin ) {\n\t\t\tlet pluginName = key;\n\n\t\t\tif ( typeof key == 'function' ) {\n\t\t\t\tpluginName = key.pluginName || key.name;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * The plugin is not loaded and could not be obtained.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n\t\t\t * the plugin collection.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n\t\t\t * to check if a plugin was loaded.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-loaded\n\t\t\t * @param {String} plugin The name of the plugin which is not loaded.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'plugincollection-plugin-not-loaded', this._context, { plugin: pluginName } );\n\t\t}\n\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Checks if a plugin is loaded.\n\t *\n\t *\t\t// Check if the 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n\t *\t\t\t// Now use the clipboard plugin instance:\n\t *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n\t *\n\t *\t\t\t// ...\n\t *\t\t}\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {Boolean}\n\t */\n\thas( key ) {\n\t\treturn this._plugins.has( key );\n\t}\n\n\t/**\n\t * Initializes a set of plugins and adds them to the collection.\n\t *\n\t * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n\t * or {@link module:core/plugin~PluginInterface.pluginName plugin names}.\n\t * @param {Array.<String|Function>} [pluginsToRemove] Names of the plugins or plugin constructors\n\t * that should not be loaded (despite being specified in the `plugins` array).\n\t * @param {Array.<Function>} [pluginsSubstitutions] An array of {@link module:core/plugin~PluginInterface plugin constructors}\n\t * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.\n\t * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced\n\t * must follow these rules:\n\t *   * The new plugin must be a class.\n\t *   * The new plugin must be named.\n\t *   * Both plugins must not depend on other plugins.\n\t * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n\t * and available in the collection.\n\t */\n\tinit( plugins, pluginsToRemove = [], pluginsSubstitutions = [] ) {\n\t\t// Plugin initialization procedure consists of 2 main steps:\n\t\t// 1) collecting all available plugin constructors,\n\t\t// 2) verification whether all required plugins can be instantiated.\n\t\t//\n\t\t// In the first step, all plugin constructors, available in the provided `plugins` array and inside\n\t\t// plugin's dependencies (from the `Plugin.requires` array), are recursively collected and added to the existing\n\t\t// `this._availablePlugins` map, but without any verification at the given moment. Performing the verification\n\t\t// at this point (during the plugin constructor searching) would cause false errors to occur, that some plugin\n\t\t// is missing but in fact it may be defined further in the array as the dependency of other plugin. After\n\t\t// traversing the entire dependency tree, it will be checked if all required \"top level\" plugins are available.\n\t\t//\n\t\t// In the second step, the list of plugins that have not been explicitly removed is traversed to get all the\n\t\t// plugin constructors to be instantiated in the correct order and to validate against some rules. Finally, if\n\t\t// no plugin is missing and no other error has been found, they all will be instantiated.\n\t\tconst that = this;\n\t\tconst context = this._context;\n\n\t\tfindAvailablePluginConstructors( plugins );\n\n\t\tvalidatePlugins( plugins );\n\n\t\tconst pluginsToLoad = plugins.filter( plugin => !isPluginRemoved( plugin, pluginsToRemove ) );\n\n\t\tconst pluginConstructors = [ ...getPluginConstructors( pluginsToLoad ) ];\n\n\t\tsubstitutePlugins( pluginConstructors, pluginsSubstitutions );\n\n\t\tconst pluginInstances = loadPlugins( pluginConstructors );\n\n\t\treturn initPlugins( pluginInstances, 'init' )\n\t\t\t.then( () => initPlugins( pluginInstances, 'afterInit' ) )\n\t\t\t.then( () => pluginInstances );\n\n\t\tfunction isPluginConstructor( plugin ) {\n\t\t\treturn typeof plugin === 'function';\n\t\t}\n\n\t\tfunction isContextPlugin( plugin ) {\n\t\t\treturn isPluginConstructor( plugin ) && plugin.isContextPlugin;\n\t\t}\n\n\t\tfunction isPluginRemoved( plugin, pluginsToRemove ) {\n\t\t\treturn pluginsToRemove.some( removedPlugin => {\n\t\t\t\tif ( removedPlugin === plugin ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif ( getPluginName( plugin ) === removedPlugin ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif ( getPluginName( removedPlugin ) === plugin ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t} );\n\t\t}\n\n\t\tfunction getPluginName( plugin ) {\n\t\t\treturn isPluginConstructor( plugin ) ?\n\t\t\t\tplugin.pluginName || plugin.name :\n\t\t\t\tplugin;\n\t\t}\n\n\t\tfunction findAvailablePluginConstructors( plugins, processed = new Set() ) {\n\t\t\tplugins.forEach( plugin => {\n\t\t\t\tif ( !isPluginConstructor( plugin ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( processed.has( plugin ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tprocessed.add( plugin );\n\n\t\t\t\tif ( plugin.pluginName && !that._availablePlugins.has( plugin.pluginName ) ) {\n\t\t\t\t\tthat._availablePlugins.set( plugin.pluginName, plugin );\n\t\t\t\t}\n\n\t\t\t\tif ( plugin.requires ) {\n\t\t\t\t\tfindAvailablePluginConstructors( plugin.requires, processed );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tfunction getPluginConstructors( plugins, processed = new Set() ) {\n\t\t\treturn plugins\n\t\t\t\t.map( plugin => {\n\t\t\t\t\treturn isPluginConstructor( plugin ) ?\n\t\t\t\t\t\tplugin :\n\t\t\t\t\t\tthat._availablePlugins.get( plugin );\n\t\t\t\t} )\n\t\t\t\t.reduce( ( result, plugin ) => {\n\t\t\t\t\tif ( processed.has( plugin ) ) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t\tprocessed.add( plugin );\n\n\t\t\t\t\tif ( plugin.requires ) {\n\t\t\t\t\t\tvalidatePlugins( plugin.requires, plugin );\n\n\t\t\t\t\t\tgetPluginConstructors( plugin.requires, processed ).forEach( plugin => result.add( plugin ) );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result.add( plugin );\n\t\t\t\t}, new Set() );\n\t\t}\n\n\t\tfunction validatePlugins( plugins, parentPluginConstructor = null ) {\n\t\t\tplugins\n\t\t\t\t.map( plugin => {\n\t\t\t\t\treturn isPluginConstructor( plugin ) ?\n\t\t\t\t\t\tplugin :\n\t\t\t\t\t\tthat._availablePlugins.get( plugin ) || plugin;\n\t\t\t\t} )\n\t\t\t\t.forEach( plugin => {\n\t\t\t\t\tcheckMissingPlugin( plugin, parentPluginConstructor );\n\t\t\t\t\tcheckContextPlugin( plugin, parentPluginConstructor );\n\t\t\t\t\tcheckRemovedPlugin( plugin, parentPluginConstructor );\n\t\t\t\t} );\n\t\t}\n\n\t\tfunction checkMissingPlugin( plugin, parentPluginConstructor ) {\n\t\t\tif ( isPluginConstructor( plugin ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( parentPluginConstructor ) {\n\t\t\t\t/**\n\t\t\t\t * A required \"soft\" dependency was not found on the plugin list.\n\t\t\t\t *\n\t\t\t\t * When configuring the editor, either prior to building (via\n\t\t\t\t * {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}) or when\n\t\t\t\t * creating a new instance of the editor (e.g. via\n\t\t\t\t * {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`}), you need to provide\n\t\t\t\t * some of the dependencies for other plugins that you used.\n\t\t\t\t *\n\t\t\t\t * This error is thrown when one of these dependencies was not provided. The name of the missing plugin\n\t\t\t\t * can be found in `missingPlugin` and the plugin that required it in `requiredBy`.\n\t\t\t\t *\n\t\t\t\t * In order to resolve it, you need to import the missing plugin and add it to the\n\t\t\t\t * current list of plugins (`Editor.builtinPlugins` or `config.plugins`/`config.extraPlugins`).\n\t\t\t\t *\n\t\t\t\t * Soft requirements were introduced in version 26.0.0. If you happen to stumble upon this error\n\t\t\t\t * when upgrading to version 26.0.0, read also the\n\t\t\t\t * {@glink builds/guides/migration/migration-to-26 Migration to 26.0.0} guide.\n\t\t\t\t *\n\t\t\t\t * @error plugincollection-soft-required\n\t\t\t\t * @param {String} missingPlugin The name of the required plugin.\n\t\t\t\t * @param {String} requiredBy The name of the plugin that requires the other plugin.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'plugincollection-soft-required',\n\t\t\t\t\tcontext,\n\t\t\t\t\t{ missingPlugin: plugin, requiredBy: getPluginName( parentPluginConstructor ) }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * A plugin is not available and could not be loaded.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n\t\t\t * that you try to enable a plugin which was not included in that build. This may be due to a typo\n\t\t\t * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n\t\t\t * read more about {@glink builds/guides/development/custom-builds custom builds}.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n\t\t\t * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n\t\t\t * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n\t\t\t * provide each plugin through a reference (as a constructor function). Check out the examples in\n\t\t\t * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-found\n\t\t\t * @param {String} plugin The name of the plugin which could not be loaded.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-plugin-not-found',\n\t\t\t\tcontext,\n\t\t\t\t{ plugin }\n\t\t\t);\n\t\t}\n\n\t\tfunction checkContextPlugin( plugin, parentPluginConstructor ) {\n\t\t\tif ( !isContextPlugin( parentPluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isContextPlugin( plugin ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * If a plugin is a context plugin, all plugins it requires should also be context plugins\n\t\t\t * instead of plugins. In other words, if one plugin can be used in the context,\n\t\t\t * all its requirements should also be ready to be used in the context. Note that the context\n\t\t\t * provides only a part of the API provided by the editor. If one plugin needs a full\n\t\t\t * editor API, all plugins which require it are considered as plugins that need a full\n\t\t\t * editor API.\n\t\t\t *\n\t\t\t * @error plugincollection-context-required\n\t\t\t * @param {String} plugin The name of the required plugin.\n\t\t\t * @param {String} requiredBy The name of the parent plugin.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-context-required',\n\t\t\t\tcontext,\n\t\t\t\t{ plugin: getPluginName( plugin ), requiredBy: getPluginName( parentPluginConstructor ) }\n\t\t\t);\n\t\t}\n\n\t\tfunction checkRemovedPlugin( plugin, parentPluginConstructor ) {\n\t\t\tif ( !parentPluginConstructor ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !isPluginRemoved( plugin, pluginsToRemove ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n\t\t\t *\n\t\t\t * @error plugincollection-required\n\t\t\t * @param {String} plugin The name of the required plugin.\n\t\t\t * @param {String} requiredBy The name of the parent plugin.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-required',\n\t\t\t\tcontext,\n\t\t\t\t{ plugin: getPluginName( plugin ), requiredBy: getPluginName( parentPluginConstructor ) }\n\t\t\t);\n\t\t}\n\n\t\tfunction loadPlugins( pluginConstructors ) {\n\t\t\treturn pluginConstructors.map( PluginConstructor => {\n\t\t\t\tconst pluginInstance = that._contextPlugins.get( PluginConstructor ) || new PluginConstructor( context );\n\n\t\t\t\tthat._add( PluginConstructor, pluginInstance );\n\n\t\t\t\treturn pluginInstance;\n\t\t\t} );\n\t\t}\n\n\t\tfunction initPlugins( pluginInstances, method ) {\n\t\t\treturn pluginInstances.reduce( ( promise, plugin ) => {\n\t\t\t\tif ( !plugin[ method ] ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\tif ( that._contextPlugins.has( plugin ) ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\treturn promise.then( plugin[ method ].bind( plugin ) );\n\t\t\t}, Promise.resolve() );\n\t\t}\n\n\t\t// Replaces plugin constructors with the specified set of plugins.\n\t\t//\n\t\t// @param {Array.<Function>} pluginConstructors\n\t\t// @param {Array.<Function>} pluginsSubstitutions\n\t\tfunction substitutePlugins( pluginConstructors, pluginsSubstitutions ) {\n\t\t\tfor ( const pluginItem of pluginsSubstitutions ) {\n\t\t\t\tif ( typeof pluginItem != 'function' ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The plugin replacing an existing plugin must be a function.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-replace-plugin-invalid-type\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-replace-plugin-invalid-type', null, { pluginItem } );\n\t\t\t\t}\n\t\t\t\tconst pluginName = pluginItem.pluginName;\n\n\t\t\t\tif ( !pluginName ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The plugin replacing an existing plugin must have a name.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-replace-plugin-missing-name\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-replace-plugin-missing-name', null, { pluginItem } );\n\t\t\t\t}\n\n\t\t\t\tif ( pluginItem.requires && pluginItem.requires.length ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The plugin replacing an existing plugin cannot depend on other plugins.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-plugin-for-replacing-cannot-have-dependencies\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-plugin-for-replacing-cannot-have-dependencies', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tconst pluginToReplace = that._availablePlugins.get( pluginName );\n\n\t\t\t\tif ( !pluginToReplace ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The replaced plugin does not exist in the\n\t\t\t\t\t * {@link module:core/plugincollection~PluginCollection available plugins} collection.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-plugin-for-replacing-not-exist\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-plugin-for-replacing-not-exist', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tconst indexInPluginConstructors = pluginConstructors.indexOf( pluginToReplace );\n\n\t\t\t\tif ( indexInPluginConstructors === -1 ) {\n\t\t\t\t\t// The Context feature can substitute plugins as well.\n\t\t\t\t\t// It may happen that the editor will be created with the given context, where the plugin for substitute\n\t\t\t\t\t// was already replaced. In such a case, we don't want to do it again.\n\t\t\t\t\tif ( that._contextPlugins.has( pluginToReplace ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * The replaced plugin will not be loaded so it cannot be replaced.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-plugin-for-replacing-not-loaded\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-plugin-for-replacing-not-loaded', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tif ( pluginToReplace.requires && pluginToReplace.requires.length ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The replaced plugin cannot depend on other plugins.\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-replaced-plugin-cannot-have-dependencies\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError( 'plugincollection-replaced-plugin-cannot-have-dependencies', null, { pluginName } );\n\t\t\t\t}\n\n\t\t\t\tpluginConstructors.splice( indexInPluginConstructors, 1, pluginItem );\n\t\t\t\tthat._availablePlugins.set( pluginName, pluginItem );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys all loaded plugins.\n\t *\n\t * @returns {Promise}\n\t */\n\tdestroy() {\n\t\tconst promises = [];\n\n\t\tfor ( const [ , pluginInstance ] of this ) {\n\t\t\tif ( typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has( pluginInstance ) ) {\n\t\t\t\tpromises.push( pluginInstance.destroy() );\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all( promises );\n\t}\n\n\t/**\n\t * Adds the plugin to the collection. Exposed mainly for testing purposes.\n\t *\n\t * @protected\n\t * @param {Function} PluginConstructor The plugin constructor.\n\t * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n\t */\n\t_add( PluginConstructor, plugin ) {\n\t\tthis._plugins.set( PluginConstructor, plugin );\n\n\t\tconst pluginName = PluginConstructor.pluginName;\n\n\t\tif ( !pluginName ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._plugins.has( pluginName ) ) {\n\t\t\t/**\n\t\t\t * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n\t\t\t * This will lead to runtime conflicts between these plugins.\n\t\t\t *\n\t\t\t * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n\t\t\t * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n\t\t\t * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n\t\t\t *\n\t\t\t * Check your import paths and the list of plugins passed to\n\t\t\t * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n\t\t\t * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n\t\t\t *\n\t\t\t * The second option is that your `node_modules/` directory contains duplicated versions of the same\n\t\t\t * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n\t\t\t * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n\t\t\t * of some packages, their dependencies may need to be installed in more than one version which may lead to this\n\t\t\t * warning.\n\t\t\t *\n\t\t\t * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n\t\t\t * the dependencies of this plugin are being duplicated.\n\t\t\t * They are already built into that editor build and now get added for the second time as dependencies\n\t\t\t * of the plugin you are installing.\n\t\t\t *\n\t\t\t * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-name-conflict\n\t\t\t * @param {String} pluginName The duplicated plugin name.\n\t\t\t * @param {Function} plugin1 The first plugin constructor.\n\t\t\t * @param {Function} plugin2 The second plugin constructor.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-plugin-name-conflict',\n\t\t\t\tnull,\n\t\t\t\t{ pluginName, plugin1: this._plugins.get( pluginName ).constructor, plugin2: PluginConstructor }\n\t\t\t);\n\t\t}\n\n\t\tthis._plugins.set( pluginName, plugin );\n\t}\n}\n\nmix( PluginCollection, EmitterMixin );\n"]},"metadata":{},"sourceType":"module"}