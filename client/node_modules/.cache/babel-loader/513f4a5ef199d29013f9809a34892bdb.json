{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/matcher\n */\nimport { isPlainObject } from 'lodash-es';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\n\nexport default class Matcher {\n  /**\n   * Creates new instance of Matcher.\n   *\n   * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n   * more information.\n   */\n  constructor() {\n    /**\n     * @private\n     * @type {Array<String|RegExp|Object>}\n     */\n    this._patterns = [];\n    this.add(...arguments);\n  }\n  /**\n   * Adds pattern or patterns to matcher instance.\n   *\n   *\t\t// String.\n   *\t\tmatcher.add( 'div' );\n   *\n   *\t\t// Regular expression.\n   *\t\tmatcher.add( /^\\w/ );\n   *\n   *\t\t// Single class.\n   *\t\tmatcher.add( {\n   *\t\t\tclasses: 'foobar'\n   *\t\t} );\n   *\n   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n   *\n   * Multiple patterns can be added in one call:\n   *\n   * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n   *\n   * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n   * is provided it will be used to match element's name. Pattern can be also provided in a form\n   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n   * Function's return value will be stored under `match` key of the object returned from\n   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n   * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n   * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n   * represents attribute name. Value under that key can be either:\n   * * `true` - then attribute is just required (can be empty),\n   * * a string - then attribute has to be equal, or\n   * * a regular expression - then attribute has to match the expression.\n   * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n   * provided in a form of string or regular expression.\n   * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n   * represents style name. Value under that key can be either a string or a regular expression and it will be used\n   * to match style value.\n   */\n\n\n  add() {\n    for (var _len = arguments.length, pattern = new Array(_len), _key = 0; _key < _len; _key++) {\n      pattern[_key] = arguments[_key];\n    }\n\n    for (let item of pattern) {\n      // String or RegExp pattern is used as element's name.\n      if (typeof item == 'string' || item instanceof RegExp) {\n        item = {\n          name: item\n        };\n      }\n\n      this._patterns.push(item);\n    }\n  }\n  /**\n   * Matches elements for currently stored patterns. Returns match information about first found\n   * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n   *\n   * Example of returned object:\n   *\n   *\t\t{\n   *\t\t\telement: <instance of found element>,\n   *\t\t\tpattern: <pattern used to match found element>,\n   *\t\t\tmatch: {\n   *\t\t\t\tname: true,\n   *\t\t\t\tattributes: [ 'title', 'href' ],\n   *\t\t\t\tclasses: [ 'foo' ],\n   *\t\t\t\tstyles: [ 'color', 'position' ]\n   *\t\t\t}\n   *\t\t}\n   *\n   * @see module:engine/view/matcher~Matcher#add\n   * @see module:engine/view/matcher~Matcher#matchAll\n   * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n   * @returns {Object|null} result\n   * @returns {module:engine/view/element~Element} result.element Matched view element.\n   * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n   * @returns {Object} result.match Object representing matched element parts.\n   * @returns {Boolean} [result.match.name] True if name of the element was matched.\n   * @returns {Array} [result.match.attributes] Array with matched attribute names.\n   * @returns {Array} [result.match.classes] Array with matched class names.\n   * @returns {Array} [result.match.styles] Array with matched style names.\n   */\n\n\n  match() {\n    for (var _len2 = arguments.length, element = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      element[_key2] = arguments[_key2];\n    }\n\n    for (const singleElement of element) {\n      for (const pattern of this._patterns) {\n        const match = isElementMatching(singleElement, pattern);\n\n        if (match) {\n          return {\n            element: singleElement,\n            pattern,\n            match\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Matches elements for currently stored patterns. Returns array of match information with all found\n   * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n   *\n   * @see module:engine/view/matcher~Matcher#add\n   * @see module:engine/view/matcher~Matcher#match\n   * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n   * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n   * see {@link module:engine/view/matcher~Matcher#match match method} description.\n   */\n\n\n  matchAll() {\n    const results = [];\n\n    for (var _len3 = arguments.length, element = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      element[_key3] = arguments[_key3];\n    }\n\n    for (const singleElement of element) {\n      for (const pattern of this._patterns) {\n        const match = isElementMatching(singleElement, pattern);\n\n        if (match) {\n          results.push({\n            element: singleElement,\n            pattern,\n            match\n          });\n        }\n      }\n    }\n\n    return results.length > 0 ? results : null;\n  }\n  /**\n   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n   *\n   * @returns {String|null} Element name trying to match.\n   */\n\n\n  getElementName() {\n    if (this._patterns.length !== 1) {\n      return null;\n    }\n\n    const pattern = this._patterns[0];\n    const name = pattern.name;\n    return typeof pattern != 'function' && name && !(name instanceof RegExp) ? name : null;\n  }\n\n} // Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\n\nfunction isElementMatching(element, pattern) {\n  // If pattern is provided as function - return result of that function;\n  if (typeof pattern == 'function') {\n    return pattern(element);\n  }\n\n  const match = {}; // Check element's name.\n\n  if (pattern.name) {\n    match.name = matchName(pattern.name, element.name);\n\n    if (!match.name) {\n      return null;\n    }\n  } // Check element's attributes.\n\n\n  if (pattern.attributes) {\n    match.attributes = matchAttributes(pattern.attributes, element);\n\n    if (!match.attributes) {\n      return null;\n    }\n  } // Check element's classes.\n\n\n  if (pattern.classes) {\n    match.classes = matchClasses(pattern.classes, element);\n\n    if (!match.classes) {\n      return false;\n    }\n  } // Check element's styles.\n\n\n  if (pattern.styles) {\n    match.styles = matchStyles(pattern.styles, element);\n\n    if (!match.styles) {\n      return false;\n    }\n  }\n\n  return match;\n} // Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\n\n\nfunction matchName(pattern, name) {\n  // If pattern is provided as RegExp - test against this regexp.\n  if (pattern instanceof RegExp) {\n    return !!name.match(pattern);\n  }\n\n  return pattern === name;\n} // Checks if an array of key/value pairs can be matched against provided patterns.\n//\n// Patterns can be provided in a following ways:\n// \t- a boolean value matches any attribute with any value (or no value):\n//\n//\t\t\tpattern: true\n//\n//\t- a RegExp expression or object matches any attribute name:\n//\n//\t\t\tpattern: /h[1-6]/\n//\n//\t- an object matches any attribute that has the same name as the object item's key, where object item's value is:\n//\t\t- equal to `true`, which matches any attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trequired: true\n//\t\t\t}\n//\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trel: 'nofollow'\n//\t\t\t}\n//\n//\t\t- a regular expression that matches attribute value,\n//\n//\t\t\tpattern: {\n//\t\t\t\tsrc: /https.*/\n//\t\t\t}\n//\n//\t- an array with items, where the item is:\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: [ 'data-property-1', 'data-property-2' ],\n//\n//\t\t- an object with `key` and `value` property, where `key` is a regular expression matching attribute name and\n//\t\t  `value` is either regular expression matching attribute value or a string equal to attribute value:\n//\n//\t\t\tpattern: [\n//\t\t\t\t{ key: /data-property-.*/, value: true },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: 'foobar' },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: /foo.*/ }\n//\t\t\t]\n//\n// @param {Object} patterns Object with information about attributes to match.\n// @param {Iterable.<String>} keys Attribute, style or class keys.\n// @param {Function} valueGetter A function providing value for a given item key.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\n\n\nfunction matchPatterns(patterns, keys, valueGetter) {\n  const normalizedPatterns = normalizePatterns(patterns);\n  const normalizedItems = Array.from(keys);\n  const match = [];\n  normalizedPatterns.forEach(_ref => {\n    let [patternKey, patternValue] = _ref;\n    normalizedItems.forEach(itemKey => {\n      if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {\n        match.push(itemKey);\n      }\n    });\n  }); // Return matches only if there are at least as many of them as there are patterns.\n  // The RegExp pattern can match more than one item.\n\n  if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {\n    return null;\n  }\n\n  return match;\n} // Bring all the possible pattern forms to an array of arrays where first item is a key and second is a value.\n//\n// Examples:\n//\n// Boolean pattern value:\n//\n//\t\ttrue\n//\n// to\n//\n//\t\t[ [ true, true ] ]\n//\n// Textual pattern value:\n//\n//\t\t'attribute-name-or-class-or-style'\n//\n// to\n//\n//\t\t[ [ 'attribute-name-or-class-or-style', true ] ]\n//\n// Regular expression:\n//\n//\t\t/^data-.*$/\n//\n// to\n//\n//\t\t[ [ /^data-.*$/, true ] ]\n//\n// Objects (plain or with `key` and `value` specified explicitly):\n//\n//\t\t{\n//\t\t\tsrc: /^https:.*$/\n//\t\t}\n//\n// or\n//\n//\t\t[ {\n//\t\t\tkey: 'src',\n//\t\t\tvalue: /^https:.*$/\n//\t\t} ]\n//\n// to:\n//\n//\t\t[ [ 'src', /^https:.*$/ ] ]\n//\n// @param {Object|Array} patterns\n// @returns {Array|null} Returns an array of objects or null if provided patterns were not in an expected form.\n\n\nfunction normalizePatterns(patterns) {\n  if (Array.isArray(patterns)) {\n    return patterns.map(pattern => {\n      if (isPlainObject(pattern)) {\n        if (pattern.key === undefined || pattern.value === undefined) {\n          // Documented at the end of matcher.js.\n          logWarning('matcher-pattern-missing-key-or-value', pattern);\n        }\n\n        return [pattern.key, pattern.value];\n      } // Assume the pattern is either String or RegExp.\n\n\n      return [pattern, true];\n    });\n  }\n\n  if (isPlainObject(patterns)) {\n    return Object.entries(patterns);\n  } // Other cases (true, string or regexp).\n\n\n  return [[patterns, true]];\n} // @param {String|RegExp} patternKey A pattern representing a key we want to match.\n// @param {String} itemKey An actual item key (e.g. `'src'`, `'background-color'`, `'ck-widget'`) we're testing against pattern.\n// @returns {Boolean}\n\n\nfunction isKeyMatched(patternKey, itemKey) {\n  return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);\n} // @param {String|RegExp} patternValue A pattern representing a value we want to match.\n// @param {String} itemKey An item key, e.g. `background`, `href`, 'rel', etc.\n// @param {Function} valueGetter A function used to provide a value for a given `itemKey`.\n// @returns {Boolean}\n\n\nfunction isValueMatched(patternValue, itemKey, valueGetter) {\n  if (patternValue === true) {\n    return true;\n  }\n\n  const itemValue = valueGetter(itemKey); // For now, the reducers are not returning the full tree of properties.\n  // Casting to string preserves the old behavior until the root cause is fixed.\n  // More can be found in https://github.com/ckeditor/ckeditor5/issues/10399.\n\n  return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);\n} // Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\n\n\nfunction matchAttributes(patterns, element) {\n  const attributeKeys = new Set(element.getAttributeKeys()); // `style` and `class` attribute keys are deprecated. Only allow them in object pattern\n  // for backward compatibility.\n\n  if (isPlainObject(patterns)) {\n    if (patterns.style !== undefined) {\n      // Documented at the end of matcher.js.\n      logWarning('matcher-pattern-deprecated-attributes-style-key', patterns);\n    }\n\n    if (patterns.class !== undefined) {\n      // Documented at the end of matcher.js.\n      logWarning('matcher-pattern-deprecated-attributes-class-key', patterns);\n    }\n  } else {\n    attributeKeys.delete('style');\n    attributeKeys.delete('class');\n  }\n\n  return matchPatterns(patterns, attributeKeys, key => element.getAttribute(key));\n} // Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\n\n\nfunction matchClasses(patterns, element) {\n  // We don't need `getter` here because patterns for classes are always normalized to `[ className, true ]`.\n  return matchPatterns(patterns, element.getClassNames());\n} // Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\n\n\nfunction matchStyles(patterns, element) {\n  return matchPatterns(patterns, element.getStyleNames(true), key => element.getStyle(key));\n}\n/**\n * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize\n * if a view element fits in a group of view elements described by the pattern.\n *\n * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.\n *\n * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:\n *\n *\t\t// Match any element with name equal to 'div'.\n *\t\tconst pattern = 'div';\n *\n *\t\t// Match any element which name starts on 'p'.\n *\t\tconst pattern = /^p/;\n *\n * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.\n * If the view element does not meet all of the object's pattern properties, the match will not happen.\n * Available `Object` matching properties:\n *\n * Matching view element:\n *\n *\t\t// Match view element's name using String:\n *\t\tconst pattern = { name: 'p' };\n *\n *\t\t// or by providing RegExp:\n *\t\tconst pattern = { name: /^(ul|ol)$/ };\n *\n *\t\t// The name can also be skipped to match any view element with matching attributes:\n *\t\tconst pattern = {\n *\t\t\tattributes: {\n *\t\t\t\t'title': true\n *\t\t\t}\n *\t\t};\n *\n * Matching view element attributes:\n *\n *\t\t// Match view element with any attribute value.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: true\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: 'title' // Match title attribute (can be empty).\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: /^data-.*$/ // Match attributes starting with `data-` e.g. `data-foo` with any value (can be empty).\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: {\n *\t\t\t\ttitle: 'foobar',           // Match `title` attribute with 'foobar' value.\n *\t\t\t\talt: true,                 // Match `alt` attribute with any value (can be empty).\n *\t\t\t\t'data-type': /^(jpg|png)$/ // Match `data-type` attribute with `jpg` or `png` value.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: [\n *\t\t\t\t'title',    // Match `title` attribute (can be empty).\n *\t\t\t\t/^data-*$/, // Match attributes starting with `data-` e.g. `data-foo` with any value (can be empty).\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'input',\n *\t\t\tattributes: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'type',                     // Match `type` as an attribute key.\n *\t\t\t\t\tvalue: /^(text|number|date)$/ }, // Match `text`, `number` or `date` values.\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^data-.*$/,                // Match attributes starting with `data-` e.g. `data-foo`.\n *\t\t\t\t\tvalue: true                      // Match any value (can be empty).\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Matching view element styles:\n *\n *\t\t// Match view element with any style.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: true\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: 'color' // Match attributes with `color` style.\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: /^border.*$/ // Match view element with any border style.\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tcolor: /rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)/, // Match `color` in RGB format only.\n *\t\t\t\t'font-weight': 600,                              // Match `font-weight` only if it's `600`.\n *\t\t\t\t'text-decoration': true                          // Match any text decoration.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: [\n *\t\t\t\t'color',      // Match `color` with any value.\n *\t\t\t\t/^border.*$/, // Match all border properties.\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'color',                                    // Match `color` as an property key.\n *\t\t\t\t\tvalue: /rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)/, // Match RGB format only.\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^border.*$/, // Match any border style.\n *\t\t\t\t\tvalue: true        // Match any value.\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Matching view element classes:\n *\n *\t\t// Match view element with any class.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: true\n *\t\t};\n *\n *\t\t// Match view element which has matching class (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: 'highlighted' // Match `highlighted` class.\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: /^image-side-(left|right)$/ // Match `image-side-left` or `image-side-right` class.\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: {\n *\t\t\t\thighlighted: true, // Match `highlighted` class.\n *\t\t\t\tmarker: true       // Match `marker` class.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: [\n *\t\t\t\t'image',                    // Match `image` class.\n *\t\t\t\t/^image-side-(left|right)$/ // Match `image-side-left` or `image-side-right` class.\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'image', // Match `image` class.\n *\t\t\t\t\tvalue: true\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^image-side-(left|right)$/, // Match `image-side-left` or `image-side-right` class.\n *\t\t\t\t\tvalue: true\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Pattern can combine multiple properties allowing for more complex view element matching:\n *\n *\t\tconst pattern = {\n *\t\t\tname: 'span',\n *\t\t\tattributes: [ 'title' ],\n *\t\t\tstyles: {\n *\t\t\t\t'font-weight': 'bold'\n *\t\t\t},\n *\t\t\tclasses: 'highlighted'\n *\t\t};\n *\n * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and\n * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.\n * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object\n * returned by {@link ~Matcher#match} call.\n *\n *\t\t// Match an empty <div> element.\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'div' && element.childCount > 0 ) {\n *\t\t\t\t// Return which part of the element was matched.\n *\t\t\t\treturn { name: true };\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n *\t\t// Match a <p> element with big font (\"heading-like\" element).\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'p' ) {\n *\t\t\t\tconst fontSize = element.getStyle( 'font-size' );\n *\t\t\t\tconst size = fontSize.match( /(\\d+)/px );\n *\n *\t\t\t\tif ( size && Number( size[ 1 ] ) > 26 ) {\n *\t\t\t\t\treturn { name: true, attribute: [ 'font-size' ] };\n *\t\t\t\t}\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},\n * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.\n *\n * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern\n *\n * @property {String|RegExp} [name] View element name to match.\n * @property {String|RegExp|Array.<String|RegExp>} [classes] View element's class name(s) to match.\n * @property {Object} [styles] Object with key-value pairs representing styles to match.\n * Each object key represents style name. Value can be given as `String` or `RegExp`.\n * @property {Object} [attributes] Object with key-value pairs representing attributes to match.\n * Each object key represents attribute name. Value can be given as `String` or `RegExp`.\n */\n\n/**\n * The key-value matcher pattern is missing key or value. Both must be present.\n * Refer the documentation: {@link module:engine/view/matcher~MatcherPattern}.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-missing-key-or-value\n */\n\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `style` key.\n *\n * Use `styles` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tstyle: /^border.*$/\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tstyles: /^border.*$/\n * \t\t}\n *\n * Refer to the {@glink builds/guides/migration/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-style-key\n */\n\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `class` key.\n *\n * Use `classes` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tclass: 'foobar'\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tclasses: 'foobar'\n * \t\t}\n *\n * Refer to the {@glink builds/guides/migration/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and the {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-class-key\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js"],"names":["isPlainObject","logWarning","Matcher","constructor","_patterns","add","pattern","item","RegExp","name","push","match","element","singleElement","isElementMatching","matchAll","results","length","getElementName","matchName","attributes","matchAttributes","classes","matchClasses","styles","matchStyles","matchPatterns","patterns","keys","valueGetter","normalizedPatterns","normalizePatterns","normalizedItems","Array","from","forEach","patternKey","patternValue","itemKey","isKeyMatched","isValueMatched","isArray","map","key","undefined","value","Object","entries","itemValue","String","attributeKeys","Set","getAttributeKeys","style","class","delete","getAttribute","getClassNames","getStyleNames","getStyle"],"mappings":"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ATD,MASO;AACNuB,IAAAA,aAAa,CAACK,MAAd,CAAsB,OAAtB;AACAL,IAAAA,aAAa,CAACK,MAAd,CAAsB,OAAtB;AACA;;AAED,SAAO7B,aAAa,CAAEC,QAAF,EAAYuB,aAAZ,EAA2BP,GAAG,IAAI/B,OAAO,CAAC4C,YAAR,CAAsBb,GAAtB,CAAlC,CAApB;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASpB,YAAT,CAAuBI,QAAvB,EAAiCf,OAAjC,EAA2C;AAC1C;AACA,SAAOc,aAAa,CAAEC,QAAF,EAAYf,OAAO,CAAC6C,aAAR,EAAZ,CAApB;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAShC,WAAT,CAAsBE,QAAtB,EAAgCf,OAAhC,EAA0C;AACzC,SAAOc,aAAa,CAAEC,QAAF,EAAYf,OAAO,CAAC8C,aAAR,CAAuB,IAAvB,CAAZ,EAA2Cf,GAAG,IAAI/B,OAAO,CAAC+C,QAAR,CAAkBhB,GAAlB,CAAlD,CAApB;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/matcher\n */\n\nimport { isPlainObject } from 'lodash-es';\n\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\nexport default class Matcher {\n\t/**\n\t * Creates new instance of Matcher.\n\t *\n\t * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n\t * more information.\n\t */\n\tconstructor( ...pattern ) {\n\t\t/**\n\t\t * @private\n\t\t * @type {Array<String|RegExp|Object>}\n\t\t */\n\t\tthis._patterns = [];\n\n\t\tthis.add( ...pattern );\n\t}\n\n\t/**\n\t * Adds pattern or patterns to matcher instance.\n\t *\n\t *\t\t// String.\n\t *\t\tmatcher.add( 'div' );\n\t *\n\t *\t\t// Regular expression.\n\t *\t\tmatcher.add( /^\\w/ );\n\t *\n\t *\t\t// Single class.\n\t *\t\tmatcher.add( {\n\t *\t\t\tclasses: 'foobar'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n\t *\n\t * Multiple patterns can be added in one call:\n\t *\n\t * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n\t *\n\t * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n\t * is provided it will be used to match element's name. Pattern can be also provided in a form\n\t * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n\t * Function's return value will be stored under `match` key of the object returned from\n\t * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n\t * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n\t * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n\t * represents attribute name. Value under that key can be either:\n\t * * `true` - then attribute is just required (can be empty),\n\t * * a string - then attribute has to be equal, or\n\t * * a regular expression - then attribute has to match the expression.\n\t * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n\t * provided in a form of string or regular expression.\n\t * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n\t * represents style name. Value under that key can be either a string or a regular expression and it will be used\n\t * to match style value.\n\t */\n\tadd( ...pattern ) {\n\t\tfor ( let item of pattern ) {\n\t\t\t// String or RegExp pattern is used as element's name.\n\t\t\tif ( typeof item == 'string' || item instanceof RegExp ) {\n\t\t\t\titem = { name: item };\n\t\t\t}\n\n\t\t\tthis._patterns.push( item );\n\t\t}\n\t}\n\n\t/**\n\t * Matches elements for currently stored patterns. Returns match information about first found\n\t * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n\t *\n\t * Example of returned object:\n\t *\n\t *\t\t{\n\t *\t\t\telement: <instance of found element>,\n\t *\t\t\tpattern: <pattern used to match found element>,\n\t *\t\t\tmatch: {\n\t *\t\t\t\tname: true,\n\t *\t\t\t\tattributes: [ 'title', 'href' ],\n\t *\t\t\t\tclasses: [ 'foo' ],\n\t *\t\t\t\tstyles: [ 'color', 'position' ]\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * @see module:engine/view/matcher~Matcher#add\n\t * @see module:engine/view/matcher~Matcher#matchAll\n\t * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n\t * @returns {Object|null} result\n\t * @returns {module:engine/view/element~Element} result.element Matched view element.\n\t * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n\t * @returns {Object} result.match Object representing matched element parts.\n\t * @returns {Boolean} [result.match.name] True if name of the element was matched.\n\t * @returns {Array} [result.match.attributes] Array with matched attribute names.\n\t * @returns {Array} [result.match.classes] Array with matched class names.\n\t * @returns {Array} [result.match.styles] Array with matched style names.\n\t */\n\tmatch( ...element ) {\n\t\tfor ( const singleElement of element ) {\n\t\t\tfor ( const pattern of this._patterns ) {\n\t\t\t\tconst match = isElementMatching( singleElement, pattern );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: singleElement,\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\tmatch\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Matches elements for currently stored patterns. Returns array of match information with all found\n\t * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n\t *\n\t * @see module:engine/view/matcher~Matcher#add\n\t * @see module:engine/view/matcher~Matcher#match\n\t * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n\t * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n\t * see {@link module:engine/view/matcher~Matcher#match match method} description.\n\t */\n\tmatchAll( ...element ) {\n\t\tconst results = [];\n\n\t\tfor ( const singleElement of element ) {\n\t\t\tfor ( const pattern of this._patterns ) {\n\t\t\t\tconst match = isElementMatching( singleElement, pattern );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tresults.push( {\n\t\t\t\t\t\telement: singleElement,\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\tmatch\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn results.length > 0 ? results : null;\n\t}\n\n\t/**\n\t * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n\t * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n\t *\n\t * @returns {String|null} Element name trying to match.\n\t */\n\tgetElementName() {\n\t\tif ( this._patterns.length !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst pattern = this._patterns[ 0 ];\n\t\tconst name = pattern.name;\n\n\t\treturn ( typeof pattern != 'function' && name && !( name instanceof RegExp ) ) ? name : null;\n\t}\n}\n\n// Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\nfunction isElementMatching( element, pattern ) {\n\t// If pattern is provided as function - return result of that function;\n\tif ( typeof pattern == 'function' ) {\n\t\treturn pattern( element );\n\t}\n\n\tconst match = {};\n\t// Check element's name.\n\tif ( pattern.name ) {\n\t\tmatch.name = matchName( pattern.name, element.name );\n\n\t\tif ( !match.name ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Check element's attributes.\n\tif ( pattern.attributes ) {\n\t\tmatch.attributes = matchAttributes( pattern.attributes, element );\n\n\t\tif ( !match.attributes ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Check element's classes.\n\tif ( pattern.classes ) {\n\t\tmatch.classes = matchClasses( pattern.classes, element );\n\n\t\tif ( !match.classes ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Check element's styles.\n\tif ( pattern.styles ) {\n\t\tmatch.styles = matchStyles( pattern.styles, element );\n\n\t\tif ( !match.styles ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n// Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\nfunction matchName( pattern, name ) {\n\t// If pattern is provided as RegExp - test against this regexp.\n\tif ( pattern instanceof RegExp ) {\n\t\treturn !!name.match( pattern );\n\t}\n\n\treturn pattern === name;\n}\n\n// Checks if an array of key/value pairs can be matched against provided patterns.\n//\n// Patterns can be provided in a following ways:\n// \t- a boolean value matches any attribute with any value (or no value):\n//\n//\t\t\tpattern: true\n//\n//\t- a RegExp expression or object matches any attribute name:\n//\n//\t\t\tpattern: /h[1-6]/\n//\n//\t- an object matches any attribute that has the same name as the object item's key, where object item's value is:\n//\t\t- equal to `true`, which matches any attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trequired: true\n//\t\t\t}\n//\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trel: 'nofollow'\n//\t\t\t}\n//\n//\t\t- a regular expression that matches attribute value,\n//\n//\t\t\tpattern: {\n//\t\t\t\tsrc: /https.*/\n//\t\t\t}\n//\n//\t- an array with items, where the item is:\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: [ 'data-property-1', 'data-property-2' ],\n//\n//\t\t- an object with `key` and `value` property, where `key` is a regular expression matching attribute name and\n//\t\t  `value` is either regular expression matching attribute value or a string equal to attribute value:\n//\n//\t\t\tpattern: [\n//\t\t\t\t{ key: /data-property-.*/, value: true },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: 'foobar' },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: /foo.*/ }\n//\t\t\t]\n//\n// @param {Object} patterns Object with information about attributes to match.\n// @param {Iterable.<String>} keys Attribute, style or class keys.\n// @param {Function} valueGetter A function providing value for a given item key.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchPatterns( patterns, keys, valueGetter ) {\n\tconst normalizedPatterns = normalizePatterns( patterns );\n\tconst normalizedItems = Array.from( keys );\n\tconst match = [];\n\n\tnormalizedPatterns.forEach( ( [ patternKey, patternValue ] ) => {\n\t\tnormalizedItems.forEach( itemKey => {\n\t\t\tif (\n\t\t\t\tisKeyMatched( patternKey, itemKey ) &&\n\t\t\t\tisValueMatched( patternValue, itemKey, valueGetter )\n\t\t\t) {\n\t\t\t\tmatch.push( itemKey );\n\t\t\t}\n\t\t} );\n\t} );\n\n\t// Return matches only if there are at least as many of them as there are patterns.\n\t// The RegExp pattern can match more than one item.\n\tif ( !normalizedPatterns.length || match.length < normalizedPatterns.length ) {\n\t\treturn null;\n\t}\n\n\treturn match;\n}\n\n// Bring all the possible pattern forms to an array of arrays where first item is a key and second is a value.\n//\n// Examples:\n//\n// Boolean pattern value:\n//\n//\t\ttrue\n//\n// to\n//\n//\t\t[ [ true, true ] ]\n//\n// Textual pattern value:\n//\n//\t\t'attribute-name-or-class-or-style'\n//\n// to\n//\n//\t\t[ [ 'attribute-name-or-class-or-style', true ] ]\n//\n// Regular expression:\n//\n//\t\t/^data-.*$/\n//\n// to\n//\n//\t\t[ [ /^data-.*$/, true ] ]\n//\n// Objects (plain or with `key` and `value` specified explicitly):\n//\n//\t\t{\n//\t\t\tsrc: /^https:.*$/\n//\t\t}\n//\n// or\n//\n//\t\t[ {\n//\t\t\tkey: 'src',\n//\t\t\tvalue: /^https:.*$/\n//\t\t} ]\n//\n// to:\n//\n//\t\t[ [ 'src', /^https:.*$/ ] ]\n//\n// @param {Object|Array} patterns\n// @returns {Array|null} Returns an array of objects or null if provided patterns were not in an expected form.\nfunction normalizePatterns( patterns ) {\n\tif ( Array.isArray( patterns ) ) {\n\t\treturn patterns.map( pattern => {\n\t\t\tif ( isPlainObject( pattern ) ) {\n\t\t\t\tif ( pattern.key === undefined || pattern.value === undefined ) {\n\t\t\t\t\t// Documented at the end of matcher.js.\n\t\t\t\t\tlogWarning( 'matcher-pattern-missing-key-or-value', pattern );\n\t\t\t\t}\n\n\t\t\t\treturn [ pattern.key, pattern.value ];\n\t\t\t}\n\n\t\t\t// Assume the pattern is either String or RegExp.\n\t\t\treturn [ pattern, true ];\n\t\t} );\n\t}\n\n\tif ( isPlainObject( patterns ) ) {\n\t\treturn Object.entries( patterns );\n\t}\n\n\t// Other cases (true, string or regexp).\n\treturn [ [ patterns, true ] ];\n}\n\n// @param {String|RegExp} patternKey A pattern representing a key we want to match.\n// @param {String} itemKey An actual item key (e.g. `'src'`, `'background-color'`, `'ck-widget'`) we're testing against pattern.\n// @returns {Boolean}\nfunction isKeyMatched( patternKey, itemKey ) {\n\treturn patternKey === true ||\n\t\tpatternKey === itemKey ||\n\t\tpatternKey instanceof RegExp && itemKey.match( patternKey );\n}\n\n// @param {String|RegExp} patternValue A pattern representing a value we want to match.\n// @param {String} itemKey An item key, e.g. `background`, `href`, 'rel', etc.\n// @param {Function} valueGetter A function used to provide a value for a given `itemKey`.\n// @returns {Boolean}\nfunction isValueMatched( patternValue, itemKey, valueGetter ) {\n\tif ( patternValue === true ) {\n\t\treturn true;\n\t}\n\n\tconst itemValue = valueGetter( itemKey );\n\n\t// For now, the reducers are not returning the full tree of properties.\n\t// Casting to string preserves the old behavior until the root cause is fixed.\n\t// More can be found in https://github.com/ckeditor/ckeditor5/issues/10399.\n\treturn patternValue === itemValue ||\n\t\tpatternValue instanceof RegExp && !!String( itemValue ).match( patternValue );\n}\n\n// Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchAttributes( patterns, element ) {\n\tconst attributeKeys = new Set( element.getAttributeKeys() );\n\n\t// `style` and `class` attribute keys are deprecated. Only allow them in object pattern\n\t// for backward compatibility.\n\tif ( isPlainObject( patterns ) ) {\n\t\tif ( patterns.style !== undefined ) {\n\t\t\t// Documented at the end of matcher.js.\n\t\t\tlogWarning( 'matcher-pattern-deprecated-attributes-style-key', patterns );\n\t\t}\n\t\tif ( patterns.class !== undefined ) {\n\t\t\t// Documented at the end of matcher.js.\n\t\t\tlogWarning( 'matcher-pattern-deprecated-attributes-class-key', patterns );\n\t\t}\n\t} else {\n\t\tattributeKeys.delete( 'style' );\n\t\tattributeKeys.delete( 'class' );\n\t}\n\n\treturn matchPatterns( patterns, attributeKeys, key => element.getAttribute( key ) );\n}\n\n// Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\nfunction matchClasses( patterns, element ) {\n\t// We don't need `getter` here because patterns for classes are always normalized to `[ className, true ]`.\n\treturn matchPatterns( patterns, element.getClassNames() );\n}\n\n// Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\nfunction matchStyles( patterns, element ) {\n\treturn matchPatterns( patterns, element.getStyleNames( true ), key => element.getStyle( key ) );\n}\n\n/**\n * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize\n * if a view element fits in a group of view elements described by the pattern.\n *\n * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.\n *\n * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:\n *\n *\t\t// Match any element with name equal to 'div'.\n *\t\tconst pattern = 'div';\n *\n *\t\t// Match any element which name starts on 'p'.\n *\t\tconst pattern = /^p/;\n *\n * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.\n * If the view element does not meet all of the object's pattern properties, the match will not happen.\n * Available `Object` matching properties:\n *\n * Matching view element:\n *\n *\t\t// Match view element's name using String:\n *\t\tconst pattern = { name: 'p' };\n *\n *\t\t// or by providing RegExp:\n *\t\tconst pattern = { name: /^(ul|ol)$/ };\n *\n *\t\t// The name can also be skipped to match any view element with matching attributes:\n *\t\tconst pattern = {\n *\t\t\tattributes: {\n *\t\t\t\t'title': true\n *\t\t\t}\n *\t\t};\n *\n * Matching view element attributes:\n *\n *\t\t// Match view element with any attribute value.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: true\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: 'title' // Match title attribute (can be empty).\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: /^data-.*$/ // Match attributes starting with `data-` e.g. `data-foo` with any value (can be empty).\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: {\n *\t\t\t\ttitle: 'foobar',           // Match `title` attribute with 'foobar' value.\n *\t\t\t\talt: true,                 // Match `alt` attribute with any value (can be empty).\n *\t\t\t\t'data-type': /^(jpg|png)$/ // Match `data-type` attribute with `jpg` or `png` value.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: [\n *\t\t\t\t'title',    // Match `title` attribute (can be empty).\n *\t\t\t\t/^data-*$/, // Match attributes starting with `data-` e.g. `data-foo` with any value (can be empty).\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'input',\n *\t\t\tattributes: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'type',                     // Match `type` as an attribute key.\n *\t\t\t\t\tvalue: /^(text|number|date)$/ }, // Match `text`, `number` or `date` values.\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^data-.*$/,                // Match attributes starting with `data-` e.g. `data-foo`.\n *\t\t\t\t\tvalue: true                      // Match any value (can be empty).\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Matching view element styles:\n *\n *\t\t// Match view element with any style.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: true\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: 'color' // Match attributes with `color` style.\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: /^border.*$/ // Match view element with any border style.\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tcolor: /rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)/, // Match `color` in RGB format only.\n *\t\t\t\t'font-weight': 600,                              // Match `font-weight` only if it's `600`.\n *\t\t\t\t'text-decoration': true                          // Match any text decoration.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: [\n *\t\t\t\t'color',      // Match `color` with any value.\n *\t\t\t\t/^border.*$/, // Match all border properties.\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'color',                                    // Match `color` as an property key.\n *\t\t\t\t\tvalue: /rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)/, // Match RGB format only.\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^border.*$/, // Match any border style.\n *\t\t\t\t\tvalue: true        // Match any value.\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Matching view element classes:\n *\n *\t\t// Match view element with any class.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: true\n *\t\t};\n *\n *\t\t// Match view element which has matching class (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: 'highlighted' // Match `highlighted` class.\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: /^image-side-(left|right)$/ // Match `image-side-left` or `image-side-right` class.\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: {\n *\t\t\t\thighlighted: true, // Match `highlighted` class.\n *\t\t\t\tmarker: true       // Match `marker` class.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: [\n *\t\t\t\t'image',                    // Match `image` class.\n *\t\t\t\t/^image-side-(left|right)$/ // Match `image-side-left` or `image-side-right` class.\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'image', // Match `image` class.\n *\t\t\t\t\tvalue: true\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^image-side-(left|right)$/, // Match `image-side-left` or `image-side-right` class.\n *\t\t\t\t\tvalue: true\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Pattern can combine multiple properties allowing for more complex view element matching:\n *\n *\t\tconst pattern = {\n *\t\t\tname: 'span',\n *\t\t\tattributes: [ 'title' ],\n *\t\t\tstyles: {\n *\t\t\t\t'font-weight': 'bold'\n *\t\t\t},\n *\t\t\tclasses: 'highlighted'\n *\t\t};\n *\n * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and\n * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.\n * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object\n * returned by {@link ~Matcher#match} call.\n *\n *\t\t// Match an empty <div> element.\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'div' && element.childCount > 0 ) {\n *\t\t\t\t// Return which part of the element was matched.\n *\t\t\t\treturn { name: true };\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n *\t\t// Match a <p> element with big font (\"heading-like\" element).\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'p' ) {\n *\t\t\t\tconst fontSize = element.getStyle( 'font-size' );\n *\t\t\t\tconst size = fontSize.match( /(\\d+)/px );\n *\n *\t\t\t\tif ( size && Number( size[ 1 ] ) > 26 ) {\n *\t\t\t\t\treturn { name: true, attribute: [ 'font-size' ] };\n *\t\t\t\t}\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},\n * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.\n *\n * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern\n *\n * @property {String|RegExp} [name] View element name to match.\n * @property {String|RegExp|Array.<String|RegExp>} [classes] View element's class name(s) to match.\n * @property {Object} [styles] Object with key-value pairs representing styles to match.\n * Each object key represents style name. Value can be given as `String` or `RegExp`.\n * @property {Object} [attributes] Object with key-value pairs representing attributes to match.\n * Each object key represents attribute name. Value can be given as `String` or `RegExp`.\n */\n\n/**\n * The key-value matcher pattern is missing key or value. Both must be present.\n * Refer the documentation: {@link module:engine/view/matcher~MatcherPattern}.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-missing-key-or-value\n */\n\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `style` key.\n *\n * Use `styles` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tstyle: /^border.*$/\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tstyles: /^border.*$/\n * \t\t}\n *\n * Refer to the {@glink builds/guides/migration/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-style-key\n */\n\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `class` key.\n *\n * Use `classes` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tclass: 'foobar'\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tclasses: 'foobar'\n * \t\t}\n *\n * Refer to the {@glink builds/guides/migration/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and the {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-class-key\n */\n"]},"metadata":{},"sourceType":"module"}