{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/document\n */\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport BubblingEmitterMixin from './observer/bubblingemittermixin';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin'; // @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\n/**\n * Document class creates an abstract layer over the content editable area, contains a tree of view elements and\n * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.\n *\n * @mixes module:engine/view/observer/bubblingemittermixin~BubblingEmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class Document {\n  /**\n   * Creates a Document instance.\n   *\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  constructor(stylesProcessor) {\n    /**\n     * Selection done on this document.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection\n     */\n    this.selection = new DocumentSelection();\n    /**\n     * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.\n     *\n     * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and\n     * {@link module:engine/model/document~Document#roots} and this is handled by\n     * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create\n     * model root using {@link module:engine/model/document~Document#createRoot}.\n     *\n     * @readonly\n     * @member {module:utils/collection~Collection} module:engine/view/document~Document#roots\n     */\n\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The styles processor instance used by this document when normalizing styles.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Defines whether document is in read-only mode.\n     *\n     * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.\n     *\n     * @observable\n     * @member {Boolean} #isReadOnly\n     */\n\n    this.set('isReadOnly', false);\n    /**\n     * True if document is focused.\n     *\n     * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.\n     * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isFocused\n     */\n\n    this.set('isFocused', false);\n    /**\n     * `true` while the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n     * When they stop selecting, the property goes back to `false`.\n     *\n     * This property is updated by the {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isSelecting\n     */\n\n    this.set('isSelecting', false);\n    /**\n     * True if composition is in progress inside the document.\n     *\n     * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n     * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isComposing\n     */\n\n    this.set('isComposing', false);\n    /**\n     * Post-fixer callbacks registered to the view document.\n     *\n     * @private\n     * @member {Set}\n     */\n\n    this._postFixers = new Set();\n  }\n  /**\n   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not\n   * specific \"main\" root is returned.\n   *\n   * @param {String} [name='main'] Name of the root.\n   * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name\n   * or null when there is no root of given name.\n   */\n\n\n  getRoot() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n    return this.roots.get(name);\n  }\n  /**\n   * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered\n   * to the DOM.\n   *\n   * Post-fixers are executed right after all changes from the outermost change block were applied but\n   * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made\n   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n   * not be fixed in the new document tree state.\n   *\n   * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that\n   * changes executed in a view post-fixer should not break model-view mapping.\n   *\n   * The types of changes which should be safe:\n   *\n   * * adding or removing attribute from elements,\n   * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},\n   * * {@link module:engine/model/differ~Differ#refreshItem marking some of the model elements to be re-converted}.\n   *\n   * Try to avoid changes which touch view structure:\n   *\n   * * you should not add or remove nor wrap or unwrap any view elements,\n   * * you should not change the editor data model in a view post-fixer.\n   *\n   * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.\n   *\n   * Typically, a post-fixer will look like this:\n   *\n   *\t\teditor.editing.view.document.registerPostFixer( writer => {\n   *\t\t\tif ( checkSomeCondition() ) {\n   *\t\t\t\twriter.doSomething();\n   *\n   *\t\t\t\t// Let other post-fixers know that something changed.\n   *\t\t\t\treturn true;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).\n   * That is because adding a post-fixer does not execute it.\n   * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.\n   * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling\n   * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.\n   *\n   * If you need to register a callback which is executed when DOM elements are already updated,\n   * use {@link module:engine/view/view~View#event:render render event}.\n   *\n   * @param {Function} postFixer\n   */\n\n\n  registerPostFixer(postFixer) {\n    this._postFixers.add(postFixer);\n  }\n  /**\n   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n   */\n\n\n  destroy() {\n    this.roots.map(root => root.destroy());\n    this.stopListening();\n  }\n  /**\n   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n   *\n   * @protected\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n   */\n\n\n  _callPostFixers(writer) {\n    let wasFixed = false;\n\n    do {\n      for (const callback of this._postFixers) {\n        wasFixed = callback(writer);\n\n        if (wasFixed) {\n          break;\n        }\n      }\n    } while (wasFixed);\n  }\n  /**\n   * Event fired whenever document content layout changes. It is fired whenever content is\n   * {@link module:engine/view/view~View#event:render rendered}, but should be also fired by observers in case of\n   * other actions which may change layout, for instance when image loads.\n   *\n   * @event layoutChanged\n   */\n  // @if CK_DEBUG_ENGINE // log( version ) {\n  // @if CK_DEBUG_ENGINE //\tlogDocument( this, version );\n  // @if CK_DEBUG_ENGINE // }\n\n\n}\nmix(Document, BubblingEmitterMixin);\nmix(Document, ObservableMixin);\n/**\n * Enum representing type of the change.\n *\n * Possible values:\n *\n * * `children` - for child list changes,\n * * `attributes` - for element attributes changes,\n * * `text` - for text nodes changes.\n *\n * @typedef {String} module:engine/view/document~ChangeType\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/document.js"],"names":["DocumentSelection","Collection","mix","BubblingEmitterMixin","ObservableMixin","Document","constructor","stylesProcessor","selection","roots","idProperty","set","_postFixers","Set","getRoot","name","get","registerPostFixer","postFixer","add","destroy","map","root","stopListening","_callPostFixers","writer","wasFixed","callback"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/document\n */\n\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport BubblingEmitterMixin from './observer/bubblingemittermixin';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\n\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\n/**\n * Document class creates an abstract layer over the content editable area, contains a tree of view elements and\n * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.\n *\n * @mixes module:engine/view/observer/bubblingemittermixin~BubblingEmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Document {\n\t/**\n\t * Creates a Document instance.\n\t *\n\t * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n\t */\n\tconstructor( stylesProcessor ) {\n\t\t/**\n\t\t * Selection done on this document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection\n\t\t */\n\t\tthis.selection = new DocumentSelection();\n\n\t\t/**\n\t\t * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.\n\t\t *\n\t\t * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and\n\t\t * {@link module:engine/model/document~Document#roots} and this is handled by\n\t\t * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create\n\t\t * model root using {@link module:engine/model/document~Document#createRoot}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/collection~Collection} module:engine/view/document~Document#roots\n\t\t */\n\t\tthis.roots = new Collection( { idProperty: 'rootName' } );\n\n\t\t/**\n\t\t * The styles processor instance used by this document when normalizing styles.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis.stylesProcessor = stylesProcessor;\n\n\t\t/**\n\t\t * Defines whether document is in read-only mode.\n\t\t *\n\t\t * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isReadOnly\n\t\t */\n\t\tthis.set( 'isReadOnly', false );\n\n\t\t/**\n\t\t * True if document is focused.\n\t\t *\n\t\t * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.\n\t\t * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} module:engine/view/document~Document#isFocused\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * `true` while the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n\t\t * When they stop selecting, the property goes back to `false`.\n\t\t *\n\t\t * This property is updated by the {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} module:engine/view/document~Document#isSelecting\n\t\t */\n\t\tthis.set( 'isSelecting', false );\n\n\t\t/**\n\t\t * True if composition is in progress inside the document.\n\t\t *\n\t\t * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n\t\t * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} module:engine/view/document~Document#isComposing\n\t\t */\n\t\tthis.set( 'isComposing', false );\n\n\t\t/**\n\t\t * Post-fixer callbacks registered to the view document.\n\t\t *\n\t\t * @private\n\t\t * @member {Set}\n\t\t */\n\t\tthis._postFixers = new Set();\n\t}\n\n\t/**\n\t * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not\n\t * specific \"main\" root is returned.\n\t *\n\t * @param {String} [name='main'] Name of the root.\n\t * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name\n\t * or null when there is no root of given name.\n\t */\n\tgetRoot( name = 'main' ) {\n\t\treturn this.roots.get( name );\n\t}\n\n\t/**\n\t * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered\n\t * to the DOM.\n\t *\n\t * Post-fixers are executed right after all changes from the outermost change block were applied but\n\t * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made\n\t * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n\t * not be fixed in the new document tree state.\n\t *\n\t * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that\n\t * changes executed in a view post-fixer should not break model-view mapping.\n\t *\n\t * The types of changes which should be safe:\n\t *\n\t * * adding or removing attribute from elements,\n\t * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},\n\t * * {@link module:engine/model/differ~Differ#refreshItem marking some of the model elements to be re-converted}.\n\t *\n\t * Try to avoid changes which touch view structure:\n\t *\n\t * * you should not add or remove nor wrap or unwrap any view elements,\n\t * * you should not change the editor data model in a view post-fixer.\n\t *\n\t * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.\n\t *\n\t * Typically, a post-fixer will look like this:\n\t *\n\t *\t\teditor.editing.view.document.registerPostFixer( writer => {\n\t *\t\t\tif ( checkSomeCondition() ) {\n\t *\t\t\t\twriter.doSomething();\n\t *\n\t *\t\t\t\t// Let other post-fixers know that something changed.\n\t *\t\t\t\treturn true;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).\n\t * That is because adding a post-fixer does not execute it.\n\t * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.\n\t * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling\n\t * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.\n\t *\n\t * If you need to register a callback which is executed when DOM elements are already updated,\n\t * use {@link module:engine/view/view~View#event:render render event}.\n\t *\n\t * @param {Function} postFixer\n\t */\n\tregisterPostFixer( postFixer ) {\n\t\tthis._postFixers.add( postFixer );\n\t}\n\n\t/**\n\t * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n\t */\n\tdestroy() {\n\t\tthis.roots.map( root => root.destroy() );\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n\t *\n\t * @protected\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\t */\n\t_callPostFixers( writer ) {\n\t\tlet wasFixed = false;\n\n\t\tdo {\n\t\t\tfor ( const callback of this._postFixers ) {\n\t\t\t\twasFixed = callback( writer );\n\n\t\t\t\tif ( wasFixed ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( wasFixed );\n\t}\n\n\t/**\n\t * Event fired whenever document content layout changes. It is fired whenever content is\n\t * {@link module:engine/view/view~View#event:render rendered}, but should be also fired by observers in case of\n\t * other actions which may change layout, for instance when image loads.\n\t *\n\t * @event layoutChanged\n\t */\n\n\t// @if CK_DEBUG_ENGINE // log( version ) {\n\t// @if CK_DEBUG_ENGINE //\tlogDocument( this, version );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\nmix( Document, BubblingEmitterMixin );\nmix( Document, ObservableMixin );\n\n/**\n * Enum representing type of the change.\n *\n * Possible values:\n *\n * * `children` - for child list changes,\n * * `attributes` - for element attributes changes,\n * * `text` - for text nodes changes.\n *\n * @typedef {String} module:engine/view/document~ChangeType\n */\n"]},"metadata":{},"sourceType":"module"}