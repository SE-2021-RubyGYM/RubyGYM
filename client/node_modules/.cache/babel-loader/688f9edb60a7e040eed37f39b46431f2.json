{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/resizeobserver\n */\n\n/* globals setTimeout, clearTimeout */\nimport mix from '../mix';\nimport global from './global';\nimport Rect from './rect';\nimport DomEmitterMixin from './emittermixin';\nconst RESIZE_CHECK_INTERVAL = 100;\n/**\n * A helper class which instances allow performing custom actions when native DOM elements are resized.\n *\n *\t\tconst editableElement = editor.editing.view.getDomRoot();\n *\n *\t\tconst observer = new ResizeObserver( editableElement, entry => {\n *\t\t\tconsole.log( 'The editable element has been resized in DOM.' );\n *\t\t\tconsole.log( entry.target ); // -> editableElement\n *\t\t\tconsole.log( entry.contentRect.width ); // -> e.g. '423px'\n *\t\t} );\n *\n * By default, it uses the [native DOM resize observer](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)\n * under the hood and in browsers that do not support the native API yet, a polyfilled observer is\n * used instead.\n */\n\nexport default class ResizeObserver {\n  /**\n   * Creates an instance of the `ResizeObserver` class.\n   *\n   * @param {HTMLElement} element A DOM element that is to be observed for resizing. Note that\n   * the element must be visible (i.e. not detached from DOM) for the observer to work.\n   * @param {Function} callback A function called when the observed element was resized. It passes\n   * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)\n   * object with information about the resize event.\n   */\n  constructor(element, callback) {\n    // **Note**: For the maximum performance, this class ensures only a single instance of the native\n    // (or polyfilled) observer is used no matter how many instances of this class were created.\n    if (!ResizeObserver._observerInstance) {\n      ResizeObserver._createObserver();\n    }\n    /**\n     * The element observer by this observer.\n     *\n     * @readonly\n     * @private\n     * @member {HTMLElement}\n     */\n\n\n    this._element = element;\n    /**\n     * The callback executed each time {@link #_element} is resized.\n     *\n     * @readonly\n     * @private\n     * @member {Function}\n     */\n\n    this._callback = callback;\n\n    ResizeObserver._addElementCallback(element, callback);\n\n    ResizeObserver._observerInstance.observe(element);\n  }\n  /**\n   * Destroys the observer which disables the `callback` passed to the {@link #constructor}.\n   */\n\n\n  destroy() {\n    ResizeObserver._deleteElementCallback(this._element, this._callback);\n  }\n  /**\n   * Registers a new resize callback for the DOM element.\n   *\n   * @private\n   * @static\n   * @param {HTMLElement} element\n   * @param {Function} callback\n   */\n\n\n  static _addElementCallback(element, callback) {\n    if (!ResizeObserver._elementCallbacks) {\n      ResizeObserver._elementCallbacks = new Map();\n    }\n\n    let callbacks = ResizeObserver._elementCallbacks.get(element);\n\n    if (!callbacks) {\n      callbacks = new Set();\n\n      ResizeObserver._elementCallbacks.set(element, callbacks);\n    }\n\n    callbacks.add(callback);\n  }\n  /**\n   * Removes a resize callback from the DOM element. If no callbacks are left\n   * for the element, it removes the element from the native observer.\n   *\n   * @private\n   * @static\n   * @param {HTMLElement} element\n   * @param {Function} callback\n   */\n\n\n  static _deleteElementCallback(element, callback) {\n    const callbacks = ResizeObserver._getElementCallbacks(element); // Remove the element callback. Check if exist first in case someone\n    // called destroy() twice.\n\n\n    if (callbacks) {\n      callbacks.delete(callback); // If no callbacks left for the element, also remove the element.\n\n      if (!callbacks.size) {\n        ResizeObserver._elementCallbacks.delete(element);\n\n        ResizeObserver._observerInstance.unobserve(element);\n      }\n    }\n\n    if (ResizeObserver._elementCallbacks && !ResizeObserver._elementCallbacks.size) {\n      ResizeObserver._observerInstance = null;\n      ResizeObserver._elementCallbacks = null;\n    }\n  }\n  /**\n   * Returns are registered resize callbacks for the DOM element.\n   *\n   * @private\n   * @static\n   * @param {HTMLElement} element\n   * @returns {Set.<HTMLElement>|null}\n   */\n\n\n  static _getElementCallbacks(element) {\n    if (!ResizeObserver._elementCallbacks) {\n      return null;\n    }\n\n    return ResizeObserver._elementCallbacks.get(element);\n  }\n  /**\n   * Creates the single native observer shared across all `ResizeObserver` instances.\n   * If the browser does not support the native API, it creates a polyfill.\n   *\n   * @private\n   * @static\n   */\n\n\n  static _createObserver() {\n    let ObserverConstructor; // TODO: One day, the `ResizeObserver` API will be supported in all modern web browsers.\n    // When it happens, this module will no longer make sense and should be removed and\n    // the native implementation should be used across the project to save bytes.\n    // Check out https://caniuse.com/#feat=resizeobserver.\n\n    if (typeof global.window.ResizeObserver === 'function') {\n      ObserverConstructor = global.window.ResizeObserver;\n    } else {\n      ObserverConstructor = ResizeObserverPolyfill;\n    }\n\n    ResizeObserver._observerInstance = new ObserverConstructor(entries => {\n      for (const entry of entries) {\n        const callbacks = ResizeObserver._getElementCallbacks(entry.target);\n\n        if (callbacks) {\n          for (const callback of callbacks) {\n            callback(entry);\n          }\n        }\n      }\n    });\n  }\n\n}\n/**\n * The single native observer instance (or polyfill in browsers that do not support the API)\n * shared across all {@link module:utils/dom/resizeobserver~ResizeObserver} instances.\n *\n * @static\n * @protected\n * @readonly\n * @property {Object|null} module:utils/dom/resizeobserver~ResizeObserver#_observerInstance\n */\n\nResizeObserver._observerInstance = null;\n/**\n * A mapping of native DOM elements and their callbacks shared across all\n * {@link module:utils/dom/resizeobserver~ResizeObserver} instances.\n *\n * @static\n * @private\n * @readonly\n * @property {Map.<HTMLElement,Set>|null} module:utils/dom/resizeobserver~ResizeObserver#_elementCallbacks\n */\n\nResizeObserver._elementCallbacks = null;\n/**\n * A polyfill class for the native [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver).\n *\n * @private\n * @mixes module:utils/domemittermixin~DomEmitterMixin\n */\n\nclass ResizeObserverPolyfill {\n  /**\n   * Creates an instance of the {@link module:utils/dom/resizeobserver~ResizeObserverPolyfill} class.\n   *\n   * It synchronously reacts to resize of the window to check if observed elements' geometry changed.\n   *\n   * Additionally, the polyfilled observer uses a timeout to check if observed elements' geometry has changed\n   * in some other way (dynamic layouts, scrollbars showing up, etc.), so its response can also be asynchronous.\n   *\n   * @param {Function} callback A function called when any observed element was resized. Refer to the\n   * native [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) API to\n   * learn more.\n   */\n  constructor(callback) {\n    /**\n     * A function called when any observed {@link #_elements element} was resized.\n     *\n     * @readonly\n     * @protected\n     * @member {Function}\n     */\n    this._callback = callback;\n    /**\n     * DOM elements currently observed by the observer instance.\n     *\n     * @readonly\n     * @protected\n     * @member {Set}\n     */\n\n    this._elements = new Set();\n    /**\n     * Cached DOM {@link #_elements elements} bounding rects to compare to upon the next check.\n     *\n     * @readonly\n     * @protected\n     * @member {Map.<HTMLElement,module:utils/dom/rect~Rect>}\n     */\n\n    this._previousRects = new Map();\n    /**\n     * An UID of the current timeout upon which the observed elements rects\n     * will be compared to the {@link #_previousRects previous rects} from the past.\n     *\n     * @readonly\n     * @protected\n     * @member {Map.<HTMLElement,module:utils/dom/rect~Rect>}\n     */\n\n    this._periodicCheckTimeout = null;\n  }\n  /**\n   * Starts observing a DOM element.\n   *\n   * Learn more in the\n   * [native method documentation](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe).\n   *\n   * @param {HTMLElement} element\n   */\n\n\n  observe(element) {\n    this._elements.add(element);\n\n    this._checkElementRectsAndExecuteCallback();\n\n    if (this._elements.size === 1) {\n      this._startPeriodicCheck();\n    }\n  }\n  /**\n   * Stops observing a DOM element.\n   *\n   * Learn more in the\n   * [native method documentation](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/unobserve).\n   *\n   * @param {HTMLElement} element\n   */\n\n\n  unobserve(element) {\n    this._elements.delete(element);\n\n    this._previousRects.delete(element);\n\n    if (!this._elements.size) {\n      this._stopPeriodicCheck();\n    }\n  }\n  /**\n   * When called, the observer calls the {@link #_callback resize callback} for all observed\n   * {@link #_elements elements} but also starts checking periodically for changes in the elements' geometry.\n   * If some are detected, {@link #_callback resize callback} is called for relevant elements that were resized.\n   *\n   * @protected\n   */\n\n\n  _startPeriodicCheck() {\n    const periodicCheck = () => {\n      this._checkElementRectsAndExecuteCallback();\n\n      this._periodicCheckTimeout = setTimeout(periodicCheck, RESIZE_CHECK_INTERVAL);\n    };\n\n    this.listenTo(global.window, 'resize', () => {\n      this._checkElementRectsAndExecuteCallback();\n    });\n    this._periodicCheckTimeout = setTimeout(periodicCheck, RESIZE_CHECK_INTERVAL);\n  }\n  /**\n   * Stops checking for changes in all observed {@link #_elements elements} geometry.\n   *\n   * @protected\n   */\n\n\n  _stopPeriodicCheck() {\n    clearTimeout(this._periodicCheckTimeout);\n    this.stopListening();\n\n    this._previousRects.clear();\n  }\n  /**\n   * Checks if the geometry of any of the {@link #_elements element} has changed. If so, executes\n   * the {@link #_callback resize callback} with element geometry data.\n   *\n   * @protected\n   */\n\n\n  _checkElementRectsAndExecuteCallback() {\n    const entries = [];\n\n    for (const element of this._elements) {\n      if (this._hasRectChanged(element)) {\n        entries.push({\n          target: element,\n          contentRect: this._previousRects.get(element)\n        });\n      }\n    }\n\n    if (entries.length) {\n      this._callback(entries);\n    }\n  }\n  /**\n   * Compares the DOM element geometry to the {@link #_previousRects cached geometry} from the past.\n   * Returns `true` if geometry has changed or the element is checked for the first time.\n   *\n   * @protected\n   * @param {HTMLElement} element\n   * @returns {Boolean}\n   */\n\n\n  _hasRectChanged(element) {\n    if (!element.ownerDocument.body.contains(element)) {\n      return false;\n    }\n\n    const currentRect = new Rect(element);\n\n    const previousRect = this._previousRects.get(element); // The first check should always yield true despite no Previous rect to compare to.\n    // The native ResizeObserver does that and... that makes sense. Sort of.\n\n\n    const hasChanged = !previousRect || !previousRect.isEqual(currentRect);\n\n    this._previousRects.set(element, currentRect);\n\n    return hasChanged;\n  }\n\n}\n\nmix(ResizeObserverPolyfill, DomEmitterMixin);","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/dom/resizeobserver.js"],"names":["mix","global","Rect","DomEmitterMixin","RESIZE_CHECK_INTERVAL","ResizeObserver","constructor","element","callback","_observerInstance","_createObserver","_element","_callback","_addElementCallback","observe","destroy","_deleteElementCallback","_elementCallbacks","Map","callbacks","get","Set","set","add","_getElementCallbacks","delete","size","unobserve","ObserverConstructor","window","ResizeObserverPolyfill","entries","entry","target","_elements","_previousRects","_periodicCheckTimeout","_checkElementRectsAndExecuteCallback","_startPeriodicCheck","_stopPeriodicCheck","periodicCheck","setTimeout","listenTo","clearTimeout","stopListening","clear","_hasRectChanged","push","contentRect","length","ownerDocument","body","contains","currentRect","previousRect","hasChanged","isEqual"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/resizeobserver\n */\n\n/* globals setTimeout, clearTimeout */\n\nimport mix from '../mix';\nimport global from './global';\nimport Rect from './rect';\nimport DomEmitterMixin from './emittermixin';\n\nconst RESIZE_CHECK_INTERVAL = 100;\n\n/**\n * A helper class which instances allow performing custom actions when native DOM elements are resized.\n *\n *\t\tconst editableElement = editor.editing.view.getDomRoot();\n *\n *\t\tconst observer = new ResizeObserver( editableElement, entry => {\n *\t\t\tconsole.log( 'The editable element has been resized in DOM.' );\n *\t\t\tconsole.log( entry.target ); // -> editableElement\n *\t\t\tconsole.log( entry.contentRect.width ); // -> e.g. '423px'\n *\t\t} );\n *\n * By default, it uses the [native DOM resize observer](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)\n * under the hood and in browsers that do not support the native API yet, a polyfilled observer is\n * used instead.\n */\nexport default class ResizeObserver {\n\t/**\n\t * Creates an instance of the `ResizeObserver` class.\n\t *\n\t * @param {HTMLElement} element A DOM element that is to be observed for resizing. Note that\n\t * the element must be visible (i.e. not detached from DOM) for the observer to work.\n\t * @param {Function} callback A function called when the observed element was resized. It passes\n\t * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)\n\t * object with information about the resize event.\n\t */\n\tconstructor( element, callback ) {\n\t\t// **Note**: For the maximum performance, this class ensures only a single instance of the native\n\t\t// (or polyfilled) observer is used no matter how many instances of this class were created.\n\t\tif ( !ResizeObserver._observerInstance ) {\n\t\t\tResizeObserver._createObserver();\n\t\t}\n\n\t\t/**\n\t\t * The element observer by this observer.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {HTMLElement}\n\t\t */\n\t\tthis._element = element;\n\n\t\t/**\n\t\t * The callback executed each time {@link #_element} is resized.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {Function}\n\t\t */\n\t\tthis._callback = callback;\n\n\t\tResizeObserver._addElementCallback( element, callback );\n\t\tResizeObserver._observerInstance.observe( element );\n\t}\n\n\t/**\n\t * Destroys the observer which disables the `callback` passed to the {@link #constructor}.\n\t */\n\tdestroy() {\n\t\tResizeObserver._deleteElementCallback( this._element, this._callback );\n\t}\n\n\t/**\n\t * Registers a new resize callback for the DOM element.\n\t *\n\t * @private\n\t * @static\n\t * @param {HTMLElement} element\n\t * @param {Function} callback\n\t */\n\tstatic _addElementCallback( element, callback ) {\n\t\tif ( !ResizeObserver._elementCallbacks ) {\n\t\t\tResizeObserver._elementCallbacks = new Map();\n\t\t}\n\n\t\tlet callbacks = ResizeObserver._elementCallbacks.get( element );\n\n\t\tif ( !callbacks ) {\n\t\t\tcallbacks = new Set();\n\t\t\tResizeObserver._elementCallbacks.set( element, callbacks );\n\t\t}\n\n\t\tcallbacks.add( callback );\n\t}\n\n\t/**\n\t * Removes a resize callback from the DOM element. If no callbacks are left\n\t * for the element, it removes the element from the native observer.\n\t *\n\t * @private\n\t * @static\n\t * @param {HTMLElement} element\n\t * @param {Function} callback\n\t */\n\tstatic _deleteElementCallback( element, callback ) {\n\t\tconst callbacks = ResizeObserver._getElementCallbacks( element );\n\n\t\t// Remove the element callback. Check if exist first in case someone\n\t\t// called destroy() twice.\n\t\tif ( callbacks ) {\n\t\t\tcallbacks.delete( callback );\n\n\t\t\t// If no callbacks left for the element, also remove the element.\n\t\t\tif ( !callbacks.size ) {\n\t\t\t\tResizeObserver._elementCallbacks.delete( element );\n\t\t\t\tResizeObserver._observerInstance.unobserve( element );\n\t\t\t}\n\t\t}\n\n\t\tif ( ResizeObserver._elementCallbacks && !ResizeObserver._elementCallbacks.size ) {\n\t\t\tResizeObserver._observerInstance = null;\n\t\t\tResizeObserver._elementCallbacks = null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns are registered resize callbacks for the DOM element.\n\t *\n\t * @private\n\t * @static\n\t * @param {HTMLElement} element\n\t * @returns {Set.<HTMLElement>|null}\n\t */\n\tstatic _getElementCallbacks( element ) {\n\t\tif ( !ResizeObserver._elementCallbacks ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn ResizeObserver._elementCallbacks.get( element );\n\t}\n\n\t/**\n\t * Creates the single native observer shared across all `ResizeObserver` instances.\n\t * If the browser does not support the native API, it creates a polyfill.\n\t *\n\t * @private\n\t * @static\n\t */\n\tstatic _createObserver() {\n\t\tlet ObserverConstructor;\n\n\t\t// TODO: One day, the `ResizeObserver` API will be supported in all modern web browsers.\n\t\t// When it happens, this module will no longer make sense and should be removed and\n\t\t// the native implementation should be used across the project to save bytes.\n\t\t// Check out https://caniuse.com/#feat=resizeobserver.\n\t\tif ( typeof global.window.ResizeObserver === 'function' ) {\n\t\t\tObserverConstructor = global.window.ResizeObserver;\n\t\t} else {\n\t\t\tObserverConstructor = ResizeObserverPolyfill;\n\t\t}\n\n\t\tResizeObserver._observerInstance = new ObserverConstructor( entries => {\n\t\t\tfor ( const entry of entries ) {\n\t\t\t\tconst callbacks = ResizeObserver._getElementCallbacks( entry.target );\n\n\t\t\t\tif ( callbacks ) {\n\t\t\t\t\tfor ( const callback of callbacks ) {\n\t\t\t\t\t\tcallback( entry );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n}\n\n/**\n * The single native observer instance (or polyfill in browsers that do not support the API)\n * shared across all {@link module:utils/dom/resizeobserver~ResizeObserver} instances.\n *\n * @static\n * @protected\n * @readonly\n * @property {Object|null} module:utils/dom/resizeobserver~ResizeObserver#_observerInstance\n */\nResizeObserver._observerInstance = null;\n\n/**\n * A mapping of native DOM elements and their callbacks shared across all\n * {@link module:utils/dom/resizeobserver~ResizeObserver} instances.\n *\n * @static\n * @private\n * @readonly\n * @property {Map.<HTMLElement,Set>|null} module:utils/dom/resizeobserver~ResizeObserver#_elementCallbacks\n */\nResizeObserver._elementCallbacks = null;\n\n/**\n * A polyfill class for the native [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver).\n *\n * @private\n * @mixes module:utils/domemittermixin~DomEmitterMixin\n */\nclass ResizeObserverPolyfill {\n\t/**\n\t * Creates an instance of the {@link module:utils/dom/resizeobserver~ResizeObserverPolyfill} class.\n\t *\n\t * It synchronously reacts to resize of the window to check if observed elements' geometry changed.\n\t *\n\t * Additionally, the polyfilled observer uses a timeout to check if observed elements' geometry has changed\n\t * in some other way (dynamic layouts, scrollbars showing up, etc.), so its response can also be asynchronous.\n\t *\n\t * @param {Function} callback A function called when any observed element was resized. Refer to the\n\t * native [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) API to\n\t * learn more.\n\t */\n\tconstructor( callback ) {\n\t\t/**\n\t\t * A function called when any observed {@link #_elements element} was resized.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {Function}\n\t\t */\n\t\tthis._callback = callback;\n\n\t\t/**\n\t\t * DOM elements currently observed by the observer instance.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {Set}\n\t\t */\n\t\tthis._elements = new Set();\n\n\t\t/**\n\t\t * Cached DOM {@link #_elements elements} bounding rects to compare to upon the next check.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {Map.<HTMLElement,module:utils/dom/rect~Rect>}\n\t\t */\n\t\tthis._previousRects = new Map();\n\n\t\t/**\n\t\t * An UID of the current timeout upon which the observed elements rects\n\t\t * will be compared to the {@link #_previousRects previous rects} from the past.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {Map.<HTMLElement,module:utils/dom/rect~Rect>}\n\t\t */\n\t\tthis._periodicCheckTimeout = null;\n\t}\n\n\t/**\n\t * Starts observing a DOM element.\n\t *\n\t * Learn more in the\n\t * [native method documentation](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe).\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tobserve( element ) {\n\t\tthis._elements.add( element );\n\n\t\tthis._checkElementRectsAndExecuteCallback();\n\n\t\tif ( this._elements.size === 1 ) {\n\t\t\tthis._startPeriodicCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Stops observing a DOM element.\n\t *\n\t * Learn more in the\n\t * [native method documentation](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/unobserve).\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tunobserve( element ) {\n\t\tthis._elements.delete( element );\n\t\tthis._previousRects.delete( element );\n\n\t\tif ( !this._elements.size ) {\n\t\t\tthis._stopPeriodicCheck();\n\t\t}\n\t}\n\n\t/**\n\t * When called, the observer calls the {@link #_callback resize callback} for all observed\n\t * {@link #_elements elements} but also starts checking periodically for changes in the elements' geometry.\n\t * If some are detected, {@link #_callback resize callback} is called for relevant elements that were resized.\n\t *\n\t * @protected\n\t */\n\t_startPeriodicCheck() {\n\t\tconst periodicCheck = () => {\n\t\t\tthis._checkElementRectsAndExecuteCallback();\n\t\t\tthis._periodicCheckTimeout = setTimeout( periodicCheck, RESIZE_CHECK_INTERVAL );\n\t\t};\n\n\t\tthis.listenTo( global.window, 'resize', () => {\n\t\t\tthis._checkElementRectsAndExecuteCallback();\n\t\t} );\n\n\t\tthis._periodicCheckTimeout = setTimeout( periodicCheck, RESIZE_CHECK_INTERVAL );\n\t}\n\n\t/**\n\t * Stops checking for changes in all observed {@link #_elements elements} geometry.\n\t *\n\t * @protected\n\t */\n\t_stopPeriodicCheck() {\n\t\tclearTimeout( this._periodicCheckTimeout );\n\t\tthis.stopListening();\n\t\tthis._previousRects.clear();\n\t}\n\n\t/**\n\t * Checks if the geometry of any of the {@link #_elements element} has changed. If so, executes\n\t * the {@link #_callback resize callback} with element geometry data.\n\t *\n\t * @protected\n\t */\n\t_checkElementRectsAndExecuteCallback() {\n\t\tconst entries = [];\n\n\t\tfor ( const element of this._elements ) {\n\t\t\tif ( this._hasRectChanged( element ) ) {\n\t\t\t\tentries.push( {\n\t\t\t\t\ttarget: element,\n\t\t\t\t\tcontentRect: this._previousRects.get( element )\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tif ( entries.length ) {\n\t\t\tthis._callback( entries );\n\t\t}\n\t}\n\n\t/**\n\t * Compares the DOM element geometry to the {@link #_previousRects cached geometry} from the past.\n\t * Returns `true` if geometry has changed or the element is checked for the first time.\n\t *\n\t * @protected\n\t * @param {HTMLElement} element\n\t * @returns {Boolean}\n\t */\n\t_hasRectChanged( element ) {\n\t\tif ( !element.ownerDocument.body.contains( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst currentRect = new Rect( element );\n\t\tconst previousRect = this._previousRects.get( element );\n\n\t\t// The first check should always yield true despite no Previous rect to compare to.\n\t\t// The native ResizeObserver does that and... that makes sense. Sort of.\n\t\tconst hasChanged = !previousRect || !previousRect.isEqual( currentRect );\n\n\t\tthis._previousRects.set( element, currentRect );\n\n\t\treturn hasChanged;\n\t}\n}\n\nmix( ResizeObserverPolyfill, DomEmitterMixin );\n"]},"metadata":{},"sourceType":"module"}