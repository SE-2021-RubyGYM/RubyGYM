{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/autoparagraphing\n */\n\n/**\n * Fixes all empty roots.\n *\n * @protected\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\nexport function autoParagraphEmptyRoots(writer) {\n  const {\n    schema,\n    document\n  } = writer.model;\n\n  for (const rootName of document.getRootNames()) {\n    const root = document.getRoot(rootName);\n\n    if (root.isEmpty && !schema.checkChild(root, '$text')) {\n      // If paragraph element is allowed in the root, create paragraph element.\n      if (schema.checkChild(root, 'paragraph')) {\n        writer.insertElement('paragraph', root); // Other roots will get fixed in the next post-fixer round. Those will be triggered\n        // in the same batch no matter if this method was triggered by the post-fixing or not\n        // (the above insertElement call will trigger the post-fixers).\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Checks if the given node wrapped with a paragraph would be accepted by the schema in the given position.\n *\n * @protected\n * @param {module:engine/model/position~Position} position The position at which to check.\n * @param {module:engine/model/node~Node|String} nodeOrType The child node or child type to check.\n * @param {module:engine/model/schema~Schema} schema A schema instance used for element validation.\n */\n\nexport function isParagraphable(position, nodeOrType, schema) {\n  const context = schema.createContext(position); // When paragraph is allowed in this context...\n\n  if (!schema.checkChild(context, 'paragraph')) {\n    return false;\n  } // And a node would be allowed in this paragraph...\n\n\n  if (!schema.checkChild(context.push('paragraph'), nodeOrType)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Inserts a new paragraph at the given position and returns a position inside that paragraph.\n *\n * @protected\n * @param {module:engine/model/position~Position} position The position where a paragraph should be inserted.\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {module:engine/model/position~Position} Position inside the created paragraph.\n */\n\nexport function wrapInParagraph(position, writer) {\n  const paragraph = writer.createElement('paragraph');\n  writer.insert(paragraph, position);\n  return writer.createPositionAt(paragraph, 0);\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/autoparagraphing.js"],"names":["autoParagraphEmptyRoots","writer","schema","document","model","rootName","getRootNames","root","getRoot","isEmpty","checkChild","insertElement","isParagraphable","position","nodeOrType","context","createContext","push","wrapInParagraph","paragraph","createElement","insert","createPositionAt"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,uBAAT,CAAkCC,MAAlC,EAA2C;AACjD,QAAM;AAAEC,IAAAA,MAAF;AAAUC,IAAAA;AAAV,MAAuBF,MAAM,CAACG,KAApC;;AAEA,OAAM,MAAMC,QAAZ,IAAwBF,QAAQ,CAACG,YAAT,EAAxB,EAAkD;AACjD,UAAMC,IAAI,GAAGJ,QAAQ,CAACK,OAAT,CAAkBH,QAAlB,CAAb;;AAEA,QAAKE,IAAI,CAACE,OAAL,IAAgB,CAACP,MAAM,CAACQ,UAAP,CAAmBH,IAAnB,EAAyB,OAAzB,CAAtB,EAA2D;AAC1D;AACA,UAAKL,MAAM,CAACQ,UAAP,CAAmBH,IAAnB,EAAyB,WAAzB,CAAL,EAA8C;AAC7CN,QAAAA,MAAM,CAACU,aAAP,CAAsB,WAAtB,EAAmCJ,IAAnC,EAD6C,CAG7C;AACA;AACA;;AACA,eAAO,IAAP;AACA;AACD;AACD;;AAED,SAAO,KAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,eAAT,CAA0BC,QAA1B,EAAoCC,UAApC,EAAgDZ,MAAhD,EAAyD;AAC/D,QAAMa,OAAO,GAAGb,MAAM,CAACc,aAAP,CAAsBH,QAAtB,CAAhB,CAD+D,CAG/D;;AACA,MAAK,CAACX,MAAM,CAACQ,UAAP,CAAmBK,OAAnB,EAA4B,WAA5B,CAAN,EAAkD;AACjD,WAAO,KAAP;AACA,GAN8D,CAQ/D;;;AACA,MAAK,CAACb,MAAM,CAACQ,UAAP,CAAmBK,OAAO,CAACE,IAAR,CAAc,WAAd,CAAnB,EAAgDH,UAAhD,CAAN,EAAqE;AACpE,WAAO,KAAP;AACA;;AAED,SAAO,IAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,eAAT,CAA0BL,QAA1B,EAAoCZ,MAApC,EAA6C;AACnD,QAAMkB,SAAS,GAAGlB,MAAM,CAACmB,aAAP,CAAsB,WAAtB,CAAlB;AAEAnB,EAAAA,MAAM,CAACoB,MAAP,CAAeF,SAAf,EAA0BN,QAA1B;AAEA,SAAOZ,MAAM,CAACqB,gBAAP,CAAyBH,SAAzB,EAAoC,CAApC,CAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/autoparagraphing\n */\n\n/**\n * Fixes all empty roots.\n *\n * @protected\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\nexport function autoParagraphEmptyRoots( writer ) {\n\tconst { schema, document } = writer.model;\n\n\tfor ( const rootName of document.getRootNames() ) {\n\t\tconst root = document.getRoot( rootName );\n\n\t\tif ( root.isEmpty && !schema.checkChild( root, '$text' ) ) {\n\t\t\t// If paragraph element is allowed in the root, create paragraph element.\n\t\t\tif ( schema.checkChild( root, 'paragraph' ) ) {\n\t\t\t\twriter.insertElement( 'paragraph', root );\n\n\t\t\t\t// Other roots will get fixed in the next post-fixer round. Those will be triggered\n\t\t\t\t// in the same batch no matter if this method was triggered by the post-fixing or not\n\t\t\t\t// (the above insertElement call will trigger the post-fixers).\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Checks if the given node wrapped with a paragraph would be accepted by the schema in the given position.\n *\n * @protected\n * @param {module:engine/model/position~Position} position The position at which to check.\n * @param {module:engine/model/node~Node|String} nodeOrType The child node or child type to check.\n * @param {module:engine/model/schema~Schema} schema A schema instance used for element validation.\n */\nexport function isParagraphable( position, nodeOrType, schema ) {\n\tconst context = schema.createContext( position );\n\n\t// When paragraph is allowed in this context...\n\tif ( !schema.checkChild( context, 'paragraph' ) ) {\n\t\treturn false;\n\t}\n\n\t// And a node would be allowed in this paragraph...\n\tif ( !schema.checkChild( context.push( 'paragraph' ), nodeOrType ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Inserts a new paragraph at the given position and returns a position inside that paragraph.\n *\n * @protected\n * @param {module:engine/model/position~Position} position The position where a paragraph should be inserted.\n * @param {module:engine/model/writer~Writer} writer The model writer.\n * @returns {module:engine/model/position~Position} Position inside the created paragraph.\n */\nexport function wrapInParagraph( position, writer ) {\n\tconst paragraph = writer.createElement( 'paragraph' );\n\n\twriter.insert( paragraph, position );\n\n\treturn writer.createPositionAt( paragraph, 0 );\n}\n"]},"metadata":{},"sourceType":"module"}