{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/selection\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Range from './range';\nimport Position from './position';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Node from './node';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport DocumentSelection from './documentselection';\n/**\n * Class representing an arbirtary selection in the view.\n * See also {@link module:engine/view/documentselection~DocumentSelection}.\n *\n * New selection instances can be created via the constructor or one these methods:\n *\n * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n *\n * A selection can consist of {@link module:engine/view/range~Range ranges} that can be set by using\n * the {@link module:engine/view/selection~Selection#setTo `Selection#setTo()`} method.\n */\n\nexport default class Selection {\n  /**\n   * Creates new selection instance.\n   *\n   * **Note**: The selection constructor is available as a factory method:\n   *\n   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n   *\n   * \t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the document selection.\n   *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n   *\n   * \t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} [selectable=null]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n  constructor() {\n    let selectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let placeOrOffset = arguments.length > 1 ? arguments[1] : undefined;\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n\n    /**\n     * Stores all ranges that are selected.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/range~Range>}\n     */\n    this._ranges = [];\n    /**\n     * Specifies whether the last added range was added as a backward or forward range.\n     *\n     * @protected\n     * @member {Boolean}\n     */\n\n    this._lastRangeBackward = false;\n    /**\n     * Specifies whether selection instance is fake.\n     *\n     * @private\n     * @member {Boolean}\n     */\n\n    this._isFake = false;\n    /**\n     * Fake selection's label.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._fakeSelectionLabel = '';\n    this.setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Returns true if selection instance is marked as `fake`.\n   *\n   * @see #setTo\n   * @type {Boolean}\n   */\n\n\n  get isFake() {\n    return this._isFake;\n  }\n  /**\n   * Returns fake selection label.\n   *\n   * @see #setTo\n   * @type {String}\n   */\n\n\n  get fakeSelectionLabel() {\n    return this._fakeSelectionLabel;\n  }\n  /**\n   * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n   * {@link #focus focus} they define the direction of selection, which is important\n   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n   * It may be a bit unintuitive when there are multiple ranges in selection.\n   *\n   * @see #focus\n   * @type {module:engine/view/position~Position}\n   */\n\n\n  get anchor() {\n    if (!this._ranges.length) {\n      return null;\n    }\n\n    const range = this._ranges[this._ranges.length - 1];\n    const anchor = this._lastRangeBackward ? range.end : range.start;\n    return anchor.clone();\n  }\n  /**\n   * Selection focus. Focus is a position where the selection ends.\n   *\n   * @see #anchor\n   * @type {module:engine/view/position~Position}\n   */\n\n\n  get focus() {\n    if (!this._ranges.length) {\n      return null;\n    }\n\n    const range = this._ranges[this._ranges.length - 1];\n    const focus = this._lastRangeBackward ? range.start : range.end;\n    return focus.clone();\n  }\n  /**\n   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n   * collapsed.\n   *\n   * @type {Boolean}\n   */\n\n\n  get isCollapsed() {\n    return this.rangeCount === 1 && this._ranges[0].isCollapsed;\n  }\n  /**\n   * Returns number of ranges in selection.\n   *\n   * @type {Number}\n   */\n\n\n  get rangeCount() {\n    return this._ranges.length;\n  }\n  /**\n   * Specifies whether the {@link #focus} precedes {@link #anchor}.\n   *\n   * @type {Boolean}\n   */\n\n\n  get isBackward() {\n    return !this.isCollapsed && this._lastRangeBackward;\n  }\n  /**\n   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n   * if the selection is not inside an editable element.\n   *\n   * @type {module:engine/view/editableelement~EditableElement|null}\n   */\n\n\n  get editableElement() {\n    if (this.anchor) {\n      return this.anchor.editableElement;\n    }\n\n    return null;\n  }\n  /**\n   * Returns an iterable that contains copies of all ranges added to the selection.\n   *\n   * @returns {Iterable.<module:engine/view/range~Range>}\n   */\n\n\n  *getRanges() {\n    for (const range of this._ranges) {\n      yield range.clone();\n    }\n  }\n  /**\n   * Returns copy of the first range in the selection. First range is the one which\n   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n   * position of all other ranges (not to confuse with the first range added to the selection).\n   * Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/range~Range|null}\n   */\n\n\n  getFirstRange() {\n    let first = null;\n\n    for (const range of this._ranges) {\n      if (!first || range.start.isBefore(first.start)) {\n        first = range;\n      }\n    }\n\n    return first ? first.clone() : null;\n  }\n  /**\n   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n   * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/range~Range|null}\n   */\n\n\n  getLastRange() {\n    let last = null;\n\n    for (const range of this._ranges) {\n      if (!last || range.end.isAfter(last.end)) {\n        last = range;\n      }\n    }\n\n    return last ? last.clone() : null;\n  }\n  /**\n   * Returns copy of the first position in the selection. First position is the position that\n   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n   * Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/position~Position|null}\n   */\n\n\n  getFirstPosition() {\n    const firstRange = this.getFirstRange();\n    return firstRange ? firstRange.start.clone() : null;\n  }\n  /**\n   * Returns copy of the last position in the selection. Last position is the position that\n   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n   * Returns `null` if no ranges are added to selection.\n   *\n   * @returns {module:engine/view/position~Position|null}\n   */\n\n\n  getLastPosition() {\n    const lastRange = this.getLastRange();\n    return lastRange ? lastRange.end.clone() : null;\n  }\n  /**\n   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n   * same number of ranges and all ranges from one selection equal to a range from other selection.\n   *\n   * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n   * Selection to compare with.\n   * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n   */\n\n\n  isEqual(otherSelection) {\n    if (this.isFake != otherSelection.isFake) {\n      return false;\n    }\n\n    if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {\n      return false;\n    }\n\n    if (this.rangeCount != otherSelection.rangeCount) {\n      return false;\n    } else if (this.rangeCount === 0) {\n      return true;\n    }\n\n    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n      return false;\n    }\n\n    for (const thisRange of this._ranges) {\n      let found = false;\n\n      for (const otherRange of otherSelection._ranges) {\n        if (thisRange.isEqual(otherRange)) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n   * equal to any trimmed range from other selection.\n   *\n   * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n   * Selection to compare with.\n   * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n   */\n\n\n  isSimilar(otherSelection) {\n    if (this.isBackward != otherSelection.isBackward) {\n      return false;\n    }\n\n    const numOfRangesA = count(this.getRanges());\n    const numOfRangesB = count(otherSelection.getRanges()); // If selections have different number of ranges, they cannot be similar.\n\n    if (numOfRangesA != numOfRangesB) {\n      return false;\n    } // If both selections have no ranges, they are similar.\n\n\n    if (numOfRangesA == 0) {\n      return true;\n    } // Check if each range in one selection has a similar range in other selection.\n\n\n    for (let rangeA of this.getRanges()) {\n      rangeA = rangeA.getTrimmed();\n      let found = false;\n\n      for (let rangeB of otherSelection.getRanges()) {\n        rangeB = rangeB.getTrimmed();\n\n        if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {\n          found = true;\n          break;\n        }\n      } // For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.\n\n\n      if (!found) {\n        return false;\n      }\n    } // There were no ranges that weren't matched. Selections are similar.\n\n\n    return true;\n  }\n  /**\n   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n   * one range in the selection, and that range contains exactly one element.\n   * Returns `null` if there is no selected element.\n   *\n   * @returns {module:engine/view/element~Element|null}\n   */\n\n\n  getSelectedElement() {\n    if (this.rangeCount !== 1) {\n      return null;\n    }\n\n    return this.getFirstRange().getContainedElement();\n  }\n  /**\n   * Sets this selection's ranges and direction to the specified location based on the given\n   * {@link module:engine/view/selection~Selectable selectable}.\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tselection.setTo( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tselection.setTo( range );\n   *\n   *\t\t// Sets selection to the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tselection.setTo( otherSelection );\n   *\n   *\t \t// Sets selection to contents of DocumentSelection.\n   *\t\tselection.setTo( editor.editing.view.document.selection );\n   *\n   * \t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionAt( root, path );\n   *\t\tselection.setTo( position );\n   *\n   * \t\t// Sets collapsed selection at the position of given item and offset.\n   *\t\tselection.setTo( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   *\t\tselection.setTo( paragraph, 'in' );\n   *\n   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\tselection.setTo( paragraph, 'on' );\n   *\n   * \t\t// Clears selection. Removes all ranges.\n   *\t\tselection.setTo( null );\n   *\n   * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\tselection.setTo( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tselection.setTo( range, { fake: true, label: 'foo' } );\n   *\n   * @fires change\n   * @param {module:engine/view/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n\n\n  setTo(selectable, placeOrOffset, options) {\n    if (selectable === null) {\n      this._setRanges([]);\n\n      this._setFakeOptions(placeOrOffset);\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      this._setRanges(selectable.getRanges(), selectable.isBackward);\n\n      this._setFakeOptions({\n        fake: selectable.isFake,\n        label: selectable.fakeSelectionLabel\n      });\n    } else if (selectable instanceof Range) {\n      this._setRanges([selectable], placeOrOffset && placeOrOffset.backward);\n\n      this._setFakeOptions(placeOrOffset);\n    } else if (selectable instanceof Position) {\n      this._setRanges([new Range(selectable)]);\n\n      this._setFakeOptions(placeOrOffset);\n    } else if (selectable instanceof Node) {\n      const backward = !!options && !!options.backward;\n      let range;\n\n      if (placeOrOffset === undefined) {\n        /**\n         * selection.setTo requires the second parameter when the first parameter is a node.\n         *\n         * @error view-selection-setto-required-second-parameter\n         */\n        throw new CKEditorError('view-selection-setto-required-second-parameter', this);\n      } else if (placeOrOffset == 'in') {\n        range = Range._createIn(selectable);\n      } else if (placeOrOffset == 'on') {\n        range = Range._createOn(selectable);\n      } else {\n        range = new Range(Position._createAt(selectable, placeOrOffset));\n      }\n\n      this._setRanges([range], backward);\n\n      this._setFakeOptions(options);\n    } else if (isIterable(selectable)) {\n      // We assume that the selectable is an iterable of ranges.\n      // Array.from() is used to prevent setting ranges to the old iterable\n      this._setRanges(selectable, placeOrOffset && placeOrOffset.backward);\n\n      this._setFakeOptions(placeOrOffset);\n    } else {\n      /**\n       * Cannot set selection to given place.\n       *\n       * @error view-selection-setto-not-selectable\n       */\n      throw new CKEditorError('view-selection-setto-not-selectable', this);\n    }\n\n    this.fire('change');\n  }\n  /**\n   * Moves {@link #focus} to the specified location.\n   *\n   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n   * parameters.\n   *\n   * @fires change\n   * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n\n\n  setFocus(itemOrPosition, offset) {\n    if (this.anchor === null) {\n      /**\n       * Cannot set selection focus if there are no ranges in selection.\n       *\n       * @error view-selection-setfocus-no-ranges\n       */\n      throw new CKEditorError('view-selection-setfocus-no-ranges', this);\n    }\n\n    const newFocus = Position._createAt(itemOrPosition, offset);\n\n    if (newFocus.compareWith(this.focus) == 'same') {\n      return;\n    }\n\n    const anchor = this.anchor;\n\n    this._ranges.pop();\n\n    if (newFocus.compareWith(anchor) == 'before') {\n      this._addRange(new Range(newFocus, anchor), true);\n    } else {\n      this._addRange(new Range(anchor, newFocus));\n    }\n\n    this.fire('change');\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   *\t\tselection.is( 'selection' ); // -> true\n   *\t\tselection.is( 'view:selection' ); // -> true\n   *\n   *\t\tselection.is( 'model:selection' ); // -> false\n   *\t\tselection.is( 'element' ); // -> false\n   *\t\tselection.is( 'range' ); // -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'selection' || type === 'view:selection';\n  }\n  /**\n   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n   * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.\n   * Accepts a flag describing in which way the selection is made.\n   *\n   * @private\n   * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.\n   * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end\n   * (`false`) or backward - from end to start (`true`). Defaults to `false`.\n   */\n\n\n  _setRanges(newRanges) {\n    let isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // New ranges should be copied to prevent removing them by setting them to `[]` first.\n    // Only applies to situations when selection is set to the same selection or same selection's ranges.\n    newRanges = Array.from(newRanges);\n    this._ranges = [];\n\n    for (const range of newRanges) {\n      this._addRange(range);\n    }\n\n    this._lastRangeBackward = !!isLastBackward;\n  }\n  /**\n   * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection\n   * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to\n   * the user and selection over elements can be represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be\n   * properly handled by screen readers).\n   *\n   * @private\n   * @param {Object} [options] Options.\n   * @param {Boolean} [options.fake] If set to true selection will be marked as `fake`.\n   * @param {String} [options.label=''] Fake selection label.\n   */\n\n\n  _setFakeOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._isFake = !!options.fake;\n    this._fakeSelectionLabel = options.fake ? options.label || '' : '';\n  }\n  /**\n   * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the\n   * selection instance and you can safely operate on it.\n   *\n   * Accepts a flag describing in which way the selection is made - passed range might be selected from\n   * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}\n   * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.\n   * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n   * with ranges already stored in Selection instance.\n   *\n   * @private\n   * @fires change\n   * @param {module:engine/view/range~Range} range\n   * @param {Boolean} [isBackward]\n   */\n\n\n  _addRange(range) {\n    let isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!(range instanceof Range)) {\n      /**\n       * Selection range set to an object that is not an instance of {@link module:engine/view/range~Range}.\n       *\n       * @error view-selection-add-range-not-range\n       */\n      throw new CKEditorError('view-selection-add-range-not-range', this);\n    }\n\n    this._pushRange(range);\n\n    this._lastRangeBackward = !!isBackward;\n  }\n  /**\n   * Adds range to selection - creates copy of given range so it can be safely used and modified.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n   * with ranges already stored in selection instance.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range\n   */\n\n\n  _pushRange(range) {\n    for (const storedRange of this._ranges) {\n      if (range.isIntersecting(storedRange)) {\n        /**\n         * Trying to add a range that intersects with another range from selection.\n         *\n         * @error view-selection-range-intersects\n         * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.\n         * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.\n         */\n        throw new CKEditorError('view-selection-range-intersects', this, {\n          addedRange: range,\n          intersectingRange: storedRange\n        });\n      }\n    }\n\n    this._ranges.push(new Range(range.start, range.end));\n  }\n  /**\n   * Fired whenever selection ranges are changed through {@link ~Selection Selection API}.\n   *\n   * @event change\n   */\n\n\n}\nmix(Selection, EmitterMixin);\n/**\n * An entity that is used to set selection.\n *\n * See also {@link module:engine/view/selection~Selection#setTo}\n *\n * @typedef {\n *    module:engine/view/selection~Selection|\n *    module:engine/view/documentselection~DocumentSelection|\n *    module:engine/view/position~Position|\n *    Iterable.<module:engine/view/range~Range>|\n *    module:engine/view/range~Range|\n *    module:engine/view/item~Item|\n *    null\n * } module:engine/view/selection~Selectable\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/selection.js"],"names":["CKEditorError","Range","Position","mix","EmitterMixin","Node","count","isIterable","DocumentSelection","Selection","constructor","selectable","placeOrOffset","options","_ranges","_lastRangeBackward","_isFake","_fakeSelectionLabel","setTo","isFake","fakeSelectionLabel","anchor","length","range","end","start","clone","focus","isCollapsed","rangeCount","isBackward","editableElement","getRanges","getFirstRange","first","isBefore","getLastRange","last","isAfter","getFirstPosition","firstRange","getLastPosition","lastRange","isEqual","otherSelection","thisRange","found","otherRange","isSimilar","numOfRangesA","numOfRangesB","rangeA","getTrimmed","rangeB","getSelectedElement","getContainedElement","_setRanges","_setFakeOptions","fake","label","backward","undefined","_createIn","_createOn","_createAt","fire","setFocus","itemOrPosition","offset","newFocus","compareWith","pop","_addRange","is","type","newRanges","isLastBackward","Array","from","_pushRange","storedRange","isIntersecting","addedRange","intersectingRange","push"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,aAAP,MAA0B,6CAA1B;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,KAAP,MAAkB,qCAAlB;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,SAAN,CAAgB;AAC9B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,GAA8C;AAAA,QAA5CC,UAA4C,uEAA/B,IAA+B;AAAA,QAAzBC,aAAyB;AAAA,QAAVC,OAAU;;AACxD;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,OAAL,GAAe,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,kBAAL,GAA0B,KAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,OAAL,GAAe,KAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,mBAAL,GAA2B,EAA3B;AAEA,SAAKC,KAAL,CAAYP,UAAZ,EAAwBC,aAAxB,EAAuCC,OAAvC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACW,MAANM,MAAM,GAAG;AACZ,WAAO,KAAKH,OAAZ;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACu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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/selection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Range from './range';\nimport Position from './position';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Node from './node';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport DocumentSelection from './documentselection';\n\n/**\n * Class representing an arbirtary selection in the view.\n * See also {@link module:engine/view/documentselection~DocumentSelection}.\n *\n * New selection instances can be created via the constructor or one these methods:\n *\n * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n *\n * A selection can consist of {@link module:engine/view/range~Range ranges} that can be set by using\n * the {@link module:engine/view/selection~Selection#setTo `Selection#setTo()`} method.\n */\nexport default class Selection {\n\t/**\n\t * Creates new selection instance.\n\t *\n\t * **Note**: The selection constructor is available as a factory method:\n\t *\n\t * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n\t * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the document selection.\n\t *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tconstructor( selectable = null, placeOrOffset, options ) {\n\t\t/**\n\t\t * Stores all ranges that are selected.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/view/range~Range>}\n\t\t */\n\t\tthis._ranges = [];\n\n\t\t/**\n\t\t * Specifies whether the last added range was added as a backward or forward range.\n\t\t *\n\t\t * @protected\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._lastRangeBackward = false;\n\n\t\t/**\n\t\t * Specifies whether selection instance is fake.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._isFake = false;\n\n\t\t/**\n\t\t * Fake selection's label.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._fakeSelectionLabel = '';\n\n\t\tthis.setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Returns true if selection instance is marked as `fake`.\n\t *\n\t * @see #setTo\n\t * @type {Boolean}\n\t */\n\tget isFake() {\n\t\treturn this._isFake;\n\t}\n\n\t/**\n\t * Returns fake selection label.\n\t *\n\t * @see #setTo\n\t * @type {String}\n\t */\n\tget fakeSelectionLabel() {\n\t\treturn this._fakeSelectionLabel;\n\t}\n\n\t/**\n\t * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n\t * {@link #focus focus} they define the direction of selection, which is important\n\t * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n\t * It may be a bit unintuitive when there are multiple ranges in selection.\n\t *\n\t * @see #focus\n\t * @type {module:engine/view/position~Position}\n\t */\n\tget anchor() {\n\t\tif ( !this._ranges.length ) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\t\tconst anchor = this._lastRangeBackward ? range.end : range.start;\n\n\t\treturn anchor.clone();\n\t}\n\n\t/**\n\t * Selection focus. Focus is a position where the selection ends.\n\t *\n\t * @see #anchor\n\t * @type {module:engine/view/position~Position}\n\t */\n\tget focus() {\n\t\tif ( !this._ranges.length ) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\t\tconst focus = this._lastRangeBackward ? range.start : range.end;\n\n\t\treturn focus.clone();\n\t}\n\n\t/**\n\t * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n\t * collapsed.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.rangeCount === 1 && this._ranges[ 0 ].isCollapsed;\n\t}\n\n\t/**\n\t * Returns number of ranges in selection.\n\t *\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._ranges.length;\n\t}\n\n\t/**\n\t * Specifies whether the {@link #focus} precedes {@link #anchor}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn !this.isCollapsed && this._lastRangeBackward;\n\t}\n\n\t/**\n\t * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n\t * if the selection is not inside an editable element.\n\t *\n\t * @type {module:engine/view/editableelement~EditableElement|null}\n\t */\n\tget editableElement() {\n\t\tif ( this.anchor ) {\n\t\t\treturn this.anchor.editableElement;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns an iterable that contains copies of all ranges added to the selection.\n\t *\n\t * @returns {Iterable.<module:engine/view/range~Range>}\n\t */\n\t* getRanges() {\n\t\tfor ( const range of this._ranges ) {\n\t\t\tyield range.clone();\n\t\t}\n\t}\n\n\t/**\n\t * Returns copy of the first range in the selection. First range is the one which\n\t * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n\t * position of all other ranges (not to confuse with the first range added to the selection).\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\tlet first = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !first || range.start.isBefore( first.start ) ) {\n\t\t\t\tfirst = range;\n\t\t\t}\n\t\t}\n\n\t\treturn first ? first.clone() : null;\n\t}\n\n\t/**\n\t * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n\t * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n\t * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\tlet last = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !last || range.end.isAfter( last.end ) ) {\n\t\t\t\tlast = range;\n\t\t\t}\n\t\t}\n\n\t\treturn last ? last.clone() : null;\n\t}\n\n\t/**\n\t * Returns copy of the first position in the selection. First position is the position that\n\t * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\tconst firstRange = this.getFirstRange();\n\n\t\treturn firstRange ? firstRange.start.clone() : null;\n\t}\n\n\t/**\n\t * Returns copy of the last position in the selection. Last position is the position that\n\t * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\tconst lastRange = this.getLastRange();\n\n\t\treturn lastRange ? lastRange.end.clone() : null;\n\t}\n\n\t/**\n\t * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n\t * same number of ranges and all ranges from one selection equal to a range from other selection.\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n\t */\n\tisEqual( otherSelection ) {\n\t\tif ( this.isFake != otherSelection.isFake ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.rangeCount != otherSelection.rangeCount ) {\n\t\t\treturn false;\n\t\t} else if ( this.rangeCount === 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( !this.anchor.isEqual( otherSelection.anchor ) || !this.focus.isEqual( otherSelection.focus ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor ( const thisRange of this._ranges ) {\n\t\t\tlet found = false;\n\n\t\t\tfor ( const otherRange of otherSelection._ranges ) {\n\t\t\t\tif ( thisRange.isEqual( otherRange ) ) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !found ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n\t * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n\t * equal to any trimmed range from other selection.\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n\t */\n\tisSimilar( otherSelection ) {\n\t\tif ( this.isBackward != otherSelection.isBackward ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst numOfRangesA = count( this.getRanges() );\n\t\tconst numOfRangesB = count( otherSelection.getRanges() );\n\n\t\t// If selections have different number of ranges, they cannot be similar.\n\t\tif ( numOfRangesA != numOfRangesB ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If both selections have no ranges, they are similar.\n\t\tif ( numOfRangesA == 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check if each range in one selection has a similar range in other selection.\n\t\tfor ( let rangeA of this.getRanges() ) {\n\t\t\trangeA = rangeA.getTrimmed();\n\n\t\t\tlet found = false;\n\n\t\t\tfor ( let rangeB of otherSelection.getRanges() ) {\n\t\t\t\trangeB = rangeB.getTrimmed();\n\n\t\t\t\tif ( rangeA.start.isEqual( rangeB.start ) && rangeA.end.isEqual( rangeB.end ) ) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.\n\t\t\tif ( !found ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// There were no ranges that weren't matched. Selections are similar.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\tif ( this.rangeCount !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.getFirstRange().getContainedElement();\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/view/selection~Selectable selectable}.\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tselection.setTo( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tselection.setTo( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tselection.setTo( otherSelection );\n\t *\n\t *\t \t// Sets selection to contents of DocumentSelection.\n\t *\t\tselection.setTo( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionAt( root, path );\n\t *\t\tselection.setTo( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tselection.setTo( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t *\t\tselection.setTo( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\tselection.setTo( paragraph, 'on' );\n\t *\n\t * \t\t// Clears selection. Removes all ranges.\n\t *\t\tselection.setTo( null );\n\t *\n\t * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\tselection.setTo( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tselection.setTo( range, { fake: true, label: 'foo' } );\n\t *\n\t * @fires change\n\t * @param {module:engine/view/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetTo( selectable, placeOrOffset, options ) {\n\t\tif ( selectable === null ) {\n\t\t\tthis._setRanges( [] );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else if ( selectable instanceof Selection || selectable instanceof DocumentSelection ) {\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t\tthis._setFakeOptions( { fake: selectable.isFake, label: selectable.fakeSelectionLabel } );\n\t\t} else if ( selectable instanceof Range ) {\n\t\t\tthis._setRanges( [ selectable ], placeOrOffset && placeOrOffset.backward );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else if ( selectable instanceof Position ) {\n\t\t\tthis._setRanges( [ new Range( selectable ) ] );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else if ( selectable instanceof Node ) {\n\t\t\tconst backward = !!options && !!options.backward;\n\t\t\tlet range;\n\n\t\t\tif ( placeOrOffset === undefined ) {\n\t\t\t\t/**\n\t\t\t\t * selection.setTo requires the second parameter when the first parameter is a node.\n\t\t\t\t *\n\t\t\t\t * @error view-selection-setto-required-second-parameter\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'view-selection-setto-required-second-parameter', this );\n\t\t\t} else if ( placeOrOffset == 'in' ) {\n\t\t\t\trange = Range._createIn( selectable );\n\t\t\t} else if ( placeOrOffset == 'on' ) {\n\t\t\t\trange = Range._createOn( selectable );\n\t\t\t} else {\n\t\t\t\trange = new Range( Position._createAt( selectable, placeOrOffset ) );\n\t\t\t}\n\n\t\t\tthis._setRanges( [ range ], backward );\n\t\t\tthis._setFakeOptions( options );\n\t\t} else if ( isIterable( selectable ) ) {\n\t\t\t// We assume that the selectable is an iterable of ranges.\n\t\t\t// Array.from() is used to prevent setting ranges to the old iterable\n\t\t\tthis._setRanges( selectable, placeOrOffset && placeOrOffset.backward );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else {\n\t\t\t/**\n\t\t\t * Cannot set selection to given place.\n\t\t\t *\n\t\t\t * @error view-selection-setto-not-selectable\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-selection-setto-not-selectable', this );\n\t\t}\n\n\t\tthis.fire( 'change' );\n\t}\n\n\t/**\n\t * Moves {@link #focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n\t * parameters.\n\t *\n\t * @fires change\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetFocus( itemOrPosition, offset ) {\n\t\tif ( this.anchor === null ) {\n\t\t\t/**\n\t\t\t * Cannot set selection focus if there are no ranges in selection.\n\t\t\t *\n\t\t\t * @error view-selection-setfocus-no-ranges\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-selection-setfocus-no-ranges', this );\n\t\t}\n\n\t\tconst newFocus = Position._createAt( itemOrPosition, offset );\n\n\t\tif ( newFocus.compareWith( this.focus ) == 'same' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst anchor = this.anchor;\n\n\t\tthis._ranges.pop();\n\n\t\tif ( newFocus.compareWith( anchor ) == 'before' ) {\n\t\t\tthis._addRange( new Range( newFocus, anchor ), true );\n\t\t} else {\n\t\t\tthis._addRange( new Range( anchor, newFocus ) );\n\t\t}\n\n\t\tthis.fire( 'change' );\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tselection.is( 'selection' ); // -> true\n\t *\t\tselection.is( 'view:selection' ); // -> true\n\t *\n\t *\t\tselection.is( 'model:selection' ); // -> false\n\t *\t\tselection.is( 'element' ); // -> false\n\t *\t\tselection.is( 'range' ); // -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'selection' || type === 'view:selection';\n\t}\n\n\t/**\n\t * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n\t * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.\n\t * Accepts a flag describing in which way the selection is made.\n\t *\n\t * @private\n\t * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.\n\t * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end\n\t * (`false`) or backward - from end to start (`true`). Defaults to `false`.\n\t */\n\t_setRanges( newRanges, isLastBackward = false ) {\n\t\t// New ranges should be copied to prevent removing them by setting them to `[]` first.\n\t\t// Only applies to situations when selection is set to the same selection or same selection's ranges.\n\t\tnewRanges = Array.from( newRanges );\n\n\t\tthis._ranges = [];\n\n\t\tfor ( const range of newRanges ) {\n\t\t\tthis._addRange( range );\n\t\t}\n\n\t\tthis._lastRangeBackward = !!isLastBackward;\n\t}\n\n\t/**\n\t * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection\n\t * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to\n\t * the user and selection over elements can be represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be\n\t * properly handled by screen readers).\n\t *\n\t * @private\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.fake] If set to true selection will be marked as `fake`.\n\t * @param {String} [options.label=''] Fake selection label.\n\t */\n\t_setFakeOptions( options = {} ) {\n\t\tthis._isFake = !!options.fake;\n\t\tthis._fakeSelectionLabel = options.fake ? options.label || '' : '';\n\t}\n\n\t/**\n\t * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the\n\t * selection instance and you can safely operate on it.\n\t *\n\t * Accepts a flag describing in which way the selection is made - passed range might be selected from\n\t * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}\n\t * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.\n\t * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n\t * with ranges already stored in Selection instance.\n\t *\n\t * @private\n\t * @fires change\n\t * @param {module:engine/view/range~Range} range\n\t * @param {Boolean} [isBackward]\n\t */\n\t_addRange( range, isBackward = false ) {\n\t\tif ( !( range instanceof Range ) ) {\n\t\t\t/**\n\t\t\t * Selection range set to an object that is not an instance of {@link module:engine/view/range~Range}.\n\t\t\t *\n\t\t\t * @error view-selection-add-range-not-range\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-selection-add-range-not-range',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tthis._pushRange( range );\n\t\tthis._lastRangeBackward = !!isBackward;\n\t}\n\n\t/**\n\t * Adds range to selection - creates copy of given range so it can be safely used and modified.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n\t * with ranges already stored in selection instance.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t */\n\t_pushRange( range ) {\n\t\tfor ( const storedRange of this._ranges ) {\n\t\t\tif ( range.isIntersecting( storedRange ) ) {\n\t\t\t\t/**\n\t\t\t\t * Trying to add a range that intersects with another range from selection.\n\t\t\t\t *\n\t\t\t\t * @error view-selection-range-intersects\n\t\t\t\t * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.\n\t\t\t\t * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'view-selection-range-intersects',\n\t\t\t\t\tthis,\n\t\t\t\t\t{ addedRange: range, intersectingRange: storedRange }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis._ranges.push( new Range( range.start, range.end ) );\n\t}\n\n\t/**\n\t * Fired whenever selection ranges are changed through {@link ~Selection Selection API}.\n\t *\n\t * @event change\n\t */\n}\n\nmix( Selection, EmitterMixin );\n\n/**\n * An entity that is used to set selection.\n *\n * See also {@link module:engine/view/selection~Selection#setTo}\n *\n * @typedef {\n *    module:engine/view/selection~Selection|\n *    module:engine/view/documentselection~DocumentSelection|\n *    module:engine/view/position~Position|\n *    Iterable.<module:engine/view/range~Range>|\n *    module:engine/view/range~Range|\n *    module:engine/view/item~Item|\n *    null\n * } module:engine/view/selection~Selectable\n */\n"]},"metadata":{},"sourceType":"module"}