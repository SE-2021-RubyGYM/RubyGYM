{"ast":null,"code":"import { isUndefined, throwError, isNullOrUndefined, extend, isBlazor, getValue } from '../util';\nimport { defaultCurrencyCode } from '../internationalization';\nimport { IntlBase as base } from './intl-base';\nimport { ParserBase as parser } from './parser-base';\nvar errorText = {\n  'ms': 'minimumSignificantDigits',\n  'ls': 'maximumSignificantDigits',\n  'mf': 'minimumFractionDigits',\n  'lf': 'maximumFractionDigits'\n};\nvar integerError = 'minimumIntegerDigits';\nvar percentSign = 'percentSign';\nvar minusSign = 'minusSign';\nvar spaceRegex = /\\s/;\nvar mapper = ['infinity', 'nan', 'group', 'decimal', 'exponential'];\nvar infinity = 'infinity';\nvar nan = 'nan';\n/**\r\n * Module for number formatting.\r\n *\r\n * @private\r\n */\n\nvar NumberFormat =\n/** @class */\nfunction () {\n  function NumberFormat() {}\n  /**\r\n   * Returns the formatter function for given skeleton.\r\n   *\r\n   * @param {string} culture -  Specifies the culture name to be which formatting.\r\n   * @param {NumberFormatOptions} option - Specific the format in which number  will format.\r\n   * @param {Object} cldr - Specifies the global cldr data collection.\r\n   * @returns {Function} ?\r\n   */\n\n\n  NumberFormat.numberFormatter = function (culture, option, cldr) {\n    var _this = this;\n\n    var fOptions = extend({}, option);\n    var cOptions = {};\n    var dOptions = {};\n    var symbolPattern;\n    var dependable = base.getDependables(cldr, culture, '', true);\n    var numObject = dependable.numericObject;\n    dOptions.numberMapper = isBlazor() ? extend({}, numObject) : parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr), true);\n    dOptions.currencySymbol = isBlazor() ? getValue('currencySymbol', numObject) : base.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode, option.altSymbol);\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n    dOptions.percentSymbol = isBlazor() ? getValue('numberSymbols.percentSign', numObject) : dOptions.numberMapper.numberSymbols[percentSign];\n    dOptions.minusSymbol = isBlazor() ? getValue('numberSymbols.minusSign', numObject) : dOptions.numberMapper.numberSymbols[minusSign];\n    var symbols = dOptions.numberMapper.numberSymbols;\n\n    if (option.format && !base.formatRegex.test(option.format)) {\n      cOptions = base.customFormat(option.format, dOptions, dependable.numericObject);\n    } else {\n      extend(fOptions, base.getProperNumericSkeleton(option.format || 'N'));\n      fOptions.isCurrency = fOptions.type === 'currency';\n      fOptions.isPercent = fOptions.type === 'percent';\n\n      if (!isBlazor()) {\n        symbolPattern = base.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);\n      }\n\n      fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);\n      this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);\n\n      if (!isUndefined(fOptions.fractionDigits)) {\n        fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;\n      }\n\n      if (isUndefined(fOptions.useGrouping)) {\n        fOptions.useGrouping = true;\n      }\n\n      if (fOptions.isCurrency && !isBlazor()) {\n        symbolPattern = symbolPattern.replace(/\\u00A4/g, base.defaultCurrency);\n      }\n\n      if (!isBlazor()) {\n        var split = symbolPattern.split(';');\n        cOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, dOptions.currencySymbol);\n        cOptions.pData = base.getFormatData(split[0], false, dOptions.currencySymbol);\n\n        if (fOptions.useGrouping) {\n          fOptions.groupSeparator = symbols[mapper[2]];\n          fOptions.groupData = this.getGroupingDetails(split[0]);\n        }\n      } else {\n        cOptions.nData = extend({}, {}, getValue(fOptions.type + 'nData', numObject));\n        cOptions.pData = extend({}, {}, getValue(fOptions.type + 'pData', numObject));\n\n        if (fOptions.type === 'currency' && option.currency) {\n          base.replaceBlazorCurrency([cOptions.pData, cOptions.nData], dOptions.currencySymbol, option.currency);\n        }\n      }\n\n      var minFrac = isUndefined(fOptions.minimumFractionDigits);\n\n      if (minFrac) {\n        fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;\n      }\n\n      if (isUndefined(fOptions.maximumFractionDigits)) {\n        var mval = cOptions.nData.maximumFraction;\n        fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;\n      }\n\n      var mfrac = fOptions.minimumFractionDigits;\n      var lfrac = fOptions.maximumFractionDigits;\n\n      if (!isUndefined(mfrac) && !isUndefined(lfrac)) {\n        if (mfrac > lfrac) {\n          fOptions.maximumFractionDigits = mfrac;\n        }\n      }\n    }\n\n    extend(cOptions.nData, fOptions);\n    extend(cOptions.pData, fOptions);\n    return function (value) {\n      if (isNaN(value)) {\n        return symbols[mapper[1]];\n      } else if (!isFinite(value)) {\n        return symbols[mapper[0]];\n      }\n\n      return _this.intNumberFormatter(value, cOptions, dOptions);\n    };\n  };\n  /**\r\n   * Returns grouping details for the pattern provided\r\n   *\r\n   * @param {string} pattern ?\r\n   * @returns {GroupDetails} ?\r\n   */\n\n\n  NumberFormat.getGroupingDetails = function (pattern) {\n    var ret = {};\n    var match = pattern.match(base.negativeDataRegex);\n\n    if (match && match[4]) {\n      var pattern_1 = match[4];\n      var p = pattern_1.lastIndexOf(',');\n\n      if (p !== -1) {\n        var temp = pattern_1.split('.')[0];\n        ret.primary = temp.length - p - 1;\n        var s = pattern_1.lastIndexOf(',', p - 1);\n\n        if (s !== -1) {\n          ret.secondary = p - 1 - s;\n        }\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Returns if the provided integer range is valid.\r\n   *\r\n   * @param {number} val1 ?\r\n   * @param {number} val2 ?\r\n   * @param {boolean} checkbothExist ?\r\n   * @param {boolean} isFraction ?\r\n   * @returns {boolean} ?\r\n   */\n\n\n  NumberFormat.checkValueRange = function (val1, val2, checkbothExist, isFraction) {\n    var decide = isFraction ? 'f' : 's';\n    var dint = 0;\n    var str1 = errorText['l' + decide]; // eslint-disable-next-line\n\n    var str2 = errorText['m' + decide];\n\n    if (!isUndefined(val1)) {\n      this.checkRange(val1, str1, isFraction);\n      dint++;\n    }\n\n    if (!isUndefined(val2)) {\n      this.checkRange(val2, str2, isFraction);\n      dint++;\n    }\n\n    if (dint === 2) {\n      if (val1 < val2) {\n        throwError(str2 + 'specified must be less than the' + str1);\n      } else {\n        return true;\n      }\n    } else if (checkbothExist && dint === 1) {\n      throwError('Both' + str2 + 'and' + str2 + 'must be present');\n    }\n\n    return false;\n  };\n  /**\r\n   * Check if the provided fraction range is valid\r\n   *\r\n   * @param {number} val ?\r\n   * @param {string} text ?\r\n   * @param {boolean} isFraction ?\r\n   * @returns {void} ?\r\n   */\n\n\n  NumberFormat.checkRange = function (val, text, isFraction) {\n    var range = isFraction ? [0, 20] : [1, 21];\n\n    if (val < range[0] || val > range[1]) {\n      throwError(text + 'value must be within the range' + range[0] + 'to' + range[1]);\n    }\n  };\n  /**\r\n   * Returns formatted numeric string for provided formatting options\r\n   *\r\n   * @param {number} value ?\r\n   * @param {base.GenericFormatOptions} fOptions ?\r\n   * @param {CommonOptions} dOptions ?\r\n   * @returns {string} ?\r\n   */\n\n\n  NumberFormat.intNumberFormatter = function (value, fOptions, dOptions) {\n    var curData;\n\n    if (isUndefined(fOptions.nData.type)) {\n      return undefined;\n    } else {\n      if (value < 0) {\n        value = value * -1;\n        curData = fOptions.nData;\n      } else if (value === 0) {\n        curData = fOptions.zeroData || fOptions.pData;\n      } else {\n        curData = fOptions.pData;\n      }\n\n      var fValue = '';\n\n      if (curData.isPercent) {\n        value = value * 100;\n      }\n\n      if (curData.groupOne) {\n        fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);\n      } else {\n        fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits);\n\n        if (curData.minimumIntegerDigits) {\n          fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);\n        }\n      }\n\n      if (curData.type === 'scientific') {\n        fValue = value.toExponential(curData.maximumFractionDigits);\n        fValue = fValue.replace('e', dOptions.numberMapper.numberSymbols[mapper[4]]);\n      }\n\n      fValue = fValue.replace('.', dOptions.numberMapper.numberSymbols[mapper[3]]);\n\n      if (curData.useGrouping) {\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\n        fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ',', dOptions.numberMapper.numberSymbols[mapper[3]] || '.', curData.groupData.secondary);\n      }\n\n      fValue = parser.convertValueParts(fValue, base.latnParseRegex, dOptions.numberMapper.mapper);\n\n      if (curData.nlead === 'N/A') {\n        return curData.nlead;\n      } else {\n        return curData.nlead + fValue + curData.nend;\n      }\n    }\n  };\n  /**\r\n   * Returns significant digits processed numeric string\r\n   *\r\n   * @param {number} value ?\r\n   * @param {number} min ?\r\n   * @param {number} max ?\r\n   * @returns {string} ?\r\n   */\n\n\n  NumberFormat.processSignificantDigits = function (value, min, max) {\n    var temp = value + '';\n    var tn;\n    var length = temp.length;\n\n    if (length < min) {\n      return value.toPrecision(min);\n    } else {\n      temp = value.toPrecision(max);\n      tn = +temp;\n      return tn + '';\n    }\n  };\n  /**\r\n   * Returns grouped numeric string\r\n   *\r\n   * @param {string} val ?\r\n   * @param {number} level1 ?\r\n   * @param {string} sep ?\r\n   * @param {string} decimalSymbol ?\r\n   * @param {number} level2 ?\r\n   * @returns {string} ?\r\n   */\n\n\n  NumberFormat.groupNumbers = function (val, level1, sep, decimalSymbol, level2) {\n    var flag = !isNullOrUndefined(level2) && level2 !== 0;\n    var split = val.split(decimalSymbol);\n    var prefix = split[0];\n    var length = prefix.length;\n    var str = '';\n\n    while (length > level1) {\n      str = prefix.slice(length - level1, length) + (str.length ? sep + str : '');\n      length -= level1;\n\n      if (flag) {\n        level1 = level2;\n        flag = false;\n      }\n    }\n\n    split[0] = prefix.slice(0, length) + (str.length ? sep : '') + str;\n    return split.join(decimalSymbol);\n  };\n  /**\r\n   * Returns fraction processed numeric string\r\n   *\r\n   * @param {number} value ?\r\n   * @param {number} min ?\r\n   * @param {number} max ?\r\n   * @returns {string} ?\r\n   */\n\n\n  NumberFormat.processFraction = function (value, min, max) {\n    var temp = (value + '').split('.')[1];\n    var length = temp ? temp.length : 0;\n\n    if (min && length < min) {\n      var ret = '';\n\n      if (length === 0) {\n        ret = value.toFixed(min);\n      } else {\n        ret += value;\n\n        for (var j = 0; j < min - length; j++) {\n          ret += '0';\n        }\n\n        return ret;\n      }\n\n      return value.toFixed(min);\n    } else if (!isNullOrUndefined(max) && (length > max || max === 0)) {\n      return value.toFixed(max);\n    }\n\n    return value + '';\n  };\n  /**\r\n   * Returns integer processed numeric string\r\n   *\r\n   * @param {string} value ?\r\n   * @param {number} min ?\r\n   * @returns {string} ?\r\n   */\n\n\n  NumberFormat.processMinimumIntegers = function (value, min) {\n    var temp = value.split('.');\n    var lead = temp[0];\n    var len = lead.length;\n\n    if (len < min) {\n      for (var i = 0; i < min - len; i++) {\n        lead = '0' + lead;\n      }\n\n      temp[0] = lead;\n    }\n\n    return temp.join('.');\n  };\n\n  return NumberFormat;\n}();\n\nexport { NumberFormat };","map":{"version":3,"sources":["D:/HUST/20211/Introduction to Software Engineering/Project/Sprint 2/RubyGYM/client/node_modules/@syncfusion/ej2-base/src/intl/number-formatter.js"],"names":["isUndefined","throwError","isNullOrUndefined","extend","isBlazor","getValue","defaultCurrencyCode","IntlBase","base","ParserBase","parser","errorText","integerError","percentSign","minusSign","spaceRegex","mapper","infinity","nan","NumberFormat","numberFormatter","culture","option","cldr","_this","fOptions","cOptions","dOptions","symbolPattern","dependable","getDependables","numObject","numericObject","numberMapper","getNumberMapper","parserObject","getNumberingSystem","currencySymbol","getCurrencySymbol","currency","altSymbol","percentSymbol","numberSymbols","minusSymbol","symbols","format","formatRegex","test","customFormat","getProperNumericSkeleton","isCurrency","type","isPercent","getSymbolPattern","numberSystem","isAccount","groupOne","checkValueRange","maximumSignificantDigits","minimumSignificantDigits","maximumFractionDigits","minimumFractionDigits","fractionDigits","useGrouping","replace","defaultCurrency","split","nData","getFormatData","pData","groupSeparator","groupData","getGroupingDetails","replaceBlazorCurrency","minFrac","minimumFraction","mval","maximumFraction","mfrac","lfrac","value","isNaN","isFinite","intNumberFormatter","pattern","ret","match","negativeDataRegex","pattern_1","p","lastIndexOf","temp","primary","length","s","secondary","val1","val2","checkbothExist","isFraction","decide","dint","str1","str2","checkRange","val","text","range","curData","undefined","zeroData","fValue","processSignificantDigits","processFraction","minimumIntegerDigits","processMinimumIntegers","toExponential","groupNumbers","convertValueParts","latnParseRegex","nlead","nend","min","max","tn","toPrecision","level1","sep","decimalSymbol","level2","flag","prefix","str","slice","join","toFixed","j","lead","len","i"],"mappings":"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","sourcesContent":["import { isUndefined, throwError, isNullOrUndefined, extend, isBlazor, getValue } from '../util';\r\nimport { defaultCurrencyCode } from '../internationalization';\r\nimport { IntlBase as base } from './intl-base';\r\nimport { ParserBase as parser } from './parser-base';\r\nvar errorText = {\r\n    'ms': 'minimumSignificantDigits',\r\n    'ls': 'maximumSignificantDigits',\r\n    'mf': 'minimumFractionDigits',\r\n    'lf': 'maximumFractionDigits',\r\n};\r\nvar integerError = 'minimumIntegerDigits';\r\nvar percentSign = 'percentSign';\r\nvar minusSign = 'minusSign';\r\nvar spaceRegex = /\\s/;\r\nvar mapper = ['infinity', 'nan', 'group', 'decimal', 'exponential'];\r\nvar infinity = 'infinity';\r\nvar nan = 'nan';\r\n/**\r\n * Module for number formatting.\r\n *\r\n * @private\r\n */\r\nvar NumberFormat = /** @class */ (function () {\r\n    function NumberFormat() {\r\n    }\r\n    /**\r\n     * Returns the formatter function for given skeleton.\r\n     *\r\n     * @param {string} culture -  Specifies the culture name to be which formatting.\r\n     * @param {NumberFormatOptions} option - Specific the format in which number  will format.\r\n     * @param {Object} cldr - Specifies the global cldr data collection.\r\n     * @returns {Function} ?\r\n     */\r\n    NumberFormat.numberFormatter = function (culture, option, cldr) {\r\n        var _this = this;\r\n        var fOptions = extend({}, option);\r\n        var cOptions = {};\r\n        var dOptions = {};\r\n        var symbolPattern;\r\n        var dependable = base.getDependables(cldr, culture, '', true);\r\n        var numObject = dependable.numericObject;\r\n        dOptions.numberMapper = isBlazor() ? extend({}, numObject) :\r\n            parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr), true);\r\n        dOptions.currencySymbol = isBlazor() ? getValue('currencySymbol', numObject) : base.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode, option.altSymbol);\r\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n        dOptions.percentSymbol = isBlazor() ? getValue('numberSymbols.percentSign', numObject) :\r\n            dOptions.numberMapper.numberSymbols[percentSign];\r\n        dOptions.minusSymbol = isBlazor() ? getValue('numberSymbols.minusSign', numObject) :\r\n            dOptions.numberMapper.numberSymbols[minusSign];\r\n        var symbols = dOptions.numberMapper.numberSymbols;\r\n        if ((option.format) && !(base.formatRegex.test(option.format))) {\r\n            cOptions = base.customFormat(option.format, dOptions, dependable.numericObject);\r\n        }\r\n        else {\r\n            extend(fOptions, base.getProperNumericSkeleton(option.format || 'N'));\r\n            fOptions.isCurrency = fOptions.type === 'currency';\r\n            fOptions.isPercent = fOptions.type === 'percent';\r\n            if (!isBlazor()) {\r\n                symbolPattern = base.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);\r\n            }\r\n            fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);\r\n            this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);\r\n            if (!isUndefined(fOptions.fractionDigits)) {\r\n                fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;\r\n            }\r\n            if (isUndefined(fOptions.useGrouping)) {\r\n                fOptions.useGrouping = true;\r\n            }\r\n            if (fOptions.isCurrency && !isBlazor()) {\r\n                symbolPattern = symbolPattern.replace(/\\u00A4/g, base.defaultCurrency);\r\n            }\r\n            if (!isBlazor()) {\r\n                var split = symbolPattern.split(';');\r\n                cOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, dOptions.currencySymbol);\r\n                cOptions.pData = base.getFormatData(split[0], false, dOptions.currencySymbol);\r\n                if (fOptions.useGrouping) {\r\n                    fOptions.groupSeparator = symbols[mapper[2]];\r\n                    fOptions.groupData = this.getGroupingDetails(split[0]);\r\n                }\r\n            }\r\n            else {\r\n                cOptions.nData = extend({}, {}, getValue(fOptions.type + 'nData', numObject));\r\n                cOptions.pData = extend({}, {}, getValue(fOptions.type + 'pData', numObject));\r\n                if (fOptions.type === 'currency' && option.currency) {\r\n                    base.replaceBlazorCurrency([cOptions.pData, cOptions.nData], dOptions.currencySymbol, option.currency);\r\n                }\r\n            }\r\n            var minFrac = isUndefined(fOptions.minimumFractionDigits);\r\n            if (minFrac) {\r\n                fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;\r\n            }\r\n            if (isUndefined(fOptions.maximumFractionDigits)) {\r\n                var mval = cOptions.nData.maximumFraction;\r\n                fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;\r\n            }\r\n            var mfrac = fOptions.minimumFractionDigits;\r\n            var lfrac = fOptions.maximumFractionDigits;\r\n            if (!isUndefined(mfrac) && !isUndefined(lfrac)) {\r\n                if (mfrac > lfrac) {\r\n                    fOptions.maximumFractionDigits = mfrac;\r\n                }\r\n            }\r\n        }\r\n        extend(cOptions.nData, fOptions);\r\n        extend(cOptions.pData, fOptions);\r\n        return function (value) {\r\n            if (isNaN(value)) {\r\n                return symbols[mapper[1]];\r\n            }\r\n            else if (!isFinite(value)) {\r\n                return symbols[mapper[0]];\r\n            }\r\n            return _this.intNumberFormatter(value, cOptions, dOptions);\r\n        };\r\n    };\r\n    /**\r\n     * Returns grouping details for the pattern provided\r\n     *\r\n     * @param {string} pattern ?\r\n     * @returns {GroupDetails} ?\r\n     */\r\n    NumberFormat.getGroupingDetails = function (pattern) {\r\n        var ret = {};\r\n        var match = pattern.match(base.negativeDataRegex);\r\n        if (match && match[4]) {\r\n            var pattern_1 = match[4];\r\n            var p = pattern_1.lastIndexOf(',');\r\n            if (p !== -1) {\r\n                var temp = pattern_1.split('.')[0];\r\n                ret.primary = (temp.length - p) - 1;\r\n                var s = pattern_1.lastIndexOf(',', p - 1);\r\n                if (s !== -1) {\r\n                    ret.secondary = p - 1 - s;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Returns if the provided integer range is valid.\r\n     *\r\n     * @param {number} val1 ?\r\n     * @param {number} val2 ?\r\n     * @param {boolean} checkbothExist ?\r\n     * @param {boolean} isFraction ?\r\n     * @returns {boolean} ?\r\n     */\r\n    NumberFormat.checkValueRange = function (val1, val2, checkbothExist, isFraction) {\r\n        var decide = isFraction ? 'f' : 's';\r\n        var dint = 0;\r\n        var str1 = errorText['l' + decide];\r\n        // eslint-disable-next-line\r\n        var str2 = errorText['m' + decide];\r\n        if (!isUndefined(val1)) {\r\n            this.checkRange(val1, str1, isFraction);\r\n            dint++;\r\n        }\r\n        if (!isUndefined(val2)) {\r\n            this.checkRange(val2, str2, isFraction);\r\n            dint++;\r\n        }\r\n        if (dint === 2) {\r\n            if (val1 < val2) {\r\n                throwError(str2 + 'specified must be less than the' + str1);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else if (checkbothExist && dint === 1) {\r\n            throwError('Both' + str2 + 'and' + str2 + 'must be present');\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Check if the provided fraction range is valid\r\n     *\r\n     * @param {number} val ?\r\n     * @param {string} text ?\r\n     * @param {boolean} isFraction ?\r\n     * @returns {void} ?\r\n     */\r\n    NumberFormat.checkRange = function (val, text, isFraction) {\r\n        var range = isFraction ? [0, 20] : [1, 21];\r\n        if (val < range[0] || val > range[1]) {\r\n            throwError(text + 'value must be within the range' + range[0] + 'to' + range[1]);\r\n        }\r\n    };\r\n    /**\r\n     * Returns formatted numeric string for provided formatting options\r\n     *\r\n     * @param {number} value ?\r\n     * @param {base.GenericFormatOptions} fOptions ?\r\n     * @param {CommonOptions} dOptions ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.intNumberFormatter = function (value, fOptions, dOptions) {\r\n        var curData;\r\n        if (isUndefined(fOptions.nData.type)) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            if (value < 0) {\r\n                value = value * -1;\r\n                curData = fOptions.nData;\r\n            }\r\n            else if (value === 0) {\r\n                curData = fOptions.zeroData || fOptions.pData;\r\n            }\r\n            else {\r\n                curData = fOptions.pData;\r\n            }\r\n            var fValue = '';\r\n            if (curData.isPercent) {\r\n                value = value * 100;\r\n            }\r\n            if (curData.groupOne) {\r\n                fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);\r\n            }\r\n            else {\r\n                fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits);\r\n                if (curData.minimumIntegerDigits) {\r\n                    fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);\r\n                }\r\n            }\r\n            if (curData.type === 'scientific') {\r\n                fValue = value.toExponential(curData.maximumFractionDigits);\r\n                fValue = fValue.replace('e', dOptions.numberMapper.numberSymbols[mapper[4]]);\r\n            }\r\n            fValue = fValue.replace('.', dOptions.numberMapper.numberSymbols[mapper[3]]);\r\n            if (curData.useGrouping) {\r\n                /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n                fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ',', dOptions.numberMapper.numberSymbols[mapper[3]] || '.', curData.groupData.secondary);\r\n            }\r\n            fValue = parser.convertValueParts(fValue, base.latnParseRegex, dOptions.numberMapper.mapper);\r\n            if (curData.nlead === 'N/A') {\r\n                return curData.nlead;\r\n            }\r\n            else {\r\n                return curData.nlead + fValue + curData.nend;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns significant digits processed numeric string\r\n     *\r\n     * @param {number} value ?\r\n     * @param {number} min ?\r\n     * @param {number} max ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.processSignificantDigits = function (value, min, max) {\r\n        var temp = value + '';\r\n        var tn;\r\n        var length = temp.length;\r\n        if (length < min) {\r\n            return value.toPrecision(min);\r\n        }\r\n        else {\r\n            temp = value.toPrecision(max);\r\n            tn = +temp;\r\n            return tn + '';\r\n        }\r\n    };\r\n    /**\r\n     * Returns grouped numeric string\r\n     *\r\n     * @param {string} val ?\r\n     * @param {number} level1 ?\r\n     * @param {string} sep ?\r\n     * @param {string} decimalSymbol ?\r\n     * @param {number} level2 ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.groupNumbers = function (val, level1, sep, decimalSymbol, level2) {\r\n        var flag = !isNullOrUndefined(level2) && level2 !== 0;\r\n        var split = val.split(decimalSymbol);\r\n        var prefix = split[0];\r\n        var length = prefix.length;\r\n        var str = '';\r\n        while (length > level1) {\r\n            str = prefix.slice(length - level1, length) + (str.length ?\r\n                (sep + str) : '');\r\n            length -= level1;\r\n            if (flag) {\r\n                level1 = level2;\r\n                flag = false;\r\n            }\r\n        }\r\n        split[0] = prefix.slice(0, length) + (str.length ? sep : '') + str;\r\n        return split.join(decimalSymbol);\r\n    };\r\n    /**\r\n     * Returns fraction processed numeric string\r\n     *\r\n     * @param {number} value ?\r\n     * @param {number} min ?\r\n     * @param {number} max ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.processFraction = function (value, min, max) {\r\n        var temp = (value + '').split('.')[1];\r\n        var length = temp ? temp.length : 0;\r\n        if (min && length < min) {\r\n            var ret = '';\r\n            if (length === 0) {\r\n                ret = value.toFixed(min);\r\n            }\r\n            else {\r\n                ret += value;\r\n                for (var j = 0; j < min - length; j++) {\r\n                    ret += '0';\r\n                }\r\n                return ret;\r\n            }\r\n            return value.toFixed(min);\r\n        }\r\n        else if (!isNullOrUndefined(max) && (length > max || max === 0)) {\r\n            return value.toFixed(max);\r\n        }\r\n        return value + '';\r\n    };\r\n    /**\r\n     * Returns integer processed numeric string\r\n     *\r\n     * @param {string} value ?\r\n     * @param {number} min ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.processMinimumIntegers = function (value, min) {\r\n        var temp = value.split('.');\r\n        var lead = temp[0];\r\n        var len = lead.length;\r\n        if (len < min) {\r\n            for (var i = 0; i < min - len; i++) {\r\n                lead = '0' + lead;\r\n            }\r\n            temp[0] = lead;\r\n        }\r\n        return temp.join('.');\r\n    };\r\n    return NumberFormat;\r\n}());\r\nexport { NumberFormat };\r\n"]},"metadata":{},"sourceType":"module"}