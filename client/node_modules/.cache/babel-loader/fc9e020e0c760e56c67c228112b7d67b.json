{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global DOMParser */\n\n/**\n * @module widget/widgettypearound\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport Enter from '@ckeditor/ckeditor5-enter/src/enter';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport { isForwardArrowKeyCode, keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { isTypeAroundWidget, getClosestTypeAroundDomButton, getTypeAroundButtonPosition, getClosestWidgetViewElement, getTypeAroundFakeCaretPosition, TYPE_AROUND_SELECTION_ATTRIBUTE } from './utils';\nimport { isNonTypingKeystroke } from '@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling';\nimport { isWidget } from '../utils';\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\nconst POSSIBLE_INSERTION_POSITIONS = ['before', 'after']; // Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\n\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, 'image/svg+xml').firstChild;\nconst PLUGIN_DISABLED_EDITING_ROOT_CLASS = 'ck-widget__type-around_disabled';\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects the user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class WidgetTypeAround extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'WidgetTypeAround';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [Enter, Delete];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  constructor(editor) {\n    super(editor);\n    /**\n     * A reference to the model widget element that has the fake caret active\n     * on either side of it. It is later used to remove CSS classes associated with the fake caret\n     * when the widget no longer needs it.\n     *\n     * @private\n     * @member {module:engine/model/element~Element|null}\n     */\n\n    this._currentFakeCaretModelElement = null;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const editingView = editor.editing.view; // Set a CSS class on the view editing root when the plugin is disabled so all the buttons\n    // and lines visually disappear. All the interactions are disabled in individual plugin methods.\n\n    this.on('change:isEnabled', (evt, data, isEnabled) => {\n      editingView.change(writer => {\n        for (const root of editingView.document.roots) {\n          if (isEnabled) {\n            writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n          } else {\n            writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n          }\n        }\n      });\n\n      if (!isEnabled) {\n        editor.model.change(writer => {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n        });\n      }\n    });\n\n    this._enableTypeAroundUIInjection();\n\n    this._enableInsertingParagraphsOnButtonClick();\n\n    this._enableInsertingParagraphsOnEnterKeypress();\n\n    this._enableInsertingParagraphsOnTypingKeystroke();\n\n    this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n\n    this._enableDeleteIntegration();\n\n    this._enableInsertContentIntegration();\n\n    this._enableDeleteContentIntegration();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    this._currentFakeCaretModelElement = null;\n  }\n  /**\n   * Inserts a new paragraph next to a widget element with the selection anchored in it.\n   *\n   * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n   * the viewport to the selection in the inserted paragraph.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.\n   * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n   */\n\n\n  _insertParagraph(widgetModelElement, position) {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    editor.execute('insertParagraph', {\n      position: editor.model.createPositionAt(widgetModelElement, position)\n    });\n    editingView.focus();\n    editingView.scrollToTheSelection();\n  }\n  /**\n   * A wrapper for the {@link module:utils/emittermixin~EmitterMixin#listenTo} method that executes the callbacks only\n   * when the plugin {@link #isEnabled is enabled}.\n   *\n   * @private\n   * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n   * @param {String} event The name of the event.\n   * @param {Function} callback The function to be called on event.\n   * @param {Object} [options={}] Additional options.\n   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n   * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n   * order they were added.\n   */\n\n\n  _listenToIfEnabled(emitter, event, callback, options) {\n    var _this = this;\n\n    this.listenTo(emitter, event, function () {\n      // Do not respond if the plugin is disabled.\n      if (_this.isEnabled) {\n        callback(...arguments);\n      }\n    }, options);\n  }\n  /**\n   * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n   * does not expect a position. Instead, it performs the insertion next to a selected widget\n   * according to the `widget-type-around` model selection attribute value (fake caret position).\n   *\n   * Because this method requires the `widget-type-around` attribute to be set,\n   * the insertion can only happen when the widget's fake caret is active (e.g. activated\n   * using the keyboard).\n   *\n   * @private\n   * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n   */\n\n\n  _insertParagraphAccordingToFakeCaretPosition() {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n\n    if (!typeAroundFakeCaretPosition) {\n      return false;\n    }\n\n    const selectedModelElement = modelSelection.getSelectedElement();\n\n    this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);\n\n    return true;\n  }\n  /**\n   * Creates a listener in the editing conversion pipeline that injects the widget type around\n   * UI into every single widget instance created in the editor.\n   *\n   * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n   * wrapper which renders DOM buttons that users can use to insert paragraphs.\n   *\n   * @private\n   */\n\n\n  _enableTypeAroundUIInjection() {\n    const editor = this.editor;\n    const schema = editor.model.schema;\n    const t = editor.locale.t;\n    const buttonTitles = {\n      before: t('Insert paragraph before block'),\n      after: t('Insert paragraph after block')\n    };\n    editor.editing.downcastDispatcher.on('insert', (evt, data, conversionApi) => {\n      const viewElement = conversionApi.mapper.toViewElement(data.item); // Filter out non-widgets and inline widgets.\n\n      if (isTypeAroundWidget(viewElement, data.item, schema)) {\n        injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);\n      }\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Brings support for the fake caret that appears when either:\n   *\n   * * the selection moves to a widget from a position next to it using arrow keys,\n   * * the arrow key is pressed when the widget is already selected.\n   *\n   * The fake caret lets the user know that they can start typing or just press\n   * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.\n   *\n   * The fake caret disappears when the user changes the selection or the editor\n   * gets blurred.\n   *\n   * The whole idea is as follows:\n   *\n   * 1. A user does one of the 2 scenarios described at the beginning.\n   * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the fake caret.\n   * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating\n   *    on which side of the widget it should appear.\n   * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n   *    fake caret on the view widget.\n   * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher\n   *    does the CSS class clean-up in the view.\n   * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection\n   *    attribute (the former also removes widget CSS classes).\n   *\n   * @private\n   */\n\n\n  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const schema = model.schema;\n    const editingView = editor.editing.view; // This is the main listener responsible for the fake caret.\n    // Note: The priority must precede the default Widget class keydown handler (\"high\").\n\n    this._listenToIfEnabled(editingView.document, 'arrowKey', (evt, domEventData) => {\n      this._handleArrowKeyPress(evt, domEventData);\n    }, {\n      context: [isWidget, '$text'],\n      priority: 'high'\n    }); // This listener makes sure the widget type around selection attribute will be gone from the model\n    // selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n    // (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n    // let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n\n\n    this._listenToIfEnabled(modelSelection, 'change:range', (evt, data) => {\n      // Do not reset the selection attribute when the change was indirect.\n      if (!data.directChange) {\n        return;\n      } // Get rid of the widget type around attribute of the selection on every change:range.\n      // If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n\n\n      editor.model.change(writer => {\n        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n      });\n    }); // Get rid of the widget type around attribute of the selection on every document change\n    // that makes widget not selected any more (i.e. widget was removed).\n\n\n    this._listenToIfEnabled(model.document, 'change:data', () => {\n      const selectedModelElement = modelSelection.getSelectedElement();\n\n      if (selectedModelElement) {\n        const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n\n        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n          return;\n        }\n      }\n\n      editor.model.change(writer => {\n        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n      });\n    }); // React to changes of the model selection attribute made by the arrow keys listener.\n    // If the block widget is selected and the attribute changes, downcast the attribute to special\n    // CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n\n\n    this._listenToIfEnabled(editor.editing.downcastDispatcher, 'selection', (evt, data, conversionApi) => {\n      const writer = conversionApi.writer;\n\n      if (this._currentFakeCaretModelElement) {\n        const selectedViewElement = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);\n\n        if (selectedViewElement) {\n          // Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n          writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement);\n          this._currentFakeCaretModelElement = null;\n        }\n      }\n\n      const selectedModelElement = data.selection.getSelectedElement();\n\n      if (!selectedModelElement) {\n        return;\n      }\n\n      const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);\n\n      if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n        return;\n      }\n\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);\n\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n\n      writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement); // Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n      // selection changes\n\n      this._currentFakeCaretModelElement = selectedModelElement;\n    });\n\n    this._listenToIfEnabled(editor.ui.focusTracker, 'change:isFocused', (evt, name, isFocused) => {\n      if (!isFocused) {\n        editor.model.change(writer => {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n        });\n      }\n    });\n\n    function positionToWidgetCssClass(position) {\n      return `ck-widget_type-around_show-fake-caret_${position}`;\n    }\n  }\n  /**\n   * A listener executed on each \"keydown\" in the view document, a part of\n   * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n   *\n   * It decides whether the arrow keypress should activate the fake caret or not (also whether it should\n   * be deactivated).\n   *\n   * The fake caret activation is done by setting the `widget-type-around` model selection attribute\n   * in this listener, and stopping and preventing the event that would normally be handled by the widget\n   * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n   * includes inline widgets, which are ignored by the widget type around plugin).\n   *\n   * @private\n   */\n\n\n  _handleArrowKeyPress(evt, domEventData) {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const schema = model.schema;\n    const editingView = editor.editing.view;\n    const keyCode = domEventData.keyCode;\n    const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);\n    const selectedViewElement = editingView.document.selection.getSelectedElement();\n    const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);\n    let shouldStopAndPreventDefault; // Handle keyboard navigation when a type-around-compatible widget is currently selected.\n\n    if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n      shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);\n    } // Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n    // and the widget is about to be selected.\n    else if (modelSelection.isCollapsed) {\n      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);\n    } // Handle collapsing a non-collapsed selection that is wider than on a single widget.\n    else if (!domEventData.shiftKey) {\n      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);\n    }\n\n    if (shouldStopAndPreventDefault) {\n      domEventData.preventDefault();\n      evt.stop();\n    }\n  }\n  /**\n   * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n   * the fake caret for that widget, depending on the current value of the `widget-type-around` model\n   * selection attribute and the direction of the pressed arrow key.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n   * process the event any further. Returns `false` otherwise.\n   */\n\n\n  _handleArrowKeyPressOnSelectedWidget(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n    return model.change(writer => {\n      // If the fake caret is displayed...\n      if (typeAroundFakeCaretPosition) {\n        const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? 'after' : 'before'); // If the keyboard arrow works against the value of the selection attribute...\n        // then remove the selection attribute but prevent default DOM actions\n        // and do not let the Widget plugin listener move the selection. This brings\n        // the widget back to the state, for instance, like if was selected using the mouse.\n        //\n        // **Note**: If leaving the widget when the fake caret is active, then the default\n        // Widget handler will change the selection and, in turn, this will automatically discard\n        // the selection attribute.\n\n        if (!isLeavingWidget) {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n          return true;\n        }\n      } // If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n      // key press. This also means we cannot let the Widget plugin listener move the selection.\n      else {\n        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n        return true;\n      }\n\n      return false;\n    });\n  }\n  /**\n   * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n   * to one and upon the fake caret should become active for this widget upon arrow keypress\n   * (AKA entering/selecting the widget).\n   *\n   * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.\n   * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the\n   * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n   * process the event any further. Returns `false` otherwise.\n   */\n\n\n  _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const schema = model.schema;\n    const widgetPlugin = editor.plugins.get('Widget'); // This is the widget the selection is about to be set on.\n\n    const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);\n\n    const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);\n\n    if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {\n      model.change(writer => {\n        widgetPlugin._setSelectionOverElement(modelElementNextToSelection);\n\n        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after');\n      }); // The change() block above does the same job as the Widget plugin. The event can\n      // be safely canceled.\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Handles the keyboard navigation on \"keydown\" when a widget is currently selected (together with some other content)\n   * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n   * process the event any further. Returns `false` otherwise.\n   */\n\n\n  _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const schema = model.schema;\n    const mapper = editor.editing.mapper;\n    const modelSelection = model.document.selection;\n    const selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;\n    const selectedViewNode = mapper.toViewElement(selectedModelNode); // There is a widget at the collapse position so collapse the selection to the fake caret on it.\n\n    if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {\n      model.change(writer => {\n        writer.setSelection(selectedModelNode, 'on');\n        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n      });\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Registers a `mousedown` listener for the view document which intercepts events\n   * coming from the widget type around UI, which happens when a user clicks one of the buttons\n   * that insert a paragraph next to a widget.\n   *\n   * @private\n   */\n\n\n  _enableInsertingParagraphsOnButtonClick() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n\n    this._listenToIfEnabled(editingView.document, 'mousedown', (evt, domEventData) => {\n      const button = getClosestTypeAroundDomButton(domEventData.domTarget);\n\n      if (!button) {\n        return;\n      }\n\n      const buttonPosition = getTypeAroundButtonPosition(button);\n      const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);\n      const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);\n\n      this._insertParagraph(widgetModelElement, buttonPosition);\n\n      domEventData.preventDefault();\n      evt.stop();\n    });\n  }\n  /**\n   * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph\n   * near the widget when either:\n   *\n   * * The fake caret was first activated using the arrow keys,\n   * * The entire widget is selected in the model.\n   *\n   * In the first case, the new paragraph is inserted according to the `widget-type-around` selection\n   * attribute (see {@link #_handleArrowKeyPress}).\n   *\n   * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke\n   * was pressed or not.\n   *\n   * @private\n   */\n\n\n  _enableInsertingParagraphsOnEnterKeypress() {\n    const editor = this.editor;\n    const selection = editor.model.document.selection;\n    const editingView = editor.editing.view;\n\n    this._listenToIfEnabled(editingView.document, 'enter', (evt, domEventData) => {\n      // This event could be triggered from inside the widget but we are interested\n      // only when the widget is selected itself.\n      if (evt.eventPhase != 'atTarget') {\n        return;\n      }\n\n      const selectedModelElement = selection.getSelectedElement();\n      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n      const schema = editor.model.schema;\n      let wasHandled; // First check if the widget is selected and there's a type around selection attribute associated\n      // with the fake caret that would tell where to insert a new paragraph.\n\n      if (this._insertParagraphAccordingToFakeCaretPosition()) {\n        wasHandled = true;\n      } // Then, if there is no selection attribute associated with the fake caret, check if the widget\n      // simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n      else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n        this._insertParagraph(selectedModelElement, domEventData.isSoft ? 'before' : 'after');\n\n        wasHandled = true;\n      }\n\n      if (wasHandled) {\n        domEventData.preventDefault();\n        evt.stop();\n      }\n    }, {\n      context: isWidget\n    });\n  }\n  /**\n   * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n   * to insert a paragraph next to a widget when the fake caret was activated using arrow\n   * keys but it responds to typing keystrokes instead of <kbd>Enter</kbd>.\n   *\n   * \"Typing keystrokes\" are keystrokes that insert new content into the document,\n   * for instance, letters (\"a\") or numbers (\"4\"). The \"keydown\" listener enabled by this method\n   * will insert a new paragraph according to the `widget-type-around` model selection attribute\n   * as the user simply starts typing, which creates the impression that the fake caret\n   * behaves like a real one rendered by the browser (AKA your text appears where the caret was).\n   *\n   * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command\n   * and another one for actual typing. It is not a disaster but this may need to be fixed\n   * sooner or later.\n   *\n   * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.\n   *\n   * @private\n   */\n\n\n  _enableInsertingParagraphsOnTypingKeystroke() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const keyCodesHandledSomewhereElse = [keyCodes.enter, keyCodes.delete, keyCodes.backspace]; // Note: The priority must precede the default observers.\n\n    this._listenToIfEnabled(editingView.document, 'keydown', (evt, domEventData) => {\n      // Don't handle enter/backspace/delete here. They are handled in dedicated listeners.\n      if (!keyCodesHandledSomewhereElse.includes(domEventData.keyCode) && !isNonTypingKeystroke(domEventData)) {\n        this._insertParagraphAccordingToFakeCaretPosition();\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * It creates a \"delete\" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>\n   * is pressed and the fake caret is currently active.\n   *\n   * The fake caret should create an illusion of a real browser caret so that when it appears before or after\n   * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content\n   * before or after a widget (depending on the content surrounding the widget).\n   *\n   * @private\n   */\n\n\n  _enableDeleteIntegration() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const model = editor.model;\n    const schema = model.schema;\n\n    this._listenToIfEnabled(editingView.document, 'delete', (evt, domEventData) => {\n      // This event could be triggered from inside the widget but we are interested\n      // only when the widget is selected itself.\n      if (evt.eventPhase != 'atTarget') {\n        return;\n      }\n\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection); // This listener handles only these cases when the fake caret is active.\n\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n\n      const direction = domEventData.direction;\n      const selectedModelWidget = model.document.selection.getSelectedElement();\n      const isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n      const isDeleteForward = direction == 'forward';\n      const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;\n\n      if (shouldDeleteEntireWidget) {\n        editor.execute('delete', {\n          selection: model.createSelection(selectedModelWidget, 'on')\n        });\n      } else {\n        const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction); // If there is somewhere to move selection to, then there will be something to delete.\n\n        if (range) {\n          // If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n          if (!range.isCollapsed) {\n            model.change(writer => {\n              writer.setSelection(range);\n              editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n            });\n          } else {\n            const probe = model.createSelection(range.start);\n            model.modifySelection(probe, {\n              direction\n            }); // If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n            // If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n\n            if (!probe.focus.isEqual(range.start)) {\n              model.change(writer => {\n                writer.setSelection(range);\n                editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n              });\n            } // If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n            // next to a widget that should be removed. \"delete\" and \"deleteForward\" commands cannot get rid of it\n            // so calling Model#deleteContent here manually.\n            else {\n              const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);\n              model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, 'on'), {\n                doNotAutoparagraph: true\n              });\n            }\n          }\n        }\n      } // If some content was deleted, don't let the handler from the Widget plugin kick in.\n      // If nothing was deleted, then the default handler will have nothing to do anyway.\n\n\n      domEventData.preventDefault();\n      evt.stop();\n    }, {\n      context: isWidget\n    });\n  }\n  /**\n   * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n   * content near a widget when the fake caret is first activated using the arrow keys.\n   *\n   * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n   *\n   * @private\n   */\n\n\n  _enableInsertContentIntegration() {\n    const editor = this.editor;\n    const model = this.editor.model;\n    const documentSelection = model.document.selection;\n\n    this._listenToIfEnabled(editor.model, 'insertContent', (evt, _ref) => {\n      let [content, selectable] = _ref;\n\n      if (selectable && !selectable.is('documentSelection')) {\n        return;\n      }\n\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n\n      evt.stop();\n      return model.change(writer => {\n        const selectedElement = documentSelection.getSelectedElement();\n        const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);\n        const selection = writer.createSelection(position);\n        const result = model.insertContent(content, selection);\n        writer.setSelection(selection);\n        return result;\n      });\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake\n   * caret is active.\n   *\n   * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n   * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,\n   * plain text pasting.\n   *\n   * @private\n   */\n\n\n  _enableDeleteContentIntegration() {\n    const editor = this.editor;\n    const model = this.editor.model;\n    const documentSelection = model.document.selection;\n\n    this._listenToIfEnabled(editor.model, 'deleteContent', (evt, _ref2) => {\n      let [selection] = _ref2;\n\n      if (selection && !selection.is('documentSelection')) {\n        return;\n      }\n\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection); // Disable removing the selection content while pasting plain text.\n\n      if (typeAroundFakeCaretPosition) {\n        evt.stop();\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n\n} // Injects the type around UI into a view widget instance.\n//\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {Object.<String,String>} buttonTitles\n// @param {module:engine/view/element~Element} widgetViewElement\n\nfunction injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {\n  const typeAroundWrapper = viewWriter.createUIElement('div', {\n    class: 'ck ck-reset_all ck-widget__type-around'\n  }, function (domDocument) {\n    const wrapperDomElement = this.toDomElement(domDocument);\n    injectButtons(wrapperDomElement, buttonTitles);\n    injectFakeCaret(wrapperDomElement);\n    return wrapperDomElement;\n  }); // Inject the type around wrapper into the widget's wrapper.\n\n  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, 'end'), typeAroundWrapper);\n} // FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n// <svg> here.\n//\n// @param {HTMLElement} wrapperDomElement\n// @param {Object.<String,String>} buttonTitles\n\n\nfunction injectButtons(wrapperDomElement, buttonTitles) {\n  for (const position of POSSIBLE_INSERTION_POSITIONS) {\n    const buttonTemplate = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-widget__type-around__button', `ck-widget__type-around__button_${position}`],\n        title: buttonTitles[position]\n      },\n      children: [wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)]\n    });\n    wrapperDomElement.appendChild(buttonTemplate.render());\n  }\n} // @param {HTMLElement} wrapperDomElement\n\n\nfunction injectFakeCaret(wrapperDomElement) {\n  const caretTemplate = new Template({\n    tag: 'div',\n    attributes: {\n      class: ['ck', 'ck-widget__type-around__fake-caret']\n    }\n  });\n  wrapperDomElement.appendChild(caretTemplate.render());\n} // Returns the ancestor of an element closest to the root which is empty. For instance,\n// for `<baz>`:\n//\n//\t\t<foo>abc<bar><baz></baz></bar></foo>\n//\n// it returns `<bar>`.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/element~Element|null}\n\n\nfunction getDeepestEmptyElementAncestor(schema, element) {\n  let deepestEmptyAncestor = element;\n\n  for (const ancestor of element.getAncestors({\n    parentFirst: true\n  })) {\n    if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {\n      break;\n    }\n\n    deepestEmptyAncestor = ancestor;\n  }\n\n  return deepestEmptyAncestor;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js"],"names":["Plugin","Template","Enter","Delete","isForwardArrowKeyCode","keyCodes","isTypeAroundWidget","getClosestTypeAroundDomButton","getTypeAroundButtonPosition","getClosestWidgetViewElement","getTypeAroundFakeCaretPosition","TYPE_AROUND_SELECTION_ATTRIBUTE","isNonTypingKeystroke","isWidget","returnIcon","POSSIBLE_INSERTION_POSITIONS","RETURN_ARROW_ICON_ELEMENT","DOMParser","parseFromString","firstChild","PLUGIN_DISABLED_EDITING_ROOT_CLASS","WidgetTypeAround","pluginName","requires","constructor","editor","_currentFakeCaretModelElement","init","editingView","editing","view","on","evt","data","isEnabled","change","writer","root","document","roots","removeClass","addClass","model","removeSelectionAttribute","_enableTypeAroundUIInjection","_enableInsertingParagraphsOnButtonClick","_enableInsertingParagraphsOnEnterKeypress","_enableInsertingParagraphsOnTypingKeystroke","_enableTypeAroundFakeCaretActivationUsingKeyboardArrows","_enableDeleteIntegration","_enableInsertContentIntegration","_enableDeleteContentIntegration","destroy","_insertParagraph","widgetModelElement","position","execute","createPositionAt","focus","scrollToTheSelection","_listenToIfEnabled","emitter","event","callback","options","listenTo","_insertParagraphAccordingToFakeCaretPosition","modelSelection","selection","typeAroundFakeCaretPosition","selectedModelElement","getSelectedElement","schema","t","locale","buttonTitles","before","after","downcastDispatcher","conversionApi","viewElement","mapper","toViewElement","item","injectUIIntoWidget","priority","domEventData","_handleArrowKeyPress","context","directChange","selectedViewElement","map","positionToWidgetCssClass","ui","focusTracker","name","isFocused","keyCode","isForward","contentLanguageDirection","toModelElement","shouldStopAndPreventDefault","_handleArrowKeyPressOnSelectedWidget","isCollapsed","_handleArrowKeyPressWhenSelectionNextToAWidget","shiftKey","_handleArrowKeyPressWhenNonCollapsedSelection","preventDefault","stop","isLeavingWidget","setSelectionAttribute","widgetPlugin","plugins","get","modelElementNextToSelection","_getObjectElementNextToSelection","viewElementNextToSelection","_setSelectionOverElement","selectedModelNode","getLastPosition","nodeBefore","getFirstPosition","nodeAfter","selectedViewNode","setSelection","button","domTarget","buttonPosition","widgetViewElement","domConverter","eventPhase","wasHandled","isSoft","keyCodesHandledSomewhereElse","enter","delete","backspace","includes","direction","selectedModelWidget","isFakeCaretBefore","isDeleteForward","shouldDeleteEntireWidget","createSelection","range","getNearestSelectionRange","probe","start","modifySelection","isEqual","deepestEmptyRangeAncestor","getDeepestEmptyElementAncestor","parent","deleteContent","doNotAutoparagraph","documentSelection","content","selectable","is","selectedElement","result","insertContent","viewWriter","typeAroundWrapper","createUIElement","class","domDocument","wrapperDomElement","toDomElement","injectButtons","injectFakeCaret","insert","buttonTemplate","tag","attributes","title","children","ownerDocument","importNode","appendChild","render","caretTemplate","element","deepestEmptyAncestor","ancestor","getAncestors","parentFirst","childCount","isLimit"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global DOMParser */\n\n/**\n * @module widget/widgettypearound\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport Enter from '@ckeditor/ckeditor5-enter/src/enter';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport {\n\tisForwardArrowKeyCode,\n\tkeyCodes\n} from '@ckeditor/ckeditor5-utils/src/keyboard';\n\nimport {\n\tisTypeAroundWidget,\n\tgetClosestTypeAroundDomButton,\n\tgetTypeAroundButtonPosition,\n\tgetClosestWidgetViewElement,\n\tgetTypeAroundFakeCaretPosition,\n\tTYPE_AROUND_SELECTION_ATTRIBUTE\n} from './utils';\n\nimport {\n\tisNonTypingKeystroke\n} from '@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling';\n\nimport { isWidget } from '../utils';\n\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\n\nconst POSSIBLE_INSERTION_POSITIONS = [ 'before', 'after' ];\n\n// Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString( returnIcon, 'image/svg+xml' ).firstChild;\n\nconst PLUGIN_DISABLED_EDITING_ROOT_CLASS = 'ck-widget__type-around_disabled';\n\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects the user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class WidgetTypeAround extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'WidgetTypeAround';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ Enter, Delete ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * A reference to the model widget element that has the fake caret active\n\t\t * on either side of it. It is later used to remove CSS classes associated with the fake caret\n\t\t * when the widget no longer needs it.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element|null}\n\t\t */\n\t\tthis._currentFakeCaretModelElement = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\t// Set a CSS class on the view editing root when the plugin is disabled so all the buttons\n\t\t// and lines visually disappear. All the interactions are disabled in individual plugin methods.\n\t\tthis.on( 'change:isEnabled', ( evt, data, isEnabled ) => {\n\t\t\teditingView.change( writer => {\n\t\t\t\tfor ( const root of editingView.document.roots ) {\n\t\t\t\t\tif ( isEnabled ) {\n\t\t\t\t\t\twriter.removeClass( PLUGIN_DISABLED_EDITING_ROOT_CLASS, root );\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriter.addClass( PLUGIN_DISABLED_EDITING_ROOT_CLASS, root );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tif ( !isEnabled ) {\n\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tthis._enableTypeAroundUIInjection();\n\t\tthis._enableInsertingParagraphsOnButtonClick();\n\t\tthis._enableInsertingParagraphsOnEnterKeypress();\n\t\tthis._enableInsertingParagraphsOnTypingKeystroke();\n\t\tthis._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n\t\tthis._enableDeleteIntegration();\n\t\tthis._enableInsertContentIntegration();\n\t\tthis._enableDeleteContentIntegration();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tthis._currentFakeCaretModelElement = null;\n\t}\n\n\t/**\n\t * Inserts a new paragraph next to a widget element with the selection anchored in it.\n\t *\n\t * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n\t * the viewport to the selection in the inserted paragraph.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.\n\t * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n\t */\n\t_insertParagraph( widgetModelElement, position ) {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\teditor.execute( 'insertParagraph', {\n\t\t\tposition: editor.model.createPositionAt( widgetModelElement, position )\n\t\t} );\n\n\t\teditingView.focus();\n\t\teditingView.scrollToTheSelection();\n\t}\n\n\t/**\n\t * A wrapper for the {@link module:utils/emittermixin~EmitterMixin#listenTo} method that executes the callbacks only\n\t * when the plugin {@link #isEnabled is enabled}.\n\t *\n\t * @private\n\t * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n\t * @param {String} event The name of the event.\n\t * @param {Function} callback The function to be called on event.\n\t * @param {Object} [options={}] Additional options.\n\t * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n\t * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n\t * order they were added.\n\t */\n\t_listenToIfEnabled( emitter, event, callback, options ) {\n\t\tthis.listenTo( emitter, event, ( ...args ) => {\n\t\t\t// Do not respond if the plugin is disabled.\n\t\t\tif ( this.isEnabled ) {\n\t\t\t\tcallback( ...args );\n\t\t\t}\n\t\t}, options );\n\t}\n\n\t/**\n\t * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n\t * does not expect a position. Instead, it performs the insertion next to a selected widget\n\t * according to the `widget-type-around` model selection attribute value (fake caret position).\n\t *\n\t * Because this method requires the `widget-type-around` attribute to be set,\n\t * the insertion can only happen when the widget's fake caret is active (e.g. activated\n\t * using the keyboard).\n\t *\n\t * @private\n\t * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n\t */\n\t_insertParagraphAccordingToFakeCaretPosition() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( modelSelection );\n\n\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\tthis._insertParagraph( selectedModelElement, typeAroundFakeCaretPosition );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a listener in the editing conversion pipeline that injects the widget type around\n\t * UI into every single widget instance created in the editor.\n\t *\n\t * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n\t * wrapper which renders DOM buttons that users can use to insert paragraphs.\n\t *\n\t * @private\n\t */\n\t_enableTypeAroundUIInjection() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\t\tconst t = editor.locale.t;\n\t\tconst buttonTitles = {\n\t\t\tbefore: t( 'Insert paragraph before block' ),\n\t\t\tafter: t( 'Insert paragraph after block' )\n\t\t};\n\n\t\teditor.editing.downcastDispatcher.on( 'insert', ( evt, data, conversionApi ) => {\n\t\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\t\t// Filter out non-widgets and inline widgets.\n\t\t\tif ( isTypeAroundWidget( viewElement, data.item, schema ) ) {\n\t\t\t\tinjectUIIntoWidget( conversionApi.writer, buttonTitles, viewElement );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Brings support for the fake caret that appears when either:\n\t *\n\t * * the selection moves to a widget from a position next to it using arrow keys,\n\t * * the arrow key is pressed when the widget is already selected.\n\t *\n\t * The fake caret lets the user know that they can start typing or just press\n\t * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.\n\t *\n\t * The fake caret disappears when the user changes the selection or the editor\n\t * gets blurred.\n\t *\n\t * The whole idea is as follows:\n\t *\n\t * 1. A user does one of the 2 scenarios described at the beginning.\n\t * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the fake caret.\n\t * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating\n\t *    on which side of the widget it should appear.\n\t * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n\t *    fake caret on the view widget.\n\t * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher\n\t *    does the CSS class clean-up in the view.\n\t * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection\n\t *    attribute (the former also removes widget CSS classes).\n\t *\n\t * @private\n\t */\n\t_enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst schema = model.schema;\n\t\tconst editingView = editor.editing.view;\n\n\t\t// This is the main listener responsible for the fake caret.\n\t\t// Note: The priority must precede the default Widget class keydown handler (\"high\").\n\t\tthis._listenToIfEnabled( editingView.document, 'arrowKey', ( evt, domEventData ) => {\n\t\t\tthis._handleArrowKeyPress( evt, domEventData );\n\t\t}, { context: [ isWidget, '$text' ], priority: 'high' } );\n\n\t\t// This listener makes sure the widget type around selection attribute will be gone from the model\n\t\t// selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n\t\t// (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n\t\t// let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n\t\tthis._listenToIfEnabled( modelSelection, 'change:range', ( evt, data ) => {\n\t\t\t// Do not reset the selection attribute when the change was indirect.\n\t\t\tif ( !data.directChange ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get rid of the widget type around attribute of the selection on every change:range.\n\t\t\t// If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n\t\t\teditor.model.change( writer => {\n\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t} );\n\t\t} );\n\n\t\t// Get rid of the widget type around attribute of the selection on every document change\n\t\t// that makes widget not selected any more (i.e. widget was removed).\n\t\tthis._listenToIfEnabled( model.document, 'change:data', () => {\n\t\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\t\tif ( selectedModelElement ) {\n\t\t\t\tconst selectedViewElement = editor.editing.mapper.toViewElement( selectedModelElement );\n\n\t\t\t\tif ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t} );\n\t\t} );\n\n\t\t// React to changes of the model selection attribute made by the arrow keys listener.\n\t\t// If the block widget is selected and the attribute changes, downcast the attribute to special\n\t\t// CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n\t\tthis._listenToIfEnabled( editor.editing.downcastDispatcher, 'selection', ( evt, data, conversionApi ) => {\n\t\t\tconst writer = conversionApi.writer;\n\n\t\t\tif ( this._currentFakeCaretModelElement ) {\n\t\t\t\tconst selectedViewElement = conversionApi.mapper.toViewElement( this._currentFakeCaretModelElement );\n\n\t\t\t\tif ( selectedViewElement ) {\n\t\t\t\t\t// Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n\t\t\t\t\twriter.removeClass( POSSIBLE_INSERTION_POSITIONS.map( positionToWidgetCssClass ), selectedViewElement );\n\n\t\t\t\t\tthis._currentFakeCaretModelElement = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst selectedModelElement = data.selection.getSelectedElement();\n\n\t\t\tif ( !selectedModelElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedViewElement = conversionApi.mapper.toViewElement( selectedModelElement );\n\n\t\t\tif ( !isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( data.selection );\n\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twriter.addClass( positionToWidgetCssClass( typeAroundFakeCaretPosition ), selectedViewElement );\n\n\t\t\t// Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n\t\t\t// selection changes\n\t\t\tthis._currentFakeCaretModelElement = selectedModelElement;\n\t\t} );\n\n\t\tthis._listenToIfEnabled( editor.ui.focusTracker, 'change:isFocused', ( evt, name, isFocused ) => {\n\t\t\tif ( !isFocused ) {\n\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tfunction positionToWidgetCssClass( position ) {\n\t\t\treturn `ck-widget_type-around_show-fake-caret_${ position }`;\n\t\t}\n\t}\n\n\t/**\n\t * A listener executed on each \"keydown\" in the view document, a part of\n\t * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n\t *\n\t * It decides whether the arrow keypress should activate the fake caret or not (also whether it should\n\t * be deactivated).\n\t *\n\t * The fake caret activation is done by setting the `widget-type-around` model selection attribute\n\t * in this listener, and stopping and preventing the event that would normally be handled by the widget\n\t * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n\t * includes inline widgets, which are ignored by the widget type around plugin).\n\t *\n\t * @private\n\t */\n\t_handleArrowKeyPress( evt, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst schema = model.schema;\n\t\tconst editingView = editor.editing.view;\n\n\t\tconst keyCode = domEventData.keyCode;\n\t\tconst isForward = isForwardArrowKeyCode( keyCode, editor.locale.contentLanguageDirection );\n\t\tconst selectedViewElement = editingView.document.selection.getSelectedElement();\n\t\tconst selectedModelElement = editor.editing.mapper.toModelElement( selectedViewElement );\n\t\tlet shouldStopAndPreventDefault;\n\n\t\t// Handle keyboard navigation when a type-around-compatible widget is currently selected.\n\t\tif ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget( isForward );\n\t\t}\n\t\t// Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n\t\t// and the widget is about to be selected.\n\t\telse if ( modelSelection.isCollapsed ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget( isForward );\n\t\t}\n\t\t// Handle collapsing a non-collapsed selection that is wider than on a single widget.\n\t\telse if ( !domEventData.shiftKey ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection( isForward );\n\t\t}\n\n\t\tif ( shouldStopAndPreventDefault ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n\t * the fake caret for that widget, depending on the current value of the `widget-type-around` model\n\t * selection attribute and the direction of the pressed arrow key.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n\t * process the event any further. Returns `false` otherwise.\n\t */\n\t_handleArrowKeyPressOnSelectedWidget( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( modelSelection );\n\n\t\treturn model.change( writer => {\n\t\t\t// If the fake caret is displayed...\n\t\t\tif ( typeAroundFakeCaretPosition ) {\n\t\t\t\tconst isLeavingWidget = typeAroundFakeCaretPosition === ( isForward ? 'after' : 'before' );\n\n\t\t\t\t// If the keyboard arrow works against the value of the selection attribute...\n\t\t\t\t// then remove the selection attribute but prevent default DOM actions\n\t\t\t\t// and do not let the Widget plugin listener move the selection. This brings\n\t\t\t\t// the widget back to the state, for instance, like if was selected using the mouse.\n\t\t\t\t//\n\t\t\t\t// **Note**: If leaving the widget when the fake caret is active, then the default\n\t\t\t\t// Widget handler will change the selection and, in turn, this will automatically discard\n\t\t\t\t// the selection attribute.\n\t\t\t\tif ( !isLeavingWidget ) {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n\t\t\t// key press. This also means we cannot let the Widget plugin listener move the selection.\n\t\t\telse {\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before' );\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t} );\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n\t * to one and upon the fake caret should become active for this widget upon arrow keypress\n\t * (AKA entering/selecting the widget).\n\t *\n\t * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.\n\t * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the\n\t * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n\t * process the event any further. Returns `false` otherwise.\n\t */\n\t_handleArrowKeyPressWhenSelectionNextToAWidget( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\t\tconst widgetPlugin = editor.plugins.get( 'Widget' );\n\n\t\t// This is the widget the selection is about to be set on.\n\t\tconst modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection( isForward );\n\t\tconst viewElementNextToSelection = editor.editing.mapper.toViewElement( modelElementNextToSelection );\n\n\t\tif ( isTypeAroundWidget( viewElementNextToSelection, modelElementNextToSelection, schema ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twidgetPlugin._setSelectionOverElement( modelElementNextToSelection );\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after' );\n\t\t\t} );\n\n\t\t\t// The change() block above does the same job as the Widget plugin. The event can\n\t\t\t// be safely canceled.\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when a widget is currently selected (together with some other content)\n\t * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n\t * process the event any further. Returns `false` otherwise.\n\t */\n\t_handleArrowKeyPressWhenNonCollapsedSelection( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\t\tconst mapper = editor.editing.mapper;\n\t\tconst modelSelection = model.document.selection;\n\n\t\tconst selectedModelNode = isForward ?\n\t\t\tmodelSelection.getLastPosition().nodeBefore :\n\t\t\tmodelSelection.getFirstPosition().nodeAfter;\n\n\t\tconst selectedViewNode = mapper.toViewElement( selectedModelNode );\n\n\t\t// There is a widget at the collapse position so collapse the selection to the fake caret on it.\n\t\tif ( isTypeAroundWidget( selectedViewNode, selectedModelNode, schema ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( selectedModelNode, 'on' );\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before' );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Registers a `mousedown` listener for the view document which intercepts events\n\t * coming from the widget type around UI, which happens when a user clicks one of the buttons\n\t * that insert a paragraph next to a widget.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnButtonClick() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\tthis._listenToIfEnabled( editingView.document, 'mousedown', ( evt, domEventData ) => {\n\t\t\tconst button = getClosestTypeAroundDomButton( domEventData.domTarget );\n\n\t\t\tif ( !button ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst buttonPosition = getTypeAroundButtonPosition( button );\n\t\t\tconst widgetViewElement = getClosestWidgetViewElement( button, editingView.domConverter );\n\t\t\tconst widgetModelElement = editor.editing.mapper.toModelElement( widgetViewElement );\n\n\t\t\tthis._insertParagraph( widgetModelElement, buttonPosition );\n\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t} );\n\t}\n\n\t/**\n\t * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph\n\t * near the widget when either:\n\t *\n\t * * The fake caret was first activated using the arrow keys,\n\t * * The entire widget is selected in the model.\n\t *\n\t * In the first case, the new paragraph is inserted according to the `widget-type-around` selection\n\t * attribute (see {@link #_handleArrowKeyPress}).\n\t *\n\t * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke\n\t * was pressed or not.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnEnterKeypress() {\n\t\tconst editor = this.editor;\n\t\tconst selection = editor.model.document.selection;\n\t\tconst editingView = editor.editing.view;\n\n\t\tthis._listenToIfEnabled( editingView.document, 'enter', ( evt, domEventData ) => {\n\t\t\t// This event could be triggered from inside the widget but we are interested\n\t\t\t// only when the widget is selected itself.\n\t\t\tif ( evt.eventPhase != 'atTarget' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedModelElement = selection.getSelectedElement();\n\t\t\tconst selectedViewElement = editor.editing.mapper.toViewElement( selectedModelElement );\n\n\t\t\tconst schema = editor.model.schema;\n\t\t\tlet wasHandled;\n\n\t\t\t// First check if the widget is selected and there's a type around selection attribute associated\n\t\t\t// with the fake caret that would tell where to insert a new paragraph.\n\t\t\tif ( this._insertParagraphAccordingToFakeCaretPosition() ) {\n\t\t\t\twasHandled = true;\n\t\t\t}\n\t\t\t// Then, if there is no selection attribute associated with the fake caret, check if the widget\n\t\t\t// simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n\t\t\telse if ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\tthis._insertParagraph( selectedModelElement, domEventData.isSoft ? 'before' : 'after' );\n\n\t\t\t\twasHandled = true;\n\t\t\t}\n\n\t\t\tif ( wasHandled ) {\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { context: isWidget } );\n\t}\n\n\t/**\n\t * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n\t * to insert a paragraph next to a widget when the fake caret was activated using arrow\n\t * keys but it responds to typing keystrokes instead of <kbd>Enter</kbd>.\n\t *\n\t * \"Typing keystrokes\" are keystrokes that insert new content into the document,\n\t * for instance, letters (\"a\") or numbers (\"4\"). The \"keydown\" listener enabled by this method\n\t * will insert a new paragraph according to the `widget-type-around` model selection attribute\n\t * as the user simply starts typing, which creates the impression that the fake caret\n\t * behaves like a real one rendered by the browser (AKA your text appears where the caret was).\n\t *\n\t * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command\n\t * and another one for actual typing. It is not a disaster but this may need to be fixed\n\t * sooner or later.\n\t *\n\t * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnTypingKeystroke() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\t\tconst keyCodesHandledSomewhereElse = [\n\t\t\tkeyCodes.enter,\n\t\t\tkeyCodes.delete,\n\t\t\tkeyCodes.backspace\n\t\t];\n\n\t\t// Note: The priority must precede the default observers.\n\t\tthis._listenToIfEnabled( editingView.document, 'keydown', ( evt, domEventData ) => {\n\t\t\t// Don't handle enter/backspace/delete here. They are handled in dedicated listeners.\n\t\t\tif ( !keyCodesHandledSomewhereElse.includes( domEventData.keyCode ) && !isNonTypingKeystroke( domEventData ) ) {\n\t\t\t\tthis._insertParagraphAccordingToFakeCaretPosition();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * It creates a \"delete\" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>\n\t * is pressed and the fake caret is currently active.\n\t *\n\t * The fake caret should create an illusion of a real browser caret so that when it appears before or after\n\t * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content\n\t * before or after a widget (depending on the content surrounding the widget).\n\t *\n\t * @private\n\t */\n\t_enableDeleteIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\n\t\tthis._listenToIfEnabled( editingView.document, 'delete', ( evt, domEventData ) => {\n\t\t\t// This event could be triggered from inside the widget but we are interested\n\t\t\t// only when the widget is selected itself.\n\t\t\tif ( evt.eventPhase != 'atTarget' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( model.document.selection );\n\n\t\t\t// This listener handles only these cases when the fake caret is active.\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst direction = domEventData.direction;\n\t\t\tconst selectedModelWidget = model.document.selection.getSelectedElement();\n\n\t\t\tconst isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n\t\t\tconst isDeleteForward = direction == 'forward';\n\t\t\tconst shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;\n\n\t\t\tif ( shouldDeleteEntireWidget ) {\n\t\t\t\teditor.execute( 'delete', {\n\t\t\t\t\tselection: model.createSelection( selectedModelWidget, 'on' )\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tconst range = schema.getNearestSelectionRange(\n\t\t\t\t\tmodel.createPositionAt( selectedModelWidget, typeAroundFakeCaretPosition ),\n\t\t\t\t\tdirection\n\t\t\t\t);\n\n\t\t\t\t// If there is somewhere to move selection to, then there will be something to delete.\n\t\t\t\tif ( range ) {\n\t\t\t\t\t// If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n\t\t\t\t\tif ( !range.isCollapsed ) {\n\t\t\t\t\t\tmodel.change( writer => {\n\t\t\t\t\t\t\twriter.setSelection( range );\n\t\t\t\t\t\t\teditor.execute( isDeleteForward ? 'deleteForward' : 'delete' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst probe = model.createSelection( range.start );\n\t\t\t\t\t\tmodel.modifySelection( probe, { direction } );\n\n\t\t\t\t\t\t// If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n\t\t\t\t\t\t// If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n\t\t\t\t\t\tif ( !probe.focus.isEqual( range.start ) ) {\n\t\t\t\t\t\t\tmodel.change( writer => {\n\t\t\t\t\t\t\t\twriter.setSelection( range );\n\t\t\t\t\t\t\t\teditor.execute( isDeleteForward ? 'deleteForward' : 'delete' );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n\t\t\t\t\t\t// next to a widget that should be removed. \"delete\" and \"deleteForward\" commands cannot get rid of it\n\t\t\t\t\t\t// so calling Model#deleteContent here manually.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor( schema, range.start.parent );\n\n\t\t\t\t\t\t\tmodel.deleteContent( model.createSelection( deepestEmptyRangeAncestor, 'on' ), {\n\t\t\t\t\t\t\t\tdoNotAutoparagraph: true\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If some content was deleted, don't let the handler from the Widget plugin kick in.\n\t\t\t// If nothing was deleted, then the default handler will have nothing to do anyway.\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t}, { context: isWidget } );\n\t}\n\n\t/**\n\t * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n\t * content near a widget when the fake caret is first activated using the arrow keys.\n\t *\n\t * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n\t *\n\t * @private\n\t */\n\t_enableInsertContentIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\n\t\tthis._listenToIfEnabled( editor.model, 'insertContent', ( evt, [ content, selectable ] ) => {\n\t\t\tif ( selectable && !selectable.is( 'documentSelection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( documentSelection );\n\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevt.stop();\n\n\t\t\treturn model.change( writer => {\n\t\t\t\tconst selectedElement = documentSelection.getSelectedElement();\n\t\t\t\tconst position = model.createPositionAt( selectedElement, typeAroundFakeCaretPosition );\n\t\t\t\tconst selection = writer.createSelection( position );\n\n\t\t\t\tconst result = model.insertContent( content, selection );\n\n\t\t\t\twriter.setSelection( selection );\n\n\t\t\t\treturn result;\n\t\t\t} );\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake\n\t * caret is active.\n\t *\n\t * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n\t * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,\n\t * plain text pasting.\n\t *\n\t * @private\n\t */\n\t_enableDeleteContentIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\n\t\tthis._listenToIfEnabled( editor.model, 'deleteContent', ( evt, [ selection ] ) => {\n\t\t\tif ( selection && !selection.is( 'documentSelection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( documentSelection );\n\n\t\t\t// Disable removing the selection content while pasting plain text.\n\t\t\tif ( typeAroundFakeCaretPosition ) {\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n}\n\n// Injects the type around UI into a view widget instance.\n//\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {Object.<String,String>} buttonTitles\n// @param {module:engine/view/element~Element} widgetViewElement\nfunction injectUIIntoWidget( viewWriter, buttonTitles, widgetViewElement ) {\n\tconst typeAroundWrapper = viewWriter.createUIElement( 'div', {\n\t\tclass: 'ck ck-reset_all ck-widget__type-around'\n\t}, function( domDocument ) {\n\t\tconst wrapperDomElement = this.toDomElement( domDocument );\n\n\t\tinjectButtons( wrapperDomElement, buttonTitles );\n\t\tinjectFakeCaret( wrapperDomElement );\n\n\t\treturn wrapperDomElement;\n\t} );\n\n\t// Inject the type around wrapper into the widget's wrapper.\n\tviewWriter.insert( viewWriter.createPositionAt( widgetViewElement, 'end' ), typeAroundWrapper );\n}\n\n// FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n// <svg> here.\n//\n// @param {HTMLElement} wrapperDomElement\n// @param {Object.<String,String>} buttonTitles\nfunction injectButtons( wrapperDomElement, buttonTitles ) {\n\tfor ( const position of POSSIBLE_INSERTION_POSITIONS ) {\n\t\tconst buttonTemplate = new Template( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-widget__type-around__button',\n\t\t\t\t\t`ck-widget__type-around__button_${ position }`\n\t\t\t\t],\n\t\t\t\ttitle: buttonTitles[ position ]\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\twrapperDomElement.ownerDocument.importNode( RETURN_ARROW_ICON_ELEMENT, true )\n\t\t\t]\n\t\t} );\n\n\t\twrapperDomElement.appendChild( buttonTemplate.render() );\n\t}\n}\n\n// @param {HTMLElement} wrapperDomElement\nfunction injectFakeCaret( wrapperDomElement ) {\n\tconst caretTemplate = new Template( {\n\t\ttag: 'div',\n\t\tattributes: {\n\t\t\tclass: [\n\t\t\t\t'ck',\n\t\t\t\t'ck-widget__type-around__fake-caret'\n\t\t\t]\n\t\t}\n\t} );\n\n\twrapperDomElement.appendChild( caretTemplate.render() );\n}\n\n// Returns the ancestor of an element closest to the root which is empty. For instance,\n// for `<baz>`:\n//\n//\t\t<foo>abc<bar><baz></baz></bar></foo>\n//\n// it returns `<bar>`.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/element~Element|null}\nfunction getDeepestEmptyElementAncestor( schema, element ) {\n\tlet deepestEmptyAncestor = element;\n\n\tfor ( const ancestor of element.getAncestors( { parentFirst: true } ) ) {\n\t\tif ( ancestor.childCount > 1 || schema.isLimit( ancestor ) ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdeepestEmptyAncestor = ancestor;\n\t}\n\n\treturn deepestEmptyAncestor;\n}\n"]},"metadata":{},"sourceType":"module"}