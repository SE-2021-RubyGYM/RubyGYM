{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/selectionobserver\n */\n\n/* global setInterval, clearInterval */\nimport Observer from './observer';\nimport MutationObserver from './mutationobserver';\nimport { debounce } from 'lodash-es';\n/**\n * Selection observer class observes selection changes in the document. If a selection changes on the document this\n * observer checks if there are any mutations and if the DOM selection is different from the\n * {@link module:engine/view/document~Document#selection view selection}. The selection observer fires\n * {@link module:engine/view/document~Document#event:selectionChange} event only if a selection change was the only change in the document\n * and the DOM selection is different then the view selection.\n *\n * This observer also manages the {@link module:engine/view/document~Document#isSelecting} property of the view document.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @extends module:engine/view/observer/observer~Observer\n */\n\nexport default class SelectionObserver extends Observer {\n  constructor(view) {\n    super(view);\n    /**\n     * Instance of the mutation observer. Selection observer calls\n     * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled\n     * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.\n     *\n     * @readonly\n     * @member {module:engine/view/observer/mutationobserver~MutationObserver}\n     * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver\n     */\n\n    this.mutationObserver = view.getObserver(MutationObserver);\n    /**\n     * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare\n     * new selection with it.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     * module:engine/view/observer/selectionobserver~SelectionObserver#selection\n     */\n\n    this.selection = this.document.selection;\n    /* eslint-disable max-len */\n\n    /**\n     * Reference to the {@link module:engine/view/view~View#domConverter}.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter\n     */\n\n    /* eslint-enable max-len */\n\n    this.domConverter = view.domConverter;\n    /**\n     * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same\n     * document.\n     *\n     * @private\n     * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents\n     */\n\n    this._documents = new WeakSet();\n    /**\n     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n     *\n     * @private\n     * @param {Object} data Selection change data.\n     * @method #_fireSelectionChangeDoneDebounced\n     */\n\n    this._fireSelectionChangeDoneDebounced = debounce(data => this.document.fire('selectionChangeDone', data), 200);\n    /**\n     * When called, starts clearing the {@link #_loopbackCounter} counter in intervals of time. When the number of selection\n     * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about\n     * possible infinite selection loop.\n     *\n     * @private\n     * @member {Number} #_clearInfiniteLoopInterval\n     */\n\n    this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1000);\n    /**\n     * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact\n     * correctly (for whatever the reason). It is a safeguard (paranoid check) that returns document to the normal state\n     * after a certain period of time (debounced, postponed by each selectionchange event).\n     *\n     * @private\n     * @method #_documentIsSelectingInactivityTimeoutDebounced\n     */\n\n    this._documentIsSelectingInactivityTimeoutDebounced = debounce(() => this.document.isSelecting = false, 5000);\n    /**\n     * Private property to check if the code does not enter infinite loop.\n     *\n     * @private\n     * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter\n     */\n\n    this._loopbackCounter = 0;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  observe(domElement) {\n    const domDocument = domElement.ownerDocument;\n\n    const startDocumentIsSelecting = () => {\n      this.document.isSelecting = true; // Let's activate the safety timeout each time the document enters the \"is selecting\" state.\n\n      this._documentIsSelectingInactivityTimeoutDebounced();\n    };\n\n    const endDocumentIsSelecting = () => {\n      this.document.isSelecting = false; // The safety timeout can be canceled when the document leaves the \"is selecting\" state.\n\n      this._documentIsSelectingInactivityTimeoutDebounced.cancel();\n    }; // The document has the \"is selecting\" state while the user keeps making (extending) the selection\n    // (e.g. by holding the mouse button and moving the cursor). The state resets when they either released\n    // the mouse button or interrupted the process by pressing or releasing any key.\n\n\n    this.listenTo(domElement, 'selectstart', startDocumentIsSelecting, {\n      priority: 'highest'\n    });\n    this.listenTo(domElement, 'keydown', endDocumentIsSelecting, {\n      priority: 'highest'\n    });\n    this.listenTo(domElement, 'keyup', endDocumentIsSelecting, {\n      priority: 'highest'\n    }); // Add document-wide listeners only once. This method could be called for multiple editing roots.\n\n    if (this._documents.has(domDocument)) {\n      return;\n    }\n\n    this.listenTo(domDocument, 'mouseup', endDocumentIsSelecting, {\n      priority: 'highest'\n    });\n    this.listenTo(domDocument, 'selectionchange', (evt, domEvent) => {\n      this._handleSelectionChange(domEvent, domDocument); // Defer the safety timeout when the selection changes (e.g. the user keeps extending the selection\n      // using their mouse).\n\n\n      this._documentIsSelectingInactivityTimeoutDebounced();\n    });\n\n    this._documents.add(domDocument);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    super.destroy();\n    clearInterval(this._clearInfiniteLoopInterval);\n\n    this._fireSelectionChangeDoneDebounced.cancel();\n\n    this._documentIsSelectingInactivityTimeoutDebounced.cancel();\n  }\n  /**\n   * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if\n   * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change\n   * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.\n   *\n   * @private\n   * @param {Event} domEvent DOM event.\n   * @param {Document} domDocument DOM document.\n   */\n\n\n  _handleSelectionChange(domEvent, domDocument) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    const domSelection = domDocument.defaultView.getSelection();\n\n    if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {\n      return;\n    } // Ensure the mutation event will be before selection event on all browsers.\n\n\n    this.mutationObserver.flush(); // If there were mutations then the view will be re-rendered by the mutation observer and the selection\n    // will be updated, so the selections will equal and the event will not be fired, as expected.\n\n    const newViewSelection = this.domConverter.domSelectionToView(domSelection); // Do not convert selection change if the new view selection has no ranges in it.\n    //\n    // It means that the DOM selection is in some way incorrect. Ranges that were in the DOM selection could not be\n    // converted to the view. This happens when the DOM selection was moved outside of the editable element.\n\n    if (newViewSelection.rangeCount == 0) {\n      this.view.hasDomSelection = false;\n      return;\n    }\n\n    this.view.hasDomSelection = true;\n\n    if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {\n      return;\n    } // Ensure we are not in the infinite loop (#400).\n    // This counter is reset each second. 60 selection changes in 1 second is enough high number\n    // to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).\n\n\n    if (++this._loopbackCounter > 60) {\n      // Selection change observer detected an infinite rendering loop.\n      // Most probably you try to put the selection in the position which is not allowed\n      // by the browser and browser fixes it automatically what causes `selectionchange` event on\n      // which a loopback through a model tries to re-render the wrong selection and again.\n      //\n      // @if CK_DEBUG // console.warn( 'Selection change observer detected an infinite rendering loop.' );\n      return;\n    }\n\n    if (this.selection.isSimilar(newViewSelection)) {\n      // If selection was equal and we are at this point of algorithm, it means that it was incorrect.\n      // Just re-render it, no need to fire any events, etc.\n      this.view.forceRender();\n    } else {\n      const data = {\n        oldSelection: this.selection,\n        newSelection: newViewSelection,\n        domSelection\n      }; // Prepare data for new selection and fire appropriate events.\n\n      this.document.fire('selectionChange', data); // Call `#_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n      // This function is debounced what means that `selectionChangeDone` event will be fired only when\n      // defined int the function time will elapse since the last time the function was called.\n      // So `selectionChangeDone` will be fired when selection will stop changing.\n\n      this._fireSelectionChangeDoneDebounced(data);\n    }\n  }\n  /**\n   * Clears `SelectionObserver` internal properties connected with preventing infinite loop.\n   *\n   * @protected\n   */\n\n\n  _clearInfiniteLoop() {\n    this._loopbackCounter = 0;\n  }\n\n}\n/**\n * Fired when a selection has changed. This event is fired only when the selection change was the only change that happened\n * in the document, and the old selection is different then the new selection.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChange\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n\n/**\n * Fired when selection stops changing.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChangeDone\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/selectionobserver.js"],"names":["Observer","MutationObserver","debounce","SelectionObserver","constructor","view","mutationObserver","getObserver","selection","document","domConverter","_documents","WeakSet","_fireSelectionChangeDoneDebounced","data","fire","_clearInfiniteLoopInterval","setInterval","_clearInfiniteLoop","_documentIsSelectingInactivityTimeoutDebounced","isSelecting","_loopbackCounter","observe","domElement","domDocument","ownerDocument","startDocumentIsSelecting","endDocumentIsSelecting","cancel","listenTo","priority","has","evt","domEvent","_handleSelectionChange","add","destroy","clearInterval","isEnabled","domSelection","defaultView","getSelection","checkShouldIgnoreEventFromTarget","anchorNode","flush","newViewSelection","domSelectionToView","rangeCount","hasDomSelection","isEqual","isDomSelectionCorrect","isSimilar","forceRender","oldSelection","newSelection"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/selectionobserver\n */\n\n/* global setInterval, clearInterval */\n\nimport Observer from './observer';\nimport MutationObserver from './mutationobserver';\nimport { debounce } from 'lodash-es';\n\n/**\n * Selection observer class observes selection changes in the document. If a selection changes on the document this\n * observer checks if there are any mutations and if the DOM selection is different from the\n * {@link module:engine/view/document~Document#selection view selection}. The selection observer fires\n * {@link module:engine/view/document~Document#event:selectionChange} event only if a selection change was the only change in the document\n * and the DOM selection is different then the view selection.\n *\n * This observer also manages the {@link module:engine/view/document~Document#isSelecting} property of the view document.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class SelectionObserver extends Observer {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * Instance of the mutation observer. Selection observer calls\n\t\t * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled\n\t\t * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/observer/mutationobserver~MutationObserver}\n\t\t * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver\n\t\t */\n\t\tthis.mutationObserver = view.getObserver( MutationObserver );\n\n\t\t/**\n\t\t * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare\n\t\t * new selection with it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection}\n\t\t * module:engine/view/observer/selectionobserver~SelectionObserver#selection\n\t\t */\n\t\tthis.selection = this.document.selection;\n\n\t\t/* eslint-disable max-len */\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/view~View#domConverter}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter\n\t\t */\n\t\t/* eslint-enable max-len */\n\t\tthis.domConverter = view.domConverter;\n\n\t\t/**\n\t\t * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same\n\t\t * document.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents\n\t\t */\n\t\tthis._documents = new WeakSet();\n\n\t\t/**\n\t\t * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n\t\t *\n\t\t * @private\n\t\t * @param {Object} data Selection change data.\n\t\t * @method #_fireSelectionChangeDoneDebounced\n\t\t */\n\t\tthis._fireSelectionChangeDoneDebounced = debounce( data => this.document.fire( 'selectionChangeDone', data ), 200 );\n\n\t\t/**\n\t\t * When called, starts clearing the {@link #_loopbackCounter} counter in intervals of time. When the number of selection\n\t\t * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about\n\t\t * possible infinite selection loop.\n\t\t *\n\t\t * @private\n\t\t * @member {Number} #_clearInfiniteLoopInterval\n\t\t */\n\t\tthis._clearInfiniteLoopInterval = setInterval( () => this._clearInfiniteLoop(), 1000 );\n\n\t\t/**\n\t\t * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact\n\t\t * correctly (for whatever the reason). It is a safeguard (paranoid check) that returns document to the normal state\n\t\t * after a certain period of time (debounced, postponed by each selectionchange event).\n\t\t *\n\t\t * @private\n\t\t * @method #_documentIsSelectingInactivityTimeoutDebounced\n\t\t */\n\t\tthis._documentIsSelectingInactivityTimeoutDebounced = debounce( () => ( this.document.isSelecting = false ), 5000 );\n\n\t\t/**\n\t\t * Private property to check if the code does not enter infinite loop.\n\t\t *\n\t\t * @private\n\t\t * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter\n\t\t */\n\t\tthis._loopbackCounter = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve( domElement ) {\n\t\tconst domDocument = domElement.ownerDocument;\n\n\t\tconst startDocumentIsSelecting = () => {\n\t\t\tthis.document.isSelecting = true;\n\n\t\t\t// Let's activate the safety timeout each time the document enters the \"is selecting\" state.\n\t\t\tthis._documentIsSelectingInactivityTimeoutDebounced();\n\t\t};\n\n\t\tconst endDocumentIsSelecting = () => {\n\t\t\tthis.document.isSelecting = false;\n\n\t\t\t// The safety timeout can be canceled when the document leaves the \"is selecting\" state.\n\t\t\tthis._documentIsSelectingInactivityTimeoutDebounced.cancel();\n\t\t};\n\n\t\t// The document has the \"is selecting\" state while the user keeps making (extending) the selection\n\t\t// (e.g. by holding the mouse button and moving the cursor). The state resets when they either released\n\t\t// the mouse button or interrupted the process by pressing or releasing any key.\n\t\tthis.listenTo( domElement, 'selectstart', startDocumentIsSelecting, { priority: 'highest' } );\n\t\tthis.listenTo( domElement, 'keydown', endDocumentIsSelecting, { priority: 'highest' } );\n\t\tthis.listenTo( domElement, 'keyup', endDocumentIsSelecting, { priority: 'highest' } );\n\n\t\t// Add document-wide listeners only once. This method could be called for multiple editing roots.\n\t\tif ( this._documents.has( domDocument ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listenTo( domDocument, 'mouseup', endDocumentIsSelecting, { priority: 'highest' } );\n\t\tthis.listenTo( domDocument, 'selectionchange', ( evt, domEvent ) => {\n\t\t\tthis._handleSelectionChange( domEvent, domDocument );\n\n\t\t\t// Defer the safety timeout when the selection changes (e.g. the user keeps extending the selection\n\t\t\t// using their mouse).\n\t\t\tthis._documentIsSelectingInactivityTimeoutDebounced();\n\t\t} );\n\n\t\tthis._documents.add( domDocument );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tclearInterval( this._clearInfiniteLoopInterval );\n\t\tthis._fireSelectionChangeDoneDebounced.cancel();\n\t\tthis._documentIsSelectingInactivityTimeoutDebounced.cancel();\n\t}\n\n\t/**\n\t * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if\n\t * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change\n\t * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.\n\t *\n\t * @private\n\t * @param {Event} domEvent DOM event.\n\t * @param {Document} domDocument DOM document.\n\t */\n\t_handleSelectionChange( domEvent, domDocument ) {\n\t\tif ( !this.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst domSelection = domDocument.defaultView.getSelection();\n\n\t\tif ( this.checkShouldIgnoreEventFromTarget( domSelection.anchorNode ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure the mutation event will be before selection event on all browsers.\n\t\tthis.mutationObserver.flush();\n\n\t\t// If there were mutations then the view will be re-rendered by the mutation observer and the selection\n\t\t// will be updated, so the selections will equal and the event will not be fired, as expected.\n\t\tconst newViewSelection = this.domConverter.domSelectionToView( domSelection );\n\n\t\t// Do not convert selection change if the new view selection has no ranges in it.\n\t\t//\n\t\t// It means that the DOM selection is in some way incorrect. Ranges that were in the DOM selection could not be\n\t\t// converted to the view. This happens when the DOM selection was moved outside of the editable element.\n\t\tif ( newViewSelection.rangeCount == 0 ) {\n\t\t\tthis.view.hasDomSelection = false;\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.view.hasDomSelection = true;\n\n\t\tif ( this.selection.isEqual( newViewSelection ) && this.domConverter.isDomSelectionCorrect( domSelection ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure we are not in the infinite loop (#400).\n\t\t// This counter is reset each second. 60 selection changes in 1 second is enough high number\n\t\t// to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).\n\t\tif ( ++this._loopbackCounter > 60 ) {\n\t\t\t// Selection change observer detected an infinite rendering loop.\n\t\t\t// Most probably you try to put the selection in the position which is not allowed\n\t\t\t// by the browser and browser fixes it automatically what causes `selectionchange` event on\n\t\t\t// which a loopback through a model tries to re-render the wrong selection and again.\n\t\t\t//\n\t\t\t// @if CK_DEBUG // console.warn( 'Selection change observer detected an infinite rendering loop.' );\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.selection.isSimilar( newViewSelection ) ) {\n\t\t\t// If selection was equal and we are at this point of algorithm, it means that it was incorrect.\n\t\t\t// Just re-render it, no need to fire any events, etc.\n\t\t\tthis.view.forceRender();\n\t\t} else {\n\t\t\tconst data = {\n\t\t\t\toldSelection: this.selection,\n\t\t\t\tnewSelection: newViewSelection,\n\t\t\t\tdomSelection\n\t\t\t};\n\n\t\t\t// Prepare data for new selection and fire appropriate events.\n\t\t\tthis.document.fire( 'selectionChange', data );\n\n\t\t\t// Call `#_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n\t\t\t// This function is debounced what means that `selectionChangeDone` event will be fired only when\n\t\t\t// defined int the function time will elapse since the last time the function was called.\n\t\t\t// So `selectionChangeDone` will be fired when selection will stop changing.\n\t\t\tthis._fireSelectionChangeDoneDebounced( data );\n\t\t}\n\t}\n\n\t/**\n\t * Clears `SelectionObserver` internal properties connected with preventing infinite loop.\n\t *\n\t * @protected\n\t */\n\t_clearInfiniteLoop() {\n\t\tthis._loopbackCounter = 0;\n\t}\n}\n\n/**\n * Fired when a selection has changed. This event is fired only when the selection change was the only change that happened\n * in the document, and the old selection is different then the new selection.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChange\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n\n/**\n * Fired when selection stops changing.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChangeDone\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n"]},"metadata":{},"sourceType":"module"}