{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/textproxy\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror'; // @if CK_DEBUG_ENGINE // const { convertMapToStringifiedObject } = require( '../dev-utils/utils' );\n\n/**\n * `TextProxy` represents a part of {@link module:engine/model/text~Text text node}.\n *\n * Since {@link module:engine/model/position~Position positions} can be placed between characters of a text node,\n * {@link module:engine/model/range~Range ranges} may contain only parts of text nodes. When {@link module:engine/model/range~Range#getItems\n * getting items}\n * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.\n * `TextProxy` solves this issue.\n *\n * `TextProxy` has an API similar to {@link module:engine/model/text~Text Text} and allows to do most of the common tasks performed\n * on model nodes.\n *\n * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.\n * See {@link module:engine/model/textproxy~TextProxy#isPartial}.\n *\n * **Note:** `TextProxy` is not an instance of {@link module:engine/model/node~Node node}. Keep this in mind when using it as a\n * parameter of methods.\n *\n * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`\n * use {@link module:engine/model/writer~Writer model writer API}.\n *\n * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is\n * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when\n * model changes, so they might get invalidated. Instead, consider creating {@link module:engine/model/liveposition~LivePosition live\n * position}.\n *\n * `TextProxy` instances are created by {@link module:engine/model/treewalker~TreeWalker model tree walker}. You should not need to create\n * an instance of this class by your own.\n */\n\nexport default class TextProxy {\n  /**\n   * Creates a text proxy.\n   *\n   * @protected\n   * @param {module:engine/model/text~Text} textNode Text node which part is represented by this text proxy.\n   * @param {Number} offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy\n   * starts.\n   * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.\n   * @constructor\n   */\n  constructor(textNode, offsetInText, length) {\n    /**\n     * Text node which part is represented by this text proxy.\n     *\n     * @readonly\n     * @member {module:engine/model/text~Text}\n     */\n    this.textNode = textNode;\n\n    if (offsetInText < 0 || offsetInText > textNode.offsetSize) {\n      /**\n       * Given `offsetInText` value is incorrect.\n       *\n       * @error model-textproxy-wrong-offsetintext\n       */\n      throw new CKEditorError('model-textproxy-wrong-offsetintext', this);\n    }\n\n    if (length < 0 || offsetInText + length > textNode.offsetSize) {\n      /**\n       * Given `length` value is incorrect.\n       *\n       * @error model-textproxy-wrong-length\n       */\n      throw new CKEditorError('model-textproxy-wrong-length', this);\n    }\n    /**\n     * Text data represented by this text proxy.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n\n    this.data = textNode.data.substring(offsetInText, offsetInText + length);\n    /**\n     * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.offsetInText = offsetInText;\n  }\n  /**\n   * Offset at which this text proxy starts in it's parent.\n   *\n   * @see module:engine/model/node~Node#startOffset\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get startOffset() {\n    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;\n  }\n  /**\n   * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.\n   *\n   * @see module:engine/model/node~Node#offsetSize\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get offsetSize() {\n    return this.data.length;\n  }\n  /**\n   * Offset at which this text proxy ends in it's parent.\n   *\n   * @see module:engine/model/node~Node#endOffset\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get endOffset() {\n    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;\n  }\n  /**\n   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}\n   * (`true`) or the whole text node (`false`).\n   *\n   * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}\n   * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to\n   * text node size.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isPartial() {\n    return this.offsetSize !== this.textNode.offsetSize;\n  }\n  /**\n   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.\n   *\n   * @readonly\n   * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n\n\n  get parent() {\n    return this.textNode.parent;\n  }\n  /**\n   * Root of this text proxy, which is same as root of text node represented by this text proxy.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  get root() {\n    return this.textNode.root;\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\ttextProxy.is( '$textProxy' ); // -> true\n   *\t\ttextProxy.is( 'model:$textProxy' ); // -> true\n   *\n   *\t\ttextProxy.is( 'view:$textProxy' ); // -> false\n   *\t\ttextProxy.is( 'range' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * **Note:** Until version 20.0.0 this method wasn't accepting `'$textProxy'` type. The legacy `'textProxt'` type is still\n   * accepted for backward compatibility.\n   *\n   * @param {String} type Type to check.\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === '$textProxy' || type === 'model:$textProxy' || // This are legacy values kept for backward compatibility.\n    type === 'textProxy' || type === 'model:textProxy';\n  }\n  /**\n   * Gets path to this text proxy.\n   *\n   * @see module:engine/model/node~Node#getPath\n   * @returns {Array.<Number>}\n   */\n\n\n  getPath() {\n    const path = this.textNode.getPath();\n\n    if (path.length > 0) {\n      path[path.length - 1] += this.offsetInText;\n    }\n\n    return path;\n  }\n  /**\n   * Returns ancestors array of this text proxy.\n   *\n   * @param {Object} options Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` this text proxy will be also included in parent's array.\n   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,\n   * otherwise root element will be the first item in the array.\n   * @returns {Array} Array with ancestors.\n   */\n\n\n  getAncestors() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      includeSelf: false,\n      parentFirst: false\n    };\n    const ancestors = [];\n    let parent = options.includeSelf ? this : this.parent;\n\n    while (parent) {\n      ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n      parent = parent.parent;\n    }\n\n    return ancestors;\n  }\n  /**\n   * Checks if this text proxy has an attribute for given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.\n   */\n\n\n  hasAttribute(key) {\n    return this.textNode.hasAttribute(key);\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n\n\n  getAttribute(key) {\n    return this.textNode.getAttribute(key);\n  }\n  /**\n   * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two\n   * items. First one is attribute key and second is attribute value.\n   *\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  getAttributes() {\n    return this.textNode.getAttributes();\n  }\n  /**\n   * Returns iterator that iterates over this node's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  getAttributeKeys() {\n    return this.textNode.getAttributeKeys();\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn `#${ this.data }`;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // log() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelTextProxy: ' + this );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logExtended() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( `ModelTextProxy: ${ this }, ` +\n  // @if CK_DEBUG_ENGINE // \t\t`attrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );\n  // @if CK_DEBUG_ENGINE // }\n\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/textproxy.js"],"names":["CKEditorError","TextProxy","constructor","textNode","offsetInText","length","offsetSize","data","substring","startOffset","endOffset","isPartial","parent","root","is","type","getPath","path","getAncestors","options","includeSelf","parentFirst","ancestors","hasAttribute","key","getAttribute","getAttributes","getAttributeKeys"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,aAAP,MAA0B,6CAA1B,C,CAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,SAAN,CAAgB;AAC9B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,QAAF,EAAYC,YAAZ,EAA0BC,MAA1B,EAAmC;AAC7C;AACF;AACA;AACA;AACA;AACA;AACE,SAAKF,QAAL,GAAgBA,QAAhB;;AAEA,QAAKC,YAAY,GAAG,CAAf,IAAoBA,YAAY,GAAGD,QAAQ,CAACG,UAAjD,EAA8D;AAC7D;AACH;AACA;AACA;AACA;AACG,YAAM,IAAIN,aAAJ,CAAmB,oCAAnB,EAAyD,IAAzD,CAAN;AACA;;AAED,QAAKK,MAAM,GAAG,CAAT,IAAcD,YAAY,GAAGC,MAAf,GAAwBF,QAAQ,CAACG,UAApD,EAAiE;AAChE;AACH;AACA;AACA;AACA;AACG,YAAM,IAAIN,aAAJ,CAAmB,8BAAnB,EAAmD,IAAnD,CAAN;AACA;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE,SAAKO,IAAL,GAAYJ,QAAQ,CAACI,IAAT,CAAcC,SAAd,CAAyBJ,YAAzB,EAAuCA,YAAY,GAAGC,MAAtD,CAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKD,YAAL,GAAoBA,YAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACgB,MAAXK,WAAW,GAAG;AACjB,WAAO,KAAKN,QAAL,CAAcM,WAAd,KAA8B,IAA9B,GAAqC,KAAKN,QAAL,CAAcM,WAAd,GAA4B,KAAKL,YAAtE,GAAqF,IAA5F;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACe,MAAVE,UAAU,GAAG;AAChB,WAAO,KAAKC,IAAL,CAAUF,MAAjB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACc,MAATK,SAAS,GAAG;AACf,WAAO,KAAKD,WAAL,KAAqB,IAArB,GAA4B,KAAKA,WAAL,GAAmB,KAAKH,UAApD,GAAiE,IAAxE;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACc,MAATK,SAAS,GAAG;AACf,WAAO,KAAKL,UAAL,KAAoB,KAAKH,QAAL,CAAcG,UAAzC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACW,MAANM,MAAM,GAAG;AACZ,WAAO,KAAKT,QAAL,CAAcS,MAArB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACS,MAAJC,IAAI,GAAG;AACV,WAAO,KAAKV,QAAL,CAAcU,IAArB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,EAAE,CAAEC,IAAF,EAAS;AACV,WAAOA,IAAI,KAAK,YAAT,IAAyBA,IAAI,KAAK,kBAAlC,IACN;AACAA,IAAAA,IAAI,KAAK,WAFH,IAEkBA,IAAI,KAAK,iBAFlC;AAGA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,OAAO,GAAG;AACT,UAAMC,IAAI,GAAG,KAAKd,QAAL,CAAca,OAAd,EAAb;;AAEA,QAAKC,IAAI,CAACZ,MAAL,GAAc,CAAnB,EAAuB;AACtBY,MAAAA,IAAI,CAAEA,IAAI,CAACZ,MAAL,GAAc,CAAhB,CAAJ,IAA2B,KAAKD,YAAhC;AACA;;AAED,WAAOa,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,GAAyD;AAAA,QAAvDC,OAAuD,uEAA7C;AAAEC,MAAAA,WAAW,EAAE,KAAf;AAAsBC,MAAAA,WAAW,EAAE;AAAnC,KAA6C;AACpE,UAAMC,SAAS,GAAG,EAAlB;AACA,QAAIV,MAAM,GAAGO,OAAO,CAACC,WAAR,GAAsB,IAAtB,GAA6B,KAAKR,MAA/C;;AAEA,WAAQA,MAAR,EAAiB;AAChBU,MAAAA,SAAS,CAAEH,OAAO,CAACE,WAAR,GAAsB,MAAtB,GAA+B,SAAjC,CAAT,CAAuDT,MAAvD;AACAA,MAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACA;;AAED,WAAOU,SAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAAEC,GAAF,EAAQ;AACnB,WAAO,KAAKrB,QAAL,CAAcoB,YAAd,CAA4BC,GAA5B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAAED,GAAF,EAAQ;AACnB,WAAO,KAAKrB,QAAL,CAAcsB,YAAd,CAA4BD,GAA5B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,aAAa,GAAG;AACf,WAAO,KAAKvB,QAAL,CAAcuB,aAAd,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,gBAAgB,GAAG;AAClB,WAAO,KAAKxB,QAAL,CAAcwB,gBAAd,EAAP;AACA,GA9N6B,CAgO9B;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AA3O8B","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/textproxy\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// @if CK_DEBUG_ENGINE // const { convertMapToStringifiedObject } = require( '../dev-utils/utils' );\n\n/**\n * `TextProxy` represents a part of {@link module:engine/model/text~Text text node}.\n *\n * Since {@link module:engine/model/position~Position positions} can be placed between characters of a text node,\n * {@link module:engine/model/range~Range ranges} may contain only parts of text nodes. When {@link module:engine/model/range~Range#getItems\n * getting items}\n * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.\n * `TextProxy` solves this issue.\n *\n * `TextProxy` has an API similar to {@link module:engine/model/text~Text Text} and allows to do most of the common tasks performed\n * on model nodes.\n *\n * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.\n * See {@link module:engine/model/textproxy~TextProxy#isPartial}.\n *\n * **Note:** `TextProxy` is not an instance of {@link module:engine/model/node~Node node}. Keep this in mind when using it as a\n * parameter of methods.\n *\n * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`\n * use {@link module:engine/model/writer~Writer model writer API}.\n *\n * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is\n * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when\n * model changes, so they might get invalidated. Instead, consider creating {@link module:engine/model/liveposition~LivePosition live\n * position}.\n *\n * `TextProxy` instances are created by {@link module:engine/model/treewalker~TreeWalker model tree walker}. You should not need to create\n * an instance of this class by your own.\n */\nexport default class TextProxy {\n\t/**\n\t * Creates a text proxy.\n\t *\n\t * @protected\n\t * @param {module:engine/model/text~Text} textNode Text node which part is represented by this text proxy.\n\t * @param {Number} offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy\n\t * starts.\n\t * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.\n\t * @constructor\n\t */\n\tconstructor( textNode, offsetInText, length ) {\n\t\t/**\n\t\t * Text node which part is represented by this text proxy.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/text~Text}\n\t\t */\n\t\tthis.textNode = textNode;\n\n\t\tif ( offsetInText < 0 || offsetInText > textNode.offsetSize ) {\n\t\t\t/**\n\t\t\t * Given `offsetInText` value is incorrect.\n\t\t\t *\n\t\t\t * @error model-textproxy-wrong-offsetintext\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-textproxy-wrong-offsetintext', this );\n\t\t}\n\n\t\tif ( length < 0 || offsetInText + length > textNode.offsetSize ) {\n\t\t\t/**\n\t\t\t * Given `length` value is incorrect.\n\t\t\t *\n\t\t\t * @error model-textproxy-wrong-length\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-textproxy-wrong-length', this );\n\t\t}\n\n\t\t/**\n\t\t * Text data represented by this text proxy.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.data = textNode.data.substring( offsetInText, offsetInText + length );\n\n\t\t/**\n\t\t * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.offsetInText = offsetInText;\n\t}\n\n\t/**\n\t * Offset at which this text proxy starts in it's parent.\n\t *\n\t * @see module:engine/model/node~Node#startOffset\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget startOffset() {\n\t\treturn this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;\n\t}\n\n\t/**\n\t * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.\n\t *\n\t * @see module:engine/model/node~Node#offsetSize\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget offsetSize() {\n\t\treturn this.data.length;\n\t}\n\n\t/**\n\t * Offset at which this text proxy ends in it's parent.\n\t *\n\t * @see module:engine/model/node~Node#endOffset\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget endOffset() {\n\t\treturn this.startOffset !== null ? this.startOffset + this.offsetSize : null;\n\t}\n\n\t/**\n\t * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}\n\t * (`true`) or the whole text node (`false`).\n\t *\n\t * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}\n\t * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to\n\t * text node size.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isPartial() {\n\t\treturn this.offsetSize !== this.textNode.offsetSize;\n\t}\n\n\t/**\n\t * Parent of this text proxy, which is same as parent of text node represented by this text proxy.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tget parent() {\n\t\treturn this.textNode.parent;\n\t}\n\n\t/**\n\t * Root of this text proxy, which is same as root of text node represented by this text proxy.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.textNode.root;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\ttextProxy.is( '$textProxy' ); // -> true\n\t *\t\ttextProxy.is( 'model:$textProxy' ); // -> true\n\t *\n\t *\t\ttextProxy.is( 'view:$textProxy' ); // -> false\n\t *\t\ttextProxy.is( 'range' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * **Note:** Until version 20.0.0 this method wasn't accepting `'$textProxy'` type. The legacy `'textProxt'` type is still\n\t * accepted for backward compatibility.\n\t *\n\t * @param {String} type Type to check.\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === '$textProxy' || type === 'model:$textProxy' ||\n\t\t\t// This are legacy values kept for backward compatibility.\n\t\t\ttype === 'textProxy' || type === 'model:textProxy';\n\t}\n\n\t/**\n\t * Gets path to this text proxy.\n\t *\n\t * @see module:engine/model/node~Node#getPath\n\t * @returns {Array.<Number>}\n\t */\n\tgetPath() {\n\t\tconst path = this.textNode.getPath();\n\n\t\tif ( path.length > 0 ) {\n\t\t\tpath[ path.length - 1 ] += this.offsetInText;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this text proxy.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this text proxy will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Checks if this text proxy has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this.textNode.hasAttribute( key );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this.textNode.getAttribute( key );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two\n\t * items. First one is attribute key and second is attribute value.\n\t *\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this.textNode.getAttributes();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this.textNode.getAttributeKeys();\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `#${ this.data }`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelTextProxy: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logExtended() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( `ModelTextProxy: ${ this }, ` +\n\t// @if CK_DEBUG_ENGINE // \t\t`attrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );\n\t// @if CK_DEBUG_ENGINE // }\n}\n"]},"metadata":{},"sourceType":"module"}