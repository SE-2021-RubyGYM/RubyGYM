{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/focuscycler\n */\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\n/**\n * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a\n * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the\n * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard\n * navigation in HTML forms, toolbars, lists and the like.\n *\n * To work properly it requires:\n * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,\n * * an associated focus tracker to determine which view is focused.\n *\n * A simple cycler setup can look like this:\n *\n *\t\tconst focusables = new ViewCollection();\n *\t\tconst focusTracker = new FocusTracker();\n *\n *\t\t// Add focusable views to the focus tracker.\n *\t\tfocusTracker.add( ... );\n *\n * Then, the cycler can be used manually:\n *\n *\t\tconst cycler = new FocusCycler( { focusables, focusTracker } );\n *\n *\t\t// Will focus the first focusable view in #focusables.\n *\t\tcycler.focusFirst();\n *\n *\t\t// Will log the next focusable item in #focusables.\n *\t\tconsole.log( cycler.next );\n *\n * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:\n *\n *\t\tconst keystrokeHandler = new KeystrokeHandler();\n *\n *\t\t// Activate the keystroke handler.\n *\t\tkeystrokeHandler.listenTo( sourceOfEvents );\n *\n *\t\tconst cycler = new FocusCycler( {\n *\t\t\tfocusables, focusTracker, keystrokeHandler,\n *\t\t\tactions: {\n *\t\t\t\t// When arrowup of arrowleft is detected by the #keystrokeHandler,\n *\t\t\t\t// focusPrevious() will be called on the cycler.\n *\t\t\t\tfocusPrevious: [ 'arrowup', 'arrowleft' ],\n *\t\t\t}\n *\t\t} );\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n */\n\nexport default class FocusCycler {\n  /**\n   * Creates an instance of the focus cycler utility.\n   *\n   * @param {Object} options Configuration options.\n   * @param {module:utils/collection~Collection|Object} options.focusables\n   * @param {module:utils/focustracker~FocusTracker} options.focusTracker\n   * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]\n   * @param {Object} [options.actions]\n   */\n  constructor(options) {\n    Object.assign(this, options);\n    /**\n     * A {@link module:ui/view~View view} collection that the cycler operates on.\n     *\n     * @readonly\n     * @member {module:utils/collection~Collection} #focusables\n     */\n\n    /**\n     * A focus tracker instance that the cycler uses to determine the current focus\n     * state in {@link #focusables}.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker} #focusTracker\n     */\n\n    /**\n     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}\n     * which can respond to certain keystrokes and cycle the focus.\n     *\n     * @readonly\n     * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler\n     */\n\n    /**\n     * Actions that the cycler can take when a keystroke is pressed. Requires\n     * `options.keystrokeHandler` to be passed and working. When an action is\n     * performed, `preventDefault` and `stopPropagation` will be called on the event\n     * the keystroke fired in the DOM.\n     *\n     *\t\tactions: {\n     *\t\t\t// Will call #focusPrevious() when arrowleft or arrowup is pressed.\n     *\t\t\tfocusPrevious: [ 'arrowleft', 'arrowup' ],\n     *\n     *\t\t\t// Will call #focusNext() when arrowdown is pressed.\n     *\t\t\tfocusNext: 'arrowdown'\n     *\t\t}\n     *\n     * @readonly\n     * @member {Object} #actions\n     */\n\n    if (options.actions && options.keystrokeHandler) {\n      for (const methodName in options.actions) {\n        let actions = options.actions[methodName];\n\n        if (typeof actions == 'string') {\n          actions = [actions];\n        }\n\n        for (const keystroke of actions) {\n          options.keystrokeHandler.set(keystroke, (data, cancel) => {\n            this[methodName]();\n            cancel();\n          });\n        }\n      }\n    }\n  }\n  /**\n   * Returns the first focusable view in {@link #focusables}.\n   * Returns `null` if there is none.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #first\n   */\n\n\n  get first() {\n    return this.focusables.find(isFocusable) || null;\n  }\n  /**\n   * Returns the last focusable view in {@link #focusables}.\n   * Returns `null` if there is none.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #last\n   */\n\n\n  get last() {\n    return this.focusables.filter(isFocusable).slice(-1)[0] || null;\n  }\n  /**\n   * Returns the next focusable view in {@link #focusables} based on {@link #current}.\n   * Returns `null` if there is none.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #next\n   */\n\n\n  get next() {\n    return this._getFocusableItem(1);\n  }\n  /**\n   * Returns the previous focusable view in {@link #focusables} based on {@link #current}.\n   * Returns `null` if there is none.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #previous\n   */\n\n\n  get previous() {\n    return this._getFocusableItem(-1);\n  }\n  /**\n   * An index of the view in the {@link #focusables} which is focused according\n   * to {@link #focusTracker}. Returns `null` when there is no such view.\n   *\n   * @readonly\n   * @member {Number|null} #current\n   */\n\n\n  get current() {\n    let index = null; // There's no focused view in the focusables.\n\n    if (this.focusTracker.focusedElement === null) {\n      return null;\n    }\n\n    this.focusables.find((view, viewIndex) => {\n      const focused = view.element === this.focusTracker.focusedElement;\n\n      if (focused) {\n        index = viewIndex;\n      }\n\n      return focused;\n    });\n    return index;\n  }\n  /**\n   * Focuses the {@link #first} item in {@link #focusables}.\n   */\n\n\n  focusFirst() {\n    this._focus(this.first);\n  }\n  /**\n   * Focuses the {@link #last} item in {@link #focusables}.\n   */\n\n\n  focusLast() {\n    this._focus(this.last);\n  }\n  /**\n   * Focuses the {@link #next} item in {@link #focusables}.\n   */\n\n\n  focusNext() {\n    this._focus(this.next);\n  }\n  /**\n   * Focuses the {@link #previous} item in {@link #focusables}.\n   */\n\n\n  focusPrevious() {\n    this._focus(this.previous);\n  }\n  /**\n   * Focuses the given view if it exists.\n   *\n   * @protected\n   * @param {module:ui/view~View} view\n   */\n\n\n  _focus(view) {\n    if (view) {\n      view.focus();\n    }\n  }\n  /**\n   * Returns the next or previous focusable view in {@link #focusables} with respect\n   * to {@link #current}.\n   *\n   * @protected\n   * @param {Number} step Either `1` for checking forward from {@link #current} or\n   * `-1` for checking backwards.\n   * @returns {module:ui/view~View|null}\n   */\n\n\n  _getFocusableItem(step) {\n    // Cache for speed.\n    const current = this.current;\n    const collectionLength = this.focusables.length;\n\n    if (!collectionLength) {\n      return null;\n    } // Start from the beginning if no view is focused.\n    // https://github.com/ckeditor/ckeditor5-ui/issues/206\n\n\n    if (current === null) {\n      return this[step === 1 ? 'first' : 'last'];\n    } // Cycle in both directions.\n\n\n    let index = (current + collectionLength + step) % collectionLength;\n\n    do {\n      const view = this.focusables.get(index); // TODO: Check if view is visible.\n\n      if (isFocusable(view)) {\n        return view;\n      } // Cycle in both directions.\n\n\n      index = (index + collectionLength + step) % collectionLength;\n    } while (index !== current);\n\n    return null;\n  }\n\n} // Checks whether a view is focusable.\n//\n// @private\n// @param {module:ui/view~View} view A view to be checked.\n// @returns {Boolean}\n\nfunction isFocusable(view) {\n  return !!(view.focus && global.window.getComputedStyle(view.element).display != 'none');\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-ui/src/focuscycler.js"],"names":["global","FocusCycler","constructor","options","Object","assign","actions","keystrokeHandler","methodName","keystroke","set","data","cancel","first","focusables","find","isFocusable","last","filter","slice","next","_getFocusableItem","previous","current","index","focusTracker","focusedElement","view","viewIndex","focused","element","focusFirst","_focus","focusLast","focusNext","focusPrevious","focus","step","collectionLength","length","get","window","getComputedStyle","display"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,MAAP,MAAmB,0CAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,WAAN,CAAkB;AAChC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,OAAF,EAAY;AACtBC,IAAAA,MAAM,CAACC,MAAP,CAAe,IAAf,EAAqBF,OAArB;AAEA;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE,QAAKA,OAAO,CAACG,OAAR,IAAmBH,OAAO,CAACI,gBAAhC,EAAmD;AAClD,WAAM,MAAMC,UAAZ,IAA0BL,OAAO,CAACG,OAAlC,EAA4C;AAC3C,YAAIA,OAAO,GAAGH,OAAO,CAACG,OAAR,CAAiBE,UAAjB,CAAd;;AAEA,YAAK,OAAOF,OAAP,IAAkB,QAAvB,EAAkC;AACjCA,UAAAA,OAAO,GAAG,CAAEA,OAAF,CAAV;AACA;;AAED,aAAM,MAAMG,SAAZ,IAAyBH,OAAzB,EAAmC;AAClCH,UAAAA,OAAO,CAACI,gBAAR,CAAyBG,GAAzB,CAA8BD,SAA9B,EAAyC,CAAEE,IAAF,EAAQC,MAAR,KAAoB;AAC5D,iBAAMJ,UAAN;AACAI,YAAAA,MAAM;AACN,WAHD;AAIA;AACD;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACU,MAALC,KAAK,GAAG;AACX,WAAO,KAAKC,UAAL,CAAgBC,IAAhB,CAAsBC,WAAtB,KAAuC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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/focuscycler\n */\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\n\n/**\n * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a\n * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the\n * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard\n * navigation in HTML forms, toolbars, lists and the like.\n *\n * To work properly it requires:\n * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,\n * * an associated focus tracker to determine which view is focused.\n *\n * A simple cycler setup can look like this:\n *\n *\t\tconst focusables = new ViewCollection();\n *\t\tconst focusTracker = new FocusTracker();\n *\n *\t\t// Add focusable views to the focus tracker.\n *\t\tfocusTracker.add( ... );\n *\n * Then, the cycler can be used manually:\n *\n *\t\tconst cycler = new FocusCycler( { focusables, focusTracker } );\n *\n *\t\t// Will focus the first focusable view in #focusables.\n *\t\tcycler.focusFirst();\n *\n *\t\t// Will log the next focusable item in #focusables.\n *\t\tconsole.log( cycler.next );\n *\n * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:\n *\n *\t\tconst keystrokeHandler = new KeystrokeHandler();\n *\n *\t\t// Activate the keystroke handler.\n *\t\tkeystrokeHandler.listenTo( sourceOfEvents );\n *\n *\t\tconst cycler = new FocusCycler( {\n *\t\t\tfocusables, focusTracker, keystrokeHandler,\n *\t\t\tactions: {\n *\t\t\t\t// When arrowup of arrowleft is detected by the #keystrokeHandler,\n *\t\t\t\t// focusPrevious() will be called on the cycler.\n *\t\t\t\tfocusPrevious: [ 'arrowup', 'arrowleft' ],\n *\t\t\t}\n *\t\t} );\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n */\nexport default class FocusCycler {\n\t/**\n\t * Creates an instance of the focus cycler utility.\n\t *\n\t * @param {Object} options Configuration options.\n\t * @param {module:utils/collection~Collection|Object} options.focusables\n\t * @param {module:utils/focustracker~FocusTracker} options.focusTracker\n\t * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]\n\t * @param {Object} [options.actions]\n\t */\n\tconstructor( options ) {\n\t\tObject.assign( this, options );\n\n\t\t/**\n\t\t * A {@link module:ui/view~View view} collection that the cycler operates on.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/collection~Collection} #focusables\n\t\t */\n\n\t\t/**\n\t\t * A focus tracker instance that the cycler uses to determine the current focus\n\t\t * state in {@link #focusables}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/focustracker~FocusTracker} #focusTracker\n\t\t */\n\n\t\t/**\n\t\t * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}\n\t\t * which can respond to certain keystrokes and cycle the focus.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler\n\t\t */\n\n\t\t/**\n\t\t * Actions that the cycler can take when a keystroke is pressed. Requires\n\t\t * `options.keystrokeHandler` to be passed and working. When an action is\n\t\t * performed, `preventDefault` and `stopPropagation` will be called on the event\n\t\t * the keystroke fired in the DOM.\n\t\t *\n\t\t *\t\tactions: {\n\t\t *\t\t\t// Will call #focusPrevious() when arrowleft or arrowup is pressed.\n\t\t *\t\t\tfocusPrevious: [ 'arrowleft', 'arrowup' ],\n\t\t *\n\t\t *\t\t\t// Will call #focusNext() when arrowdown is pressed.\n\t\t *\t\t\tfocusNext: 'arrowdown'\n\t\t *\t\t}\n\t\t *\n\t\t * @readonly\n\t\t * @member {Object} #actions\n\t\t */\n\n\t\tif ( options.actions && options.keystrokeHandler ) {\n\t\t\tfor ( const methodName in options.actions ) {\n\t\t\t\tlet actions = options.actions[ methodName ];\n\n\t\t\t\tif ( typeof actions == 'string' ) {\n\t\t\t\t\tactions = [ actions ];\n\t\t\t\t}\n\n\t\t\t\tfor ( const keystroke of actions ) {\n\t\t\t\t\toptions.keystrokeHandler.set( keystroke, ( data, cancel ) => {\n\t\t\t\t\t\tthis[ methodName ]();\n\t\t\t\t\t\tcancel();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the first focusable view in {@link #focusables}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #first\n\t */\n\tget first() {\n\t\treturn this.focusables.find( isFocusable ) || null;\n\t}\n\n\t/**\n\t * Returns the last focusable view in {@link #focusables}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #last\n\t */\n\tget last() {\n\t\treturn this.focusables.filter( isFocusable ).slice( -1 )[ 0 ] || null;\n\t}\n\n\t/**\n\t * Returns the next focusable view in {@link #focusables} based on {@link #current}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #next\n\t */\n\tget next() {\n\t\treturn this._getFocusableItem( 1 );\n\t}\n\n\t/**\n\t * Returns the previous focusable view in {@link #focusables} based on {@link #current}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #previous\n\t */\n\tget previous() {\n\t\treturn this._getFocusableItem( -1 );\n\t}\n\n\t/**\n\t * An index of the view in the {@link #focusables} which is focused according\n\t * to {@link #focusTracker}. Returns `null` when there is no such view.\n\t *\n\t * @readonly\n\t * @member {Number|null} #current\n\t */\n\tget current() {\n\t\tlet index = null;\n\n\t\t// There's no focused view in the focusables.\n\t\tif ( this.focusTracker.focusedElement === null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.focusables.find( ( view, viewIndex ) => {\n\t\t\tconst focused = view.element === this.focusTracker.focusedElement;\n\n\t\t\tif ( focused ) {\n\t\t\t\tindex = viewIndex;\n\t\t\t}\n\n\t\t\treturn focused;\n\t\t} );\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Focuses the {@link #first} item in {@link #focusables}.\n\t */\n\tfocusFirst() {\n\t\tthis._focus( this.first );\n\t}\n\n\t/**\n\t * Focuses the {@link #last} item in {@link #focusables}.\n\t */\n\tfocusLast() {\n\t\tthis._focus( this.last );\n\t}\n\n\t/**\n\t * Focuses the {@link #next} item in {@link #focusables}.\n\t */\n\tfocusNext() {\n\t\tthis._focus( this.next );\n\t}\n\n\t/**\n\t * Focuses the {@link #previous} item in {@link #focusables}.\n\t */\n\tfocusPrevious() {\n\t\tthis._focus( this.previous );\n\t}\n\n\t/**\n\t * Focuses the given view if it exists.\n\t *\n\t * @protected\n\t * @param {module:ui/view~View} view\n\t */\n\t_focus( view ) {\n\t\tif ( view ) {\n\t\t\tview.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the next or previous focusable view in {@link #focusables} with respect\n\t * to {@link #current}.\n\t *\n\t * @protected\n\t * @param {Number} step Either `1` for checking forward from {@link #current} or\n\t * `-1` for checking backwards.\n\t * @returns {module:ui/view~View|null}\n\t */\n\t_getFocusableItem( step ) {\n\t\t// Cache for speed.\n\t\tconst current = this.current;\n\t\tconst collectionLength = this.focusables.length;\n\n\t\tif ( !collectionLength ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Start from the beginning if no view is focused.\n\t\t// https://github.com/ckeditor/ckeditor5-ui/issues/206\n\t\tif ( current === null ) {\n\t\t\treturn this[ step === 1 ? 'first' : 'last' ];\n\t\t}\n\n\t\t// Cycle in both directions.\n\t\tlet index = ( current + collectionLength + step ) % collectionLength;\n\n\t\tdo {\n\t\t\tconst view = this.focusables.get( index );\n\n\t\t\t// TODO: Check if view is visible.\n\t\t\tif ( isFocusable( view ) ) {\n\t\t\t\treturn view;\n\t\t\t}\n\n\t\t\t// Cycle in both directions.\n\t\t\tindex = ( index + collectionLength + step ) % collectionLength;\n\t\t} while ( index !== current );\n\n\t\treturn null;\n\t}\n}\n\n// Checks whether a view is focusable.\n//\n// @private\n// @param {module:ui/view~View} view A view to be checked.\n// @returns {Boolean}\nfunction isFocusable( view ) {\n\treturn !!( view.focus && global.window.getComputedStyle( view.element ).display != 'none' );\n}\n"]},"metadata":{},"sourceType":"module"}