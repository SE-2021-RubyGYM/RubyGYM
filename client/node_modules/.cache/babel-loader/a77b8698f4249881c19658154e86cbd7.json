{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/changebuffer\n */\n\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n *\t\tconst buffer = new ChangeBuffer( model, LIMIT );\n *\n *\t\t// Later on in your feature:\n *\t\tbuffer.batch.insert( pos, insertedCharacters );\n *\t\tbuffer.input( insertedCharacters.length );\n *\n */\nexport default class ChangeBuffer {\n  /**\n   * Creates a new instance of the change buffer.\n   *\n   * @param {module:engine/model/model~Model} model\n   * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.\n   */\n  constructor(model) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n\n    /**\n     * The model instance.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n     * the {@link #batch batch} is set to a new one.\n     *\n     * @readonly\n     * @member {Number} #size\n     */\n\n    this.size = 0;\n    /**\n     * The maximum number of atomic changes which can be contained in one batch.\n     *\n     * @readonly\n     * @member {Number} #limit\n     */\n\n    this.limit = limit;\n    /**\n     * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n     *\n     * @readonly\n     * @member {Boolean} #isLocked\n     */\n\n    this.isLocked = false; // The function to be called in order to notify the buffer about batches which appeared in the document.\n    // The callback will check whether it is a new batch and in that case the buffer will be flushed.\n    //\n    // The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n    // should be added to a new batch. For instance, when the  user types, then inserts an image, and then types again,\n    // the characters typed after inserting the image should be added to a different batch than the characters typed before.\n\n    this._changeCallback = (evt, batch) => {\n      if (batch.type != 'transparent' && batch !== this._batch) {\n        this._reset(true);\n      }\n    };\n\n    this._selectionChangeCallback = () => {\n      this._reset();\n    };\n\n    this.model.document.on('change', this._changeCallback);\n    this.model.document.selection.on('change:range', this._selectionChangeCallback);\n    this.model.document.selection.on('change:attribute', this._selectionChangeCallback);\n    /**\n     * The current batch instance.\n     *\n     * @private\n     * @member #_batch\n     */\n\n    /**\n     * The callback to document the change event which later needs to be removed.\n     *\n     * @private\n     * @member #_changeCallback\n     */\n\n    /**\n     * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.\n     *\n     * @private\n     * @member #_selectionChangeCallback\n     */\n  }\n  /**\n   * The current batch to which a feature should add its operations. Once the {@link #size}\n   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n   *\n   * @type {module:engine/model/batch~Batch}\n   */\n\n\n  get batch() {\n    if (!this._batch) {\n      this._batch = this.model.createBatch();\n    }\n\n    return this._batch;\n  }\n  /**\n   * The input number of changes into the buffer. Once the {@link #size} is\n   * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n   *\n   * @param {Number} changeCount The number of atomic changes to input.\n   */\n\n\n  input(changeCount) {\n    this.size += changeCount;\n\n    if (this.size >= this.limit) {\n      this._reset(true);\n    }\n  }\n  /**\n   * Locks the buffer.\n   */\n\n\n  lock() {\n    this.isLocked = true;\n  }\n  /**\n   * Unlocks the buffer.\n   */\n\n\n  unlock() {\n    this.isLocked = false;\n  }\n  /**\n   * Destroys the buffer.\n   */\n\n\n  destroy() {\n    this.model.document.off('change', this._changeCallback);\n    this.model.document.selection.off('change:range', this._selectionChangeCallback);\n    this.model.document.selection.off('change:attribute', this._selectionChangeCallback);\n  }\n  /**\n   * Resets the change buffer.\n   *\n   * @private\n   * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.\n   */\n\n\n  _reset(ignoreLock) {\n    if (!this.isLocked || ignoreLock) {\n      this._batch = null;\n      this.size = 0;\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-typing/src/utils/changebuffer.js"],"names":["ChangeBuffer","constructor","model","limit","size","isLocked","_changeCallback","evt","batch","type","_batch","_reset","_selectionChangeCallback","document","on","selection","createBatch","input","changeCount","lock","unlock","destroy","off","ignoreLock"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/changebuffer\n */\n\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n *\t\tconst buffer = new ChangeBuffer( model, LIMIT );\n *\n *\t\t// Later on in your feature:\n *\t\tbuffer.batch.insert( pos, insertedCharacters );\n *\t\tbuffer.input( insertedCharacters.length );\n *\n */\nexport default class ChangeBuffer {\n\t/**\n\t * Creates a new instance of the change buffer.\n\t *\n\t * @param {module:engine/model/model~Model} model\n\t * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.\n\t */\n\tconstructor( model, limit = 20 ) {\n\t\t/**\n\t\t * The model instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model} #model\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n\t\t * the {@link #batch batch} is set to a new one.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #size\n\t\t */\n\t\tthis.size = 0;\n\n\t\t/**\n\t\t * The maximum number of atomic changes which can be contained in one batch.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #limit\n\t\t */\n\t\tthis.limit = limit;\n\n\t\t/**\n\t\t * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} #isLocked\n\t\t */\n\t\tthis.isLocked = false;\n\n\t\t// The function to be called in order to notify the buffer about batches which appeared in the document.\n\t\t// The callback will check whether it is a new batch and in that case the buffer will be flushed.\n\t\t//\n\t\t// The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n\t\t// should be added to a new batch. For instance, when the  user types, then inserts an image, and then types again,\n\t\t// the characters typed after inserting the image should be added to a different batch than the characters typed before.\n\t\tthis._changeCallback = ( evt, batch ) => {\n\t\t\tif ( batch.type != 'transparent' && batch !== this._batch ) {\n\t\t\t\tthis._reset( true );\n\t\t\t}\n\t\t};\n\n\t\tthis._selectionChangeCallback = () => {\n\t\t\tthis._reset();\n\t\t};\n\n\t\tthis.model.document.on( 'change', this._changeCallback );\n\n\t\tthis.model.document.selection.on( 'change:range', this._selectionChangeCallback );\n\t\tthis.model.document.selection.on( 'change:attribute', this._selectionChangeCallback );\n\n\t\t/**\n\t\t * The current batch instance.\n\t\t *\n\t\t * @private\n\t\t * @member #_batch\n\t\t */\n\n\t\t/**\n\t\t * The callback to document the change event which later needs to be removed.\n\t\t *\n\t\t * @private\n\t\t * @member #_changeCallback\n\t\t */\n\n\t\t/**\n\t\t * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.\n\t\t *\n\t\t * @private\n\t\t * @member #_selectionChangeCallback\n\t\t */\n\t}\n\n\t/**\n\t * The current batch to which a feature should add its operations. Once the {@link #size}\n\t * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n\t *\n\t * @type {module:engine/model/batch~Batch}\n\t */\n\tget batch() {\n\t\tif ( !this._batch ) {\n\t\t\tthis._batch = this.model.createBatch();\n\t\t}\n\n\t\treturn this._batch;\n\t}\n\n\t/**\n\t * The input number of changes into the buffer. Once the {@link #size} is\n\t * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n\t *\n\t * @param {Number} changeCount The number of atomic changes to input.\n\t */\n\tinput( changeCount ) {\n\t\tthis.size += changeCount;\n\n\t\tif ( this.size >= this.limit ) {\n\t\t\tthis._reset( true );\n\t\t}\n\t}\n\n\t/**\n\t * Locks the buffer.\n\t */\n\tlock() {\n\t\tthis.isLocked = true;\n\t}\n\n\t/**\n\t * Unlocks the buffer.\n\t */\n\tunlock() {\n\t\tthis.isLocked = false;\n\t}\n\n\t/**\n\t * Destroys the buffer.\n\t */\n\tdestroy() {\n\t\tthis.model.document.off( 'change', this._changeCallback );\n\t\tthis.model.document.selection.off( 'change:range', this._selectionChangeCallback );\n\t\tthis.model.document.selection.off( 'change:attribute', this._selectionChangeCallback );\n\t}\n\n\t/**\n\t * Resets the change buffer.\n\t *\n\t * @private\n\t * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.\n\t */\n\t_reset( ignoreLock ) {\n\t\tif ( !this.isLocked || ignoreLock ) {\n\t\t\tthis._batch = null;\n\t\t\tthis.size = 0;\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}