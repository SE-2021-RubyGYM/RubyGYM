{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/selection-post-fixer\n */\nimport Range from '../range';\nimport Position from '../position';\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isSelectable selectable elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><imageBlock></imageBlock>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\n\nexport function injectSelectionPostFixer(model) {\n  model.document.registerPostFixer(writer => selectionPostFixer(writer, model));\n} // The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction selectionPostFixer(writer, model) {\n  const selection = model.document.selection;\n  const schema = model.schema;\n  const ranges = [];\n  let wasFixed = false;\n\n  for (const modelRange of selection.getRanges()) {\n    // Go through all ranges in selection and try fixing each of them.\n    // Those ranges might overlap but will be corrected later.\n    const correctedRange = tryFixingRange(modelRange, schema); // \"Selection fixing\" algorithms sometimes get lost. In consequence, it may happen\n    // that a new range is returned but, in fact, it has the same positions as the original\n    // range anyway. If this range is not discarded, a new selection will be set and that,\n    // for instance, would destroy the selection attributes. Let's make sure that the post-fixer\n    // actually worked first before setting a new selection.\n    //\n    // https://github.com/ckeditor/ckeditor5/issues/6693\n\n    if (correctedRange && !correctedRange.isEqual(modelRange)) {\n      ranges.push(correctedRange);\n      wasFixed = true;\n    } else {\n      ranges.push(modelRange);\n    }\n  } // If any of ranges were corrected update the selection.\n\n\n  if (wasFixed) {\n    writer.setSelection(mergeIntersectingRanges(ranges), {\n      backward: selection.isBackward\n    });\n  }\n} // Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingRange(range, schema) {\n  if (range.isCollapsed) {\n    return tryFixingCollapsedRange(range, schema);\n  }\n\n  return tryFixingNonCollapsedRage(range, schema);\n} // Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingCollapsedRange(range, schema) {\n  const originalPosition = range.start;\n  const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition); // This might be null ie when editor data is empty or the selection is inside limit element\n  // that doesn't allow text inside.\n  // In the first case there is no need to fix the selection range.\n  // In the second let's go up to the outer selectable element\n\n  if (!nearestSelectionRange) {\n    const ancestorObject = originalPosition.getAncestors().reverse().find(item => schema.isObject(item));\n\n    if (ancestorObject) {\n      return Range._createOn(ancestorObject);\n    }\n\n    return null;\n  }\n\n  if (!nearestSelectionRange.isCollapsed) {\n    return nearestSelectionRange;\n  }\n\n  const fixedPosition = nearestSelectionRange.start; // Fixed position is the same as original - no need to return corrected range.\n\n  if (originalPosition.isEqual(fixedPosition)) {\n    return null;\n  }\n\n  return new Range(fixedPosition);\n} // Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingNonCollapsedRage(range, schema) {\n  const {\n    start,\n    end\n  } = range;\n  const isTextAllowedOnStart = schema.checkChild(start, '$text');\n  const isTextAllowedOnEnd = schema.checkChild(end, '$text');\n  const startLimitElement = schema.getLimitElement(start);\n  const endLimitElement = schema.getLimitElement(end); // Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n\n  if (startLimitElement === endLimitElement) {\n    // Range is valid when both position allows to place a text:\n    // - <block>f[oobarba]z</block>\n    // This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n    if (isTextAllowedOnStart && isTextAllowedOnEnd) {\n      return null;\n    } // Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n    // - [<block>foo</block>]    ->    <block>[foo]</block>\n    // - [<block>foo]</block>    ->    <block>[foo]</block>\n    // - <block>f[oo</block>]    ->    <block>f[oo]</block>\n    // - [<block>foo</block><selectable></selectable>]    ->    <block>[foo</block><selectable></selectable>]\n\n\n    if (checkSelectionOnNonLimitElements(start, end, schema)) {\n      const isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);\n      const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, 'forward');\n      const isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);\n      const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, 'backward'); // The schema.getNearestSelectionRange might return null - if that happens use original position.\n\n      const rangeStart = fixedStart ? fixedStart.start : start;\n      const rangeEnd = fixedEnd ? fixedEnd.end : end;\n      return new Range(rangeStart, rangeEnd);\n    }\n  }\n\n  const isStartInLimit = startLimitElement && !startLimitElement.is('rootElement');\n  const isEndInLimit = endLimitElement && !endLimitElement.is('rootElement'); // At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n  // then the range crossed limit element boundaries and needs to be fixed.\n\n  if (isStartInLimit || isEndInLimit) {\n    const bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;\n    const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));\n    const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema)); // Although we've already found limit element on start/end positions we must find the outer-most limit element.\n    // as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n\n    let fixedStart = start;\n    let fixedEnd = end;\n\n    if (expandStart) {\n      fixedStart = Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));\n    }\n\n    if (expandEnd) {\n      fixedEnd = Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));\n    }\n\n    return new Range(fixedStart, fixedEnd);\n  } // Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n\n\n  return null;\n} // Finds the outer-most ancestor.\n//\n// @param {module:engine/model/node~Node} startingNode\n// @param {module:engine/model/schema~Schema} schema\n// @param {String} expandToDirection Direction of expansion - either 'start' or 'end' of the range.\n// @returns {module:engine/model/node~Node}\n\n\nfunction findOutermostLimitAncestor(startingNode, schema) {\n  let isLimitNode = startingNode;\n  let parent = isLimitNode; // Find outer most isLimit block as such blocks might be nested (ie. in tables).\n\n  while (schema.isLimit(parent) && parent.parent) {\n    isLimitNode = parent;\n    parent = parent.parent;\n  }\n\n  return isLimitNode;\n} // Checks whether any of range boundaries is placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction checkSelectionOnNonLimitElements(start, end, schema) {\n  const startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, '$text');\n  const endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, '$text'); // We should fix such selection when one of those nodes needs fixing.\n\n  return startIsOnBlock || endIsOnBlock;\n} // Returns a minimal non-intersecting array of ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @returns {Array.<module:engine/model/range~Range>}\n\n\nfunction mergeIntersectingRanges(ranges) {\n  const nonIntersectingRanges = []; // First range will always be fine.\n\n  nonIntersectingRanges.push(ranges.shift());\n\n  for (const range of ranges) {\n    const previousRange = nonIntersectingRanges.pop();\n\n    if (range.isEqual(previousRange)) {\n      // Use only one of two identical ranges.\n      nonIntersectingRanges.push(previousRange);\n    } else if (range.isIntersecting(previousRange)) {\n      // Get the sum of two ranges.\n      const start = previousRange.start.isAfter(range.start) ? range.start : previousRange.start;\n      const end = previousRange.end.isAfter(range.end) ? previousRange.end : range.end;\n      const merged = new Range(start, end);\n      nonIntersectingRanges.push(merged);\n    } else {\n      nonIntersectingRanges.push(previousRange);\n      nonIntersectingRanges.push(range);\n    }\n  }\n\n  return nonIntersectingRanges;\n} // Checks if node exists and if it's a selectable.\n//\n// @param {module:engine/model/node~Node} node\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction isSelectable(node, schema) {\n  return node && schema.isSelectable(node);\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js"],"names":["Range","Position","injectSelectionPostFixer","model","document","registerPostFixer","writer","selectionPostFixer","selection","schema","ranges","wasFixed","modelRange","getRanges","correctedRange","tryFixingRange","isEqual","push","setSelection","mergeIntersectingRanges","backward","isBackward","range","isCollapsed","tryFixingCollapsedRange","tryFixingNonCollapsedRage","originalPosition","start","nearestSelectionRange","getNearestSelectionRange","ancestorObject","getAncestors","reverse","find","item","isObject","_createOn","fixedPosition","end","isTextAllowedOnStart","checkChild","isTextAllowedOnEnd","startLimitElement","getLimitElement","endLimitElement","checkSelectionOnNonLimitElements","isStartBeforeSelectable","nodeAfter","isSelectable","fixedStart","isEndAfterSelectable","nodeBefore","fixedEnd","rangeStart","rangeEnd","isStartInLimit","is","isEndInLimit","bothInSameParent","parent","expandStart","expandEnd","_createBefore","findOutermostLimitAncestor","_createAfter","startingNode","isLimitNode","isLimit","startIsOnBlock","endIsOnBlock","nonIntersectingRanges","shift","previousRange","pop","isIntersecting","isAfter","merged","node"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,KAAP,MAAkB,UAAlB;AACA,OAAOC,QAAP,MAAqB,aAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,wBAAT,CAAmCC,KAAnC,EAA2C;AACjDA,EAAAA,KAAK,CAACC,QAAN,CAAeC,iBAAf,CAAkCC,MAAM,IAAIC,kBAAkB,CAAED,MAAF,EAAUH,KAAV,CAA9D;AACA,C,CAED;AACA;AACA;AACA;;AACA,SAASI,kBAAT,CAA6BD,MAA7B,EAAqCH,KAArC,EAA6C;AAC5C,QAAMK,SAAS,GAAGL,KAAK,CAACC,QAAN,CAAeI,SAAjC;AACA,QAAMC,MAAM,GAAGN,KAAK,CAACM,MAArB;AAEA,QAAMC,MAAM,GAAG,EAAf;AAEA,MAAIC,QAAQ,GAAG,KAAf;;AAEA,OAAM,MAAMC,UAAZ,IAA0BJ,SAAS,CAACK,SAAV,EAA1B,EAAkD;AACjD;AACA;AACA,UAAMC,cAAc,GAAGC,cAAc,CAAEH,UAAF,EAAcH,MAAd,CAArC,CAHiD,CAKjD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAKK,cAAc,IAAI,CAACA,cAAc,CAACE,OAAf,CAAwBJ,UAAxB,CAAxB,EAA+D;AAC9DF,MAAAA,MAAM,CAACO,IAAP,CAAaH,cAAb;AACAH,MAAAA,QAAQ,GAAG,IAAX;AACA,KAHD,MAGO;AACND,MAAAA,MAAM,CAACO,IAAP,CAAaL,UAAb;AACA;AACD,GA1B2C,CA4B5C;;;AACA,MAAKD,QAAL,EAAgB;AACfL,IAAAA,MAAM,CAACY,YAAP,CAAqBC,uBAAuB,CAAET,MAAF,CAA5C,EAAwD;AAAEU,MAAAA,QAAQ,EAAEZ,SAAS,CAACa;AAAtB,KAAxD;AACA;AACD,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASN,cAAT,CAAyBO,KAAzB,EAAgCb,MAAhC,EAAyC;AACxC,MAAKa,KAAK,CAACC,WAAX,EAAyB;AACxB,WAAOC,uBAAuB,CAAEF,KAAF,EAASb,MAAT,CAA9B;AACA;;AAED,SAAOgB,yBAAyB,CAAEH,KAAF,EAASb,MAAT,CAAhC;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASe,uBAAT,CAAkCF,KAAlC,EAAyCb,MAAzC,EAAkD;AACjD,QAAMiB,gBAAgB,GAAGJ,KAAK,CAACK,KAA/B;AAEA,QAAMC,qBAAqB,GAAGnB,MAAM,CAACoB,wBAAP,CAAiCH,gBAAjC,CAA9B,CAHiD,CAKjD;AACA;AACA;AACA;;AACA,MAAK,CAACE,qBAAN,EAA8B;AAC7B,UAAME,cAAc,GAAGJ,gBAAgB,CAACK,YAAjB,GAAgCC,OAAhC,GAA0CC,IAA1C,CAAgDC,IAAI,IAAIzB,MAAM,CAAC0B,QAAP,CAAiBD,IAAjB,CAAxD,CAAvB;;AAEA,QAAKJ,cAAL,EAAsB;AACrB,aAAO9B,KAAK,CAACoC,SAAN,CAAiBN,cAAjB,CAAP;AACA;;AAED,WAAO,IAAP;AACA;;AAED,MAAK,CAACF,qBAAqB,CAACL,WAA5B,EAA0C;AACzC,WAAOK,qBAAP;AACA;;AAED,QAAMS,aAAa,GAAGT,qBAAqB,CAACD,KAA5C,CAvBiD,CAyBjD;;AACA,MAAKD,gBAAgB,CAACV,OAAjB,CAA0BqB,aAA1B,CAAL,EAAiD;AAChD,WAAO,IAAP;AACA;;AAED,SAAO,IAAIrC,KAAJ,CAAWqC,aAAX,CAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASZ,yBAAT,CAAoCH,KAApC,EAA2Cb,MAA3C,EAAoD;AACnD,QAAM;AAAEkB,IAAAA,KAAF;AAASW,IAAAA;AAAT,MAAiBhB,KAAvB;AAEA,QAAMiB,oBAAoB,GAAG9B,MAAM,CAAC+B,UAAP,CAAmBb,KAAnB,EAA0B,OAA1B,CAA7B;AACA,QAAMc,kBAAkB,GAAGhC,MAAM,CAAC+B,UAAP,CAAmBF,GAAnB,EAAwB,OAAxB,CAA3B;AAEA,QAAMI,iBAAiB,GAAGjC,MAAM,CAACkC,eAAP,CAAwBhB,KAAxB,CAA1B;AACA,QAAMiB,eAAe,GAAGnC,MAAM,CAACkC,eAAP,CAAwBL,GAAxB,CAAxB,CAPmD,CASnD;;AACA,MAAKI,iBAAiB,KAAKE,eAA3B,EAA6C;AAC5C;AACA;AACA;AACA,QAAKL,oBAAoB,IAAIE,kBAA7B,EAAkD;AACjD,aAAO,IAAP;AACA,KAN2C,CAQ5C;AACA;AACA;AACA;AACA;;;AACA,QAAKI,gCAAgC,CAAElB,KAAF,EAASW,GAAT,EAAc7B,MAAd,CAArC,EAA8D;AAC7D,YAAMqC,uBAAuB,GAAGnB,KAAK,CAACoB,SAAN,IAAmBtC,MAAM,CAACuC,YAAP,CAAqBrB,KAAK,CAACoB,SAA3B,CAAnD;AACA,YAAME,UAAU,GAAGH,uBAAuB,GAAG,IAAH,GAAUrC,MAAM,CAACoB,wBAAP,CAAiCF,KAAjC,EAAwC,SAAxC,CAApD;AAEA,YAAMuB,oBAAoB,GAAGZ,GAAG,CAACa,UAAJ,IAAkB1C,MAAM,CAACuC,YAAP,CAAqBV,GAAG,CAACa,UAAzB,CAA/C;AACA,YAAMC,QAAQ,GAAGF,oBAAoB,GAAG,IAAH,GAAUzC,MAAM,CAACoB,wBAAP,CAAiCS,GAAjC,EAAsC,UAAtC,CAA/C,CAL6D,CAO7D;;AACA,YAAMe,UAAU,GAAGJ,UAAU,GAAGA,UAAU,CAACtB,KAAd,GAAsBA,KAAnD;AACA,YAAM2B,QAAQ,GAAGF,QAAQ,GAAGA,QAAQ,CAACd,GAAZ,GAAkBA,GAA3C;AAEA,aAAO,IAAItC,KAAJ,CAAWqD,UAAX,EAAuBC,QAAvB,CAAP;AACA;AACD;;AAED,QAAMC,cAAc,GAAGb,iBAAiB,IAAI,CAACA,iBAAiB,CAACc,EAAlB,CAAsB,aAAtB,CAA7C;AACA,QAAMC,YAAY,GAAGb,eAAe,IAAI,CAACA,eAAe,CAACY,EAAhB,CAAoB,aAApB,CAAzC,CAvCmD,CAyCnD;AACA;;AACA,MAAKD,cAAc,IAAIE,YAAvB,EAAsC;AACrC,UAAMC,gBAAgB,GAAK/B,KAAK,CAACoB,SAAN,IAAmBT,GAAG,CAACa,UAAzB,IAAyCxB,KAAK,CAACoB,SAAN,CAAgBY,MAAhB,KAA2BrB,GAAG,CAACa,UAAJ,CAAeQ,MAA5G;AAEA,UAAMC,WAAW,GAAGL,cAAc,KAAM,CAACG,gBAAD,IAAqB,CAACV,YAAY,CAAErB,KAAK,CAACoB,SAAR,EAAmBtC,MAAnB,CAAxC,CAAlC;AACA,UAAMoD,SAAS,GAAGJ,YAAY,KAAM,CAACC,gBAAD,IAAqB,CAACV,YAAY,CAAEV,GAAG,CAACa,UAAN,EAAkB1C,MAAlB,CAAxC,CAA9B,CAJqC,CAMrC;AACA;;AACA,QAAIwC,UAAU,GAAGtB,KAAjB;AACA,QAAIyB,QAAQ,GAAGd,GAAf;;AAEA,QAAKsB,WAAL,EAAmB;AAClBX,MAAAA,UAAU,GAAGhD,QAAQ,CAAC6D,aAAT,CAAwBC,0BAA0B,CAAErB,iBAAF,EAAqBjC,MAArB,CAAlD,CAAb;AACA;;AAED,QAAKoD,SAAL,EAAiB;AAChBT,MAAAA,QAAQ,GAAGnD,QAAQ,CAAC+D,YAAT,CAAuBD,0BAA0B,CAAEnB,eAAF,EAAmBnC,MAAnB,CAAjD,CAAX;AACA;;AAED,WAAO,IAAIT,KAAJ,CAAWiD,UAAX,EAAuBG,QAAvB,CAAP;AACA,GA/DkD,CAiEnD;;;AACA,SAAO,IAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,0BAAT,CAAqCE,YAArC,EAAmDxD,MAAnD,EAA4D;AAC3D,MAAIyD,WAAW,GAAGD,YAAlB;AACA,MAAIN,MAAM,GAAGO,WAAb,CAF2D,CAI3D;;AACA,SAAQzD,MAAM,CAAC0D,OAAP,CAAgBR,MAAhB,KAA4BA,MAAM,CAACA,MAA3C,EAAoD;AACnDO,IAAAA,WAAW,GAAGP,MAAd;AACAA,IAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACA;;AAED,SAAOO,WAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASrB,gCAAT,CAA2ClB,KAA3C,EAAkDW,GAAlD,EAAuD7B,MAAvD,EAAgE;AAC/D,QAAM2D,cAAc,GAAKzC,KAAK,CAACoB,SAAN,IAAmB,CAACtC,MAAM,CAAC0D,OAAP,CAAgBxC,KAAK,CAACoB,SAAtB,CAAtB,IAA6DtC,MAAM,CAAC+B,UAAP,CAAmBb,KAAnB,EAA0B,OAA1B,CAApF;AACA,QAAM0C,YAAY,GAAK/B,GAAG,CAACa,UAAJ,IAAkB,CAAC1C,MAAM,CAAC0D,OAAP,CAAgB7B,GAAG,CAACa,UAApB,CAArB,IAA2D1C,MAAM,CAAC+B,UAAP,CAAmBF,GAAnB,EAAwB,OAAxB,CAAhF,CAF+D,CAI/D;;AACA,SAAO8B,cAAc,IAAIC,YAAzB;AACA,C,CAED;AACA;AACA;AACA;;;AACA,SAASlD,uBAAT,CAAkCT,MAAlC,EAA2C;AAC1C,QAAM4D,qBAAqB,GAAG,EAA9B,CAD0C,CAG1C;;AACAA,EAAAA,qBAAqB,CAACrD,IAAtB,CAA4BP,MAAM,CAAC6D,KAAP,EAA5B;;AAEA,OAAM,MAAMjD,KAAZ,IAAqBZ,MAArB,EAA8B;AAC7B,UAAM8D,aAAa,GAAGF,qBAAqB,CAACG,GAAtB,EAAtB;;AAEA,QAAKnD,KAAK,CAACN,OAAN,CAAewD,aAAf,CAAL,EAAsC;AACrC;AACAF,MAAAA,qBAAqB,CAACrD,IAAtB,CAA4BuD,aAA5B;AACA,KAHD,MAGO,IAAKlD,KAAK,CAACoD,cAAN,CAAsBF,aAAtB,CAAL,EAA6C;AACnD;AACA,YAAM7C,KAAK,GAAG6C,aAAa,CAAC7C,KAAd,CAAoBgD,OAApB,CAA6BrD,KAAK,CAACK,KAAnC,IAA6CL,KAAK,CAACK,KAAnD,GAA2D6C,aAAa,CAAC7C,KAAvF;AACA,YAAMW,GAAG,GAAGkC,aAAa,CAAClC,GAAd,CAAkBqC,OAAlB,CAA2BrD,KAAK,CAACgB,GAAjC,IAAyCkC,aAAa,CAAClC,GAAvD,GAA6DhB,KAAK,CAACgB,GAA/E;AAEA,YAAMsC,MAAM,GAAG,IAAI5E,KAAJ,CAAW2B,KAAX,EAAkBW,GAAlB,CAAf;AACAgC,MAAAA,qBAAqB,CAACrD,IAAtB,CAA4B2D,MAA5B;AACA,KAPM,MAOA;AACNN,MAAAA,qBAAqB,CAACrD,IAAtB,CAA4BuD,aAA5B;AACAF,MAAAA,qBAAqB,CAACrD,IAAtB,CAA4BK,KAA5B;AACA;AACD;;AAED,SAAOgD,qBAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAAStB,YAAT,CAAuB6B,IAAvB,EAA6BpE,MAA7B,EAAsC;AACrC,SAAOoE,IAAI,IAAIpE,MAAM,CAACuC,YAAP,CAAqB6B,IAArB,CAAf;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/selection-post-fixer\n */\n\nimport Range from '../range';\nimport Position from '../position';\n\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isSelectable selectable elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><imageBlock></imageBlock>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\nexport function injectSelectionPostFixer( model ) {\n\tmodel.document.registerPostFixer( writer => selectionPostFixer( writer, model ) );\n}\n\n// The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction selectionPostFixer( writer, model ) {\n\tconst selection = model.document.selection;\n\tconst schema = model.schema;\n\n\tconst ranges = [];\n\n\tlet wasFixed = false;\n\n\tfor ( const modelRange of selection.getRanges() ) {\n\t\t// Go through all ranges in selection and try fixing each of them.\n\t\t// Those ranges might overlap but will be corrected later.\n\t\tconst correctedRange = tryFixingRange( modelRange, schema );\n\n\t\t// \"Selection fixing\" algorithms sometimes get lost. In consequence, it may happen\n\t\t// that a new range is returned but, in fact, it has the same positions as the original\n\t\t// range anyway. If this range is not discarded, a new selection will be set and that,\n\t\t// for instance, would destroy the selection attributes. Let's make sure that the post-fixer\n\t\t// actually worked first before setting a new selection.\n\t\t//\n\t\t// https://github.com/ckeditor/ckeditor5/issues/6693\n\t\tif ( correctedRange && !correctedRange.isEqual( modelRange ) ) {\n\t\t\tranges.push( correctedRange );\n\t\t\twasFixed = true;\n\t\t} else {\n\t\t\tranges.push( modelRange );\n\t\t}\n\t}\n\n\t// If any of ranges were corrected update the selection.\n\tif ( wasFixed ) {\n\t\twriter.setSelection( mergeIntersectingRanges( ranges ), { backward: selection.isBackward } );\n\t}\n}\n\n// Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingRange( range, schema ) {\n\tif ( range.isCollapsed ) {\n\t\treturn tryFixingCollapsedRange( range, schema );\n\t}\n\n\treturn tryFixingNonCollapsedRage( range, schema );\n}\n\n// Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingCollapsedRange( range, schema ) {\n\tconst originalPosition = range.start;\n\n\tconst nearestSelectionRange = schema.getNearestSelectionRange( originalPosition );\n\n\t// This might be null ie when editor data is empty or the selection is inside limit element\n\t// that doesn't allow text inside.\n\t// In the first case there is no need to fix the selection range.\n\t// In the second let's go up to the outer selectable element\n\tif ( !nearestSelectionRange ) {\n\t\tconst ancestorObject = originalPosition.getAncestors().reverse().find( item => schema.isObject( item ) );\n\n\t\tif ( ancestorObject ) {\n\t\t\treturn Range._createOn( ancestorObject );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tif ( !nearestSelectionRange.isCollapsed ) {\n\t\treturn nearestSelectionRange;\n\t}\n\n\tconst fixedPosition = nearestSelectionRange.start;\n\n\t// Fixed position is the same as original - no need to return corrected range.\n\tif ( originalPosition.isEqual( fixedPosition ) ) {\n\t\treturn null;\n\t}\n\n\treturn new Range( fixedPosition );\n}\n\n// Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingNonCollapsedRage( range, schema ) {\n\tconst { start, end } = range;\n\n\tconst isTextAllowedOnStart = schema.checkChild( start, '$text' );\n\tconst isTextAllowedOnEnd = schema.checkChild( end, '$text' );\n\n\tconst startLimitElement = schema.getLimitElement( start );\n\tconst endLimitElement = schema.getLimitElement( end );\n\n\t// Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n\tif ( startLimitElement === endLimitElement ) {\n\t\t// Range is valid when both position allows to place a text:\n\t\t// - <block>f[oobarba]z</block>\n\t\t// This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n\t\tif ( isTextAllowedOnStart && isTextAllowedOnEnd ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n\t\t// - [<block>foo</block>]    ->    <block>[foo]</block>\n\t\t// - [<block>foo]</block>    ->    <block>[foo]</block>\n\t\t// - <block>f[oo</block>]    ->    <block>f[oo]</block>\n\t\t// - [<block>foo</block><selectable></selectable>]    ->    <block>[foo</block><selectable></selectable>]\n\t\tif ( checkSelectionOnNonLimitElements( start, end, schema ) ) {\n\t\t\tconst isStartBeforeSelectable = start.nodeAfter && schema.isSelectable( start.nodeAfter );\n\t\t\tconst fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange( start, 'forward' );\n\n\t\t\tconst isEndAfterSelectable = end.nodeBefore && schema.isSelectable( end.nodeBefore );\n\t\t\tconst fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange( end, 'backward' );\n\n\t\t\t// The schema.getNearestSelectionRange might return null - if that happens use original position.\n\t\t\tconst rangeStart = fixedStart ? fixedStart.start : start;\n\t\t\tconst rangeEnd = fixedEnd ? fixedEnd.end : end;\n\n\t\t\treturn new Range( rangeStart, rangeEnd );\n\t\t}\n\t}\n\n\tconst isStartInLimit = startLimitElement && !startLimitElement.is( 'rootElement' );\n\tconst isEndInLimit = endLimitElement && !endLimitElement.is( 'rootElement' );\n\n\t// At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n\t// then the range crossed limit element boundaries and needs to be fixed.\n\tif ( isStartInLimit || isEndInLimit ) {\n\t\tconst bothInSameParent = ( start.nodeAfter && end.nodeBefore ) && start.nodeAfter.parent === end.nodeBefore.parent;\n\n\t\tconst expandStart = isStartInLimit && ( !bothInSameParent || !isSelectable( start.nodeAfter, schema ) );\n\t\tconst expandEnd = isEndInLimit && ( !bothInSameParent || !isSelectable( end.nodeBefore, schema ) );\n\n\t\t// Although we've already found limit element on start/end positions we must find the outer-most limit element.\n\t\t// as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n\t\tlet fixedStart = start;\n\t\tlet fixedEnd = end;\n\n\t\tif ( expandStart ) {\n\t\t\tfixedStart = Position._createBefore( findOutermostLimitAncestor( startLimitElement, schema ) );\n\t\t}\n\n\t\tif ( expandEnd ) {\n\t\t\tfixedEnd = Position._createAfter( findOutermostLimitAncestor( endLimitElement, schema ) );\n\t\t}\n\n\t\treturn new Range( fixedStart, fixedEnd );\n\t}\n\n\t// Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n\treturn null;\n}\n\n// Finds the outer-most ancestor.\n//\n// @param {module:engine/model/node~Node} startingNode\n// @param {module:engine/model/schema~Schema} schema\n// @param {String} expandToDirection Direction of expansion - either 'start' or 'end' of the range.\n// @returns {module:engine/model/node~Node}\nfunction findOutermostLimitAncestor( startingNode, schema ) {\n\tlet isLimitNode = startingNode;\n\tlet parent = isLimitNode;\n\n\t// Find outer most isLimit block as such blocks might be nested (ie. in tables).\n\twhile ( schema.isLimit( parent ) && parent.parent ) {\n\t\tisLimitNode = parent;\n\t\tparent = parent.parent;\n\t}\n\n\treturn isLimitNode;\n}\n\n// Checks whether any of range boundaries is placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction checkSelectionOnNonLimitElements( start, end, schema ) {\n\tconst startIsOnBlock = ( start.nodeAfter && !schema.isLimit( start.nodeAfter ) ) || schema.checkChild( start, '$text' );\n\tconst endIsOnBlock = ( end.nodeBefore && !schema.isLimit( end.nodeBefore ) ) || schema.checkChild( end, '$text' );\n\n\t// We should fix such selection when one of those nodes needs fixing.\n\treturn startIsOnBlock || endIsOnBlock;\n}\n\n// Returns a minimal non-intersecting array of ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @returns {Array.<module:engine/model/range~Range>}\nfunction mergeIntersectingRanges( ranges ) {\n\tconst nonIntersectingRanges = [];\n\n\t// First range will always be fine.\n\tnonIntersectingRanges.push( ranges.shift() );\n\n\tfor ( const range of ranges ) {\n\t\tconst previousRange = nonIntersectingRanges.pop();\n\n\t\tif ( range.isEqual( previousRange ) ) {\n\t\t\t// Use only one of two identical ranges.\n\t\t\tnonIntersectingRanges.push( previousRange );\n\t\t} else if ( range.isIntersecting( previousRange ) ) {\n\t\t\t// Get the sum of two ranges.\n\t\t\tconst start = previousRange.start.isAfter( range.start ) ? range.start : previousRange.start;\n\t\t\tconst end = previousRange.end.isAfter( range.end ) ? previousRange.end : range.end;\n\n\t\t\tconst merged = new Range( start, end );\n\t\t\tnonIntersectingRanges.push( merged );\n\t\t} else {\n\t\t\tnonIntersectingRanges.push( previousRange );\n\t\t\tnonIntersectingRanges.push( range );\n\t\t}\n\t}\n\n\treturn nonIntersectingRanges;\n}\n\n// Checks if node exists and if it's a selectable.\n//\n// @param {module:engine/model/node~Node} node\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction isSelectable( node, schema ) {\n\treturn node && schema.isSelectable( node );\n}\n"]},"metadata":{},"sourceType":"module"}