{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageutils\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { findOptimalInsertionRange, isWidget, toWidget } from 'ckeditor5/src/widget';\nimport { determineImageTypeForInsertionAtSelection } from './image/utils';\n/**\n * A set of helpers related to images.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class ImageUtils extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'ImageUtils';\n  }\n  /**\n   * Checks if the provided model element is an `image` or `imageInline`.\n   *\n   * @param {module:engine/model/element~Element} modelElement\n   * @returns {Boolean}\n   */\n\n\n  isImage(modelElement) {\n    return this.isInlineImage(modelElement) || this.isBlockImage(modelElement);\n  }\n  /**\n   * Checks if the provided view element represents an inline image.\n   *\n   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n   *\n   * @param {module:engine/view/element~Element} element\n   * @returns {Boolean}\n   */\n\n\n  isInlineImageView(element) {\n    return !!element && element.is('element', 'img');\n  }\n  /**\n   * Checks if the provided view element represents a block image.\n   *\n   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n   *\n   * @param {module:engine/view/element~Element} element\n   * @returns {Boolean}\n   */\n\n\n  isBlockImageView(element) {\n    return !!element && element.is('element', 'figure') && element.hasClass('image');\n  }\n  /**\n   * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}\n   * method.\n   *\n   *\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n   *\n   *\t\timageUtils.insertImage( { src: 'path/to/image.jpg' } );\n   *\n   * @param {Object} [attributes={}] Attributes of the inserted image.\n   * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.\n   * @param {module:engine/model/selection~Selectable} [selectable] Place to insert the image. If not specified,\n   * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images\n   * and `model.document.selection` for the inline images.\n   *\n   * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)\n   * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.\n   *\n   * @param {'imageBlock'|'imageInline'} [imageType] Image type of inserted image. If not specified,\n   * it will be determined automatically depending of editor config or place of the insertion.\n   * @return {module:engine/view/element~Element|null} The inserted model image element.\n   */\n\n\n  insertImage() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let selectable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let imageType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const editor = this.editor;\n    const model = editor.model;\n    const selection = model.document.selection;\n    imageType = determineImageTypeForInsertion(editor, selectable || selection, imageType); // Mix declarative attributes with selection attributes because the new image should \"inherit\"\n    // the latter for best UX. For instance, inline images inserted into existing links\n    // should not split them. To do that, they need to have \"linkHref\" inherited from the selection.\n\n    attributes = { ...Object.fromEntries(selection.getAttributes()),\n      ...attributes\n    };\n\n    for (const attributeName in attributes) {\n      if (!model.schema.checkAttribute(imageType, attributeName)) {\n        delete attributes[attributeName];\n      }\n    }\n\n    return model.change(writer => {\n      const imageElement = writer.createElement(imageType, attributes); // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.\n      // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).\n\n      if (!selectable && imageType != 'imageInline') {\n        selectable = findOptimalInsertionRange(selection, model);\n      }\n\n      model.insertContent(imageElement, selectable); // Inserting an image might've failed due to schema regulations.\n\n      if (imageElement.parent) {\n        writer.setSelection(imageElement, 'on');\n        return imageElement;\n      }\n\n      return null;\n    });\n  }\n  /**\n   * Returns an image widget editing view element if one is selected or is among the selection's ancestors.\n   *\n   * @protected\n   * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n   * @returns {module:engine/view/element~Element|null}\n   */\n\n\n  getClosestSelectedImageWidget(selection) {\n    const viewElement = selection.getSelectedElement();\n\n    if (viewElement && this.isImageWidget(viewElement)) {\n      return viewElement;\n    }\n\n    let parent = selection.getFirstPosition().parent;\n\n    while (parent) {\n      if (parent.is('element') && this.isImageWidget(parent)) {\n        return parent;\n      }\n\n      parent = parent.parent;\n    }\n\n    return null;\n  }\n  /**\n   * Returns a image model element if one is selected or is among the selection's ancestors.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  getClosestSelectedImageElement(selection) {\n    const selectedElement = selection.getSelectedElement();\n    return this.isImage(selectedElement) ? selectedElement : selection.getFirstPosition().findAncestor('imageBlock');\n  }\n  /**\n   * Checks if image can be inserted at current model selection.\n   *\n   * @protected\n   * @returns {Boolean}\n   */\n\n\n  isImageAllowed() {\n    const model = this.editor.model;\n    const selection = model.document.selection;\n    return isImageAllowedInParent(this.editor, selection) && isNotInsideImage(selection);\n  }\n  /**\n   * Converts a given {@link module:engine/view/element~Element} to an image widget:\n   * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget\n   * element.\n   * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n   *\n   * @protected\n   * @param {module:engine/view/element~Element} viewElement\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n   * @param {String} label The element's label. It will be concatenated with the image `alt` attribute if one is present.\n   * @returns {module:engine/view/element~Element}\n   */\n\n\n  toImageWidget(viewElement, writer, label) {\n    writer.setCustomProperty('image', true, viewElement);\n\n    const labelCreator = () => {\n      const imgElement = this.findViewImgElement(viewElement);\n      const altText = imgElement.getAttribute('alt');\n      return altText ? `${altText} ${label}` : label;\n    };\n\n    return toWidget(viewElement, writer, {\n      label: labelCreator\n    });\n  }\n  /**\n   * Checks if a given view element is an image widget.\n   *\n   * @protected\n   * @param {module:engine/view/element~Element} viewElement\n   * @returns {Boolean}\n   */\n\n\n  isImageWidget(viewElement) {\n    return !!viewElement.getCustomProperty('image') && isWidget(viewElement);\n  }\n  /**\n   * Checks if the provided model element is an `image`.\n   *\n   * @param {module:engine/model/element~Element} modelElement\n   * @returns {Boolean}\n   */\n\n\n  isBlockImage(modelElement) {\n    return !!modelElement && modelElement.is('element', 'imageBlock');\n  }\n  /**\n   * Checks if the provided model element is an `imageInline`.\n   *\n   * @param {module:engine/model/element~Element} modelElement\n   * @returns {Boolean}\n   */\n\n\n  isInlineImage(modelElement) {\n    return !!modelElement && modelElement.is('element', 'imageInline');\n  }\n  /**\n   * Get the view `<img>` from another view element, e.g. a widget (`<figure class=\"image\">`), a link (`<a>`).\n   *\n   * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.\n   *\n   * @param {module:engine/view/element~Element} figureView\n   * @returns {module:engine/view/element~Element}\n   */\n\n\n  findViewImgElement(figureView) {\n    if (this.isInlineImageView(figureView)) {\n      return figureView;\n    }\n\n    const editingView = this.editor.editing.view;\n\n    for (const {\n      item\n    } of editingView.createRangeIn(figureView)) {\n      if (this.isInlineImageView(item)) {\n        return item;\n      }\n    }\n  }\n\n} // Checks if image is allowed by schema in optimal insertion parent.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selection} selection\n// @returns {Boolean}\n\nfunction isImageAllowedInParent(editor, selection) {\n  const imageType = determineImageTypeForInsertion(editor, selection);\n\n  if (imageType == 'imageBlock') {\n    const parent = getInsertImageParent(selection, editor.model);\n\n    if (editor.model.schema.checkChild(parent, 'imageBlock')) {\n      return true;\n    }\n  } else if (editor.model.schema.checkChild(selection.focus, 'imageInline')) {\n    return true;\n  }\n\n  return false;\n} // Checks if selection is not placed inside an image (e.g. its caption).\n//\n// @private\n// @param {module:engine/model/selection~Selectable} selection\n// @returns {Boolean}\n\n\nfunction isNotInsideImage(selection) {\n  return [...selection.focus.getAncestors()].every(ancestor => !ancestor.is('element', 'imageBlock'));\n} // Returns a node that will be used to insert image with `model.insertContent`.\n//\n// @private\n// @param {module:engine/model/selection~Selection} selection\n// @param {module:engine/model/model~Model} model\n// @returns {module:engine/model/element~Element}\n\n\nfunction getInsertImageParent(selection, model) {\n  const insertionRange = findOptimalInsertionRange(selection, model);\n  const parent = insertionRange.start.parent;\n\n  if (parent.isEmpty && !parent.is('element', '$root')) {\n    return parent.parent;\n  }\n\n  return parent;\n} // Determine image element type name depending on editor config or place of insertion.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selectable} selectable\n// @param {'imageBlock'|'imageInline'} [imageType] Image element type name. Used to force return of provided element name,\n// but only if there is proper plugin enabled.\n// @returns {'imageBlock'|'imageInline'} imageType\n\n\nfunction determineImageTypeForInsertion(editor, selectable, imageType) {\n  const schema = editor.model.schema;\n  const configImageInsertType = editor.config.get('image.insert.type');\n\n  if (!editor.plugins.has('ImageBlockEditing')) {\n    return 'imageInline';\n  }\n\n  if (!editor.plugins.has('ImageInlineEditing')) {\n    return 'imageBlock';\n  }\n\n  if (imageType) {\n    return imageType;\n  }\n\n  if (configImageInsertType === 'inline') {\n    return 'imageInline';\n  }\n\n  if (configImageInsertType === 'block') {\n    return 'imageBlock';\n  } // Try to replace the selected widget (e.g. another image).\n\n\n  if (selectable.is('selection')) {\n    return determineImageTypeForInsertionAtSelection(schema, selectable);\n  }\n\n  return schema.checkChild(selectable, 'imageInline') ? 'imageInline' : 'imageBlock';\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-image/src/imageutils.js"],"names":["Plugin","findOptimalInsertionRange","isWidget","toWidget","determineImageTypeForInsertionAtSelection","ImageUtils","pluginName","isImage","modelElement","isInlineImage","isBlockImage","isInlineImageView","element","is","isBlockImageView","hasClass","insertImage","attributes","selectable","imageType","editor","model","selection","document","determineImageTypeForInsertion","Object","fromEntries","getAttributes","attributeName","schema","checkAttribute","change","writer","imageElement","createElement","insertContent","parent","setSelection","getClosestSelectedImageWidget","viewElement","getSelectedElement","isImageWidget","getFirstPosition","getClosestSelectedImageElement","selectedElement","findAncestor","isImageAllowed","isImageAllowedInParent","isNotInsideImage","toImageWidget","label","setCustomProperty","labelCreator","imgElement","findViewImgElement","altText","getAttribute","getCustomProperty","figureView","editingView","editing","view","item","createRangeIn","getInsertImageParent","checkChild","focus","getAncestors","every","ancestor","insertionRange","start","isEmpty","configImageInsertType","config","get","plugins","has"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageutils\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { findOptimalInsertionRange, isWidget, toWidget } from 'ckeditor5/src/widget';\nimport { determineImageTypeForInsertionAtSelection } from './image/utils';\n\n/**\n * A set of helpers related to images.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUtils extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ImageUtils';\n\t}\n\n\t/**\n\t * Checks if the provided model element is an `image` or `imageInline`.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement\n\t * @returns {Boolean}\n\t */\n\tisImage( modelElement ) {\n\t\treturn this.isInlineImage( modelElement ) || this.isBlockImage( modelElement );\n\t}\n\n\t/**\n\t * Checks if the provided view element represents an inline image.\n\t *\n\t * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n\t *\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean}\n\t */\n\tisInlineImageView( element ) {\n\t\treturn !!element && element.is( 'element', 'img' );\n\t}\n\n\t/**\n\t * Checks if the provided view element represents a block image.\n\t *\n\t * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.\n\t *\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean}\n\t */\n\tisBlockImageView( element ) {\n\t\treturn !!element && element.is( 'element', 'figure' ) && element.hasClass( 'image' );\n\t}\n\n\t/**\n\t * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}\n\t * method.\n\t *\n\t *\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t *\n\t *\t\timageUtils.insertImage( { src: 'path/to/image.jpg' } );\n\t *\n\t * @param {Object} [attributes={}] Attributes of the inserted image.\n\t * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.\n\t * @param {module:engine/model/selection~Selectable} [selectable] Place to insert the image. If not specified,\n\t * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images\n\t * and `model.document.selection` for the inline images.\n\t *\n\t * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)\n\t * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.\n\t *\n\t * @param {'imageBlock'|'imageInline'} [imageType] Image type of inserted image. If not specified,\n\t * it will be determined automatically depending of editor config or place of the insertion.\n\t * @return {module:engine/view/element~Element|null} The inserted model image element.\n\t */\n\tinsertImage( attributes = {}, selectable = null, imageType = null ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\timageType = determineImageTypeForInsertion( editor, selectable || selection, imageType );\n\n\t\t// Mix declarative attributes with selection attributes because the new image should \"inherit\"\n\t\t// the latter for best UX. For instance, inline images inserted into existing links\n\t\t// should not split them. To do that, they need to have \"linkHref\" inherited from the selection.\n\t\tattributes = {\n\t\t\t...Object.fromEntries( selection.getAttributes() ),\n\t\t\t...attributes\n\t\t};\n\n\t\tfor ( const attributeName in attributes ) {\n\t\t\tif ( !model.schema.checkAttribute( imageType, attributeName ) ) {\n\t\t\t\tdelete attributes[ attributeName ];\n\t\t\t}\n\t\t}\n\n\t\treturn model.change( writer => {\n\t\t\tconst imageElement = writer.createElement( imageType, attributes );\n\n\t\t\t// If we want to insert a block image (for whatever reason) then we don't want to split text blocks.\n\t\t\t// This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).\n\t\t\tif ( !selectable && imageType != 'imageInline' ) {\n\t\t\t\tselectable = findOptimalInsertionRange( selection, model );\n\t\t\t}\n\n\t\t\tmodel.insertContent( imageElement, selectable );\n\n\t\t\t// Inserting an image might've failed due to schema regulations.\n\t\t\tif ( imageElement.parent ) {\n\t\t\t\twriter.setSelection( imageElement, 'on' );\n\n\t\t\t\treturn imageElement;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} );\n\t}\n\n\t/**\n\t * Returns an image widget editing view element if one is selected or is among the selection's ancestors.\n\t *\n\t * @protected\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetClosestSelectedImageWidget( selection ) {\n\t\tconst viewElement = selection.getSelectedElement();\n\n\t\tif ( viewElement && this.isImageWidget( viewElement ) ) {\n\t\t\treturn viewElement;\n\t\t}\n\n\t\tlet parent = selection.getFirstPosition().parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( parent.is( 'element' ) && this.isImageWidget( parent ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a image model element if one is selected or is among the selection's ancestors.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetClosestSelectedImageElement( selection ) {\n\t\tconst selectedElement = selection.getSelectedElement();\n\n\t\treturn this.isImage( selectedElement ) ? selectedElement : selection.getFirstPosition().findAncestor( 'imageBlock' );\n\t}\n\n\t/**\n\t * Checks if image can be inserted at current model selection.\n\t *\n\t * @protected\n\t * @returns {Boolean}\n\t */\n\tisImageAllowed() {\n\t\tconst model = this.editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\treturn isImageAllowedInParent( this.editor, selection ) && isNotInsideImage( selection );\n\t}\n\n\t/**\n\t * Converts a given {@link module:engine/view/element~Element} to an image widget:\n\t * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget\n\t * element.\n\t * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} viewElement\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n\t * @param {String} label The element's label. It will be concatenated with the image `alt` attribute if one is present.\n\t * @returns {module:engine/view/element~Element}\n\t */\n\ttoImageWidget( viewElement, writer, label ) {\n\t\twriter.setCustomProperty( 'image', true, viewElement );\n\n\t\tconst labelCreator = () => {\n\t\t\tconst imgElement = this.findViewImgElement( viewElement );\n\t\t\tconst altText = imgElement.getAttribute( 'alt' );\n\n\t\t\treturn altText ? `${ altText } ${ label }` : label;\n\t\t};\n\n\t\treturn toWidget( viewElement, writer, { label: labelCreator } );\n\t}\n\n\t/**\n\t * Checks if a given view element is an image widget.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} viewElement\n\t * @returns {Boolean}\n\t */\n\tisImageWidget( viewElement ) {\n\t\treturn !!viewElement.getCustomProperty( 'image' ) && isWidget( viewElement );\n\t}\n\n\t/**\n\t * Checks if the provided model element is an `image`.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement\n\t * @returns {Boolean}\n\t */\n\tisBlockImage( modelElement ) {\n\t\treturn !!modelElement && modelElement.is( 'element', 'imageBlock' );\n\t}\n\n\t/**\n\t * Checks if the provided model element is an `imageInline`.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement\n\t * @returns {Boolean}\n\t */\n\tisInlineImage( modelElement ) {\n\t\treturn !!modelElement && modelElement.is( 'element', 'imageInline' );\n\t}\n\n\t/**\n\t * Get the view `<img>` from another view element, e.g. a widget (`<figure class=\"image\">`), a link (`<a>`).\n\t *\n\t * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.\n\t *\n\t * @param {module:engine/view/element~Element} figureView\n\t * @returns {module:engine/view/element~Element}\n\t */\n\tfindViewImgElement( figureView ) {\n\t\tif ( this.isInlineImageView( figureView ) ) {\n\t\t\treturn figureView;\n\t\t}\n\n\t\tconst editingView = this.editor.editing.view;\n\n\t\tfor ( const { item } of editingView.createRangeIn( figureView ) ) {\n\t\t\tif ( this.isInlineImageView( item ) ) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Checks if image is allowed by schema in optimal insertion parent.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selection} selection\n// @returns {Boolean}\nfunction isImageAllowedInParent( editor, selection ) {\n\tconst imageType = determineImageTypeForInsertion( editor, selection );\n\n\tif ( imageType == 'imageBlock' ) {\n\t\tconst parent = getInsertImageParent( selection, editor.model );\n\n\t\tif ( editor.model.schema.checkChild( parent, 'imageBlock' ) ) {\n\t\t\treturn true;\n\t\t}\n\t} else if ( editor.model.schema.checkChild( selection.focus, 'imageInline' ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// Checks if selection is not placed inside an image (e.g. its caption).\n//\n// @private\n// @param {module:engine/model/selection~Selectable} selection\n// @returns {Boolean}\nfunction isNotInsideImage( selection ) {\n\treturn [ ...selection.focus.getAncestors() ].every( ancestor => !ancestor.is( 'element', 'imageBlock' ) );\n}\n\n// Returns a node that will be used to insert image with `model.insertContent`.\n//\n// @private\n// @param {module:engine/model/selection~Selection} selection\n// @param {module:engine/model/model~Model} model\n// @returns {module:engine/model/element~Element}\nfunction getInsertImageParent( selection, model ) {\n\tconst insertionRange = findOptimalInsertionRange( selection, model );\n\tconst parent = insertionRange.start.parent;\n\n\tif ( parent.isEmpty && !parent.is( 'element', '$root' ) ) {\n\t\treturn parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Determine image element type name depending on editor config or place of insertion.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/selection~Selectable} selectable\n// @param {'imageBlock'|'imageInline'} [imageType] Image element type name. Used to force return of provided element name,\n// but only if there is proper plugin enabled.\n// @returns {'imageBlock'|'imageInline'} imageType\nfunction determineImageTypeForInsertion( editor, selectable, imageType ) {\n\tconst schema = editor.model.schema;\n\tconst configImageInsertType = editor.config.get( 'image.insert.type' );\n\n\tif ( !editor.plugins.has( 'ImageBlockEditing' ) ) {\n\t\treturn 'imageInline';\n\t}\n\n\tif ( !editor.plugins.has( 'ImageInlineEditing' ) ) {\n\t\treturn 'imageBlock';\n\t}\n\n\tif ( imageType ) {\n\t\treturn imageType;\n\t}\n\n\tif ( configImageInsertType === 'inline' ) {\n\t\treturn 'imageInline';\n\t}\n\n\tif ( configImageInsertType === 'block' ) {\n\t\treturn 'imageBlock';\n\t}\n\n\t// Try to replace the selected widget (e.g. another image).\n\tif ( selectable.is( 'selection' ) ) {\n\t\treturn determineImageTypeForInsertionAtSelection( schema, selectable );\n\t}\n\n\treturn schema.checkChild( selectable, 'imageInline' ) ? 'imageInline' : 'imageBlock';\n}\n"]},"metadata":{},"sourceType":"module"}