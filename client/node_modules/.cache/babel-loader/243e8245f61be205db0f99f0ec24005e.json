{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Upcast dispatcher is a central point of the view-to-model conversion, which is a process of\n * converting a given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element view element} into a correct model structure.\n *\n * During the conversion process, the dispatcher fires events for all {@link module:engine/view/node~Node view nodes}\n * from the converted view document fragment.\n * Special callbacks called \"converters\" should listen to these events in order to convert the view nodes.\n *\n * The second parameter of the callback is the `data` object with the following properties:\n *\n * * `data.viewItem` contains a {@link module:engine/view/node~Node view node} or a\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback.\n * * `data.modelRange` is used to point to the result\n * of the current conversion (e.g. the element that is being inserted)\n * and is always a {@link module:engine/model/range~Range} when the conversion succeeds.\n * * `data.modelCursor` is a {@link module:engine/model/position~Position position} on which the converter should insert\n * the newly created items.\n *\n * The third parameter of the callback is an instance of {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n * which provides additional tools for converters.\n *\n * You can read more about conversion in the following guides:\n *\n * * {@glink framework/guides/deep-dive/conversion/conversion-introduction Advanced conversion concepts &mdash; attributes}\n * * {@glink framework/guides/deep-dive/conversion/custom-element-conversion Custom element conversion}\n *\n * Examples of event-based converters:\n *\n *\t\t// A converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// The <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why you need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p> element's font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it is executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Do not go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into a paragraph (autoparagraphing).\n *\t\teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *\t\t\t// Check if an element can be converted.\n *\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *\t\t\t\t// When an element is already consumed by higher priority converters, do nothing.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *\t\t\t// Try to safely insert a paragraph at the model cursor - it will find an allowed parent for the current element.\n *\t\t\tif ( !conversionApi.safeInsert( paragraph, data.modelCursor ) ) {\n *\t\t\t\t// When an element was not inserted, it means that you cannot insert a paragraph at this position.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Consume the inserted element.\n *\t\t\tconversionApi.consumable.consume( data.viewItem, { name: data.viewItem.name } ) );\n *\n *\t\t\t// Convert the children to a paragraph.\n *\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem,  paragraph ) );\n *\n *\t\t\t// Update `modelRange` and `modelCursor` in the `data` as a conversion result.\n *\t\t\tconversionApi.updateConversionResult( paragraph, data );\n *\t\t}, { priority: 'low' } );\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\n\nexport default class UpcastDispatcher {\n  /**\n   * Creates an upcast dispatcher that operates using the passed API.\n   *\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n   * @param {Object} [conversionApi] Additional properties for an interface that will be passed to events fired\n   * by the upcast dispatcher.\n   */\n  constructor() {\n    let conversionApi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\n     * The list of elements that were created during splitting.\n     *\n     * After the conversion process the list is cleared.\n     *\n     * @private\n     * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n     */\n    this._splitParts = new Map();\n    /**\n     * The list of cursor parent elements that were created during splitting.\n     *\n     * After the conversion process the list is cleared.\n     *\n     * @private\n     * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n     */\n\n    this._cursorParents = new Map();\n    /**\n     * The position in the temporary structure where the converted content is inserted. The structure reflects the context of\n     * the target position where the content will be inserted. This property is built based on the context parameter of the\n     * convert method.\n     *\n     * @private\n     * @type {module:engine/model/position~Position|null}\n     */\n\n    this._modelCursor = null;\n    /**\n     * An interface passed by the dispatcher to the event callbacks.\n     *\n     * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n     */\n\n    this.conversionApi = Object.assign({}, conversionApi); // The below methods are bound to this `UpcastDispatcher` instance and set on `conversionApi`.\n    // This way only a part of `UpcastDispatcher` API is exposed.\n\n    this.conversionApi.convertItem = this._convertItem.bind(this);\n    this.conversionApi.convertChildren = this._convertChildren.bind(this);\n    this.conversionApi.safeInsert = this._safeInsert.bind(this);\n    this.conversionApi.updateConversionResult = this._updateConversionResult.bind(this); // Advanced API - use only if custom position handling is needed.\n\n    this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);\n    this.conversionApi.getSplitParts = this._getSplitParts.bind(this);\n  }\n  /**\n   * Starts the conversion process. The entry point for the conversion.\n   *\n   * @fires element\n   * @fires text\n   * @fires documentFragment\n   * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n   * The part of the view to be converted.\n   * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is the result of the conversion process\n   * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   */\n\n\n  convert(viewItem, writer) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['$root'];\n    this.fire('viewCleanup', viewItem); // Create context tree and set position in the top element.\n    // Items will be converted according to this position.\n\n    this._modelCursor = createContextTree(context, writer); // Store writer in conversion as a conversion API\n    // to be sure that conversion process will use the same batch.\n\n    this.conversionApi.writer = writer; // Create consumable values list for conversion process.\n\n    this.conversionApi.consumable = ViewConsumable.createFrom(viewItem); // Custom data stored by converter for conversion process.\n\n    this.conversionApi.store = {}; // Do the conversion.\n\n    const {\n      modelRange\n    } = this._convertItem(viewItem, this._modelCursor); // Conversion result is always a document fragment so let's create it.\n\n\n    const documentFragment = writer.createDocumentFragment(); // When there is a conversion result.\n\n    if (modelRange) {\n      // Remove all empty elements that were create while splitting.\n      this._removeEmptyElements(); // Move all items that were converted in context tree to the document fragment.\n\n\n      for (const item of Array.from(this._modelCursor.parent.getChildren())) {\n        writer.append(item, documentFragment);\n      } // Extract temporary markers elements from model and set as static markers collection.\n\n\n      documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);\n    } // Clear context position.\n\n\n    this._modelCursor = null; // Clear split elements & parents lists.\n\n    this._splitParts.clear();\n\n    this._cursorParents.clear(); // Clear conversion API.\n\n\n    this.conversionApi.writer = null;\n    this.conversionApi.store = null; // Return fragment as conversion result.\n\n    return documentFragment;\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n   */\n\n\n  _convertItem(viewItem, modelCursor) {\n    const data = Object.assign({\n      viewItem,\n      modelCursor,\n      modelRange: null\n    });\n\n    if (viewItem.is('element')) {\n      this.fire('element:' + viewItem.name, data, this.conversionApi);\n    } else if (viewItem.is('$text')) {\n      this.fire('text', data, this.conversionApi);\n    } else {\n      this.fire('documentFragment', data, this.conversionApi);\n    } // Handle incorrect conversion result.\n\n\n    if (data.modelRange && !(data.modelRange instanceof ModelRange)) {\n      /**\n       * Incorrect conversion result was dropped.\n       *\n       * {@link module:engine/model/range~Range Model range} should be a conversion result.\n       *\n       * @error view-conversion-dispatcher-incorrect-result\n       */\n      throw new CKEditorError('view-conversion-dispatcher-incorrect-result', this);\n    }\n\n    return {\n      modelRange: data.modelRange,\n      modelCursor: data.modelCursor\n    };\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n   */\n\n\n  _convertChildren(viewItem, elementOrModelCursor) {\n    let nextModelCursor = elementOrModelCursor.is('position') ? elementOrModelCursor : ModelPosition._createAt(elementOrModelCursor, 0);\n    const modelRange = new ModelRange(nextModelCursor);\n\n    for (const viewChild of Array.from(viewItem.getChildren())) {\n      const result = this._convertItem(viewChild, nextModelCursor);\n\n      if (result.modelRange instanceof ModelRange) {\n        modelRange.end = result.modelRange.end;\n        nextModelCursor = result.modelCursor;\n      }\n    }\n\n    return {\n      modelRange,\n      modelCursor: nextModelCursor\n    };\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert\n   */\n\n\n  _safeInsert(modelElement, position) {\n    // Find allowed parent for element that we are going to insert.\n    // If current parent does not allow to insert element but one of the ancestors does\n    // then split nodes to allowed parent.\n    const splitResult = this._splitToAllowedParent(modelElement, position); // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\n\n    if (!splitResult) {\n      return false;\n    } // Insert element on allowed position.\n\n\n    this.conversionApi.writer.insert(modelElement, splitResult.position);\n    return true;\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult\n   */\n\n\n  _updateConversionResult(modelElement, data) {\n    const parts = this._getSplitParts(modelElement);\n\n    const writer = this.conversionApi.writer; // Set conversion result range - only if not set already.\n\n    if (!data.modelRange) {\n      data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));\n    }\n\n    const savedCursorParent = this._cursorParents.get(modelElement); // Now we need to check where the `modelCursor` should be.\n\n\n    if (savedCursorParent) {\n      // If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n      //\n      // before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n      // after:  <allowed><notAllowed>foo</notAllowed> <converted></converted> <notAllowed>[]</notAllowed></allowed>\n      data.modelCursor = writer.createPositionAt(savedCursorParent, 0);\n    } else {\n      // Otherwise just continue after inserted element.\n      data.modelCursor = data.modelRange.end;\n    }\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n   */\n\n\n  _splitToAllowedParent(node, modelCursor) {\n    const {\n      schema,\n      writer\n    } = this.conversionApi; // Try to find allowed parent.\n\n    let allowedParent = schema.findAllowedParent(modelCursor, node);\n\n    if (allowedParent) {\n      // When current position parent allows to insert node then return this position.\n      if (allowedParent === modelCursor.parent) {\n        return {\n          position: modelCursor\n        };\n      } // When allowed parent is in context tree (it's outside the converted tree).\n\n\n      if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {\n        allowedParent = null;\n      }\n    }\n\n    if (!allowedParent) {\n      // Check if the node wrapped with a paragraph would be accepted by the schema.\n      if (!isParagraphable(modelCursor, node, schema)) {\n        return null;\n      }\n\n      return {\n        position: wrapInParagraph(modelCursor, writer)\n      };\n    } // Split element to allowed parent.\n\n\n    const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent); // Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n    //\n    // The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n    // that got split) to the beginning of the other part of that element:\n    //\n    // <limit><a><b><c>X[]Y</c></b><a></limit> ->\n    // <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n    //\n    // After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n    // Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n    // Also, since we split all those elements, each of them has to have the other part.\n    //\n    // With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n    // them with \"opening tags\" in the reverse order. For that we can use a stack.\n\n    const stack = [];\n\n    for (const treeWalkerValue of splitResult.range.getWalker()) {\n      if (treeWalkerValue.type == 'elementEnd') {\n        stack.push(treeWalkerValue.item);\n      } else {\n        // There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n        const originalPart = stack.pop();\n        const splitPart = treeWalkerValue.item;\n\n        this._registerSplitPair(originalPart, splitPart);\n      }\n    }\n\n    const cursorParent = splitResult.range.end.parent;\n\n    this._cursorParents.set(node, cursorParent);\n\n    return {\n      position: splitResult.position,\n      cursorParent\n    };\n  }\n  /**\n   * Registers that a `splitPart` element is a split part of the `originalPart` element.\n   *\n   * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} originalPart\n   * @param {module:engine/model/element~Element} splitPart\n   */\n\n\n  _registerSplitPair(originalPart, splitPart) {\n    if (!this._splitParts.has(originalPart)) {\n      this._splitParts.set(originalPart, [originalPart]);\n    }\n\n    const list = this._splitParts.get(originalPart);\n\n    this._splitParts.set(splitPart, list);\n\n    list.push(splitPart);\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n   */\n\n\n  _getSplitParts(element) {\n    let parts;\n\n    if (!this._splitParts.has(element)) {\n      parts = [element];\n    } else {\n      parts = this._splitParts.get(element);\n    }\n\n    return parts;\n  }\n  /**\n   * Checks if there are any empty elements created while splitting and removes them.\n   *\n   * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n   * as some elements might have become empty after other empty elements were removed from them.\n   *\n   * @private\n   */\n\n\n  _removeEmptyElements() {\n    let anyRemoved = false;\n\n    for (const element of this._splitParts.keys()) {\n      if (element.isEmpty) {\n        this.conversionApi.writer.remove(element);\n\n        this._splitParts.delete(element);\n\n        anyRemoved = true;\n      }\n    }\n\n    if (anyRemoved) {\n      this._removeEmptyElements();\n    }\n  }\n  /**\n   * Fired before the first conversion event, at the beginning of the upcast (view-to-model conversion) process.\n   *\n   * @event viewCleanup\n   * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n   * viewItem A part of the view to be converted.\n   */\n\n  /**\n   * Fired when an {@link module:engine/view/element~Element} is converted.\n   *\n   * `element` is a namespace event for a class of events. Names of actually called events follow the pattern of\n   * `element:<elementName>` where `elementName` is the name of the converted element. This way listeners may listen to\n   * a conversion of all or just specific elements.\n   *\n   * @event element\n   * @param {module:engine/conversion/upcastdispatcher~UpcastConversionData} data The conversion data. Keep in mind that this object is\n   * shared by reference between all callbacks that will be called. This means that callbacks can override values if needed, and these\n   * values will be available in other callbacks.\n   * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by the\n   * callback.\n   */\n\n  /**\n   * Fired when a {@link module:engine/view/text~Text} is converted.\n   *\n   * @event text\n   * @see #event:element\n   */\n\n  /**\n   * Fired when a {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n   *\n   * @event documentFragment\n   * @see #event:element\n   */\n\n\n}\nmix(UpcastDispatcher, EmitterMixin); // Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\n\nfunction extractMarkersFromModelFragment(modelItem, writer) {\n  const markerElements = new Set();\n  const markers = new Map(); // Create ModelTreeWalker.\n\n  const range = ModelRange._createIn(modelItem).getItems(); // Walk through DocumentFragment and collect marker elements.\n\n\n  for (const item of range) {\n    // Check if current element is a marker.\n    if (item.name == '$marker') {\n      markerElements.add(item);\n    }\n  } // Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\n\n  for (const markerElement of markerElements) {\n    const markerName = markerElement.getAttribute('data-name');\n    const currentPosition = writer.createPositionBefore(markerElement); // When marker of given name is not stored it means that we have found the beginning of the range.\n\n    if (!markers.has(markerName)) {\n      markers.set(markerName, new ModelRange(currentPosition.clone())); // Otherwise is means that we have found end of the marker range.\n    } else {\n      markers.get(markerName).end = currentPosition.clone();\n    } // Remove marker element from DocumentFragment.\n\n\n    writer.remove(markerElement);\n  }\n\n  return markers;\n} // Creates model fragment according to given context and returns position in the bottom (the deepest) element.\n\n\nfunction createContextTree(contextDefinition, writer) {\n  let position;\n\n  for (const item of new SchemaContext(contextDefinition)) {\n    const attributes = {};\n\n    for (const key of item.getAttributeKeys()) {\n      attributes[key] = item.getAttribute(key);\n    }\n\n    const current = writer.createElement(item.name, attributes);\n\n    if (position) {\n      writer.append(current, position);\n    }\n\n    position = ModelPosition._createAt(current, 0);\n  }\n\n  return position;\n}\n/**\n * A set of conversion utilities available as the third parameter of the\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher upcast dispatcher}'s events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts the conversion of a given item by firing an appropriate event.\n *\n * Every fired event is passed (as the first parameter) an object with the `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of the `modelRange` property is returned by this method.\n * The `modelRange` must be a {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor The conversion position.\n * @returns {Object} result The conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange The model range containing the result of the item conversion,\n * created and modified by callbacks attached to the fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor The position where the conversion should be continued.\n */\n\n/**\n * Starts the conversion of all children of a given item by firing appropriate events for all the children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem An element whose children should be converted.\n * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrElement A position or an element of\n * the conversion.\n * @returns {Object} result The conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange The model range containing the results of the conversion of all children\n * of the given item. When no child was converted, the range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor The position where the conversion should be continued.\n */\n\n/**\n * Safely inserts an element to the document, checking the {@link module:engine/model/schema~Schema schema} to find an allowed parent for\n * an element that you are going to insert, starting from the given position. If the current parent does not allow to insert the element\n * but one of the ancestors does, then splits the nodes to allowed parent.\n *\n * If the schema allows to insert the node in a given position, nothing is split.\n *\n * If it was not possible to find an allowed parent, `false` is returned and nothing is split.\n *\n * Otherwise, ancestors are split.\n *\n * For instance, if `<imageBlock>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *\t\t-> safe insert for `<imageBlock>` will split ->\n *\n *\t\t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * Example usage:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\tif ( !conversionApi.safeInsert( myElement, data.modelCursor ) ) {\n *\t\t\treturn;\n *\t\t}\n *\n * The split result is saved and {@link #updateConversionResult} should be used to update the\n * {@link module:engine/conversion/upcastdispatcher~UpcastConversionData conversion data}.\n *\n * @method #safeInsert\n * @param {module:engine/model/node~Node} node The node to insert.\n * @param {module:engine/model/position~Position} position The position where an element is going to be inserted.\n * @returns {Boolean} The split result. If it was not possible to find an allowed position, `false` is returned.\n */\n\n/**\n * Updates the conversion result and sets a proper {@link module:engine/conversion/upcastdispatcher~UpcastConversionData#modelRange} and\n * the next {@link module:engine/conversion/upcastdispatcher~UpcastConversionData#modelCursor} after the conversion.\n * Used together with {@link #safeInsert}, it enables you to easily convert elements without worrying if the node was split\n * during the conversion of its children.\n *\n * A usage example in converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\tif ( !conversionApi.safeInsert( myElement, data.modelCursor ) ) {\n *\t\t\treturn;\n *\t\t}\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( data.viewItem, myElement );\n *\n *\t\tconversionApi.updateConversionResult( myElement, data );\n *\n * @method #updateConversionResult\n * @param {module:engine/model/element~Element} element\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionData} data Conversion data.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by the callback.\n */\n\n/**\n * Checks the {@link module:engine/model/schema~Schema schema} to find an allowed parent for an element that is going to be inserted\n * starting from the given position. If the current parent does not allow inserting an element but one of the ancestors does, the method\n * splits nodes to allowed parent.\n *\n * If the schema allows inserting the node in the given position, nothing is split and an object with that position is returned.\n *\n * If it was not possible to find an allowed parent, `null` is returned and nothing is split.\n *\n * Otherwise, ancestors are split and an object with a position and the copy of the split element is returned.\n *\n * For instance, if `<imageBlock>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *\t\t-> split for `<imageBlock>` ->\n *\n *\t\t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the example above, the position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * **Note:** This is an advanced method. For most cases {@link #safeInsert} and {@link #updateConversionResult} should be used.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position The position where the element is going to be inserted.\n * @param {module:engine/model/node~Node} node The node to insert.\n * @returns {Object|null} The split result. If it was not possible to find an allowed position, `null` is returned.\n * @returns {module:engine/model/position~Position} The position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] The element inside which the cursor should be placed to\n * continue the conversion. When the element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of the given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track these elements and continue processing them after they are split during the conversion of their children.\n *\n *\t\t<paragraph>Foo<imageBlock />bar<imageBlock />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><imageBlock /><paragraph>bar</paragraph><imageBlock /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If the given `element` was not split, an array with a single element is returned.\n *\n * A usage example in the converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** If you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it has already been converted, you may want to check the first element in `data.modelRange`. This is a common\n * situation if an attribute converter is separated from an element converter.\n *\n * **Note:** This is an advanced method. For most cases {@link #safeInsert} and {@link #updateConversionResult} should be used.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of the processed view item are still waiting to be handled. After a piece of view item\n * was converted, an appropriate consumable value should be\n * {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for the conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and the `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that the `data` parameters allow you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */\n\n/**\n * Conversion data.\n *\n * **Note:** Keep in mind that this object is shared by reference between all conversion callbacks that will be called.\n * This means that callbacks can override values if needed, and these values will be available in other callbacks.\n *\n * @typedef {Object} module:engine/conversion/upcastdispatcher~UpcastConversionData\n *\n * @property {module:engine/view/item~Item} viewItem The converted item.\n * @property {module:engine/model/position~Position} modelCursor The position where the converter should start changes.\n * Change this value for the next converter to tell where the conversion should continue.\n * @property {module:engine/model/range~Range} [modelRange] The current state of conversion result. Every change to\n * the converted element should be reflected by setting or modifying this property.\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js"],"names":["ViewConsumable","ModelRange","ModelPosition","SchemaContext","isParagraphable","wrapInParagraph","CKEditorError","EmitterMixin","mix","UpcastDispatcher","constructor","conversionApi","_splitParts","Map","_cursorParents","_modelCursor","Object","assign","convertItem","_convertItem","bind","convertChildren","_convertChildren","safeInsert","_safeInsert","updateConversionResult","_updateConversionResult","splitToAllowedParent","_splitToAllowedParent","getSplitParts","_getSplitParts","convert","viewItem","writer","context","fire","createContextTree","consumable","createFrom","store","modelRange","documentFragment","createDocumentFragment","_removeEmptyElements","item","Array","from","parent","getChildren","append","markers","extractMarkersFromModelFragment","clear","modelCursor","data","is","name","elementOrModelCursor","nextModelCursor","_createAt","viewChild","result","end","modelElement","position","splitResult","insert","parts","createRange","createPositionBefore","createPositionAfter","length","savedCursorParent","get","createPositionAt","node","schema","allowedParent","findAllowedParent","getAncestors","includes","split","stack","treeWalkerValue","range","getWalker","type","push","originalPart","pop","splitPart","_registerSplitPair","cursorParent","set","has","list","element","anyRemoved","keys","isEmpty","remove","delete","modelItem","markerElements","Set","_createIn","getItems","add","markerElement","markerName","getAttribute","currentPosition","clone","contextDefinition","attributes","key","getAttributeKeys","current","createElement"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,OAAOC,UAAP,MAAuB,gBAAvB;AACA,OAAOC,aAAP,MAA0B,mBAA1B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,eAAT,EAA0BC,eAA1B,QAAiD,iCAAjD;AAEA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,gBAAN,CAAuB;AACrC;AACD;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,GAAuB;AAAA,QAArBC,aAAqB,uEAAL,EAAK;;AACjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,cAAL,GAAsB,IAAID,GAAJ,EAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKE,YAAL,GAAoB,IAApB;AAEA;AACF;AACA;AACA;AACA;;AACE,SAAKJ,aAAL,GAAqBK,MAAM,CAACC,MAAP,CAAe,EAAf,EAAmBN,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B;AACf/B,MAAAA,MAAM,CAACgB,MAAP,CAAeoE,OAAf,EAAwBrD,QAAxB;AACA;;AAEDA,IAAAA,QAAQ,GAAG9D,aAAa,CAACyD,SAAd,CAAyB0D,OAAzB,EAAkC,CAAlC,CAAX;AACA;;AAED,SAAOrD,QAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\n\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Upcast dispatcher is a central point of the view-to-model conversion, which is a process of\n * converting a given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element view element} into a correct model structure.\n *\n * During the conversion process, the dispatcher fires events for all {@link module:engine/view/node~Node view nodes}\n * from the converted view document fragment.\n * Special callbacks called \"converters\" should listen to these events in order to convert the view nodes.\n *\n * The second parameter of the callback is the `data` object with the following properties:\n *\n * * `data.viewItem` contains a {@link module:engine/view/node~Node view node} or a\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback.\n * * `data.modelRange` is used to point to the result\n * of the current conversion (e.g. the element that is being inserted)\n * and is always a {@link module:engine/model/range~Range} when the conversion succeeds.\n * * `data.modelCursor` is a {@link module:engine/model/position~Position position} on which the converter should insert\n * the newly created items.\n *\n * The third parameter of the callback is an instance of {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n * which provides additional tools for converters.\n *\n * You can read more about conversion in the following guides:\n *\n * * {@glink framework/guides/deep-dive/conversion/conversion-introduction Advanced conversion concepts &mdash; attributes}\n * * {@glink framework/guides/deep-dive/conversion/custom-element-conversion Custom element conversion}\n *\n * Examples of event-based converters:\n *\n *\t\t// A converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// The <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why you need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p> element's font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it is executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Do not go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into a paragraph (autoparagraphing).\n *\t\teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *\t\t\t// Check if an element can be converted.\n *\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *\t\t\t\t// When an element is already consumed by higher priority converters, do nothing.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *\t\t\t// Try to safely insert a paragraph at the model cursor - it will find an allowed parent for the current element.\n *\t\t\tif ( !conversionApi.safeInsert( paragraph, data.modelCursor ) ) {\n *\t\t\t\t// When an element was not inserted, it means that you cannot insert a paragraph at this position.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Consume the inserted element.\n *\t\t\tconversionApi.consumable.consume( data.viewItem, { name: data.viewItem.name } ) );\n *\n *\t\t\t// Convert the children to a paragraph.\n *\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem,  paragraph ) );\n *\n *\t\t\t// Update `modelRange` and `modelCursor` in the `data` as a conversion result.\n *\t\t\tconversionApi.updateConversionResult( paragraph, data );\n *\t\t}, { priority: 'low' } );\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher {\n\t/**\n\t * Creates an upcast dispatcher that operates using the passed API.\n\t *\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n\t * @param {Object} [conversionApi] Additional properties for an interface that will be passed to events fired\n\t * by the upcast dispatcher.\n\t */\n\tconstructor( conversionApi = {} ) {\n\t\t/**\n\t\t * The list of elements that were created during splitting.\n\t\t *\n\t\t * After the conversion process the list is cleared.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n\t\t */\n\t\tthis._splitParts = new Map();\n\n\t\t/**\n\t\t * The list of cursor parent elements that were created during splitting.\n\t\t *\n\t\t * After the conversion process the list is cleared.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n\t\t */\n\t\tthis._cursorParents = new Map();\n\n\t\t/**\n\t\t * The position in the temporary structure where the converted content is inserted. The structure reflects the context of\n\t\t * the target position where the content will be inserted. This property is built based on the context parameter of the\n\t\t * convert method.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position|null}\n\t\t */\n\t\tthis._modelCursor = null;\n\n\t\t/**\n\t\t * An interface passed by the dispatcher to the event callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n\t\t */\n\t\tthis.conversionApi = Object.assign( {}, conversionApi );\n\n\t\t// The below methods are bound to this `UpcastDispatcher` instance and set on `conversionApi`.\n\t\t// This way only a part of `UpcastDispatcher` API is exposed.\n\t\tthis.conversionApi.convertItem = this._convertItem.bind( this );\n\t\tthis.conversionApi.convertChildren = this._convertChildren.bind( this );\n\t\tthis.conversionApi.safeInsert = this._safeInsert.bind( this );\n\t\tthis.conversionApi.updateConversionResult = this._updateConversionResult.bind( this );\n\t\t// Advanced API - use only if custom position handling is needed.\n\t\tthis.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind( this );\n\t\tthis.conversionApi.getSplitParts = this._getSplitParts.bind( this );\n\t}\n\n\t/**\n\t * Starts the conversion process. The entry point for the conversion.\n\t *\n\t * @fires element\n\t * @fires text\n\t * @fires documentFragment\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n\t * The part of the view to be converted.\n\t * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is the result of the conversion process\n\t * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t */\n\tconvert( viewItem, writer, context = [ '$root' ] ) {\n\t\tthis.fire( 'viewCleanup', viewItem );\n\n\t\t// Create context tree and set position in the top element.\n\t\t// Items will be converted according to this position.\n\t\tthis._modelCursor = createContextTree( context, writer );\n\n\t\t// Store writer in conversion as a conversion API\n\t\t// to be sure that conversion process will use the same batch.\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create consumable values list for conversion process.\n\t\tthis.conversionApi.consumable = ViewConsumable.createFrom( viewItem );\n\n\t\t// Custom data stored by converter for conversion process.\n\t\tthis.conversionApi.store = {};\n\n\t\t// Do the conversion.\n\t\tconst { modelRange } = this._convertItem( viewItem, this._modelCursor );\n\n\t\t// Conversion result is always a document fragment so let's create it.\n\t\tconst documentFragment = writer.createDocumentFragment();\n\n\t\t// When there is a conversion result.\n\t\tif ( modelRange ) {\n\t\t\t// Remove all empty elements that were create while splitting.\n\t\t\tthis._removeEmptyElements();\n\n\t\t\t// Move all items that were converted in context tree to the document fragment.\n\t\t\tfor ( const item of Array.from( this._modelCursor.parent.getChildren() ) ) {\n\t\t\t\twriter.append( item, documentFragment );\n\t\t\t}\n\n\t\t\t// Extract temporary markers elements from model and set as static markers collection.\n\t\t\tdocumentFragment.markers = extractMarkersFromModelFragment( documentFragment, writer );\n\t\t}\n\n\t\t// Clear context position.\n\t\tthis._modelCursor = null;\n\n\t\t// Clear split elements & parents lists.\n\t\tthis._splitParts.clear();\n\t\tthis._cursorParents.clear();\n\n\t\t// Clear conversion API.\n\t\tthis.conversionApi.writer = null;\n\t\tthis.conversionApi.store = null;\n\n\t\t// Return fragment as conversion result.\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n\t */\n\t_convertItem( viewItem, modelCursor ) {\n\t\tconst data = Object.assign( { viewItem, modelCursor, modelRange: null } );\n\n\t\tif ( viewItem.is( 'element' ) ) {\n\t\t\tthis.fire( 'element:' + viewItem.name, data, this.conversionApi );\n\t\t} else if ( viewItem.is( '$text' ) ) {\n\t\t\tthis.fire( 'text', data, this.conversionApi );\n\t\t} else {\n\t\t\tthis.fire( 'documentFragment', data, this.conversionApi );\n\t\t}\n\n\t\t// Handle incorrect conversion result.\n\t\tif ( data.modelRange && !( data.modelRange instanceof ModelRange ) ) {\n\t\t\t/**\n\t\t\t * Incorrect conversion result was dropped.\n\t\t\t *\n\t\t\t * {@link module:engine/model/range~Range Model range} should be a conversion result.\n\t\t\t *\n\t\t\t * @error view-conversion-dispatcher-incorrect-result\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-conversion-dispatcher-incorrect-result', this );\n\t\t}\n\n\t\treturn { modelRange: data.modelRange, modelCursor: data.modelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n\t */\n\t_convertChildren( viewItem, elementOrModelCursor ) {\n\t\tlet nextModelCursor = elementOrModelCursor.is( 'position' ) ?\n\t\t\telementOrModelCursor : ModelPosition._createAt( elementOrModelCursor, 0 );\n\n\t\tconst modelRange = new ModelRange( nextModelCursor );\n\n\t\tfor ( const viewChild of Array.from( viewItem.getChildren() ) ) {\n\t\t\tconst result = this._convertItem( viewChild, nextModelCursor );\n\n\t\t\tif ( result.modelRange instanceof ModelRange ) {\n\t\t\t\tmodelRange.end = result.modelRange.end;\n\t\t\t\tnextModelCursor = result.modelCursor;\n\t\t\t}\n\t\t}\n\n\t\treturn { modelRange, modelCursor: nextModelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert\n\t */\n\t_safeInsert( modelElement, position ) {\n\t\t// Find allowed parent for element that we are going to insert.\n\t\t// If current parent does not allow to insert element but one of the ancestors does\n\t\t// then split nodes to allowed parent.\n\t\tconst splitResult = this._splitToAllowedParent( modelElement, position );\n\n\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\tif ( !splitResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Insert element on allowed position.\n\t\tthis.conversionApi.writer.insert( modelElement, splitResult.position );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult\n\t */\n\t_updateConversionResult( modelElement, data ) {\n\t\tconst parts = this._getSplitParts( modelElement );\n\n\t\tconst writer = this.conversionApi.writer;\n\n\t\t// Set conversion result range - only if not set already.\n\t\tif ( !data.modelRange ) {\n\t\t\tdata.modelRange = writer.createRange(\n\t\t\t\twriter.createPositionBefore( modelElement ),\n\t\t\t\twriter.createPositionAfter( parts[ parts.length - 1 ] )\n\t\t\t);\n\t\t}\n\n\t\tconst savedCursorParent = this._cursorParents.get( modelElement );\n\n\t\t// Now we need to check where the `modelCursor` should be.\n\t\tif ( savedCursorParent ) {\n\t\t\t// If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n\t\t\t//\n\t\t\t// before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n\t\t\t// after:  <allowed><notAllowed>foo</notAllowed> <converted></converted> <notAllowed>[]</notAllowed></allowed>\n\n\t\t\tdata.modelCursor = writer.createPositionAt( savedCursorParent, 0 );\n\t\t} else {\n\t\t\t// Otherwise just continue after inserted element.\n\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n\t */\n\t_splitToAllowedParent( node, modelCursor ) {\n\t\tconst { schema, writer } = this.conversionApi;\n\n\t\t// Try to find allowed parent.\n\t\tlet allowedParent = schema.findAllowedParent( modelCursor, node );\n\n\t\tif ( allowedParent ) {\n\t\t\t// When current position parent allows to insert node then return this position.\n\t\t\tif ( allowedParent === modelCursor.parent ) {\n\t\t\t\treturn { position: modelCursor };\n\t\t\t}\n\n\t\t\t// When allowed parent is in context tree (it's outside the converted tree).\n\t\t\tif ( this._modelCursor.parent.getAncestors().includes( allowedParent ) ) {\n\t\t\t\tallowedParent = null;\n\t\t\t}\n\t\t}\n\n\t\tif ( !allowedParent ) {\n\t\t\t// Check if the node wrapped with a paragraph would be accepted by the schema.\n\t\t\tif ( !isParagraphable( modelCursor, node, schema ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tposition: wrapInParagraph( modelCursor, writer )\n\t\t\t};\n\t\t}\n\n\t\t// Split element to allowed parent.\n\t\tconst splitResult = this.conversionApi.writer.split( modelCursor, allowedParent );\n\n\t\t// Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n\t\t//\n\t\t// The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n\t\t// that got split) to the beginning of the other part of that element:\n\t\t//\n\t\t// <limit><a><b><c>X[]Y</c></b><a></limit> ->\n\t\t// <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n\t\t//\n\t\t// After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n\t\t// Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n\t\t// Also, since we split all those elements, each of them has to have the other part.\n\t\t//\n\t\t// With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n\t\t// them with \"opening tags\" in the reverse order. For that we can use a stack.\n\t\tconst stack = [];\n\n\t\tfor ( const treeWalkerValue of splitResult.range.getWalker() ) {\n\t\t\tif ( treeWalkerValue.type == 'elementEnd' ) {\n\t\t\t\tstack.push( treeWalkerValue.item );\n\t\t\t} else {\n\t\t\t\t// There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n\t\t\t\tconst originalPart = stack.pop();\n\t\t\t\tconst splitPart = treeWalkerValue.item;\n\n\t\t\t\tthis._registerSplitPair( originalPart, splitPart );\n\t\t\t}\n\t\t}\n\n\t\tconst cursorParent = splitResult.range.end.parent;\n\t\tthis._cursorParents.set( node, cursorParent );\n\n\t\treturn {\n\t\t\tposition: splitResult.position,\n\t\t\tcursorParent\n\t\t};\n\t}\n\n\t/**\n\t * Registers that a `splitPart` element is a split part of the `originalPart` element.\n\t *\n\t * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} originalPart\n\t * @param {module:engine/model/element~Element} splitPart\n\t */\n\t_registerSplitPair( originalPart, splitPart ) {\n\t\tif ( !this._splitParts.has( originalPart ) ) {\n\t\t\tthis._splitParts.set( originalPart, [ originalPart ] );\n\t\t}\n\n\t\tconst list = this._splitParts.get( originalPart );\n\n\t\tthis._splitParts.set( splitPart, list );\n\t\tlist.push( splitPart );\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n\t */\n\t_getSplitParts( element ) {\n\t\tlet parts;\n\n\t\tif ( !this._splitParts.has( element ) ) {\n\t\t\tparts = [ element ];\n\t\t} else {\n\t\t\tparts = this._splitParts.get( element );\n\t\t}\n\n\t\treturn parts;\n\t}\n\n\t/**\n\t * Checks if there are any empty elements created while splitting and removes them.\n\t *\n\t * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n\t * as some elements might have become empty after other empty elements were removed from them.\n\t *\n\t * @private\n\t */\n\t_removeEmptyElements() {\n\t\tlet anyRemoved = false;\n\n\t\tfor ( const element of this._splitParts.keys() ) {\n\t\t\tif ( element.isEmpty ) {\n\t\t\t\tthis.conversionApi.writer.remove( element );\n\t\t\t\tthis._splitParts.delete( element );\n\n\t\t\t\tanyRemoved = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( anyRemoved ) {\n\t\t\tthis._removeEmptyElements();\n\t\t}\n\t}\n\n\t/**\n\t * Fired before the first conversion event, at the beginning of the upcast (view-to-model conversion) process.\n\t *\n\t * @event viewCleanup\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n\t * viewItem A part of the view to be converted.\n\t */\n\n\t/**\n\t * Fired when an {@link module:engine/view/element~Element} is converted.\n\t *\n\t * `element` is a namespace event for a class of events. Names of actually called events follow the pattern of\n\t * `element:<elementName>` where `elementName` is the name of the converted element. This way listeners may listen to\n\t * a conversion of all or just specific elements.\n\t *\n\t * @event element\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastConversionData} data The conversion data. Keep in mind that this object is\n\t * shared by reference between all callbacks that will be called. This means that callbacks can override values if needed, and these\n\t * values will be available in other callbacks.\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by the\n\t * callback.\n\t */\n\n\t/**\n\t * Fired when a {@link module:engine/view/text~Text} is converted.\n\t *\n\t * @event text\n\t * @see #event:element\n\t */\n\n\t/**\n\t * Fired when a {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n\t *\n\t * @event documentFragment\n\t * @see #event:element\n\t */\n}\n\nmix( UpcastDispatcher, EmitterMixin );\n\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment( modelItem, writer ) {\n\tconst markerElements = new Set();\n\tconst markers = new Map();\n\n\t// Create ModelTreeWalker.\n\tconst range = ModelRange._createIn( modelItem ).getItems();\n\n\t// Walk through DocumentFragment and collect marker elements.\n\tfor ( const item of range ) {\n\t\t// Check if current element is a marker.\n\t\tif ( item.name == '$marker' ) {\n\t\t\tmarkerElements.add( item );\n\t\t}\n\t}\n\n\t// Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\tfor ( const markerElement of markerElements ) {\n\t\tconst markerName = markerElement.getAttribute( 'data-name' );\n\t\tconst currentPosition = writer.createPositionBefore( markerElement );\n\n\t\t// When marker of given name is not stored it means that we have found the beginning of the range.\n\t\tif ( !markers.has( markerName ) ) {\n\t\t\tmarkers.set( markerName, new ModelRange( currentPosition.clone() ) );\n\t\t// Otherwise is means that we have found end of the marker range.\n\t\t} else {\n\t\t\tmarkers.get( markerName ).end = currentPosition.clone();\n\t\t}\n\n\t\t// Remove marker element from DocumentFragment.\n\t\twriter.remove( markerElement );\n\t}\n\n\treturn markers;\n}\n\n// Creates model fragment according to given context and returns position in the bottom (the deepest) element.\nfunction createContextTree( contextDefinition, writer ) {\n\tlet position;\n\n\tfor ( const item of new SchemaContext( contextDefinition ) ) {\n\t\tconst attributes = {};\n\n\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\tattributes[ key ] = item.getAttribute( key );\n\t\t}\n\n\t\tconst current = writer.createElement( item.name, attributes );\n\n\t\tif ( position ) {\n\t\t\twriter.append( current, position );\n\t\t}\n\n\t\tposition = ModelPosition._createAt( current, 0 );\n\t}\n\n\treturn position;\n}\n\n/**\n * A set of conversion utilities available as the third parameter of the\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher upcast dispatcher}'s events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts the conversion of a given item by firing an appropriate event.\n *\n * Every fired event is passed (as the first parameter) an object with the `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of the `modelRange` property is returned by this method.\n * The `modelRange` must be a {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor The conversion position.\n * @returns {Object} result The conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange The model range containing the result of the item conversion,\n * created and modified by callbacks attached to the fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor The position where the conversion should be continued.\n */\n\n/**\n * Starts the conversion of all children of a given item by firing appropriate events for all the children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem An element whose children should be converted.\n * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrElement A position or an element of\n * the conversion.\n * @returns {Object} result The conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange The model range containing the results of the conversion of all children\n * of the given item. When no child was converted, the range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor The position where the conversion should be continued.\n */\n\n/**\n * Safely inserts an element to the document, checking the {@link module:engine/model/schema~Schema schema} to find an allowed parent for\n * an element that you are going to insert, starting from the given position. If the current parent does not allow to insert the element\n * but one of the ancestors does, then splits the nodes to allowed parent.\n *\n * If the schema allows to insert the node in a given position, nothing is split.\n *\n * If it was not possible to find an allowed parent, `false` is returned and nothing is split.\n *\n * Otherwise, ancestors are split.\n *\n * For instance, if `<imageBlock>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *\t\t-> safe insert for `<imageBlock>` will split ->\n *\n *\t\t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * Example usage:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\tif ( !conversionApi.safeInsert( myElement, data.modelCursor ) ) {\n *\t\t\treturn;\n *\t\t}\n *\n * The split result is saved and {@link #updateConversionResult} should be used to update the\n * {@link module:engine/conversion/upcastdispatcher~UpcastConversionData conversion data}.\n *\n * @method #safeInsert\n * @param {module:engine/model/node~Node} node The node to insert.\n * @param {module:engine/model/position~Position} position The position where an element is going to be inserted.\n * @returns {Boolean} The split result. If it was not possible to find an allowed position, `false` is returned.\n */\n\n/**\n * Updates the conversion result and sets a proper {@link module:engine/conversion/upcastdispatcher~UpcastConversionData#modelRange} and\n * the next {@link module:engine/conversion/upcastdispatcher~UpcastConversionData#modelCursor} after the conversion.\n * Used together with {@link #safeInsert}, it enables you to easily convert elements without worrying if the node was split\n * during the conversion of its children.\n *\n * A usage example in converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\tif ( !conversionApi.safeInsert( myElement, data.modelCursor ) ) {\n *\t\t\treturn;\n *\t\t}\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( data.viewItem, myElement );\n *\n *\t\tconversionApi.updateConversionResult( myElement, data );\n *\n * @method #updateConversionResult\n * @param {module:engine/model/element~Element} element\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionData} data Conversion data.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by the callback.\n */\n\n/**\n * Checks the {@link module:engine/model/schema~Schema schema} to find an allowed parent for an element that is going to be inserted\n * starting from the given position. If the current parent does not allow inserting an element but one of the ancestors does, the method\n * splits nodes to allowed parent.\n *\n * If the schema allows inserting the node in the given position, nothing is split and an object with that position is returned.\n *\n * If it was not possible to find an allowed parent, `null` is returned and nothing is split.\n *\n * Otherwise, ancestors are split and an object with a position and the copy of the split element is returned.\n *\n * For instance, if `<imageBlock>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *\t\t-> split for `<imageBlock>` ->\n *\n *\t\t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the example above, the position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * **Note:** This is an advanced method. For most cases {@link #safeInsert} and {@link #updateConversionResult} should be used.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position The position where the element is going to be inserted.\n * @param {module:engine/model/node~Node} node The node to insert.\n * @returns {Object|null} The split result. If it was not possible to find an allowed position, `null` is returned.\n * @returns {module:engine/model/position~Position} The position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] The element inside which the cursor should be placed to\n * continue the conversion. When the element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of the given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track these elements and continue processing them after they are split during the conversion of their children.\n *\n *\t\t<paragraph>Foo<imageBlock />bar<imageBlock />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><imageBlock /><paragraph>bar</paragraph><imageBlock /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If the given `element` was not split, an array with a single element is returned.\n *\n * A usage example in the converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** If you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it has already been converted, you may want to check the first element in `data.modelRange`. This is a common\n * situation if an attribute converter is separated from an element converter.\n *\n * **Note:** This is an advanced method. For most cases {@link #safeInsert} and {@link #updateConversionResult} should be used.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of the processed view item are still waiting to be handled. After a piece of view item\n * was converted, an appropriate consumable value should be\n * {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for the conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and the `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that the `data` parameters allow you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */\n\n/**\n * Conversion data.\n *\n * **Note:** Keep in mind that this object is shared by reference between all conversion callbacks that will be called.\n * This means that callbacks can override values if needed, and these values will be available in other callbacks.\n *\n * @typedef {Object} module:engine/conversion/upcastdispatcher~UpcastConversionData\n *\n * @property {module:engine/view/item~Item} viewItem The converted item.\n * @property {module:engine/model/position~Position} modelCursor The position where the converter should start changes.\n * Change this value for the next converter to tell where the conversion should continue.\n * @property {module:engine/model/range~Range} [modelRange] The current state of conversion result. Every change to\n * the converted element should be reflected by setting or modifying this property.\n */\n"]},"metadata":{},"sourceType":"module"}