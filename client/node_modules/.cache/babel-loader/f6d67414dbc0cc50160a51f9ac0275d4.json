{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widgettoolbarrepository\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';\nimport ToolbarView from '@ckeditor/ckeditor5-ui/src/toolbar/toolbarview';\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\nimport { isWidget } from './utils';\nimport CKEditorError, { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Widget toolbar repository plugin. A central point for registering widget toolbars. This plugin handles the whole\n * toolbar rendering process and exposes a concise API.\n *\n * To add a toolbar for your widget use the {@link ~WidgetToolbarRepository#register `WidgetToolbarRepository#register()`} method.\n *\n * The following example comes from the {@link module:image/imagetoolbar~ImageToolbar} plugin:\n *\n * \t\tclass ImageToolbar extends Plugin {\n *\t\t\tstatic get requires() {\n *\t\t\t\treturn [ WidgetToolbarRepository ];\n *\t\t\t}\n *\n *\t\t\tafterInit() {\n *\t\t\t\tconst editor = this.editor;\n *\t\t\t\tconst widgetToolbarRepository = editor.plugins.get( WidgetToolbarRepository );\n *\n *\t\t\t\twidgetToolbarRepository.register( 'image', {\n *\t\t\t\t\titems: editor.config.get( 'image.toolbar' ),\n *\t\t\t\t\tgetRelatedElement: getClosestSelectedImageWidget\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n */\n\nexport default class WidgetToolbarRepository extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [ContextualBalloon];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get pluginName() {\n    return 'WidgetToolbarRepository';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor; // Disables the default balloon toolbar for all widgets.\n\n    if (editor.plugins.has('BalloonToolbar')) {\n      const balloonToolbar = editor.plugins.get('BalloonToolbar');\n      this.listenTo(balloonToolbar, 'show', evt => {\n        if (isWidgetSelected(editor.editing.view.document.selection)) {\n          evt.stop();\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * A map of toolbar definitions.\n     *\n     * @protected\n     * @member {Map.<String,module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition>} #_toolbarDefinitions\n     */\n\n\n    this._toolbarDefinitions = new Map();\n    /**\n     * @private\n     */\n\n    this._balloon = this.editor.plugins.get('ContextualBalloon');\n    this.on('change:isEnabled', () => {\n      this._updateToolbarsVisibility();\n    });\n    this.listenTo(editor.ui, 'update', () => {\n      this._updateToolbarsVisibility();\n    }); // UI#update is not fired after focus is back in editor, we need to check if balloon panel should be visible.\n\n    this.listenTo(editor.ui.focusTracker, 'change:isFocused', () => {\n      this._updateToolbarsVisibility();\n    }, {\n      priority: 'low'\n    });\n  }\n\n  destroy() {\n    super.destroy();\n\n    for (const toolbarConfig of this._toolbarDefinitions.values()) {\n      toolbarConfig.view.destroy();\n    }\n  }\n  /**\n   * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked\n   * `getRelatedElement` function. Toolbar items are gathered from `items` array.\n   * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.\n   *\n   * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}\n   * callback (or later) to make sure that the given toolbar items were already registered by other plugins.\n   *\n   * @param {String} toolbarId An id for the toolbar. Used to\n   * @param {Object} options\n   * @param {String} [options.ariaLabel] Label used by assistive technologies to describe this toolbar element.\n   * @param {Array.<String>} options.items Array of toolbar items.\n   * @param {Function} options.getRelatedElement Callback which returns an element the toolbar should be attached to.\n   * @param {String} [options.balloonClassName='ck-toolbar-container'] CSS class for the widget balloon.\n   */\n\n\n  register(toolbarId, _ref) {\n    let {\n      ariaLabel,\n      items,\n      getRelatedElement,\n      balloonClassName = 'ck-toolbar-container'\n    } = _ref;\n\n    // Trying to register a toolbar without any item.\n    if (!items.length) {\n      /**\n       * When {@link #register} a new toolbar, you need to provide a non-empty array with\n       * the items that will be inserted into the toolbar.\n       *\n       * @error widget-toolbar-no-items\n       */\n      logWarning('widget-toolbar-no-items', {\n        toolbarId\n      });\n      return;\n    }\n\n    const editor = this.editor;\n    const t = editor.t;\n    const toolbarView = new ToolbarView(editor.locale);\n    toolbarView.ariaLabel = ariaLabel || t('Widget toolbar');\n\n    if (this._toolbarDefinitions.has(toolbarId)) {\n      /**\n       * Toolbar with the given id was already added.\n       *\n       * @error widget-toolbar-duplicated\n       * @param toolbarId Toolbar id.\n       */\n      throw new CKEditorError('widget-toolbar-duplicated', this, {\n        toolbarId\n      });\n    }\n\n    toolbarView.fillFromConfig(items, editor.ui.componentFactory);\n\n    this._toolbarDefinitions.set(toolbarId, {\n      view: toolbarView,\n      getRelatedElement,\n      balloonClassName\n    });\n  }\n  /**\n   * Iterates over stored toolbars and makes them visible or hidden.\n   *\n   * @private\n   */\n\n\n  _updateToolbarsVisibility() {\n    let maxRelatedElementDepth = 0;\n    let deepestRelatedElement = null;\n    let deepestToolbarDefinition = null;\n\n    for (const definition of this._toolbarDefinitions.values()) {\n      const relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);\n\n      if (!this.isEnabled || !relatedElement) {\n        if (this._isToolbarInBalloon(definition)) {\n          this._hideToolbar(definition);\n        }\n      } else if (!this.editor.ui.focusTracker.isFocused) {\n        if (this._isToolbarVisible(definition)) {\n          this._hideToolbar(definition);\n        }\n      } else {\n        const relatedElementDepth = relatedElement.getAncestors().length; // Many toolbars can express willingness to be displayed but they do not know about\n        // each other. Figure out which toolbar is deepest in the view tree to decide which\n        // should be displayed. For instance, if a selected image is inside a table cell, display\n        // the ImageToolbar rather than the TableToolbar (#60).\n\n        if (relatedElementDepth > maxRelatedElementDepth) {\n          maxRelatedElementDepth = relatedElementDepth;\n          deepestRelatedElement = relatedElement;\n          deepestToolbarDefinition = definition;\n        }\n      }\n    }\n\n    if (deepestToolbarDefinition) {\n      this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);\n    }\n  }\n  /**\n   * Hides the given toolbar.\n   *\n   * @private\n   * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n   */\n\n\n  _hideToolbar(toolbarDefinition) {\n    this._balloon.remove(toolbarDefinition.view);\n\n    this.stopListening(this._balloon, 'change:visibleView');\n  }\n  /**\n   * Shows up the toolbar if the toolbar is not visible.\n   * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.\n   *\n   * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view\n   * should be still visible after the {@link module:core/editor/editorui~EditorUI#event:update}.\n   *\n   * @private\n   * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n   * @param {module:engine/view/element~Element} relatedElement\n   */\n\n\n  _showToolbar(toolbarDefinition, relatedElement) {\n    if (this._isToolbarVisible(toolbarDefinition)) {\n      repositionContextualBalloon(this.editor, relatedElement);\n    } else if (!this._isToolbarInBalloon(toolbarDefinition)) {\n      this._balloon.add({\n        view: toolbarDefinition.view,\n        position: getBalloonPositionData(this.editor, relatedElement),\n        balloonClassName: toolbarDefinition.balloonClassName\n      }); // Update toolbar position each time stack with toolbar view is switched to visible.\n      // This is in a case target element has changed when toolbar was in invisible stack\n      // e.g. target image was wrapped by a block quote.\n      // See https://github.com/ckeditor/ckeditor5-widget/issues/92.\n\n\n      this.listenTo(this._balloon, 'change:visibleView', () => {\n        for (const definition of this._toolbarDefinitions.values()) {\n          if (this._isToolbarVisible(definition)) {\n            const relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);\n            repositionContextualBalloon(this.editor, relatedElement);\n          }\n        }\n      });\n    }\n  }\n  /**\n   * @private\n   * @param {Object} toolbar\n   * @returns {Boolean}\n   */\n\n\n  _isToolbarVisible(toolbar) {\n    return this._balloon.visibleView === toolbar.view;\n  }\n  /**\n   * @private\n   * @param {Object} toolbar\n   * @returns {Boolean}\n   */\n\n\n  _isToolbarInBalloon(toolbar) {\n    return this._balloon.hasView(toolbar.view);\n  }\n\n}\n\nfunction repositionContextualBalloon(editor, relatedElement) {\n  const balloon = editor.plugins.get('ContextualBalloon');\n  const position = getBalloonPositionData(editor, relatedElement);\n  balloon.updatePosition(position);\n}\n\nfunction getBalloonPositionData(editor, relatedElement) {\n  const editingView = editor.editing.view;\n  const defaultPositions = BalloonPanelView.defaultPositions;\n  return {\n    target: editingView.domConverter.mapViewToDom(relatedElement),\n    positions: [defaultPositions.northArrowSouth, defaultPositions.northArrowSouthWest, defaultPositions.northArrowSouthEast, defaultPositions.southArrowNorth, defaultPositions.southArrowNorthWest, defaultPositions.southArrowNorthEast, defaultPositions.viewportStickyNorth]\n  };\n}\n\nfunction isWidgetSelected(selection) {\n  const viewElement = selection.getSelectedElement();\n  return !!(viewElement && isWidget(viewElement));\n}\n/**\n * The toolbar definition object used by the toolbar repository to manage toolbars.\n * It contains information necessary to display the toolbar in the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} and\n * update it during its life (display) cycle.\n *\n * @typedef {Object} module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition\n *\n * @property {module:ui/view~View} view The UI view of the toolbar.\n * @property {Function} getRelatedElement A function that returns an engine {@link module:engine/view/view~View}\n * element the toolbar is to be attached to. For instance, an image widget or a table widget (or `null` when\n * there is no such element). The function accepts an instance of {@link module:engine/view/selection~Selection}.\n * @property {String} balloonClassName CSS class for the widget balloon when a toolbar is displayed.\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js"],"names":["Plugin","ContextualBalloon","ToolbarView","BalloonPanelView","isWidget","CKEditorError","logWarning","WidgetToolbarRepository","requires","pluginName","init","editor","plugins","has","balloonToolbar","get","listenTo","evt","isWidgetSelected","editing","view","document","selection","stop","priority","_toolbarDefinitions","Map","_balloon","on","_updateToolbarsVisibility","ui","focusTracker","destroy","toolbarConfig","values","register","toolbarId","ariaLabel","items","getRelatedElement","balloonClassName","length","t","toolbarView","locale","fillFromConfig","componentFactory","set","maxRelatedElementDepth","deepestRelatedElement","deepestToolbarDefinition","definition","relatedElement","isEnabled","_isToolbarInBalloon","_hideToolbar","isFocused","_isToolbarVisible","relatedElementDepth","getAncestors","_showToolbar","toolbarDefinition","remove","stopListening","repositionContextualBalloon","add","position","getBalloonPositionData","toolbar","visibleView","hasView","balloon","updatePosition","editingView","defaultPositions","target","domConverter","mapViewToDom","positions","northArrowSouth","northArrowSouthWest","northArrowSouthEast","southArrowNorth","southArrowNorthWest","southArrowNorthEast","viewportStickyNorth","viewElement","getSelectedElement"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widgettoolbarrepository\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';\nimport ToolbarView from '@ckeditor/ckeditor5-ui/src/toolbar/toolbarview';\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\nimport { isWidget } from './utils';\nimport CKEditorError, { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Widget toolbar repository plugin. A central point for registering widget toolbars. This plugin handles the whole\n * toolbar rendering process and exposes a concise API.\n *\n * To add a toolbar for your widget use the {@link ~WidgetToolbarRepository#register `WidgetToolbarRepository#register()`} method.\n *\n * The following example comes from the {@link module:image/imagetoolbar~ImageToolbar} plugin:\n *\n * \t\tclass ImageToolbar extends Plugin {\n *\t\t\tstatic get requires() {\n *\t\t\t\treturn [ WidgetToolbarRepository ];\n *\t\t\t}\n *\n *\t\t\tafterInit() {\n *\t\t\t\tconst editor = this.editor;\n *\t\t\t\tconst widgetToolbarRepository = editor.plugins.get( WidgetToolbarRepository );\n *\n *\t\t\t\twidgetToolbarRepository.register( 'image', {\n *\t\t\t\t\titems: editor.config.get( 'image.toolbar' ),\n *\t\t\t\t\tgetRelatedElement: getClosestSelectedImageWidget\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n */\nexport default class WidgetToolbarRepository extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ContextualBalloon ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'WidgetToolbarRepository';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Disables the default balloon toolbar for all widgets.\n\t\tif ( editor.plugins.has( 'BalloonToolbar' ) ) {\n\t\t\tconst balloonToolbar = editor.plugins.get( 'BalloonToolbar' );\n\n\t\t\tthis.listenTo( balloonToolbar, 'show', evt => {\n\t\t\t\tif ( isWidgetSelected( editor.editing.view.document.selection ) ) {\n\t\t\t\t\tevt.stop();\n\t\t\t\t}\n\t\t\t}, { priority: 'high' } );\n\t\t}\n\n\t\t/**\n\t\t * A map of toolbar definitions.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map.<String,module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition>} #_toolbarDefinitions\n\t\t */\n\t\tthis._toolbarDefinitions = new Map();\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._balloon = this.editor.plugins.get( 'ContextualBalloon' );\n\n\t\tthis.on( 'change:isEnabled', () => {\n\t\t\tthis._updateToolbarsVisibility();\n\t\t} );\n\n\t\tthis.listenTo( editor.ui, 'update', () => {\n\t\t\tthis._updateToolbarsVisibility();\n\t\t} );\n\n\t\t// UI#update is not fired after focus is back in editor, we need to check if balloon panel should be visible.\n\t\tthis.listenTo( editor.ui.focusTracker, 'change:isFocused', () => {\n\t\t\tthis._updateToolbarsVisibility();\n\t\t}, { priority: 'low' } );\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tfor ( const toolbarConfig of this._toolbarDefinitions.values() ) {\n\t\t\ttoolbarConfig.view.destroy();\n\t\t}\n\t}\n\n\t/**\n\t * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked\n\t * `getRelatedElement` function. Toolbar items are gathered from `items` array.\n\t * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.\n\t *\n\t * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}\n\t * callback (or later) to make sure that the given toolbar items were already registered by other plugins.\n\t *\n\t * @param {String} toolbarId An id for the toolbar. Used to\n\t * @param {Object} options\n\t * @param {String} [options.ariaLabel] Label used by assistive technologies to describe this toolbar element.\n\t * @param {Array.<String>} options.items Array of toolbar items.\n\t * @param {Function} options.getRelatedElement Callback which returns an element the toolbar should be attached to.\n\t * @param {String} [options.balloonClassName='ck-toolbar-container'] CSS class for the widget balloon.\n\t */\n\tregister( toolbarId, { ariaLabel, items, getRelatedElement, balloonClassName = 'ck-toolbar-container' } ) {\n\t\t// Trying to register a toolbar without any item.\n\t\tif ( !items.length ) {\n\t\t\t/**\n\t\t\t * When {@link #register} a new toolbar, you need to provide a non-empty array with\n\t\t\t * the items that will be inserted into the toolbar.\n\t\t\t *\n\t\t\t * @error widget-toolbar-no-items\n\t\t\t */\n\t\t\tlogWarning( 'widget-toolbar-no-items', { toolbarId } );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst editor = this.editor;\n\t\tconst t = editor.t;\n\t\tconst toolbarView = new ToolbarView( editor.locale );\n\n\t\ttoolbarView.ariaLabel = ariaLabel || t( 'Widget toolbar' );\n\n\t\tif ( this._toolbarDefinitions.has( toolbarId ) ) {\n\t\t\t/**\n\t\t\t * Toolbar with the given id was already added.\n\t\t\t *\n\t\t\t * @error widget-toolbar-duplicated\n\t\t\t * @param toolbarId Toolbar id.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'widget-toolbar-duplicated', this, { toolbarId } );\n\t\t}\n\n\t\ttoolbarView.fillFromConfig( items, editor.ui.componentFactory );\n\n\t\tthis._toolbarDefinitions.set( toolbarId, {\n\t\t\tview: toolbarView,\n\t\t\tgetRelatedElement,\n\t\t\tballoonClassName\n\t\t} );\n\t}\n\n\t/**\n\t * Iterates over stored toolbars and makes them visible or hidden.\n\t *\n\t * @private\n\t */\n\t_updateToolbarsVisibility() {\n\t\tlet maxRelatedElementDepth = 0;\n\t\tlet deepestRelatedElement = null;\n\t\tlet deepestToolbarDefinition = null;\n\n\t\tfor ( const definition of this._toolbarDefinitions.values() ) {\n\t\t\tconst relatedElement = definition.getRelatedElement( this.editor.editing.view.document.selection );\n\n\t\t\tif ( !this.isEnabled || !relatedElement ) {\n\t\t\t\tif ( this._isToolbarInBalloon( definition ) ) {\n\t\t\t\t\tthis._hideToolbar( definition );\n\t\t\t\t}\n\t\t\t} else if ( !this.editor.ui.focusTracker.isFocused ) {\n\t\t\t\tif ( this._isToolbarVisible( definition ) ) {\n\t\t\t\t\tthis._hideToolbar( definition );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst relatedElementDepth = relatedElement.getAncestors().length;\n\n\t\t\t\t// Many toolbars can express willingness to be displayed but they do not know about\n\t\t\t\t// each other. Figure out which toolbar is deepest in the view tree to decide which\n\t\t\t\t// should be displayed. For instance, if a selected image is inside a table cell, display\n\t\t\t\t// the ImageToolbar rather than the TableToolbar (#60).\n\t\t\t\tif ( relatedElementDepth > maxRelatedElementDepth ) {\n\t\t\t\t\tmaxRelatedElementDepth = relatedElementDepth;\n\t\t\t\t\tdeepestRelatedElement = relatedElement;\n\t\t\t\t\tdeepestToolbarDefinition = definition;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( deepestToolbarDefinition ) {\n\t\t\tthis._showToolbar( deepestToolbarDefinition, deepestRelatedElement );\n\t\t}\n\t}\n\n\t/**\n\t * Hides the given toolbar.\n\t *\n\t * @private\n\t * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n\t */\n\t_hideToolbar( toolbarDefinition ) {\n\t\tthis._balloon.remove( toolbarDefinition.view );\n\t\tthis.stopListening( this._balloon, 'change:visibleView' );\n\t}\n\n\t/**\n\t * Shows up the toolbar if the toolbar is not visible.\n\t * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.\n\t *\n\t * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view\n\t * should be still visible after the {@link module:core/editor/editorui~EditorUI#event:update}.\n\t *\n\t * @private\n\t * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n\t * @param {module:engine/view/element~Element} relatedElement\n\t */\n\t_showToolbar( toolbarDefinition, relatedElement ) {\n\t\tif ( this._isToolbarVisible( toolbarDefinition ) ) {\n\t\t\trepositionContextualBalloon( this.editor, relatedElement );\n\t\t} else if ( !this._isToolbarInBalloon( toolbarDefinition ) ) {\n\t\t\tthis._balloon.add( {\n\t\t\t\tview: toolbarDefinition.view,\n\t\t\t\tposition: getBalloonPositionData( this.editor, relatedElement ),\n\t\t\t\tballoonClassName: toolbarDefinition.balloonClassName\n\t\t\t} );\n\n\t\t\t// Update toolbar position each time stack with toolbar view is switched to visible.\n\t\t\t// This is in a case target element has changed when toolbar was in invisible stack\n\t\t\t// e.g. target image was wrapped by a block quote.\n\t\t\t// See https://github.com/ckeditor/ckeditor5-widget/issues/92.\n\t\t\tthis.listenTo( this._balloon, 'change:visibleView', () => {\n\t\t\t\tfor ( const definition of this._toolbarDefinitions.values() ) {\n\t\t\t\t\tif ( this._isToolbarVisible( definition ) ) {\n\t\t\t\t\t\tconst relatedElement = definition.getRelatedElement( this.editor.editing.view.document.selection );\n\t\t\t\t\t\trepositionContextualBalloon( this.editor, relatedElement );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} toolbar\n\t * @returns {Boolean}\n\t */\n\t_isToolbarVisible( toolbar ) {\n\t\treturn this._balloon.visibleView === toolbar.view;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} toolbar\n\t * @returns {Boolean}\n\t */\n\t_isToolbarInBalloon( toolbar ) {\n\t\treturn this._balloon.hasView( toolbar.view );\n\t}\n}\n\nfunction repositionContextualBalloon( editor, relatedElement ) {\n\tconst balloon = editor.plugins.get( 'ContextualBalloon' );\n\tconst position = getBalloonPositionData( editor, relatedElement );\n\n\tballoon.updatePosition( position );\n}\n\nfunction getBalloonPositionData( editor, relatedElement ) {\n\tconst editingView = editor.editing.view;\n\tconst defaultPositions = BalloonPanelView.defaultPositions;\n\n\treturn {\n\t\ttarget: editingView.domConverter.mapViewToDom( relatedElement ),\n\t\tpositions: [\n\t\t\tdefaultPositions.northArrowSouth,\n\t\t\tdefaultPositions.northArrowSouthWest,\n\t\t\tdefaultPositions.northArrowSouthEast,\n\t\t\tdefaultPositions.southArrowNorth,\n\t\t\tdefaultPositions.southArrowNorthWest,\n\t\t\tdefaultPositions.southArrowNorthEast,\n\t\t\tdefaultPositions.viewportStickyNorth\n\t\t]\n\t};\n}\n\nfunction isWidgetSelected( selection ) {\n\tconst viewElement = selection.getSelectedElement();\n\n\treturn !!( viewElement && isWidget( viewElement ) );\n}\n\n/**\n * The toolbar definition object used by the toolbar repository to manage toolbars.\n * It contains information necessary to display the toolbar in the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} and\n * update it during its life (display) cycle.\n *\n * @typedef {Object} module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition\n *\n * @property {module:ui/view~View} view The UI view of the toolbar.\n * @property {Function} getRelatedElement A function that returns an engine {@link module:engine/view/view~View}\n * element the toolbar is to be attached to. For instance, an image widget or a table widget (or `null` when\n * there is no such element). The function accepts an instance of {@link module:engine/view/selection~Selection}.\n * @property {String} balloonClassName CSS class for the widget balloon when a toolbar is displayed.\n */\n"]},"metadata":{},"sourceType":"module"}