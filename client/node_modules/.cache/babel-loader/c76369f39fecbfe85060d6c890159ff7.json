{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/position\n */\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EditableElement from './editableelement'; // To check if component is loaded more than once.\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Position in the view tree. Position is represented by its parent node and an offset in this parent.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\n\nexport default class Position {\n  /**\n   * Creates a position.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} parent Position parent.\n   * @param {Number} offset Position offset.\n   */\n  constructor(parent, offset) {\n    /**\n     * Position parent.\n     *\n     * @readonly\n     * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n     * module:engine/view/position~Position#parent\n     */\n    this.parent = parent;\n    /**\n     * Position offset.\n     *\n     * @readonly\n     * @member {Number} module:engine/view/position~Position#offset\n     */\n\n    this.offset = offset;\n  }\n  /**\n   * Node directly after the position. Equals `null` when there is no node after position or position is located\n   * inside text node.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|null}\n   */\n\n\n  get nodeAfter() {\n    if (this.parent.is('$text')) {\n      return null;\n    }\n\n    return this.parent.getChild(this.offset) || null;\n  }\n  /**\n   * Node directly before the position. Equals `null` when there is no node before position or position is located\n   * inside text node.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|null}\n   */\n\n\n  get nodeBefore() {\n    if (this.parent.is('$text')) {\n      return null;\n    }\n\n    return this.parent.getChild(this.offset - 1) || null;\n  }\n  /**\n   * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isAtStart() {\n    return this.offset === 0;\n  }\n  /**\n   * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isAtEnd() {\n    const endOffset = this.parent.is('$text') ? this.parent.data.length : this.parent.childCount;\n    return this.offset === endOffset;\n  }\n  /**\n   * Position's root, that is the root of the position's parent element.\n   *\n   * @readonly\n   * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n   */\n\n\n  get root() {\n    return this.parent.root;\n  }\n  /**\n   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if\n   * position is not inside an editable element.\n   *\n   * @type {module:engine/view/editableelement~EditableElement|null}\n   */\n\n\n  get editableElement() {\n    let editable = this.parent;\n\n    while (!(editable instanceof EditableElement)) {\n      if (editable.parent) {\n        editable = editable.parent;\n      } else {\n        return null;\n      }\n    }\n\n    return editable;\n  }\n  /**\n   * Returns a new instance of Position with offset incremented by `shift` value.\n   *\n   * @param {Number} shift How position offset should get changed. Accepts negative values.\n   * @returns {module:engine/view/position~Position} Shifted position.\n   */\n\n\n  getShiftedBy(shift) {\n    const shifted = Position._createAt(this);\n\n    const offset = shifted.offset + shift;\n    shifted.offset = offset < 0 ? 0 : offset;\n    return shifted;\n  }\n  /**\n   * Gets the farthest position which matches the callback using\n   * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.\n   *\n   * For example:\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n   * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>\n   * \t\tgetLastMatchingPosition( value => false ); // Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   *\n   * @returns {module:engine/view/position~Position} The position after the last item which matches the `skip` callback test.\n   */\n\n\n  getLastMatchingPosition(skip) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.startPosition = this;\n    const treeWalker = new TreeWalker(options);\n    treeWalker.skip(skip);\n    return treeWalker.position;\n  }\n  /**\n   * Returns ancestors array of this position, that is this position's parent and it's ancestors.\n   *\n   * @returns {Array} Array with ancestors.\n   */\n\n\n  getAncestors() {\n    if (this.parent.is('documentFragment')) {\n      return [this.parent];\n    } else {\n      return this.parent.getAncestors({\n        includeSelf: true\n      });\n    }\n  }\n  /**\n   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n   * which is a common ancestor of both positions.\n   *\n   * @param {module:engine/view/position~Position} position\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n   */\n\n\n  getCommonAncestor(position) {\n    const ancestorsA = this.getAncestors();\n    const ancestorsB = position.getAncestors();\n    let i = 0;\n\n    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n      i++;\n    }\n\n    return i === 0 ? null : ancestorsA[i - 1];\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   *\t\tposition.is( 'position' ); // -> true\n   *\t\tposition.is( 'view:position' ); // -> true\n   *\n   *\t\tposition.is( 'model:position' ); // -> false\n   *\t\tposition.is( 'element' ); // -> false\n   *\t\tposition.is( 'range' ); // -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'position' || type === 'view:position';\n  }\n  /**\n   * Checks whether this position equals given position.\n   *\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions are same.\n   */\n\n\n  isEqual(otherPosition) {\n    return this.parent == otherPosition.parent && this.offset == otherPosition.offset;\n  }\n  /**\n   * Checks whether this position is located before given position. When method returns `false` it does not mean that\n   * this position is after give one. Two positions may be located inside separate roots and in that situation this\n   * method will still return `false`.\n   *\n   * @see module:engine/view/position~Position#isAfter\n   * @see module:engine/view/position~Position#compareWith\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} Returns `true` if this position is before given position.\n   */\n\n\n  isBefore(otherPosition) {\n    return this.compareWith(otherPosition) == 'before';\n  }\n  /**\n   * Checks whether this position is located after given position. When method returns `false` it does not mean that\n   * this position is before give one. Two positions may be located inside separate roots and in that situation this\n   * method will still return `false`.\n   *\n   * @see module:engine/view/position~Position#isBefore\n   * @see module:engine/view/position~Position#compareWith\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} Returns `true` if this position is after given position.\n   */\n\n\n  isAfter(otherPosition) {\n    return this.compareWith(otherPosition) == 'after';\n  }\n  /**\n   * Checks whether this position is before, after or in same position that other position. Two positions may be also\n   * different when they are located in separate roots.\n   *\n   * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n   * @returns {module:engine/view/position~PositionRelation}\n   */\n\n\n  compareWith(otherPosition) {\n    if (this.root !== otherPosition.root) {\n      return 'different';\n    }\n\n    if (this.isEqual(otherPosition)) {\n      return 'same';\n    } // Get path from root to position's parent element.\n\n\n    const thisPath = this.parent.is('node') ? this.parent.getPath() : [];\n    const otherPath = otherPosition.parent.is('node') ? otherPosition.parent.getPath() : []; // Add the positions' offsets to the parents offsets.\n\n    thisPath.push(this.offset);\n    otherPath.push(otherPosition.offset); // Compare both path arrays to find common ancestor.\n\n    const result = compareArrays(thisPath, otherPath);\n\n    switch (result) {\n      case 'prefix':\n        return 'before';\n\n      case 'extension':\n        return 'after';\n\n      default:\n        return thisPath[result] < otherPath[result] ? 'before' : 'after';\n    }\n  }\n  /**\n   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}\n   * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n   * @param {Boolean} [options.singleCharacters=false]\n   * @param {Boolean} [options.shallow=false]\n   * @param {Boolean} [options.ignoreElementEnd=false]\n   */\n\n\n  getWalker() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.startPosition = this;\n    return new TreeWalker(options);\n  }\n\n  clone() {\n    return new Position(this.parent, this.offset);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/view/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n   *\n   * This method is a shortcut to other constructors such as:\n   *\n   * * {@link module:engine/view/position~Position._createBefore},\n   * * {@link module:engine/view/position~Position._createAfter}.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n\n\n  static _createAt(itemOrPosition, offset) {\n    if (itemOrPosition instanceof Position) {\n      return new this(itemOrPosition.parent, itemOrPosition.offset);\n    } else {\n      const node = itemOrPosition;\n\n      if (offset == 'end') {\n        offset = node.is('$text') ? node.data.length : node.childCount;\n      } else if (offset == 'before') {\n        return this._createBefore(node);\n      } else if (offset == 'after') {\n        return this._createAfter(node);\n      } else if (offset !== 0 && !offset) {\n        /**\n         * {@link module:engine/view/view~View#createPositionAt `View#createPositionAt()`}\n         * requires the offset to be specified when the first parameter is a view item.\n         *\n         * @error view-createpositionat-offset-required\n         */\n        throw new CKEditorError('view-createpositionat-offset-required', node);\n      }\n\n      return new Position(node, offset);\n    }\n  }\n  /**\n   * Creates a new position after given view item.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item} item View item after which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  static _createAfter(item) {\n    // TextProxy is not a instance of Node so we need do handle it in specific way.\n    if (item.is('$textProxy')) {\n      return new Position(item.textNode, item.offsetInText + item.data.length);\n    }\n\n    if (!item.parent) {\n      /**\n       * You can not make a position after a root.\n       *\n       * @error view-position-after-root\n       * @param {module:engine/view/node~Node} root\n       */\n      throw new CKEditorError('view-position-after-root', item, {\n        root: item\n      });\n    }\n\n    return new Position(item.parent, item.index + 1);\n  }\n  /**\n   * Creates a new position before given view item.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item} item View item before which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  static _createBefore(item) {\n    // TextProxy is not a instance of Node so we need do handle it in specific way.\n    if (item.is('$textProxy')) {\n      return new Position(item.textNode, item.offsetInText);\n    }\n\n    if (!item.parent) {\n      /**\n       * You cannot make a position before a root.\n       *\n       * @error view-position-before-root\n       * @param {module:engine/view/node~Node} root\n       */\n      throw new CKEditorError('view-position-before-root', item, {\n        root: item\n      });\n    }\n\n    return new Position(item.parent, item.index);\n  }\n\n}\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/view/position~PositionRelation\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/position.js"],"names":["TreeWalker","compareArrays","CKEditorError","EditableElement","Position","constructor","parent","offset","nodeAfter","is","getChild","nodeBefore","isAtStart","isAtEnd","endOffset","data","length","childCount","root","editableElement","editable","getShiftedBy","shift","shifted","_createAt","getLastMatchingPosition","skip","options","startPosition","treeWalker","position","getAncestors","includeSelf","getCommonAncestor","ancestorsA","ancestorsB","i","type","isEqual","otherPosition","isBefore","compareWith","isAfter","thisPath","getPath","otherPath","push","result","getWalker","clone","itemOrPosition","node","_createBefore","_createAfter","item","textNode","offsetInText","index"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/position\n */\n\nimport TreeWalker from './treewalker';\n\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EditableElement from './editableelement';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Position in the view tree. Position is represented by its parent node and an offset in this parent.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} parent Position parent.\n\t * @param {Number} offset Position offset.\n\t */\n\tconstructor( parent, offset ) {\n\t\t/**\n\t\t * Position parent.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t\t * module:engine/view/position~Position#parent\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * Position offset.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} module:engine/view/position~Position#offset\n\t\t */\n\t\tthis.offset = offset;\n\t}\n\n\t/**\n\t * Node directly after the position. Equals `null` when there is no node after position or position is located\n\t * inside text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\tif ( this.parent.is( '$text' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.parent.getChild( this.offset ) || null;\n\t}\n\n\t/**\n\t * Node directly before the position. Equals `null` when there is no node before position or position is located\n\t * inside text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|null}\n\t */\n\tget nodeBefore() {\n\t\tif ( this.parent.is( '$text' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.parent.getChild( this.offset - 1 ) || null;\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\tconst endOffset = this.parent.is( '$text' ) ? this.parent.data.length : this.parent.childCount;\n\n\t\treturn this.offset === endOffset;\n\t}\n\n\t/**\n\t * Position's root, that is the root of the position's parent element.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.parent.root;\n\t}\n\n\t/**\n\t * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if\n\t * position is not inside an editable element.\n\t *\n\t * @type {module:engine/view/editableelement~EditableElement|null}\n\t */\n\tget editableElement() {\n\t\tlet editable = this.parent;\n\n\t\twhile ( !( editable instanceof EditableElement ) ) {\n\t\t\tif ( editable.parent ) {\n\t\t\t\teditable = editable.parent;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn editable;\n\t}\n\n\t/**\n\t * Returns a new instance of Position with offset incremented by `shift` value.\n\t *\n\t * @param {Number} shift How position offset should get changed. Accepts negative values.\n\t * @returns {module:engine/view/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = Position._createAt( this );\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>\n\t * \t\tgetLastMatchingPosition( value => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/view/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and it's ancestors.\n\t *\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tif ( this.parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ this.parent ];\n\t\t} else {\n\t\t\treturn this.parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions.\n\t *\n\t * @param {module:engine/view/position~Position} position\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tposition.is( 'position' ); // -> true\n\t *\t\tposition.is( 'view:position' ); // -> true\n\t *\n\t *\t\tposition.is( 'model:position' ); // -> false\n\t *\t\tposition.is( 'element' ); // -> false\n\t *\t\tposition.is( 'range' ); // -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'position' || type === 'view:position';\n\t}\n\n\t/**\n\t * Checks whether this position equals given position.\n\t *\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn ( this.parent == otherPosition.parent && this.offset == otherPosition.offset );\n\t}\n\n\t/**\n\t * Checks whether this position is located before given position. When method returns `false` it does not mean that\n\t * this position is after give one. Two positions may be located inside separate roots and in that situation this\n\t * method will still return `false`.\n\t *\n\t * @see module:engine/view/position~Position#isAfter\n\t * @see module:engine/view/position~Position#compareWith\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} Returns `true` if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is located after given position. When method returns `false` it does not mean that\n\t * this position is before give one. Two positions may be located inside separate roots and in that situation this\n\t * method will still return `false`.\n\t *\n\t * @see module:engine/view/position~Position#isBefore\n\t * @see module:engine/view/position~Position#compareWith\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} Returns `true` if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before, after or in same position that other position. Two positions may be also\n\t * different when they are located in separate roots.\n\t *\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/view/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root !== otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tif ( this.isEqual( otherPosition ) ) {\n\t\t\treturn 'same';\n\t\t}\n\n\t\t// Get path from root to position's parent element.\n\t\tconst thisPath = this.parent.is( 'node' ) ? this.parent.getPath() : [];\n\t\tconst otherPath = otherPosition.parent.is( 'node' ) ? otherPosition.parent.getPath() : [];\n\n\t\t// Add the positions' offsets to the parents offsets.\n\t\tthisPath.push( this.offset );\n\t\totherPath.push( otherPosition.offset );\n\n\t\t// Compare both path arrays to find common ancestor.\n\t\tconst result = compareArrays( thisPath, otherPath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < otherPath[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}\n\t * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\tclone() {\n\t\treturn new Position( this.parent, this.offset );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/view/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link module:engine/view/position~Position._createBefore},\n\t * * {@link module:engine/view/position~Position._createAfter}.\n\t *\n\t * @protected\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tstatic _createAt( itemOrPosition, offset ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn new this( itemOrPosition.parent, itemOrPosition.offset );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.is( '$text' ) ? node.data.length : node.childCount;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this._createBefore( node );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this._createAfter( node );\n\t\t\t} else if ( offset !== 0 && !offset ) {\n\t\t\t\t/**\n\t\t\t\t * {@link module:engine/view/view~View#createPositionAt `View#createPositionAt()`}\n\t\t\t\t * requires the offset to be specified when the first parameter is a view item.\n\t\t\t\t *\n\t\t\t\t * @error view-createpositionat-offset-required\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'view-createpositionat-offset-required', node );\n\t\t\t}\n\n\t\t\treturn new Position( node, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position after given view item.\n\t *\n\t * @protected\n\t * @param {module:engine/view/item~Item} item View item after which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tstatic _createAfter( item ) {\n\t\t// TextProxy is not a instance of Node so we need do handle it in specific way.\n\t\tif ( item.is( '$textProxy' ) ) {\n\t\t\treturn new Position( item.textNode, item.offsetInText + item.data.length );\n\t\t}\n\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root.\n\t\t\t *\n\t\t\t * @error view-position-after-root\n\t\t\t * @param {module:engine/view/node~Node} root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-position-after-root', item, { root: item } );\n\t\t}\n\n\t\treturn new Position( item.parent, item.index + 1 );\n\t}\n\n\t/**\n\t * Creates a new position before given view item.\n\t *\n\t * @protected\n\t * @param {module:engine/view/item~Item} item View item before which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tstatic _createBefore( item ) {\n\t\t// TextProxy is not a instance of Node so we need do handle it in specific way.\n\t\tif ( item.is( '$textProxy' ) ) {\n\t\t\treturn new Position( item.textNode, item.offsetInText );\n\t\t}\n\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You cannot make a position before a root.\n\t\t\t *\n\t\t\t * @error view-position-before-root\n\t\t\t * @param {module:engine/view/node~Node} root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-position-before-root', item, { root: item } );\n\t\t}\n\n\t\treturn new Position( item.parent, item.index );\n\t}\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/view/position~PositionRelation\n */\n"]},"metadata":{},"sourceType":"module"}