{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/observablemixin\n */\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport { extend, isObject } from 'lodash-es';\nconst observablePropertiesSymbol = Symbol('observableProperties');\nconst boundObservablesSymbol = Symbol('boundObservables');\nconst boundPropertiesSymbol = Symbol('boundProperties');\n\nconst _decoratedMethods = Symbol('decoratedMethods');\n\nconst _decoratedOriginal = Symbol('decoratedOriginal');\n/**\n * A mixin that injects the \"observable properties\" and data binding functionality described in the\n * {@link ~Observable} interface.\n *\n * Read more about the concept of observables in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide,\n * * {@glink framework/guides/deep-dive/observables Observables deep dive} guide.\n *\n * @mixin ObservableMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/observablemixin~Observable\n */\n\n\nconst ObservableMixin = {\n  /**\n   * @inheritDoc\n   */\n  set(name, value) {\n    // If the first parameter is an Object, iterate over its properties.\n    if (isObject(name)) {\n      Object.keys(name).forEach(property => {\n        this.set(property, name[property]);\n      }, this);\n      return;\n    }\n\n    initObservable(this);\n    const properties = this[observablePropertiesSymbol];\n\n    if (name in this && !properties.has(name)) {\n      /**\n       * Cannot override an existing property.\n       *\n       * This error is thrown when trying to {@link ~Observable#set set} a property with\n       * a name of an already existing property. For example:\n       *\n       *\t\tlet observable = new Model();\n       *\t\tobservable.property = 1;\n       *\t\tobservable.set( 'property', 2 );\t\t\t// throws\n       *\n       *\t\tobservable.set( 'property', 1 );\n       *\t\tobservable.set( 'property', 2 );\t\t\t// ok, because this is an existing property.\n       *\n       * @error observable-set-cannot-override\n       */\n      throw new CKEditorError('observable-set-cannot-override', this);\n    }\n\n    Object.defineProperty(this, name, {\n      enumerable: true,\n      configurable: true,\n\n      get() {\n        return properties.get(name);\n      },\n\n      set(value) {\n        const oldValue = properties.get(name); // Fire `set` event before the new value will be set to make it possible\n        // to override observable property without affecting `change` event.\n        // See https://github.com/ckeditor/ckeditor5-utils/issues/171.\n\n        let newValue = this.fire('set:' + name, name, value, oldValue);\n\n        if (newValue === undefined) {\n          newValue = value;\n        } // Allow undefined as an initial value like A.define( 'x', undefined ) (#132).\n        // Note: When properties map has no such own property, then its value is undefined.\n\n\n        if (oldValue !== newValue || !properties.has(name)) {\n          properties.set(name, newValue);\n          this.fire('change:' + name, name, newValue, oldValue);\n        }\n      }\n\n    });\n    this[name] = value;\n  },\n\n  /**\n   * @inheritDoc\n   */\n  bind() {\n    for (var _len = arguments.length, bindProperties = new Array(_len), _key = 0; _key < _len; _key++) {\n      bindProperties[_key] = arguments[_key];\n    }\n\n    if (!bindProperties.length || !isStringArray(bindProperties)) {\n      /**\n       * All properties must be strings.\n       *\n       * @error observable-bind-wrong-properties\n       */\n      throw new CKEditorError('observable-bind-wrong-properties', this);\n    }\n\n    if (new Set(bindProperties).size !== bindProperties.length) {\n      /**\n       * Properties must be unique.\n       *\n       * @error observable-bind-duplicate-properties\n       */\n      throw new CKEditorError('observable-bind-duplicate-properties', this);\n    }\n\n    initObservable(this);\n    const boundProperties = this[boundPropertiesSymbol];\n    bindProperties.forEach(propertyName => {\n      if (boundProperties.has(propertyName)) {\n        /**\n         * Cannot bind the same property more than once.\n         *\n         * @error observable-bind-rebind\n         */\n        throw new CKEditorError('observable-bind-rebind', this);\n      }\n    });\n    const bindings = new Map(); // @typedef {Object} Binding\n    // @property {Array} property Property which is bound.\n    // @property {Array} to Array of observable–property components of the binding (`{ observable: ..., property: .. }`).\n    // @property {Array} callback A function which processes `to` components.\n\n    bindProperties.forEach(a => {\n      const binding = {\n        property: a,\n        to: []\n      };\n      boundProperties.set(a, binding);\n      bindings.set(a, binding);\n    }); // @typedef {Object} BindChain\n    // @property {Function} to See {@link ~ObservableMixin#_bindTo}.\n    // @property {Function} toMany See {@link ~ObservableMixin#_bindToMany}.\n    // @property {module:utils/observablemixin~Observable} _observable The observable which initializes the binding.\n    // @property {Array} _bindProperties Array of `_observable` properties to be bound.\n    // @property {Array} _to Array of `to()` observable–properties (`{ observable: toObservable, properties: ...toProperties }`).\n    // @property {Map} _bindings Stores bindings to be kept in\n    // {@link ~ObservableMixin#_boundProperties}/{@link ~ObservableMixin#_boundObservables}\n    // initiated in this binding chain.\n\n    return {\n      to: bindTo,\n      toMany: bindToMany,\n      _observable: this,\n      _bindProperties: bindProperties,\n      _to: [],\n      _bindings: bindings\n    };\n  },\n\n  /**\n   * @inheritDoc\n   */\n  unbind() {\n    // Nothing to do here if not inited yet.\n    if (!this[observablePropertiesSymbol]) {\n      return;\n    }\n\n    const boundProperties = this[boundPropertiesSymbol];\n    const boundObservables = this[boundObservablesSymbol];\n\n    for (var _len2 = arguments.length, unbindProperties = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      unbindProperties[_key2] = arguments[_key2];\n    }\n\n    if (unbindProperties.length) {\n      if (!isStringArray(unbindProperties)) {\n        /**\n         * Properties must be strings.\n         *\n         * @error observable-unbind-wrong-properties\n         */\n        throw new CKEditorError('observable-unbind-wrong-properties', this);\n      }\n\n      unbindProperties.forEach(propertyName => {\n        const binding = boundProperties.get(propertyName); // Nothing to do if the binding is not defined\n\n        if (!binding) {\n          return;\n        }\n\n        let toObservable, toProperty, toProperties, toPropertyBindings;\n        binding.to.forEach(to => {\n          // TODO: ES6 destructuring.\n          toObservable = to[0];\n          toProperty = to[1];\n          toProperties = boundObservables.get(toObservable);\n          toPropertyBindings = toProperties[toProperty];\n          toPropertyBindings.delete(binding);\n\n          if (!toPropertyBindings.size) {\n            delete toProperties[toProperty];\n          }\n\n          if (!Object.keys(toProperties).length) {\n            boundObservables.delete(toObservable);\n            this.stopListening(toObservable, 'change');\n          }\n        });\n        boundProperties.delete(propertyName);\n      });\n    } else {\n      boundObservables.forEach((bindings, boundObservable) => {\n        this.stopListening(boundObservable, 'change');\n      });\n      boundObservables.clear();\n      boundProperties.clear();\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  decorate(methodName) {\n    const originalMethod = this[methodName];\n\n    if (!originalMethod) {\n      /**\n       * Cannot decorate an undefined method.\n       *\n       * @error observablemixin-cannot-decorate-undefined\n       * @param {Object} object The object which method should be decorated.\n       * @param {String} methodName Name of the method which does not exist.\n       */\n      throw new CKEditorError('observablemixin-cannot-decorate-undefined', this, {\n        object: this,\n        methodName\n      });\n    }\n\n    this.on(methodName, (evt, args) => {\n      evt.return = originalMethod.apply(this, args);\n    });\n\n    this[methodName] = function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.fire(methodName, args);\n    };\n\n    this[methodName][_decoratedOriginal] = originalMethod;\n\n    if (!this[_decoratedMethods]) {\n      this[_decoratedMethods] = [];\n    }\n\n    this[_decoratedMethods].push(methodName);\n  }\n\n};\nextend(ObservableMixin, EmitterMixin); // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.\n// This is needed in case of:\n//  1. Have x.foo() decorated.\n//  2. Call x.stopListening()\n//  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)\n\nObservableMixin.stopListening = function (emitter, event, callback) {\n  // Removing all listeners so let's clean the decorated methods to the original state.\n  if (!emitter && this[_decoratedMethods]) {\n    for (const methodName of this[_decoratedMethods]) {\n      this[methodName] = this[methodName][_decoratedOriginal];\n    }\n\n    delete this[_decoratedMethods];\n  }\n\n  EmitterMixin.stopListening.call(this, emitter, event, callback);\n};\n\nexport default ObservableMixin; // Init symbol properties needed for the observable mechanism to work.\n//\n// @private\n// @param {module:utils/observablemixin~ObservableMixin} observable\n\nfunction initObservable(observable) {\n  // Do nothing if already inited.\n  if (observable[observablePropertiesSymbol]) {\n    return;\n  } // The internal hash containing the observable's state.\n  //\n  // @private\n  // @type {Map}\n\n\n  Object.defineProperty(observable, observablePropertiesSymbol, {\n    value: new Map()\n  }); // Map containing bindings to external observables. It shares the binding objects\n  // (`{ observable: A, property: 'a', to: ... }`) with {@link module:utils/observablemixin~ObservableMixin#_boundProperties} and\n  // it is used to observe external observables to update own properties accordingly.\n  // See {@link module:utils/observablemixin~ObservableMixin#bind}.\n  //\n  //\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n  //\t\tconsole.log( A._boundObservables );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\tB: {\n  //\t\t\t\t\tx: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n  //\t\t\t\t\t] ),\n  //\t\t\t\t\ty: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\t\t] )\n  //\t\t\t\t}\n  //\t\t\t} )\n  //\n  //\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n  //\t\tconsole.log( A._boundObservables );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\tB: {\n  //\t\t\t\t\tx: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n  //\t\t\t\t\t] ),\n  //\t\t\t\t\ty: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\t\t] ),\n  //\t\t\t\t\tz: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n  //\t\t\t\t\t] )\n  //\t\t\t\t},\n  //\t\t\t\tC: {\n  //\t\t\t\t\tw: Set( [\n  //\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n  //\t\t\t\t\t] )\n  //\t\t\t\t}\n  //\t\t\t} )\n  //\n  // @private\n  // @type {Map}\n\n  Object.defineProperty(observable, boundObservablesSymbol, {\n    value: new Map()\n  }); // Object that stores which properties of this observable are bound and how. It shares\n  // the binding objects (`{ observable: A, property: 'a', to: ... }`) with\n  // {@link module:utils/observablemixin~ObservableMixin#_boundObservables}. This data structure is\n  // a reverse of {@link module:utils/observablemixin~ObservableMixin#_boundObservables} and it is helpful for\n  // {@link module:utils/observablemixin~ObservableMixin#unbind}.\n  //\n  // See {@link module:utils/observablemixin~ObservableMixin#bind}.\n  //\n  //\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n  //\t\tconsole.log( A._boundProperties );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n  //\t\t\t} )\n  //\n  //\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n  //\t\tconsole.log( A._boundProperties );\n  //\n  //\t\t\tMap( {\n  //\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n  //\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n  //\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] },\n  //\t\t\t\td: { observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n  //\t\t\t} )\n  //\n  // @private\n  // @type {Map}\n\n  Object.defineProperty(observable, boundPropertiesSymbol, {\n    value: new Map()\n  });\n} // A chaining for {@link module:utils/observablemixin~ObservableMixin#bind} providing `.to()` interface.\n//\n// @private\n// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.\n\n\nfunction bindTo() {\n  const parsedArgs = parseBindToArgs(...arguments);\n  const bindingsKeys = Array.from(this._bindings.keys());\n  const numberOfBindings = bindingsKeys.length; // Eliminate A.bind( 'x' ).to( B, C )\n\n  if (!parsedArgs.callback && parsedArgs.to.length > 1) {\n    /**\n     * Binding multiple observables only possible with callback.\n     *\n     * @error observable-bind-to-no-callback\n     */\n    throw new CKEditorError('observable-bind-to-no-callback', this);\n  } // Eliminate A.bind( 'x', 'y' ).to( B, callback )\n\n\n  if (numberOfBindings > 1 && parsedArgs.callback) {\n    /**\n     * Cannot bind multiple properties and use a callback in one binding.\n     *\n     * @error observable-bind-to-extra-callback\n     */\n    throw new CKEditorError('observable-bind-to-extra-callback', this);\n  }\n\n  parsedArgs.to.forEach(to => {\n    // Eliminate A.bind( 'x', 'y' ).to( B, 'a' )\n    if (to.properties.length && to.properties.length !== numberOfBindings) {\n      /**\n       * The number of properties must match.\n       *\n       * @error observable-bind-to-properties-length\n       */\n      throw new CKEditorError('observable-bind-to-properties-length', this);\n    } // When no to.properties specified, observing source properties instead i.e.\n    // A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y\n\n\n    if (!to.properties.length) {\n      to.properties = this._bindProperties;\n    }\n  });\n  this._to = parsedArgs.to; // Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.\n\n  if (parsedArgs.callback) {\n    this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;\n  }\n\n  attachBindToListeners(this._observable, this._to); // Update observable._boundProperties and observable._boundObservables.\n\n  updateBindToBound(this); // Set initial values of bound properties.\n\n  this._bindProperties.forEach(propertyName => {\n    updateBoundObservableProperty(this._observable, propertyName);\n  });\n} // Binds to an attribute in a set of iterable observables.\n//\n// @private\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @param {Function} callback\n\n\nfunction bindToMany(observables, attribute, callback) {\n  if (this._bindings.size > 1) {\n    /**\n     * Binding one attribute to many observables only possible with one attribute.\n     *\n     * @error observable-bind-to-many-not-one-binding\n     */\n    throw new CKEditorError('observable-bind-to-many-not-one-binding', this);\n  }\n\n  this.to( // Bind to #attribute of each observable...\n  ...getBindingTargets(observables, attribute), // ...using given callback to parse attribute values.\n  callback);\n} // Returns an array of binding components for\n// {@link Observable#bind} from a set of iterable observables.\n//\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @returns {Array.<String|Observable>}\n\n\nfunction getBindingTargets(observables, attribute) {\n  const observableAndAttributePairs = observables.map(observable => [observable, attribute]); // Merge pairs to one-dimension array of observables and attributes.\n\n  return Array.prototype.concat.apply([], observableAndAttributePairs);\n} // Check if all entries of the array are of `String` type.\n//\n// @private\n// @param {Array} arr An array to be checked.\n// @returns {Boolean}\n\n\nfunction isStringArray(arr) {\n  return arr.every(a => typeof a == 'string');\n} // Parses and validates {@link Observable#bind}`.to( args )` arguments and returns\n// an object with a parsed structure. For example\n//\n//\t\tA.bind( 'x' ).to( B, 'a', C, 'b', call );\n//\n// becomes\n//\n//\t\t{\n//\t\t\tto: [\n//\t\t\t\t{ observable: B, properties: [ 'a' ] },\n//\t\t\t\t{ observable: C, properties: [ 'b' ] },\n//\t\t\t],\n//\t\t\tcallback: call\n// \t\t}\n//\n// @private\n// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.\n// @returns {Object}\n\n\nfunction parseBindToArgs() {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  // Eliminate A.bind( 'x' ).to()\n  if (!args.length) {\n    /**\n     * Invalid argument syntax in `to()`.\n     *\n     * @error observable-bind-to-parse-error\n     */\n    throw new CKEditorError('observable-bind-to-parse-error', null);\n  }\n\n  const parsed = {\n    to: []\n  };\n  let lastObservable;\n\n  if (typeof args[args.length - 1] == 'function') {\n    parsed.callback = args.pop();\n  }\n\n  args.forEach(a => {\n    if (typeof a == 'string') {\n      lastObservable.properties.push(a);\n    } else if (typeof a == 'object') {\n      lastObservable = {\n        observable: a,\n        properties: []\n      };\n      parsed.to.push(lastObservable);\n    } else {\n      throw new CKEditorError('observable-bind-to-parse-error', null);\n    }\n  });\n  return parsed;\n} // Synchronizes {@link module:utils/observablemixin#_boundObservables} with {@link Binding}.\n//\n// @private\n// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.\n// @param {Observable} toObservable A observable, which is a new component of `binding`.\n// @param {String} toPropertyName A name of `toObservable`'s property, a new component of the `binding`.\n\n\nfunction updateBoundObservables(observable, binding, toObservable, toPropertyName) {\n  const boundObservables = observable[boundObservablesSymbol];\n  const bindingsToObservable = boundObservables.get(toObservable);\n  const bindings = bindingsToObservable || {};\n\n  if (!bindings[toPropertyName]) {\n    bindings[toPropertyName] = new Set();\n  } // Pass the binding to a corresponding Set in `observable._boundObservables`.\n\n\n  bindings[toPropertyName].add(binding);\n\n  if (!bindingsToObservable) {\n    boundObservables.set(toObservable, bindings);\n  }\n} // Synchronizes {@link Observable#_boundProperties} and {@link Observable#_boundObservables}\n// with {@link BindChain}.\n//\n// Assuming the following binding being created\n//\n// \t\tA.bind( 'a', 'b' ).to( B, 'x', 'y' );\n//\n// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [] },\n// \t\t\tb: { observable: A, property: 'b', to: [] },\n// \t\t}\n//\n// Iterate over all bindings in this chain and fill their `to` properties with\n// corresponding to( ... ) arguments (components of the binding), so\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [ B, 'x' ] },\n// \t\t\tb: { observable: A, property: 'b', to: [ B, 'y' ] },\n// \t\t}\n//\n// Then update the structure of {@link Observable#_boundObservables} with updated\n// binding, so it becomes:\n//\n// \t\tMap( {\n// \t\t\tB: {\n// \t\t\t\tx: Set( [\n// \t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] }\n// \t\t\t\t] ),\n// \t\t\t\ty: Set( [\n// \t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n// \t\t\t\t] )\n//\t\t\t}\n// \t\t} )\n//\n// @private\n// @param {BindChain} chain The binding initialized by {@link Observable#bind}.\n\n\nfunction updateBindToBound(chain) {\n  let toProperty;\n\n  chain._bindings.forEach((binding, propertyName) => {\n    // Note: For a binding without a callback, this will run only once\n    // like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )\n    // TODO: ES6 destructuring.\n    chain._to.forEach(to => {\n      toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];\n      binding.to.push([to.observable, toProperty]);\n      updateBoundObservables(chain._observable, binding, to.observable, toProperty);\n    });\n  });\n} // Updates an property of a {@link Observable} with a value\n// determined by an entry in {@link Observable#_boundProperties}.\n//\n// @private\n// @param {Observable} observable A observable which property is to be updated.\n// @param {String} propertyName An property to be updated.\n\n\nfunction updateBoundObservableProperty(observable, propertyName) {\n  const boundProperties = observable[boundPropertiesSymbol];\n  const binding = boundProperties.get(propertyName);\n  let propertyValue; // When a binding with callback is created like\n  //\n  // \t\tA.bind( 'a' ).to( B, 'b', C, 'c', callback );\n  //\n  // collect B.b and C.c, then pass them to callback to set A.a.\n\n  if (binding.callback) {\n    propertyValue = binding.callback.apply(observable, binding.to.map(to => to[0][to[1]]));\n  } else {\n    propertyValue = binding.to[0];\n    propertyValue = propertyValue[0][propertyValue[1]];\n  }\n\n  if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {\n    observable[propertyName] = propertyValue;\n  } else {\n    observable.set(propertyName, propertyValue);\n  }\n} // Starts listening to changes in {@link BindChain._to} observables to update\n// {@link BindChain._observable} {@link BindChain._bindProperties}. Also sets the\n// initial state of {@link BindChain._observable}.\n//\n// @private\n// @param {BindChain} chain The chain initialized by {@link Observable#bind}.\n\n\nfunction attachBindToListeners(observable, toBindings) {\n  toBindings.forEach(to => {\n    const boundObservables = observable[boundObservablesSymbol];\n    let bindings; // If there's already a chain between the observables (`observable` listens to\n    // `to.observable`), there's no need to create another `change` event listener.\n\n    if (!boundObservables.get(to.observable)) {\n      observable.listenTo(to.observable, 'change', (evt, propertyName) => {\n        bindings = boundObservables.get(to.observable)[propertyName]; // Note: to.observable will fire for any property change, react\n        // to changes of properties which are bound only.\n\n        if (bindings) {\n          bindings.forEach(binding => {\n            updateBoundObservableProperty(observable, binding.property);\n          });\n        }\n      });\n    }\n  });\n}\n/**\n * An interface which adds \"observable properties\" and data binding functionality.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/observablemixin~ObservableMixin} mixin.\n *\n * Read more about the usage of this interface in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide,\n * * {@glink framework/guides/deep-dive/observables Observables deep dive} guide.\n *\n * @interface Observable\n * @extends module:utils/emittermixin~Emitter\n */\n\n/**\n * Fired when a property changed value.\n *\n *\t\tobservable.set( 'prop', 1 );\n *\n *\t\tobservable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `${ propertyName } has changed from ${ oldValue } to ${ newValue }` );\n *\t\t} );\n *\n *\t\tobservable.prop = 2; // -> 'prop has changed from 1 to 2'\n *\n * @event change:{property}\n * @param {String} name The property name.\n * @param {*} value The new property value.\n * @param {*} oldValue The previous property value.\n */\n\n/**\n * Fired when a property value is going to be set but is not set yet (before the `change` event is fired).\n *\n * You can control the final value of the property by using\n * the {@link module:utils/eventinfo~EventInfo#return event's `return` property}.\n *\n *\t\tobservable.set( 'prop', 1 );\n *\n *\t\tobservable.on( 'set:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `Value is going to be changed from ${ oldValue } to ${ newValue }` );\n *\t\t\tconsole.log( `Current property value is ${ observable[ propertyName ] }` );\n *\n *\t\t\t// Let's override the value.\n *\t\t\tevt.return = 3;\n *\t\t} );\n *\n *\t\tobservable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `Value has changed from ${ oldValue } to ${ newValue }` );\n *\t\t} );\n *\n *\t\tobservable.prop = 2; // -> 'Value is going to be changed from 1 to 2'\n *\t\t                     // -> 'Current property value is 1'\n *\t\t                     // -> 'Value has changed from 1 to 3'\n *\n * **Note:** The event is fired even when the new value is the same as the old value.\n *\n * @event set:{property}\n * @param {String} name The property name.\n * @param {*} value The new property value.\n * @param {*} oldValue The previous property value.\n */\n\n/**\n * Creates and sets the value of an observable property of this object. Such a property becomes a part\n * of the state and is observable.\n *\n * It accepts also a single object literal containing key/value pairs with properties to be set.\n *\n * This method throws the `observable-set-cannot-override` error if the observable instance already\n * has a property with the given property name. This prevents from mistakenly overriding existing\n * properties and methods, but means that `foo.set( 'bar', 1 )` may be slightly slower than `foo.bar = 1`.\n *\n * @method #set\n * @param {String|Object} name The property's name or object with `name=>value` pairs.\n * @param {*} [value] The property's value (if `name` was passed in the first parameter).\n */\n\n/**\n * Binds {@link #set observable properties} to other objects implementing the\n * {@link module:utils/observablemixin~Observable} interface.\n *\n * Read more in the {@glink framework/guides/deep-dive/observables#property-bindings dedicated guide}\n * covering the topic of property bindings with some additional examples.\n *\n * Consider two objects: a `button` and an associated `command` (both `Observable`).\n *\n * A simple property binding could be as follows:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'isEnabled' );\n *\n * or even shorter:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command );\n *\n * which works in the following way:\n *\n * * `button.isEnabled` **instantly equals** `command.isEnabled`,\n * * whenever `command.isEnabled` changes, `button.isEnabled` will immediately reflect its value.\n *\n * **Note**: To release the binding, use {@link module:utils/observablemixin~Observable#unbind}.\n *\n * You can also \"rename\" the property in the binding by specifying the new name in the `to()` chain:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'isWorking' );\n *\n * It is possible to bind more than one property at a time to shorten the code:\n *\n *\t\tbutton.bind( 'isEnabled', 'value' ).to( command );\n *\n * which corresponds to:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command );\n *\t\tbutton.bind( 'value' ).to( command );\n *\n * The binding can include more than one observable, combining multiple data sources in a custom callback:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'isEnabled', ui, 'isVisible',\n *\t\t\t( isCommandEnabled, isUIVisible ) => isCommandEnabled && isUIVisible );\n *\n * Using a custom callback allows processing the value before passing it to the target property:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'value', value => value === 'heading1' );\n *\n * It is also possible to bind to the same property in an array of observables.\n * To bind a `button` to multiple commands (also `Observables`) so that each and every one of them\n * must be enabled for the button to become enabled, use the following code:\n *\n *\t\tbutton.bind( 'isEnabled' ).toMany( [ commandA, commandB, commandC ], 'isEnabled',\n *\t\t\t( isAEnabled, isBEnabled, isCEnabled ) => isAEnabled && isBEnabled && isCEnabled );\n *\n * @method #bind\n * @param {...String} bindProperties Observable properties that will be bound to other observable(s).\n * @returns {Object} The bind chain with the `to()` and `toMany()` methods.\n */\n\n/**\n * Removes the binding created with {@link #bind}.\n *\n *\t\t// Removes the binding for the 'a' property.\n *\t\tA.unbind( 'a' );\n *\n *\t\t// Removes bindings for all properties.\n *\t\tA.unbind();\n *\n * @method #unbind\n * @param {...String} [unbindProperties] Observable properties to be unbound. All the bindings will\n * be released if no properties are provided.\n */\n\n/**\n * Turns the given methods of this object into event-based ones. This means that the new method will fire an event\n * (named after the method) and the original action will be plugged as a listener to that event.\n *\n * Read more in the {@glink framework/guides/deep-dive/observables#decorating-object-methods dedicated guide}\n * covering the topic of decorating methods with some additional examples.\n *\n * Decorating the method does not change its behavior (it only adds an event),\n * but it allows to modify it later on by listening to the method's event.\n *\n * For example, to cancel the method execution the event can be {@link module:utils/eventinfo~EventInfo#stop stopped}:\n *\n *\t\tclass Foo {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.decorate( 'method' );\n *\t\t\t}\n *\n *\t\t\tmethod() {\n *\t\t\t\tconsole.log( 'called!' );\n *\t\t\t}\n *\t\t}\n *\n *\t\tconst foo = new Foo();\n *\t\tfoo.on( 'method', ( evt ) => {\n *\t\t\tevt.stop();\n *\t\t}, { priority: 'high' } );\n *\n *\t\tfoo.method(); // Nothing is logged.\n *\n *\n * **Note**: The high {@link module:utils/priorities~PriorityString priority} listener\n * has been used to execute this particular callback before the one which calls the original method\n * (which uses the \"normal\" priority).\n *\n * It is also possible to change the returned value:\n *\n *\t\tfoo.on( 'method', ( evt ) => {\n *\t\t\tevt.return = 'Foo!';\n *\t\t} );\n *\n *\t\tfoo.method(); // -> 'Foo'\n *\n * Finally, it is possible to access and modify the arguments the method is called with:\n *\n *\t\tmethod( a, b ) {\n *\t\t\tconsole.log( `${ a }, ${ b }`  );\n *\t\t}\n *\n *\t\t// ...\n *\n *\t\tfoo.on( 'method', ( evt, args ) => {\n *\t\t\targs[ 0 ] = 3;\n *\n *\t\t\tconsole.log( args[ 1 ] ); // -> 2\n *\t\t}, { priority: 'high' } );\n *\n *\t\tfoo.method( 1, 2 ); // -> '3, 2'\n *\n * @method #decorate\n * @param {String} methodName Name of the method to decorate.\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/observablemixin.js"],"names":["EmitterMixin","CKEditorError","extend","isObject","observablePropertiesSymbol","Symbol","boundObservablesSymbol","boundPropertiesSymbol","_decoratedMethods","_decoratedOriginal","ObservableMixin","set","name","value","Object","keys","forEach","property","initObservable","properties","has","defineProperty","enumerable","configurable","get","oldValue","newValue","fire","undefined","bind","bindProperties","length","isStringArray","Set","size","boundProperties","propertyName","bindings","Map","a","binding","to","bindTo","toMany","bindToMany","_observable","_bindProperties","_to","_bindings","unbind","boundObservables","unbindProperties","toObservable","toProperty","toProperties","toPropertyBindings","delete","stopListening","boundObservable","clear","decorate","methodName","originalMethod","object","on","evt","args","return","apply","push","emitter","event","callback","call","observable","parsedArgs","parseBindToArgs","bindingsKeys","Array","from","numberOfBindings","attachBindToListeners","updateBindToBound","updateBoundObservableProperty","observables","attribute","getBindingTargets","observableAndAttributePairs","map","prototype","concat","arr","every","parsed","lastObservable","pop","updateBoundObservables","toPropertyName","bindingsToObservable","add","chain","indexOf","propertyValue","hasOwnProperty","toBindings","listenTo"],"mappings":"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AACa,gBAAgB,CAAC1B,GAAjB,CAAsBiB,EAAE,CAACiC,UAAzB,CAAN,EAA8C;AAC7CA,MAAAA,UAAU,CAAC+B,QAAX,CAAqBhE,EAAE,CAACiC,UAAxB,EAAoC,QAApC,EAA8C,CAAET,GAAF,EAAO7B,YAAP,KAAyB;AACtEC,QAAAA,QAAQ,GAAGa,gBAAgB,CAAC1B,GAAjB,CAAsBiB,EAAE,CAACiC,UAAzB,EAAuCtC,YAAvC,CAAX,CADsE,CAGtE;AACA;;AACA,YAAKC,QAAL,EAAgB;AACfA,UAAAA,QAAQ,CAACrB,OAAT,CAAkBwB,OAAO,IAAI;AAC5B2C,YAAAA,6BAA6B,CAAET,UAAF,EAAclC,OAAO,CAACvB,QAAtB,CAA7B;AACA,WAFD;AAGA;AACD,OAVD;AAWA;AACD,GAnBD;AAoBA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/observablemixin\n */\n\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport { extend, isObject } from 'lodash-es';\n\nconst observablePropertiesSymbol = Symbol( 'observableProperties' );\nconst boundObservablesSymbol = Symbol( 'boundObservables' );\nconst boundPropertiesSymbol = Symbol( 'boundProperties' );\n\nconst _decoratedMethods = Symbol( 'decoratedMethods' );\nconst _decoratedOriginal = Symbol( 'decoratedOriginal' );\n\n/**\n * A mixin that injects the \"observable properties\" and data binding functionality described in the\n * {@link ~Observable} interface.\n *\n * Read more about the concept of observables in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide,\n * * {@glink framework/guides/deep-dive/observables Observables deep dive} guide.\n *\n * @mixin ObservableMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/observablemixin~Observable\n */\nconst ObservableMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\tset( name, value ) {\n\t\t// If the first parameter is an Object, iterate over its properties.\n\t\tif ( isObject( name ) ) {\n\t\t\tObject.keys( name ).forEach( property => {\n\t\t\t\tthis.set( property, name[ property ] );\n\t\t\t}, this );\n\n\t\t\treturn;\n\t\t}\n\n\t\tinitObservable( this );\n\n\t\tconst properties = this[ observablePropertiesSymbol ];\n\n\t\tif ( ( name in this ) && !properties.has( name ) ) {\n\t\t\t/**\n\t\t\t * Cannot override an existing property.\n\t\t\t *\n\t\t\t * This error is thrown when trying to {@link ~Observable#set set} a property with\n\t\t\t * a name of an already existing property. For example:\n\t\t\t *\n\t\t\t *\t\tlet observable = new Model();\n\t\t\t *\t\tobservable.property = 1;\n\t\t\t *\t\tobservable.set( 'property', 2 );\t\t\t// throws\n\t\t\t *\n\t\t\t *\t\tobservable.set( 'property', 1 );\n\t\t\t *\t\tobservable.set( 'property', 2 );\t\t\t// ok, because this is an existing property.\n\t\t\t *\n\t\t\t * @error observable-set-cannot-override\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-set-cannot-override', this );\n\t\t}\n\n\t\tObject.defineProperty( this, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget() {\n\t\t\t\treturn properties.get( name );\n\t\t\t},\n\n\t\t\tset( value ) {\n\t\t\t\tconst oldValue = properties.get( name );\n\n\t\t\t\t// Fire `set` event before the new value will be set to make it possible\n\t\t\t\t// to override observable property without affecting `change` event.\n\t\t\t\t// See https://github.com/ckeditor/ckeditor5-utils/issues/171.\n\t\t\t\tlet newValue = this.fire( 'set:' + name, name, value, oldValue );\n\n\t\t\t\tif ( newValue === undefined ) {\n\t\t\t\t\tnewValue = value;\n\t\t\t\t}\n\n\t\t\t\t// Allow undefined as an initial value like A.define( 'x', undefined ) (#132).\n\t\t\t\t// Note: When properties map has no such own property, then its value is undefined.\n\t\t\t\tif ( oldValue !== newValue || !properties.has( name ) ) {\n\t\t\t\t\tproperties.set( name, newValue );\n\t\t\t\t\tthis.fire( 'change:' + name, name, newValue, oldValue );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\tthis[ name ] = value;\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tbind( ...bindProperties ) {\n\t\tif ( !bindProperties.length || !isStringArray( bindProperties ) ) {\n\t\t\t/**\n\t\t\t * All properties must be strings.\n\t\t\t *\n\t\t\t * @error observable-bind-wrong-properties\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-bind-wrong-properties', this );\n\t\t}\n\n\t\tif ( ( new Set( bindProperties ) ).size !== bindProperties.length ) {\n\t\t\t/**\n\t\t\t * Properties must be unique.\n\t\t\t *\n\t\t\t * @error observable-bind-duplicate-properties\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-bind-duplicate-properties', this );\n\t\t}\n\n\t\tinitObservable( this );\n\n\t\tconst boundProperties = this[ boundPropertiesSymbol ];\n\n\t\tbindProperties.forEach( propertyName => {\n\t\t\tif ( boundProperties.has( propertyName ) ) {\n\t\t\t\t/**\n\t\t\t\t * Cannot bind the same property more than once.\n\t\t\t\t *\n\t\t\t\t * @error observable-bind-rebind\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'observable-bind-rebind', this );\n\t\t\t}\n\t\t} );\n\n\t\tconst bindings = new Map();\n\n\t\t// @typedef {Object} Binding\n\t\t// @property {Array} property Property which is bound.\n\t\t// @property {Array} to Array of observable–property components of the binding (`{ observable: ..., property: .. }`).\n\t\t// @property {Array} callback A function which processes `to` components.\n\t\tbindProperties.forEach( a => {\n\t\t\tconst binding = { property: a, to: [] };\n\n\t\t\tboundProperties.set( a, binding );\n\t\t\tbindings.set( a, binding );\n\t\t} );\n\n\t\t// @typedef {Object} BindChain\n\t\t// @property {Function} to See {@link ~ObservableMixin#_bindTo}.\n\t\t// @property {Function} toMany See {@link ~ObservableMixin#_bindToMany}.\n\t\t// @property {module:utils/observablemixin~Observable} _observable The observable which initializes the binding.\n\t\t// @property {Array} _bindProperties Array of `_observable` properties to be bound.\n\t\t// @property {Array} _to Array of `to()` observable–properties (`{ observable: toObservable, properties: ...toProperties }`).\n\t\t// @property {Map} _bindings Stores bindings to be kept in\n\t\t// {@link ~ObservableMixin#_boundProperties}/{@link ~ObservableMixin#_boundObservables}\n\t\t// initiated in this binding chain.\n\t\treturn {\n\t\t\tto: bindTo,\n\t\t\ttoMany: bindToMany,\n\n\t\t\t_observable: this,\n\t\t\t_bindProperties: bindProperties,\n\t\t\t_to: [],\n\t\t\t_bindings: bindings\n\t\t};\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tunbind( ...unbindProperties ) {\n\t\t// Nothing to do here if not inited yet.\n\t\tif ( !( this[ observablePropertiesSymbol ] ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst boundProperties = this[ boundPropertiesSymbol ];\n\t\tconst boundObservables = this[ boundObservablesSymbol ];\n\n\t\tif ( unbindProperties.length ) {\n\t\t\tif ( !isStringArray( unbindProperties ) ) {\n\t\t\t\t/**\n\t\t\t\t * Properties must be strings.\n\t\t\t\t *\n\t\t\t\t * @error observable-unbind-wrong-properties\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'observable-unbind-wrong-properties', this );\n\t\t\t}\n\n\t\t\tunbindProperties.forEach( propertyName => {\n\t\t\t\tconst binding = boundProperties.get( propertyName );\n\n\t\t\t\t// Nothing to do if the binding is not defined\n\t\t\t\tif ( !binding ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet toObservable, toProperty, toProperties, toPropertyBindings;\n\n\t\t\t\tbinding.to.forEach( to => {\n\t\t\t\t\t// TODO: ES6 destructuring.\n\t\t\t\t\ttoObservable = to[ 0 ];\n\t\t\t\t\ttoProperty = to[ 1 ];\n\t\t\t\t\ttoProperties = boundObservables.get( toObservable );\n\t\t\t\t\ttoPropertyBindings = toProperties[ toProperty ];\n\n\t\t\t\t\ttoPropertyBindings.delete( binding );\n\n\t\t\t\t\tif ( !toPropertyBindings.size ) {\n\t\t\t\t\t\tdelete toProperties[ toProperty ];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !Object.keys( toProperties ).length ) {\n\t\t\t\t\t\tboundObservables.delete( toObservable );\n\t\t\t\t\t\tthis.stopListening( toObservable, 'change' );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tboundProperties.delete( propertyName );\n\t\t\t} );\n\t\t} else {\n\t\t\tboundObservables.forEach( ( bindings, boundObservable ) => {\n\t\t\t\tthis.stopListening( boundObservable, 'change' );\n\t\t\t} );\n\n\t\t\tboundObservables.clear();\n\t\t\tboundProperties.clear();\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdecorate( methodName ) {\n\t\tconst originalMethod = this[ methodName ];\n\n\t\tif ( !originalMethod ) {\n\t\t\t/**\n\t\t\t * Cannot decorate an undefined method.\n\t\t\t *\n\t\t\t * @error observablemixin-cannot-decorate-undefined\n\t\t\t * @param {Object} object The object which method should be decorated.\n\t\t\t * @param {String} methodName Name of the method which does not exist.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'observablemixin-cannot-decorate-undefined',\n\t\t\t\tthis,\n\t\t\t\t{ object: this, methodName }\n\t\t\t);\n\t\t}\n\n\t\tthis.on( methodName, ( evt, args ) => {\n\t\t\tevt.return = originalMethod.apply( this, args );\n\t\t} );\n\n\t\tthis[ methodName ] = function( ...args ) {\n\t\t\treturn this.fire( methodName, args );\n\t\t};\n\n\t\tthis[ methodName ][ _decoratedOriginal ] = originalMethod;\n\n\t\tif ( !this[ _decoratedMethods ] ) {\n\t\t\tthis[ _decoratedMethods ] = [];\n\t\t}\n\n\t\tthis[ _decoratedMethods ].push( methodName );\n\t}\n};\n\nextend( ObservableMixin, EmitterMixin );\n\n// Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.\n// This is needed in case of:\n//  1. Have x.foo() decorated.\n//  2. Call x.stopListening()\n//  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)\nObservableMixin.stopListening = function( emitter, event, callback ) {\n\t// Removing all listeners so let's clean the decorated methods to the original state.\n\tif ( !emitter && this[ _decoratedMethods ] ) {\n\t\tfor ( const methodName of this[ _decoratedMethods ] ) {\n\t\t\tthis[ methodName ] = this[ methodName ][ _decoratedOriginal ];\n\t\t}\n\n\t\tdelete this[ _decoratedMethods ];\n\t}\n\n\tEmitterMixin.stopListening.call( this, emitter, event, callback );\n};\n\nexport default ObservableMixin;\n\n// Init symbol properties needed for the observable mechanism to work.\n//\n// @private\n// @param {module:utils/observablemixin~ObservableMixin} observable\nfunction initObservable( observable ) {\n\t// Do nothing if already inited.\n\tif ( observable[ observablePropertiesSymbol ] ) {\n\t\treturn;\n\t}\n\n\t// The internal hash containing the observable's state.\n\t//\n\t// @private\n\t// @type {Map}\n\tObject.defineProperty( observable, observablePropertiesSymbol, {\n\t\tvalue: new Map()\n\t} );\n\n\t// Map containing bindings to external observables. It shares the binding objects\n\t// (`{ observable: A, property: 'a', to: ... }`) with {@link module:utils/observablemixin~ObservableMixin#_boundProperties} and\n\t// it is used to observe external observables to update own properties accordingly.\n\t// See {@link module:utils/observablemixin~ObservableMixin#bind}.\n\t//\n\t//\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n\t//\t\tconsole.log( A._boundObservables );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\tB: {\n\t//\t\t\t\t\tx: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n\t//\t\t\t\t\t] ),\n\t//\t\t\t\t\ty: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\t\t] )\n\t//\t\t\t\t}\n\t//\t\t\t} )\n\t//\n\t//\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n\t//\t\tconsole.log( A._boundObservables );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\tB: {\n\t//\t\t\t\t\tx: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n\t//\t\t\t\t\t] ),\n\t//\t\t\t\t\ty: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\t\t] ),\n\t//\t\t\t\t\tz: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n\t//\t\t\t\t\t] )\n\t//\t\t\t\t},\n\t//\t\t\t\tC: {\n\t//\t\t\t\t\tw: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n\t//\t\t\t\t\t] )\n\t//\t\t\t\t}\n\t//\t\t\t} )\n\t//\n\t// @private\n\t// @type {Map}\n\tObject.defineProperty( observable, boundObservablesSymbol, {\n\t\tvalue: new Map()\n\t} );\n\n\t// Object that stores which properties of this observable are bound and how. It shares\n\t// the binding objects (`{ observable: A, property: 'a', to: ... }`) with\n\t// {@link module:utils/observablemixin~ObservableMixin#_boundObservables}. This data structure is\n\t// a reverse of {@link module:utils/observablemixin~ObservableMixin#_boundObservables} and it is helpful for\n\t// {@link module:utils/observablemixin~ObservableMixin#unbind}.\n\t//\n\t// See {@link module:utils/observablemixin~ObservableMixin#bind}.\n\t//\n\t//\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n\t//\t\tconsole.log( A._boundProperties );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n\t//\t\t\t} )\n\t//\n\t//\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n\t//\t\tconsole.log( A._boundProperties );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\td: { observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n\t//\t\t\t} )\n\t//\n\t// @private\n\t// @type {Map}\n\tObject.defineProperty( observable, boundPropertiesSymbol, {\n\t\tvalue: new Map()\n\t} );\n}\n\n// A chaining for {@link module:utils/observablemixin~ObservableMixin#bind} providing `.to()` interface.\n//\n// @private\n// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.\nfunction bindTo( ...args ) {\n\tconst parsedArgs = parseBindToArgs( ...args );\n\tconst bindingsKeys = Array.from( this._bindings.keys() );\n\tconst numberOfBindings = bindingsKeys.length;\n\n\t// Eliminate A.bind( 'x' ).to( B, C )\n\tif ( !parsedArgs.callback && parsedArgs.to.length > 1 ) {\n\t\t/**\n\t\t * Binding multiple observables only possible with callback.\n\t\t *\n\t\t * @error observable-bind-to-no-callback\n\t\t */\n\t\tthrow new CKEditorError( 'observable-bind-to-no-callback', this );\n\t}\n\n\t// Eliminate A.bind( 'x', 'y' ).to( B, callback )\n\tif ( numberOfBindings > 1 && parsedArgs.callback ) {\n\t\t/**\n\t\t * Cannot bind multiple properties and use a callback in one binding.\n\t\t *\n\t\t * @error observable-bind-to-extra-callback\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'observable-bind-to-extra-callback',\n\t\t\tthis\n\t\t);\n\t}\n\n\tparsedArgs.to.forEach( to => {\n\t\t// Eliminate A.bind( 'x', 'y' ).to( B, 'a' )\n\t\tif ( to.properties.length && to.properties.length !== numberOfBindings ) {\n\t\t\t/**\n\t\t\t * The number of properties must match.\n\t\t\t *\n\t\t\t * @error observable-bind-to-properties-length\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-bind-to-properties-length', this );\n\t\t}\n\n\t\t// When no to.properties specified, observing source properties instead i.e.\n\t\t// A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y\n\t\tif ( !to.properties.length ) {\n\t\t\tto.properties = this._bindProperties;\n\t\t}\n\t} );\n\n\tthis._to = parsedArgs.to;\n\n\t// Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.\n\tif ( parsedArgs.callback ) {\n\t\tthis._bindings.get( bindingsKeys[ 0 ] ).callback = parsedArgs.callback;\n\t}\n\n\tattachBindToListeners( this._observable, this._to );\n\n\t// Update observable._boundProperties and observable._boundObservables.\n\tupdateBindToBound( this );\n\n\t// Set initial values of bound properties.\n\tthis._bindProperties.forEach( propertyName => {\n\t\tupdateBoundObservableProperty( this._observable, propertyName );\n\t} );\n}\n\n// Binds to an attribute in a set of iterable observables.\n//\n// @private\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @param {Function} callback\nfunction bindToMany( observables, attribute, callback ) {\n\tif ( this._bindings.size > 1 ) {\n\t\t/**\n\t\t * Binding one attribute to many observables only possible with one attribute.\n\t\t *\n\t\t * @error observable-bind-to-many-not-one-binding\n\t\t */\n\t\tthrow new CKEditorError( 'observable-bind-to-many-not-one-binding', this );\n\t}\n\n\tthis.to(\n\t\t// Bind to #attribute of each observable...\n\t\t...getBindingTargets( observables, attribute ),\n\t\t// ...using given callback to parse attribute values.\n\t\tcallback\n\t);\n}\n\n// Returns an array of binding components for\n// {@link Observable#bind} from a set of iterable observables.\n//\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @returns {Array.<String|Observable>}\nfunction getBindingTargets( observables, attribute ) {\n\tconst observableAndAttributePairs = observables.map( observable => [ observable, attribute ] );\n\n\t// Merge pairs to one-dimension array of observables and attributes.\n\treturn Array.prototype.concat.apply( [], observableAndAttributePairs );\n}\n\n// Check if all entries of the array are of `String` type.\n//\n// @private\n// @param {Array} arr An array to be checked.\n// @returns {Boolean}\nfunction isStringArray( arr ) {\n\treturn arr.every( a => typeof a == 'string' );\n}\n\n// Parses and validates {@link Observable#bind}`.to( args )` arguments and returns\n// an object with a parsed structure. For example\n//\n//\t\tA.bind( 'x' ).to( B, 'a', C, 'b', call );\n//\n// becomes\n//\n//\t\t{\n//\t\t\tto: [\n//\t\t\t\t{ observable: B, properties: [ 'a' ] },\n//\t\t\t\t{ observable: C, properties: [ 'b' ] },\n//\t\t\t],\n//\t\t\tcallback: call\n// \t\t}\n//\n// @private\n// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.\n// @returns {Object}\nfunction parseBindToArgs( ...args ) {\n\t// Eliminate A.bind( 'x' ).to()\n\tif ( !args.length ) {\n\t\t/**\n\t\t * Invalid argument syntax in `to()`.\n\t\t *\n\t\t * @error observable-bind-to-parse-error\n\t\t */\n\t\tthrow new CKEditorError( 'observable-bind-to-parse-error', null );\n\t}\n\n\tconst parsed = { to: [] };\n\tlet lastObservable;\n\n\tif ( typeof args[ args.length - 1 ] == 'function' ) {\n\t\tparsed.callback = args.pop();\n\t}\n\n\targs.forEach( a => {\n\t\tif ( typeof a == 'string' ) {\n\t\t\tlastObservable.properties.push( a );\n\t\t} else if ( typeof a == 'object' ) {\n\t\t\tlastObservable = { observable: a, properties: [] };\n\t\t\tparsed.to.push( lastObservable );\n\t\t} else {\n\t\t\tthrow new CKEditorError( 'observable-bind-to-parse-error', null );\n\t\t}\n\t} );\n\n\treturn parsed;\n}\n\n// Synchronizes {@link module:utils/observablemixin#_boundObservables} with {@link Binding}.\n//\n// @private\n// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.\n// @param {Observable} toObservable A observable, which is a new component of `binding`.\n// @param {String} toPropertyName A name of `toObservable`'s property, a new component of the `binding`.\nfunction updateBoundObservables( observable, binding, toObservable, toPropertyName ) {\n\tconst boundObservables = observable[ boundObservablesSymbol ];\n\tconst bindingsToObservable = boundObservables.get( toObservable );\n\tconst bindings = bindingsToObservable || {};\n\n\tif ( !bindings[ toPropertyName ] ) {\n\t\tbindings[ toPropertyName ] = new Set();\n\t}\n\n\t// Pass the binding to a corresponding Set in `observable._boundObservables`.\n\tbindings[ toPropertyName ].add( binding );\n\n\tif ( !bindingsToObservable ) {\n\t\tboundObservables.set( toObservable, bindings );\n\t}\n}\n\n// Synchronizes {@link Observable#_boundProperties} and {@link Observable#_boundObservables}\n// with {@link BindChain}.\n//\n// Assuming the following binding being created\n//\n// \t\tA.bind( 'a', 'b' ).to( B, 'x', 'y' );\n//\n// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [] },\n// \t\t\tb: { observable: A, property: 'b', to: [] },\n// \t\t}\n//\n// Iterate over all bindings in this chain and fill their `to` properties with\n// corresponding to( ... ) arguments (components of the binding), so\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [ B, 'x' ] },\n// \t\t\tb: { observable: A, property: 'b', to: [ B, 'y' ] },\n// \t\t}\n//\n// Then update the structure of {@link Observable#_boundObservables} with updated\n// binding, so it becomes:\n//\n// \t\tMap( {\n// \t\t\tB: {\n// \t\t\t\tx: Set( [\n// \t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] }\n// \t\t\t\t] ),\n// \t\t\t\ty: Set( [\n// \t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n// \t\t\t\t] )\n//\t\t\t}\n// \t\t} )\n//\n// @private\n// @param {BindChain} chain The binding initialized by {@link Observable#bind}.\nfunction updateBindToBound( chain ) {\n\tlet toProperty;\n\n\tchain._bindings.forEach( ( binding, propertyName ) => {\n\t\t// Note: For a binding without a callback, this will run only once\n\t\t// like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )\n\t\t// TODO: ES6 destructuring.\n\t\tchain._to.forEach( to => {\n\t\t\ttoProperty = to.properties[ binding.callback ? 0 : chain._bindProperties.indexOf( propertyName ) ];\n\n\t\t\tbinding.to.push( [ to.observable, toProperty ] );\n\t\t\tupdateBoundObservables( chain._observable, binding, to.observable, toProperty );\n\t\t} );\n\t} );\n}\n\n// Updates an property of a {@link Observable} with a value\n// determined by an entry in {@link Observable#_boundProperties}.\n//\n// @private\n// @param {Observable} observable A observable which property is to be updated.\n// @param {String} propertyName An property to be updated.\nfunction updateBoundObservableProperty( observable, propertyName ) {\n\tconst boundProperties = observable[ boundPropertiesSymbol ];\n\tconst binding = boundProperties.get( propertyName );\n\tlet propertyValue;\n\n\t// When a binding with callback is created like\n\t//\n\t// \t\tA.bind( 'a' ).to( B, 'b', C, 'c', callback );\n\t//\n\t// collect B.b and C.c, then pass them to callback to set A.a.\n\tif ( binding.callback ) {\n\t\tpropertyValue = binding.callback.apply( observable, binding.to.map( to => to[ 0 ][ to[ 1 ] ] ) );\n\t} else {\n\t\tpropertyValue = binding.to[ 0 ];\n\t\tpropertyValue = propertyValue[ 0 ][ propertyValue[ 1 ] ];\n\t}\n\n\tif ( Object.prototype.hasOwnProperty.call( observable, propertyName ) ) {\n\t\tobservable[ propertyName ] = propertyValue;\n\t} else {\n\t\tobservable.set( propertyName, propertyValue );\n\t}\n}\n\n// Starts listening to changes in {@link BindChain._to} observables to update\n// {@link BindChain._observable} {@link BindChain._bindProperties}. Also sets the\n// initial state of {@link BindChain._observable}.\n//\n// @private\n// @param {BindChain} chain The chain initialized by {@link Observable#bind}.\nfunction attachBindToListeners( observable, toBindings ) {\n\ttoBindings.forEach( to => {\n\t\tconst boundObservables = observable[ boundObservablesSymbol ];\n\t\tlet bindings;\n\n\t\t// If there's already a chain between the observables (`observable` listens to\n\t\t// `to.observable`), there's no need to create another `change` event listener.\n\t\tif ( !boundObservables.get( to.observable ) ) {\n\t\t\tobservable.listenTo( to.observable, 'change', ( evt, propertyName ) => {\n\t\t\t\tbindings = boundObservables.get( to.observable )[ propertyName ];\n\n\t\t\t\t// Note: to.observable will fire for any property change, react\n\t\t\t\t// to changes of properties which are bound only.\n\t\t\t\tif ( bindings ) {\n\t\t\t\t\tbindings.forEach( binding => {\n\t\t\t\t\t\tupdateBoundObservableProperty( observable, binding.property );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n}\n\n/**\n * An interface which adds \"observable properties\" and data binding functionality.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/observablemixin~ObservableMixin} mixin.\n *\n * Read more about the usage of this interface in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide,\n * * {@glink framework/guides/deep-dive/observables Observables deep dive} guide.\n *\n * @interface Observable\n * @extends module:utils/emittermixin~Emitter\n */\n\n/**\n * Fired when a property changed value.\n *\n *\t\tobservable.set( 'prop', 1 );\n *\n *\t\tobservable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `${ propertyName } has changed from ${ oldValue } to ${ newValue }` );\n *\t\t} );\n *\n *\t\tobservable.prop = 2; // -> 'prop has changed from 1 to 2'\n *\n * @event change:{property}\n * @param {String} name The property name.\n * @param {*} value The new property value.\n * @param {*} oldValue The previous property value.\n */\n\n/**\n * Fired when a property value is going to be set but is not set yet (before the `change` event is fired).\n *\n * You can control the final value of the property by using\n * the {@link module:utils/eventinfo~EventInfo#return event's `return` property}.\n *\n *\t\tobservable.set( 'prop', 1 );\n *\n *\t\tobservable.on( 'set:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `Value is going to be changed from ${ oldValue } to ${ newValue }` );\n *\t\t\tconsole.log( `Current property value is ${ observable[ propertyName ] }` );\n *\n *\t\t\t// Let's override the value.\n *\t\t\tevt.return = 3;\n *\t\t} );\n *\n *\t\tobservable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `Value has changed from ${ oldValue } to ${ newValue }` );\n *\t\t} );\n *\n *\t\tobservable.prop = 2; // -> 'Value is going to be changed from 1 to 2'\n *\t\t                     // -> 'Current property value is 1'\n *\t\t                     // -> 'Value has changed from 1 to 3'\n *\n * **Note:** The event is fired even when the new value is the same as the old value.\n *\n * @event set:{property}\n * @param {String} name The property name.\n * @param {*} value The new property value.\n * @param {*} oldValue The previous property value.\n */\n\n/**\n * Creates and sets the value of an observable property of this object. Such a property becomes a part\n * of the state and is observable.\n *\n * It accepts also a single object literal containing key/value pairs with properties to be set.\n *\n * This method throws the `observable-set-cannot-override` error if the observable instance already\n * has a property with the given property name. This prevents from mistakenly overriding existing\n * properties and methods, but means that `foo.set( 'bar', 1 )` may be slightly slower than `foo.bar = 1`.\n *\n * @method #set\n * @param {String|Object} name The property's name or object with `name=>value` pairs.\n * @param {*} [value] The property's value (if `name` was passed in the first parameter).\n */\n\n/**\n * Binds {@link #set observable properties} to other objects implementing the\n * {@link module:utils/observablemixin~Observable} interface.\n *\n * Read more in the {@glink framework/guides/deep-dive/observables#property-bindings dedicated guide}\n * covering the topic of property bindings with some additional examples.\n *\n * Consider two objects: a `button` and an associated `command` (both `Observable`).\n *\n * A simple property binding could be as follows:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'isEnabled' );\n *\n * or even shorter:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command );\n *\n * which works in the following way:\n *\n * * `button.isEnabled` **instantly equals** `command.isEnabled`,\n * * whenever `command.isEnabled` changes, `button.isEnabled` will immediately reflect its value.\n *\n * **Note**: To release the binding, use {@link module:utils/observablemixin~Observable#unbind}.\n *\n * You can also \"rename\" the property in the binding by specifying the new name in the `to()` chain:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'isWorking' );\n *\n * It is possible to bind more than one property at a time to shorten the code:\n *\n *\t\tbutton.bind( 'isEnabled', 'value' ).to( command );\n *\n * which corresponds to:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command );\n *\t\tbutton.bind( 'value' ).to( command );\n *\n * The binding can include more than one observable, combining multiple data sources in a custom callback:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'isEnabled', ui, 'isVisible',\n *\t\t\t( isCommandEnabled, isUIVisible ) => isCommandEnabled && isUIVisible );\n *\n * Using a custom callback allows processing the value before passing it to the target property:\n *\n *\t\tbutton.bind( 'isEnabled' ).to( command, 'value', value => value === 'heading1' );\n *\n * It is also possible to bind to the same property in an array of observables.\n * To bind a `button` to multiple commands (also `Observables`) so that each and every one of them\n * must be enabled for the button to become enabled, use the following code:\n *\n *\t\tbutton.bind( 'isEnabled' ).toMany( [ commandA, commandB, commandC ], 'isEnabled',\n *\t\t\t( isAEnabled, isBEnabled, isCEnabled ) => isAEnabled && isBEnabled && isCEnabled );\n *\n * @method #bind\n * @param {...String} bindProperties Observable properties that will be bound to other observable(s).\n * @returns {Object} The bind chain with the `to()` and `toMany()` methods.\n */\n\n/**\n * Removes the binding created with {@link #bind}.\n *\n *\t\t// Removes the binding for the 'a' property.\n *\t\tA.unbind( 'a' );\n *\n *\t\t// Removes bindings for all properties.\n *\t\tA.unbind();\n *\n * @method #unbind\n * @param {...String} [unbindProperties] Observable properties to be unbound. All the bindings will\n * be released if no properties are provided.\n */\n\n/**\n * Turns the given methods of this object into event-based ones. This means that the new method will fire an event\n * (named after the method) and the original action will be plugged as a listener to that event.\n *\n * Read more in the {@glink framework/guides/deep-dive/observables#decorating-object-methods dedicated guide}\n * covering the topic of decorating methods with some additional examples.\n *\n * Decorating the method does not change its behavior (it only adds an event),\n * but it allows to modify it later on by listening to the method's event.\n *\n * For example, to cancel the method execution the event can be {@link module:utils/eventinfo~EventInfo#stop stopped}:\n *\n *\t\tclass Foo {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.decorate( 'method' );\n *\t\t\t}\n *\n *\t\t\tmethod() {\n *\t\t\t\tconsole.log( 'called!' );\n *\t\t\t}\n *\t\t}\n *\n *\t\tconst foo = new Foo();\n *\t\tfoo.on( 'method', ( evt ) => {\n *\t\t\tevt.stop();\n *\t\t}, { priority: 'high' } );\n *\n *\t\tfoo.method(); // Nothing is logged.\n *\n *\n * **Note**: The high {@link module:utils/priorities~PriorityString priority} listener\n * has been used to execute this particular callback before the one which calls the original method\n * (which uses the \"normal\" priority).\n *\n * It is also possible to change the returned value:\n *\n *\t\tfoo.on( 'method', ( evt ) => {\n *\t\t\tevt.return = 'Foo!';\n *\t\t} );\n *\n *\t\tfoo.method(); // -> 'Foo'\n *\n * Finally, it is possible to access and modify the arguments the method is called with:\n *\n *\t\tmethod( a, b ) {\n *\t\t\tconsole.log( `${ a }, ${ b }`  );\n *\t\t}\n *\n *\t\t// ...\n *\n *\t\tfoo.on( 'method', ( evt, args ) => {\n *\t\t\targs[ 0 ] = 3;\n *\n *\t\t\tconsole.log( args[ 1 ] ); // -> 2\n *\t\t}, { priority: 'high' } );\n *\n *\t\tfoo.method( 1, 2 ); // -> '3, 2'\n *\n * @method #decorate\n * @param {String} methodName Name of the method to decorate.\n */\n"]},"metadata":{},"sourceType":"module"}