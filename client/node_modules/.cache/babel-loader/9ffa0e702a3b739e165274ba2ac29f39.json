{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/model/documentfragment\n */\nimport NodeList from './nodelist';\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable'; // @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );\n\n/**\n * DocumentFragment represents a part of model which does not have a common root but its top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\n\nexport default class DocumentFragment {\n  /**\n   * Creates an empty `DocumentFragment`.\n   *\n   * **Note:** Constructor of this class shouldn't be used directly in the code.\n   * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n   *\n   * @protected\n   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n   * Nodes to be contained inside the `DocumentFragment`.\n   */\n  constructor(children) {\n    /**\n     * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n     * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n     * when DocumentFragment will be inserted to the document.\n     *\n     * @readonly\n     * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n     */\n    this.markers = new Map();\n    /**\n     * List of nodes contained inside the document fragment.\n     *\n     * @private\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n     */\n\n    this._children = new NodeList();\n\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Returns an iterator that iterates over all nodes contained inside this document fragment.\n   *\n   * @returns {Iterable.<module:engine/model/node~Node>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this.getChildren();\n  }\n  /**\n   * Number of this document fragment's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get maxOffset() {\n    return this._children.maxOffset;\n  }\n  /**\n   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isEmpty() {\n    return this.childCount === 0;\n  }\n  /**\n   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  get root() {\n    return this;\n  }\n  /**\n   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {null}\n   */\n\n\n  get parent() {\n    return null;\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   *\t\tdocFrag.is( 'documentFragment' ); // -> true\n   *\t\tdocFrag.is( 'model:documentFragment' ); // -> true\n   *\n   *\t\tdocFrag.is( 'view:documentFragment' ); // -> false\n   *\t\tdocFrag.is( 'element' ); // -> false\n   *\t\tdocFrag.is( 'node' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'documentFragment' || type === 'model:documentFragment';\n  }\n  /**\n   * Gets the child at the given index. Returns `null` if incorrect index was passed.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/model/node~Node|null} Child node.\n   */\n\n\n  getChild(index) {\n    return this._children.getNode(index);\n  }\n  /**\n   * Returns an iterator that iterates over all of this document fragment's children.\n   *\n   * @returns {Iterable.<module:engine/model/node~Node>}\n   */\n\n\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number|null} Child node's index.\n   */\n\n\n  getChildIndex(node) {\n    return this._children.getNodeIndex(node);\n  }\n  /**\n   * Returns the starting offset of given child. Starting offset is equal to the sum of\n   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n   * given node is not a child of this document fragment.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number|null} Child node's starting offset.\n   */\n\n\n  getChildStartOffset(node) {\n    return this._children.getNodeStartOffset(node);\n  }\n  /**\n   * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n   *\n   * @returns {Array}\n   */\n\n\n  getPath() {\n    return [];\n  }\n  /**\n   * Returns a descendant node by its path relative to this element.\n   *\n   *\t\t// <this>a<b>c</b></this>\n   *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n   *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n   *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n   *\n   * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n   * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  getNodeByPath(relativePath) {\n    let node = this; // eslint-disable-line consistent-this\n\n    for (const index of relativePath) {\n      node = node.getChild(node.offsetToIndex(index));\n    }\n\n    return node;\n  }\n  /**\n   * Converts offset \"position\" to index \"position\".\n   *\n   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n   * too high, returns index after last child}.\n   *\n   *\t\tconst textNode = new Text( 'foo' );\n   *\t\tconst pElement = new Element( 'p' );\n   *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n   *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n   *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n   *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n   *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n   *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n   *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n   *\n   * @param {Number} offset Offset to look for.\n   * @returns {Number} Index of a node that occupies given offset.\n   */\n\n\n  offsetToIndex(offset) {\n    return this._children.offsetToIndex(offset);\n  }\n  /**\n   * Converts `DocumentFragment` instance to plain object and returns it.\n   * Takes care of converting all of this document fragment's children.\n   *\n   * @returns {Object} `DocumentFragment` instance converted to plain object.\n   */\n\n\n  toJSON() {\n    const json = [];\n\n    for (const node of this._children) {\n      json.push(node.toJSON());\n    }\n\n    return json;\n  }\n  /**\n   * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n   * Converts `DocumentFragment` children to proper nodes.\n   *\n   * @param {Object} json Plain object to be converted to `DocumentFragment`.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n   */\n\n\n  static fromJSON(json) {\n    const children = [];\n\n    for (const child of json) {\n      if (child.name) {\n        // If child has name property, it is an Element.\n        children.push(Element.fromJSON(child));\n      } else {\n        // Otherwise, it is a Text node.\n        children.push(Text.fromJSON(child));\n      }\n    }\n\n    return new DocumentFragment(children);\n  }\n  /**\n   * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n   *\n   * @protected\n   * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n   */\n\n\n  _appendChild(items) {\n    this._insertChild(this.childCount, items);\n  }\n  /**\n   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n   * to this document fragment.\n   *\n   * @protected\n   * @param {Number} index Index at which nodes should be inserted.\n   * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n   */\n\n\n  _insertChild(index, items) {\n    const nodes = normalize(items);\n\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n\n      node.parent = this;\n    }\n\n    this._children._insertNodes(index, nodes);\n  }\n  /**\n   * Removes one or more nodes starting at the given index\n   * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n   *\n   * @protected\n   * @param {Number} index Index of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n   */\n\n\n  _removeChildren(index) {\n    let howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    const nodes = this._children._removeNodes(index, howMany);\n\n    for (const node of nodes) {\n      node.parent = null;\n    }\n\n    return nodes;\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn 'documentFragment';\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // log() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelDocumentFragment: ' + this );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // printTree() {\n  // @if CK_DEBUG_ENGINE //\tlet string = 'ModelDocumentFragment: [';\n  // @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n  // @if CK_DEBUG_ENGINE //\t\tstring += '\\n';\n  // @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n  // @if CK_DEBUG_ENGINE //\t\t\tconst textAttrs = stringifyMap( child._attrs );\n  // @if CK_DEBUG_ENGINE //\t\t\tstring += '\\t'.repeat( 1 );\n  // @if CK_DEBUG_ENGINE //\t\t\tif ( textAttrs !== '' ) {\n  // @if CK_DEBUG_ENGINE //\t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n  // @if CK_DEBUG_ENGINE //\t\t\t} else {\n  // @if CK_DEBUG_ENGINE //\t\t\t\tstring += child.data;\n  // @if CK_DEBUG_ENGINE //\t\t\t}\n  // @if CK_DEBUG_ENGINE //\t\t} else {\n  // @if CK_DEBUG_ENGINE //\t\t\tstring += child.printTree( 1 );\n  // @if CK_DEBUG_ENGINE //\t\t}\n  // @if CK_DEBUG_ENGINE //\t}\n  // @if CK_DEBUG_ENGINE //\tstring += '\\n]';\n  // @if CK_DEBUG_ENGINE //\treturn string;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logTree() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n  // @if CK_DEBUG_ENGINE // }\n\n\n} // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\n\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(node.data, node.getAttributes());\n    }\n\n    return node;\n  });\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js"],"names":["NodeList","Element","Text","TextProxy","isIterable","DocumentFragment","constructor","children","markers","Map","_children","_insertChild","Symbol","iterator","getChildren","childCount","length","maxOffset","isEmpty","root","parent","is","type","getChild","index","getNode","getChildIndex","node","getNodeIndex","getChildStartOffset","getNodeStartOffset","getPath","getNodeByPath","relativePath","offsetToIndex","offset","toJSON","json","push","fromJSON","child","name","_appendChild","items","nodes","normalize","_remove","_insertNodes","_removeChildren","howMany","_removeNodes","Array","from","map","data","getAttributes"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,UAAP,MAAuB,0CAAvB,C,CAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,gBAAN,CAAuB;AACrC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,QAAF,EAAa;AACvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,SAAL,GAAiB,IAAIV,QAAJ,EAAjB;;AAEA,QAAKO,QAAL,EAAgB;AACf,WAAKI,YAAL,CAAmB,CAAnB,EAAsBJ,QAAtB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;;;AACkB,GAAfK,MAAM,CAACC,QAAQ,IAAK;AACrB,WAAO,KAAKC,WAAL,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACe,MAAVC,UAAU,GAAG;AAChB,WAAO,KAAKL,SAAL,CAAeM,MAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACc,MAATC,SAAS,GAAG;AACf,WAAO,KAAKP,SAAL,CAAeO,SAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACY,MAAPC,OAAO,GAAG;AACb,WAAO,KAAKH,UAAL,KAAoB,CAA3B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACS,MAAJI,IAAI,GAAG;AACV,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACW,MAANC,MAAM,GAAG;AACZ,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,EAAE,CAAEC,IAAF,EAAS;AACV,WAAOA,IAAI,KA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/model/documentfragment\n */\n\nimport NodeList from './nodelist';\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n// @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );\n\n/**\n * DocumentFragment represents a part of model which does not have a common root but its top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\nexport default class DocumentFragment {\n\t/**\n\t * Creates an empty `DocumentFragment`.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * Nodes to be contained inside the `DocumentFragment`.\n\t */\n\tconstructor( children ) {\n\t\t/**\n\t\t * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n\t\t * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n\t\t * when DocumentFragment will be inserted to the document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n\t\t */\n\t\tthis.markers = new Map();\n\n\t\t/**\n\t\t * List of nodes contained inside the document fragment.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all nodes contained inside this document fragment.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this.getChildren();\n\t}\n\n\t/**\n\t * Number of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {null}\n\t */\n\tget parent() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tdocFrag.is( 'documentFragment' ); // -> true\n\t *\t\tdocFrag.is( 'model:documentFragment' ); // -> true\n\t *\n\t *\t\tdocFrag.is( 'view:documentFragment' ); // -> false\n\t *\t\tdocFrag.is( 'element' ); // -> false\n\t *\t\tdocFrag.is( 'node' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'documentFragment' || type === 'model:documentFragment';\n\t}\n\n\t/**\n\t * Gets the child at the given index. Returns `null` if incorrect index was passed.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node|null} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this document fragment's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's index.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n\t *\n\t * @returns {Array}\n\t */\n\tgetPath() {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Converts offset \"position\" to index \"position\".\n\t *\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n\t *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number} Index of a node that occupies given offset.\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Converts `DocumentFragment` instance to plain object and returns it.\n\t * Takes care of converting all of this document fragment's children.\n\t *\n\t * @returns {Object} `DocumentFragment` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = [];\n\n\t\tfor ( const node of this._children ) {\n\t\t\tjson.push( node.toJSON() );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `DocumentFragment` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `DocumentFragment`.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tconst children = [];\n\n\t\tfor ( const child of json ) {\n\t\t\tif ( child.name ) {\n\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t} else {\n\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t}\n\t\t}\n\n\t\treturn new DocumentFragment( children );\n\t}\n\n\t/**\n\t * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_appendChild( items ) {\n\t\tthis._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this document fragment.\n\t *\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index\n\t * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn 'documentFragment';\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelDocumentFragment: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // printTree() {\n\t// @if CK_DEBUG_ENGINE //\tlet string = 'ModelDocumentFragment: [';\n\n\t// @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE //\t\tstring += '\\n';\n\n\t// @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\tconst textAttrs = stringifyMap( child._attrs );\n\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += '\\t'.repeat( 1 );\n\n\t// @if CK_DEBUG_ENGINE //\t\t\tif ( textAttrs !== '' ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n\t// @if CK_DEBUG_ENGINE //\t\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\t\tstring += child.data;\n\t// @if CK_DEBUG_ENGINE //\t\t\t}\n\t// @if CK_DEBUG_ENGINE //\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += child.printTree( 1 );\n\t// @if CK_DEBUG_ENGINE //\t\t}\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\tstring += '\\n]';\n\n\t// @if CK_DEBUG_ENGINE //\treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]},"metadata":{},"sourceType":"module"}