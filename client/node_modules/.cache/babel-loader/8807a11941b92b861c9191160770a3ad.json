{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global setTimeout, clearTimeout */\n\n/**\n * @module utils/focustracker\n */\nimport DomEmitterMixin from './dom/emittermixin';\nimport ObservableMixin from './observablemixin';\nimport CKEditorError from './ckeditorerror';\nimport mix from './mix';\n/**\n * Allows observing a group of `HTMLElement`s whether at least one of them is focused.\n *\n * Used by the {@link module:core/editor/editor~Editor} in order to track whether the focus is still within the application,\n * or were used outside of its UI.\n *\n * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`\n * which contain other `focusable` elements. But note that this wrapper element has to be focusable too\n * (have e.g. `tabindex=\"-1\"`).\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n *\n * @mixes module:utils/dom/emittermixin~EmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class FocusTracker {\n  constructor() {\n    /**\n     * True when one of the registered elements is focused.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isFocused\n     */\n    this.set('isFocused', false);\n    /**\n     * The currently focused element.\n     *\n     * While {@link #isFocused `isFocused`} remains `true`, the focus can\n     * move between different UI elements. This property tracks those\n     * elements and tells which one is currently focused.\n     *\n     * @readonly\n     * @observable\n     * @member {HTMLElement|null} #focusedElement\n     */\n\n    this.set('focusedElement', null);\n    /**\n     * List of registered elements.\n     *\n     * @private\n     * @member {Set.<HTMLElement>}\n     */\n\n    this._elements = new Set();\n    /**\n     * Event loop timeout.\n     *\n     * @private\n     * @member {Number}\n     */\n\n    this._nextEventLoopTimeout = null;\n  }\n  /**\n   * Starts tracking the specified element.\n   *\n   * @param {HTMLElement} element\n   */\n\n\n  add(element) {\n    if (this._elements.has(element)) {\n      /**\n       * This element is already tracked by {@link module:utils/focustracker~FocusTracker}.\n       *\n       * @error focustracker-add-element-already-exist\n       */\n      throw new CKEditorError('focustracker-add-element-already-exist', this);\n    }\n\n    this.listenTo(element, 'focus', () => this._focus(element), {\n      useCapture: true\n    });\n    this.listenTo(element, 'blur', () => this._blur(), {\n      useCapture: true\n    });\n\n    this._elements.add(element);\n  }\n  /**\n   * Stops tracking the specified element and stops listening on this element.\n   *\n   * @param {HTMLElement} element\n   */\n\n\n  remove(element) {\n    if (element === this.focusedElement) {\n      this._blur(element);\n    }\n\n    if (this._elements.has(element)) {\n      this.stopListening(element);\n\n      this._elements.delete(element);\n    }\n  }\n  /**\n   * Destroys the focus tracker by:\n   * - Disabling all event listeners attached to tracked elements.\n   * - Removing all tracked elements that were previously added.\n   */\n\n\n  destroy() {\n    this.stopListening();\n  }\n  /**\n   * Stores currently focused element and set {#isFocused} as `true`.\n   *\n   * @private\n   * @param {HTMLElement} element Element which has been focused.\n   */\n\n\n  _focus(element) {\n    clearTimeout(this._nextEventLoopTimeout);\n    this.focusedElement = element;\n    this.isFocused = true;\n  }\n  /**\n   * Clears currently focused element and set {@link #isFocused} as `false`.\n   * This method uses `setTimeout` to change order of fires `blur` and `focus` events.\n   *\n   * @private\n   * @fires blur\n   */\n\n\n  _blur() {\n    clearTimeout(this._nextEventLoopTimeout);\n    this._nextEventLoopTimeout = setTimeout(() => {\n      this.focusedElement = null;\n      this.isFocused = false;\n    }, 0);\n  }\n  /**\n   * @event focus\n   */\n\n  /**\n   * @event blur\n   */\n\n\n}\nmix(FocusTracker, DomEmitterMixin);\nmix(FocusTracker, ObservableMixin);","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/focustracker.js"],"names":["DomEmitterMixin","ObservableMixin","CKEditorError","mix","FocusTracker","constructor","set","_elements","Set","_nextEventLoopTimeout","add","element","has","listenTo","_focus","useCapture","_blur","remove","focusedElement","stopListening","delete","destroy","clearTimeout","isFocused","setTimeout"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA,OAAOA,eAAP,MAA4B,oBAA5B;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,GAAP,MAAgB,OAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,YAAN,CAAmB;AACjCC,EAAAA,WAAW,GAAG;AACb;AACF;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,GAAL,CAAU,WAAV,EAAuB,KAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,GAAL,CAAU,gBAAV,EAA4B,IAA5B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,SAAL,GAAiB,IAAIC,GAAJ,EAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,qBAAL,GAA6B,IAA7B;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,GAAG,CAAEC,OAAF,EAAY;AACd,QAAK,KAAKJ,SAAL,CAAeK,GAAf,CAAoBD,OAApB,CAAL,EAAqC;AACpC;AACH;AACA;AACA;AACA;AACG,YAAM,IAAIT,aAAJ,CAAmB,wCAAnB,EAA6D,IAA7D,CAAN;AACA;;AAED,SAAKW,QAAL,CAAeF,OAAf,EAAwB,OAAxB,EAAiC,MAAM,KAAKG,MAAL,CAAaH,OAAb,CAAvC,EAA+D;AAAEI,MAAAA,UAAU,EAAE;AAAd,KAA/D;AACA,SAAKF,QAAL,CAAeF,OAAf,EAAwB,MAAxB,EAAgC,MAAM,KAAKK,KAAL,EAAtC,EAAoD;AAAED,MAAAA,UAAU,EAAE;AAAd,KAApD;;AACA,SAAKR,SAAL,CAAeG,GAAf,CAAoBC,OAApB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCM,EAAAA,MAAM,CAAEN,OAAF,EAAY;AACjB,QAAKA,OAAO,KAAK,KAAKO,cAAtB,EAAuC;AACtC,WAAKF,KAAL,CAAYL,OAAZ;AACA;;AAED,QAAK,KAAKJ,SAAL,CAAeK,GAAf,CAAoBD,OAApB,CAAL,EAAqC;AACpC,WAAKQ,aAAL,CAAoBR,OAApB;;AACA,WAAKJ,SAAL,CAAea,MAAf,CAAuBT,OAAvB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;;;AACCU,EAAAA,OAAO,GAAG;AACT,SAAKF,aAAL;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCL,EAAAA,MAAM,CAAEH,OAAF,EAAY;AACjBW,IAAAA,YAAY,CAAE,KAAKb,qBAAP,CAAZ;AAEA,SAAKS,cAAL,GAAsBP,OAAtB;AACA,SAAKY,SAAL,GAAiB,IAAjB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCP,EAAAA,KAAK,GAAG;AACPM,IAAAA,YAAY,CAAE,KAAKb,qBAAP,CAAZ;AAEA,SAAKA,qBAAL,GAA6Be,UAAU,CAAE,MAAM;AAC9C,WAAKN,cAAL,GAAsB,IAAtB;AACA,WAAKK,SAAL,GAAiB,KAAjB;AACA,KAHsC,EAGpC,CAHoC,CAAvC;AAIA;AAED;AACD;AACA;;AAEC;AACD;AACA;;;AAzHkC;AA4HlCpB,GAAG,CAAEC,YAAF,EAAgBJ,eAAhB,CAAH;AACAG,GAAG,CAAEC,YAAF,EAAgBH,eAAhB,CAAH","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global setTimeout, clearTimeout */\n\n/**\n * @module utils/focustracker\n */\n\nimport DomEmitterMixin from './dom/emittermixin';\nimport ObservableMixin from './observablemixin';\nimport CKEditorError from './ckeditorerror';\nimport mix from './mix';\n\n/**\n * Allows observing a group of `HTMLElement`s whether at least one of them is focused.\n *\n * Used by the {@link module:core/editor/editor~Editor} in order to track whether the focus is still within the application,\n * or were used outside of its UI.\n *\n * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`\n * which contain other `focusable` elements. But note that this wrapper element has to be focusable too\n * (have e.g. `tabindex=\"-1\"`).\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n *\n * @mixes module:utils/dom/emittermixin~EmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class FocusTracker {\n\tconstructor() {\n\t\t/**\n\t\t * True when one of the registered elements is focused.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #isFocused\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * The currently focused element.\n\t\t *\n\t\t * While {@link #isFocused `isFocused`} remains `true`, the focus can\n\t\t * move between different UI elements. This property tracks those\n\t\t * elements and tells which one is currently focused.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {HTMLElement|null} #focusedElement\n\t\t */\n\t\tthis.set( 'focusedElement', null );\n\n\t\t/**\n\t\t * List of registered elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<HTMLElement>}\n\t\t */\n\t\tthis._elements = new Set();\n\n\t\t/**\n\t\t * Event loop timeout.\n\t\t *\n\t\t * @private\n\t\t * @member {Number}\n\t\t */\n\t\tthis._nextEventLoopTimeout = null;\n\t}\n\n\t/**\n\t * Starts tracking the specified element.\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tadd( element ) {\n\t\tif ( this._elements.has( element ) ) {\n\t\t\t/**\n\t\t\t * This element is already tracked by {@link module:utils/focustracker~FocusTracker}.\n\t\t\t *\n\t\t\t * @error focustracker-add-element-already-exist\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'focustracker-add-element-already-exist', this );\n\t\t}\n\n\t\tthis.listenTo( element, 'focus', () => this._focus( element ), { useCapture: true } );\n\t\tthis.listenTo( element, 'blur', () => this._blur(), { useCapture: true } );\n\t\tthis._elements.add( element );\n\t}\n\n\t/**\n\t * Stops tracking the specified element and stops listening on this element.\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tremove( element ) {\n\t\tif ( element === this.focusedElement ) {\n\t\t\tthis._blur( element );\n\t\t}\n\n\t\tif ( this._elements.has( element ) ) {\n\t\t\tthis.stopListening( element );\n\t\t\tthis._elements.delete( element );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the focus tracker by:\n\t * - Disabling all event listeners attached to tracked elements.\n\t * - Removing all tracked elements that were previously added.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Stores currently focused element and set {#isFocused} as `true`.\n\t *\n\t * @private\n\t * @param {HTMLElement} element Element which has been focused.\n\t */\n\t_focus( element ) {\n\t\tclearTimeout( this._nextEventLoopTimeout );\n\n\t\tthis.focusedElement = element;\n\t\tthis.isFocused = true;\n\t}\n\n\t/**\n\t * Clears currently focused element and set {@link #isFocused} as `false`.\n\t * This method uses `setTimeout` to change order of fires `blur` and `focus` events.\n\t *\n\t * @private\n\t * @fires blur\n\t */\n\t_blur() {\n\t\tclearTimeout( this._nextEventLoopTimeout );\n\n\t\tthis._nextEventLoopTimeout = setTimeout( () => {\n\t\t\tthis.focusedElement = null;\n\t\t\tthis.isFocused = false;\n\t\t}, 0 );\n\t}\n\n\t/**\n\t * @event focus\n\t */\n\n\t/**\n\t * @event blur\n\t */\n}\n\nmix( FocusTracker, DomEmitterMixin );\nmix( FocusTracker, ObservableMixin );\n"]},"metadata":{},"sourceType":"module"}