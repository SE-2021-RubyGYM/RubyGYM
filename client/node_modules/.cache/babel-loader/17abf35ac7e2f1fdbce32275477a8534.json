{"ast":null,"code":"/**\r\n * Copyright 2013-2015, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule ReactInstanceHandles\r\n * @typechecks static-only\r\n */\n'use strict';\n\nvar ReactRootIndex = require('./ReactRootIndex');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n/**\r\n * Maximum depth of traversals before we consider the possibility of a bad ID.\r\n */\n\nvar MAX_TREE_DEPTH = 10000;\n/**\r\n * Creates a DOM ID prefix to use when mounting React components.\r\n *\r\n * @param {number} index A unique integer\r\n * @return {string} React root ID.\r\n * @internal\r\n */\n\nfunction getReactRootIDString(index) {\n  return SEPARATOR + index.toString(36);\n}\n/**\r\n * Checks if a character in the supplied ID is a separator or the end.\r\n *\r\n * @param {string} id A React DOM ID.\r\n * @param {number} index Index of the character to check.\r\n * @return {boolean} True if the character is a separator or end of the ID.\r\n * @private\r\n */\n\n\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n/**\r\n * Checks if the supplied string is a valid React DOM ID.\r\n *\r\n * @param {string} id A React DOM ID, maybe.\r\n * @return {boolean} True if the string is a valid React DOM ID.\r\n * @private\r\n */\n\n\nfunction isValidID(id) {\n  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;\n}\n/**\r\n * Checks if the first ID is an ancestor of or equal to the second ID.\r\n *\r\n * @param {string} ancestorID\r\n * @param {string} descendantID\r\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\r\n * @internal\r\n */\n\n\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);\n}\n/**\r\n * Gets the parent ID of the supplied React DOM ID, `id`.\r\n *\r\n * @param {string} id ID of a component.\r\n * @return {string} ID of the parent, or an empty string.\r\n * @private\r\n */\n\n\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n/**\r\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\r\n * supplied `destinationID`. If they are equal, the ID is returned.\r\n *\r\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\r\n * @param {string} destinationID ID of the destination node.\r\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\r\n * @private\r\n */\n\n\nfunction getNextDescendantID(ancestorID, destinationID) {\n  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;\n  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;\n\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  } // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n\n\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  var i;\n\n  for (i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n\n  return destinationID.substr(0, i);\n}\n/**\r\n * Gets the nearest common ancestor ID of two IDs.\r\n *\r\n * Using this ID scheme, the nearest common ancestor ID is the longest common\r\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\r\n *\r\n * @param {string} oneID\r\n * @param {string} twoID\r\n * @return {string} Nearest common ancestor ID, or the empty string if none.\r\n * @private\r\n */\n\n\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n\n  if (minLength === 0) {\n    return '';\n  }\n\n  var lastCommonMarkerIndex = 0; // Use `<=` to traverse until the \"EOL\" of the shorter string.\n\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;\n  return longestCommonID;\n}\n/**\r\n * Traverses the parent path between two IDs (either up or down). The IDs must\r\n * not be the same, and there must exist a parent path between them. If the\r\n * callback returns `false`, traversal is stopped.\r\n *\r\n * @param {?string} start ID at which to start traversal.\r\n * @param {?string} stop ID at which to end traversal.\r\n * @param {function} cb Callback to invoke each ID with.\r\n * @param {*} arg Argument to invoke the callback with.\r\n * @param {?boolean} skipFirst Whether or not to skip the first node.\r\n * @param {?boolean} skipLast Whether or not to skip the last node.\r\n * @private\r\n */\n\n\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;\n  var traverseUp = isAncestorIDOf(stop, start);\n  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined; // Traverse from `start` to `stop` one depth at a time.\n\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n\n  for (var id = start;;\n  /* until break */\n  id = traverse(id, stop)) {\n    var ret;\n\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      ret = cb(id, traverseUp, arg);\n    }\n\n    if (ret === false || id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n\n    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;\n  }\n}\n/**\r\n * Manages the IDs assigned to DOM representations of React components. This\r\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\r\n * order to simulate events).\r\n *\r\n * @internal\r\n */\n\n\nvar ReactInstanceHandles = {\n  /**\r\n   * Constructs a React root ID\r\n   * @return {string} A React root ID.\r\n   */\n  createReactRootID: function () {\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\n  },\n\n  /**\r\n   * Constructs a React ID by joining a root ID with a name.\r\n   *\r\n   * @param {string} rootID Root ID of a parent component.\r\n   * @param {string} name A component's name (as flattened children).\r\n   * @return {string} A React ID.\r\n   * @internal\r\n   */\n  createReactID: function (rootID, name) {\n    return rootID + name;\n  },\n\n  /**\r\n   * Gets the DOM ID of the React component that is the root of the tree that\r\n   * contains the React component with the supplied DOM ID.\r\n   *\r\n   * @param {string} id DOM ID of a React component.\r\n   * @return {?string} DOM ID of the React component that is the root.\r\n   * @internal\r\n   */\n  getReactRootIDFromNodeID: function (id) {\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\n      var index = id.indexOf(SEPARATOR, 1);\n      return index > -1 ? id.substr(0, index) : id;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\r\n   * should would receive a `mouseEnter` or `mouseLeave` event.\r\n   *\r\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\r\n   * nothing \"entered\" or \"left\" that element.\r\n   *\r\n   * @param {string} leaveID ID being left.\r\n   * @param {string} enterID ID being entered.\r\n   * @param {function} cb Callback to invoke on each entered/left ID.\r\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\r\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\r\n   * @internal\r\n   */\n  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\r\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\r\n   *\r\n   * NOTE: This traversal happens on IDs without touching the DOM.\r\n   *\r\n   * @param {string} targetID ID of the target node.\r\n   * @param {function} cb Callback to invoke.\r\n   * @param {*} arg Argument to invoke the callback with.\r\n   * @internal\r\n   */\n  traverseTwoPhase: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\r\n   * Same as `traverseTwoPhase` but skips the `targetID`.\r\n   */\n  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, true);\n      traverseParentPath(targetID, '', cb, arg, true, true);\n    }\n  },\n\n  /**\r\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\r\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\r\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\r\n   *\r\n   * NOTE: This traversal happens on IDs without touching the DOM.\r\n   *\r\n   * @param {string} targetID ID of the target node.\r\n   * @param {function} cb Callback to invoke.\r\n   * @param {*} arg Argument to invoke the callback with.\r\n   * @internal\r\n   */\n  traverseAncestors: function (targetID, cb, arg) {\n    traverseParentPath('', targetID, cb, arg, true, false);\n  },\n  getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\r\n   * Exposed for unit testing.\r\n   * @private\r\n   */\n  _getNextDescendantID: getNextDescendantID,\n  isAncestorIDOf: isAncestorIDOf,\n  SEPARATOR: SEPARATOR\n};\nmodule.exports = ReactInstanceHandles;","map":{"version":3,"sources":["C:/Users/nvtung/Các project thực hiện/RubyGYM-master_test_2/client/node_modules/jsx-to-string/node_modules/react/lib/ReactInstanceHandles.js"],"names":["ReactRootIndex","require","invariant","SEPARATOR","SEPARATOR_LENGTH","length","MAX_TREE_DEPTH","getReactRootIDString","index","toString","isBoundary","id","charAt","isValidID","isAncestorIDOf","ancestorID","descendantID","indexOf","getParentID","substr","lastIndexOf","getNextDescendantID","destinationID","process","env","NODE_ENV","undefined","start","i","getFirstCommonAncestorID","oneID","twoID","minLength","Math","min","lastCommonMarkerIndex","longestCommonID","traverseParentPath","stop","cb","arg","skipFirst","skipLast","traverseUp","depth","traverse","ret","ReactInstanceHandles","createReactRootID","createReactRootIndex","createReactID","rootID","name","getReactRootIDFromNodeID","traverseEnterLeave","leaveID","enterID","upArg","downArg","traverseTwoPhase","targetID","traverseTwoPhaseSkipTarget","traverseAncestors","_getNextDescendantID","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright 2013-2015, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule ReactInstanceHandles\r\n * @typechecks static-only\r\n */\r\n\r\n'use strict';\r\n\r\nvar ReactRootIndex = require('./ReactRootIndex');\r\n\r\nvar invariant = require('fbjs/lib/invariant');\r\n\r\nvar SEPARATOR = '.';\r\nvar SEPARATOR_LENGTH = SEPARATOR.length;\r\n\r\n/**\r\n * Maximum depth of traversals before we consider the possibility of a bad ID.\r\n */\r\nvar MAX_TREE_DEPTH = 10000;\r\n\r\n/**\r\n * Creates a DOM ID prefix to use when mounting React components.\r\n *\r\n * @param {number} index A unique integer\r\n * @return {string} React root ID.\r\n * @internal\r\n */\r\nfunction getReactRootIDString(index) {\r\n  return SEPARATOR + index.toString(36);\r\n}\r\n\r\n/**\r\n * Checks if a character in the supplied ID is a separator or the end.\r\n *\r\n * @param {string} id A React DOM ID.\r\n * @param {number} index Index of the character to check.\r\n * @return {boolean} True if the character is a separator or end of the ID.\r\n * @private\r\n */\r\nfunction isBoundary(id, index) {\r\n  return id.charAt(index) === SEPARATOR || index === id.length;\r\n}\r\n\r\n/**\r\n * Checks if the supplied string is a valid React DOM ID.\r\n *\r\n * @param {string} id A React DOM ID, maybe.\r\n * @return {boolean} True if the string is a valid React DOM ID.\r\n * @private\r\n */\r\nfunction isValidID(id) {\r\n  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;\r\n}\r\n\r\n/**\r\n * Checks if the first ID is an ancestor of or equal to the second ID.\r\n *\r\n * @param {string} ancestorID\r\n * @param {string} descendantID\r\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\r\n * @internal\r\n */\r\nfunction isAncestorIDOf(ancestorID, descendantID) {\r\n  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);\r\n}\r\n\r\n/**\r\n * Gets the parent ID of the supplied React DOM ID, `id`.\r\n *\r\n * @param {string} id ID of a component.\r\n * @return {string} ID of the parent, or an empty string.\r\n * @private\r\n */\r\nfunction getParentID(id) {\r\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\r\n}\r\n\r\n/**\r\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\r\n * supplied `destinationID`. If they are equal, the ID is returned.\r\n *\r\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\r\n * @param {string} destinationID ID of the destination node.\r\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\r\n * @private\r\n */\r\nfunction getNextDescendantID(ancestorID, destinationID) {\r\n  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;\r\n  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;\r\n  if (ancestorID === destinationID) {\r\n    return ancestorID;\r\n  }\r\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\r\n  // another separator or we reach the end of `destinationID`.\r\n  var start = ancestorID.length + SEPARATOR_LENGTH;\r\n  var i;\r\n  for (i = start; i < destinationID.length; i++) {\r\n    if (isBoundary(destinationID, i)) {\r\n      break;\r\n    }\r\n  }\r\n  return destinationID.substr(0, i);\r\n}\r\n\r\n/**\r\n * Gets the nearest common ancestor ID of two IDs.\r\n *\r\n * Using this ID scheme, the nearest common ancestor ID is the longest common\r\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\r\n *\r\n * @param {string} oneID\r\n * @param {string} twoID\r\n * @return {string} Nearest common ancestor ID, or the empty string if none.\r\n * @private\r\n */\r\nfunction getFirstCommonAncestorID(oneID, twoID) {\r\n  var minLength = Math.min(oneID.length, twoID.length);\r\n  if (minLength === 0) {\r\n    return '';\r\n  }\r\n  var lastCommonMarkerIndex = 0;\r\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\r\n  for (var i = 0; i <= minLength; i++) {\r\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\r\n      lastCommonMarkerIndex = i;\r\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\r\n      break;\r\n    }\r\n  }\r\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\r\n  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;\r\n  return longestCommonID;\r\n}\r\n\r\n/**\r\n * Traverses the parent path between two IDs (either up or down). The IDs must\r\n * not be the same, and there must exist a parent path between them. If the\r\n * callback returns `false`, traversal is stopped.\r\n *\r\n * @param {?string} start ID at which to start traversal.\r\n * @param {?string} stop ID at which to end traversal.\r\n * @param {function} cb Callback to invoke each ID with.\r\n * @param {*} arg Argument to invoke the callback with.\r\n * @param {?boolean} skipFirst Whether or not to skip the first node.\r\n * @param {?boolean} skipLast Whether or not to skip the last node.\r\n * @private\r\n */\r\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\r\n  start = start || '';\r\n  stop = stop || '';\r\n  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;\r\n  var traverseUp = isAncestorIDOf(stop, start);\r\n  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;\r\n  // Traverse from `start` to `stop` one depth at a time.\r\n  var depth = 0;\r\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\r\n  for (var id = start;; /* until break */id = traverse(id, stop)) {\r\n    var ret;\r\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\r\n      ret = cb(id, traverseUp, arg);\r\n    }\r\n    if (ret === false || id === stop) {\r\n      // Only break //after// visiting `stop`.\r\n      break;\r\n    }\r\n    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Manages the IDs assigned to DOM representations of React components. This\r\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\r\n * order to simulate events).\r\n *\r\n * @internal\r\n */\r\nvar ReactInstanceHandles = {\r\n\r\n  /**\r\n   * Constructs a React root ID\r\n   * @return {string} A React root ID.\r\n   */\r\n  createReactRootID: function () {\r\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\r\n  },\r\n\r\n  /**\r\n   * Constructs a React ID by joining a root ID with a name.\r\n   *\r\n   * @param {string} rootID Root ID of a parent component.\r\n   * @param {string} name A component's name (as flattened children).\r\n   * @return {string} A React ID.\r\n   * @internal\r\n   */\r\n  createReactID: function (rootID, name) {\r\n    return rootID + name;\r\n  },\r\n\r\n  /**\r\n   * Gets the DOM ID of the React component that is the root of the tree that\r\n   * contains the React component with the supplied DOM ID.\r\n   *\r\n   * @param {string} id DOM ID of a React component.\r\n   * @return {?string} DOM ID of the React component that is the root.\r\n   * @internal\r\n   */\r\n  getReactRootIDFromNodeID: function (id) {\r\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\r\n      var index = id.indexOf(SEPARATOR, 1);\r\n      return index > -1 ? id.substr(0, index) : id;\r\n    }\r\n    return null;\r\n  },\r\n\r\n  /**\r\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\r\n   * should would receive a `mouseEnter` or `mouseLeave` event.\r\n   *\r\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\r\n   * nothing \"entered\" or \"left\" that element.\r\n   *\r\n   * @param {string} leaveID ID being left.\r\n   * @param {string} enterID ID being entered.\r\n   * @param {function} cb Callback to invoke on each entered/left ID.\r\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\r\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\r\n   * @internal\r\n   */\r\n  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {\r\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\r\n    if (ancestorID !== leaveID) {\r\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\r\n    }\r\n    if (ancestorID !== enterID) {\r\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\r\n   *\r\n   * NOTE: This traversal happens on IDs without touching the DOM.\r\n   *\r\n   * @param {string} targetID ID of the target node.\r\n   * @param {function} cb Callback to invoke.\r\n   * @param {*} arg Argument to invoke the callback with.\r\n   * @internal\r\n   */\r\n  traverseTwoPhase: function (targetID, cb, arg) {\r\n    if (targetID) {\r\n      traverseParentPath('', targetID, cb, arg, true, false);\r\n      traverseParentPath(targetID, '', cb, arg, false, true);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Same as `traverseTwoPhase` but skips the `targetID`.\r\n   */\r\n  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {\r\n    if (targetID) {\r\n      traverseParentPath('', targetID, cb, arg, true, true);\r\n      traverseParentPath(targetID, '', cb, arg, true, true);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\r\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\r\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\r\n   *\r\n   * NOTE: This traversal happens on IDs without touching the DOM.\r\n   *\r\n   * @param {string} targetID ID of the target node.\r\n   * @param {function} cb Callback to invoke.\r\n   * @param {*} arg Argument to invoke the callback with.\r\n   * @internal\r\n   */\r\n  traverseAncestors: function (targetID, cb, arg) {\r\n    traverseParentPath('', targetID, cb, arg, true, false);\r\n  },\r\n\r\n  getFirstCommonAncestorID: getFirstCommonAncestorID,\r\n\r\n  /**\r\n   * Exposed for unit testing.\r\n   * @private\r\n   */\r\n  _getNextDescendantID: getNextDescendantID,\r\n\r\n  isAncestorIDOf: isAncestorIDOf,\r\n\r\n  SEPARATOR: SEPARATOR\r\n\r\n};\r\n\r\nmodule.exports = ReactInstanceHandles;"]},"metadata":{},"sourceType":"script"}