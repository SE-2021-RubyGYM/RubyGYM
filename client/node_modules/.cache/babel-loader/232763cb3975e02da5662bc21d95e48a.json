{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n/**\n * The model's schema. It defines the allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by the features and based on them, the editing framework and features\n * make decisions on how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * The {@glink framework/guides/architecture/editing-engine#schema schema section} of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture} guide.\n * * The {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class Schema {\n  /**\n   * Creates a schema instance.\n   */\n  constructor() {\n    this._sourceDefinitions = {};\n    /**\n     * A dictionary containing attribute properties.\n     *\n     * @private\n     * @member {Object.<String,String>}\n     */\n\n    this._attributeProperties = {};\n    this.decorate('checkChild');\n    this.decorate('checkAttribute');\n    this.on('checkAttribute', (evt, args) => {\n      args[0] = new SchemaContext(args[0]);\n    }, {\n      priority: 'highest'\n    });\n    this.on('checkChild', (evt, args) => {\n      args[0] = new SchemaContext(args[0]);\n      args[1] = this.getDefinition(args[1]);\n    }, {\n      priority: 'highest'\n    });\n  }\n  /**\n   * Registers a schema item. Can only be called once for every item name.\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tinheritAllFrom: '$block'\n   *\t\t} );\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n\n\n  register(itemName, definition) {\n    if (this._sourceDefinitions[itemName]) {\n      /**\n       * A single item cannot be registered twice in the schema.\n       *\n       * This situation may happen when:\n       *\n       * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n       * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n       * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n       * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n       * and usually means one or more of the following issues:\n       *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n       *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n       *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n       *\n       * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n       *\n       * @param itemName The name of the model element that is being registered twice.\n       * @error schema-cannot-register-item-twice\n       */\n      throw new CKEditorError('schema-cannot-register-item-twice', this, {\n        itemName\n      });\n    }\n\n    this._sourceDefinitions[itemName] = [Object.assign({}, definition)];\n\n    this._clearCache();\n  }\n  /**\n   * Extends a {@link #register registered} item's definition.\n   *\n   * Extending properties such as `allowIn` will add more items to the existing properties,\n   * while redefining properties such as `isBlock` will override the previously defined ones.\n   *\n   *\t\tschema.register( 'foo', {\n   *\t\t\tallowIn: '$root',\n   *\t\t\tisBlock: true;\n   *\t\t} );\n   *\t\tschema.extend( 'foo', {\n   *\t\t\tallowIn: 'blockQuote',\n   *\t\t\tisBlock: false\n   *\t\t} );\n   *\n   *\t\tschema.getDefinition( 'foo' );\n   *\t\t//\t{\n   *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n   *\t\t// \t\tisBlock: false\n   *\t\t//\t}\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n\n\n  extend(itemName, definition) {\n    if (!this._sourceDefinitions[itemName]) {\n      /**\n       * Cannot extend an item which was not registered yet.\n       *\n       * This error happens when a plugin tries to extend the schema definition of an item which was not\n       * {@link #register registered} yet.\n       *\n       * @param itemName The name of the model element which is being extended.\n       * @error schema-cannot-extend-missing-item\n       */\n      throw new CKEditorError('schema-cannot-extend-missing-item', this, {\n        itemName\n      });\n    }\n\n    this._sourceDefinitions[itemName].push(Object.assign({}, definition));\n\n    this._clearCache();\n  }\n  /**\n   * Returns data of all registered items.\n   *\n   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n   * checking a list of all block elements, etc).\n   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n   * in other cases.\n   *\n   * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n   */\n\n\n  getDefinitions() {\n    if (!this._compiledDefinitions) {\n      this._compile();\n    }\n\n    return this._compiledDefinitions;\n  }\n  /**\n   * Returns a definition of the given item or `undefined` if an item is not registered.\n   *\n   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n   * checking a list of all block elements, etc).\n   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n   * in other cases.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n   */\n\n\n  getDefinition(item) {\n    let itemName;\n\n    if (typeof item == 'string') {\n      itemName = item;\n    } else if (item.is && (item.is('$text') || item.is('$textProxy'))) {\n      itemName = '$text';\n    } // Element or module:engine/model/schema~SchemaContextItem.\n    else {\n      itemName = item.name;\n    }\n\n    return this.getDefinitions()[itemName];\n  }\n  /**\n   * Returns `true` if the given item is registered in the schema.\n   *\n   *\t\tschema.isRegistered( 'paragraph' ); // -> true\n   *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n   *\t\tschema.isRegistered( 'foo' ); // -> false\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n   */\n\n\n  isRegistered(item) {\n    return !!this.getDefinition(item);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n   *\n   *\t\tschema.isBlock( 'paragraph' ); // -> true\n   *\t\tschema.isBlock( '$root' ); // -> false\n   *\n   *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n   *\t\tschema.isBlock( paragraphElement ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   \t * @returns {Boolean}\n   */\n\n\n  isBlock(item) {\n    const def = this.getDefinition(item);\n    return !!(def && def.isBlock);\n  }\n  /**\n   * Returns `true` if the given item should be treated as a limit element.\n   *\n   * It considers an item to be a limit element if its\n   * {@link module:engine/model/schema~SchemaItemDefinition}'s\n   * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n   * was set to `true`.\n   *\n   *\t\tschema.isLimit( 'paragraph' ); // -> false\n   *\t\tschema.isLimit( '$root' ); // -> true\n   *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n   *\t\tschema.isLimit( 'imageBlock' ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   \t * @returns {Boolean}\n   */\n\n\n  isLimit(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    }\n\n    return !!(def.isLimit || def.isObject);\n  }\n  /**\n   * Returns `true` if the given item should be treated as an object element.\n   *\n   * It considers an item to be an object element if its\n   * {@link module:engine/model/schema~SchemaItemDefinition}'s\n   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n   * was set to `true`.\n   *\n   *\t\tschema.isObject( 'paragraph' ); // -> false\n   *\t\tschema.isObject( 'imageBlock' ); // -> true\n   *\n   *\t\tconst imageElement = writer.createElement( 'imageBlock' );\n   *\t\tschema.isObject( imageElement ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   \t * @returns {Boolean}\n   */\n\n\n  isObject(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    } // Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n    // to understand why these three constitute an object.\n\n\n    return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n   *\n   *\t\tschema.isInline( 'paragraph' ); // -> false\n   *\t\tschema.isInline( 'softBreak' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isInline( text ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n\n\n  isInline(item) {\n    const def = this.getDefinition(item);\n    return !!(def && def.isInline);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n   *\n   *\t\tschema.isSelectable( 'paragraph' ); // -> false\n   *\t\tschema.isSelectable( 'heading1' ); // -> false\n   *\t\tschema.isSelectable( 'imageBlock' ); // -> true\n   *\t\tschema.isSelectable( 'tableCell' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isSelectable( text ); // -> false\n   *\n   * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n\n\n  isSelectable(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    }\n\n    return !!(def.isSelectable || def.isObject);\n  }\n  /**\n   * Returns `true` if the given item is defined to be\n   * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n   *\n   *\t\tschema.isContent( 'paragraph' ); // -> false\n   *\t\tschema.isContent( 'heading1' ); // -> false\n   *\t\tschema.isContent( 'imageBlock' ); // -> true\n   *\t\tschema.isContent( 'horizontalLine' ); // -> true\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\tschema.isContent( text ); // -> true\n   *\n   * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n   * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n   * @returns {Boolean}\n   */\n\n\n  isContent(item) {\n    const def = this.getDefinition(item);\n\n    if (!def) {\n      return false;\n    }\n\n    return !!(def.isContent || def.isObject);\n  }\n  /**\n   * Checks whether the given node (`child`) can be a child of the given context.\n   *\n   *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tallowIn: '$root'\n   *\t\t} );\n   *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n   *\n   * Note: When verifying whether the given node can be a child of the given context, the\n   * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n   * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n   * It happens if one of the context's elements does not allow its child.\n   *\n   * @fires checkChild\n   * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n   * @param {module:engine/model/node~Node|String} def The child to check.\n   * @returns {Boolean}\n   */\n\n\n  checkChild(context, def) {\n    // Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n    if (!def) {\n      return false;\n    }\n\n    return this._checkContextMatch(def, context);\n  }\n  /**\n   * Checks whether the given attribute can be applied in the given context (on the last\n   * item of the context).\n   *\n   *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n   *\n   *\t\tschema.extend( '$text', {\n   *\t\t\tallowAttributes: 'bold'\n   *\t\t} );\n   *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n   *\n   * @fires checkAttribute\n   * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n   * @param {String} attributeName\n   * @returns {Boolean}\n   */\n\n\n  checkAttribute(context, attributeName) {\n    const def = this.getDefinition(context.last);\n\n    if (!def) {\n      return false;\n    }\n\n    return def.allowAttributes.includes(attributeName);\n  }\n  /**\n   * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n   *\n   * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n   *\n   * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n   * will be valid.\n   *\n   * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n   * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n   *\n   * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n   * element to which the `elementToMerge` will be merged.\n   * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n   * @returns {Boolean}\n   */\n\n\n  checkMerge(positionOrBaseElement) {\n    let elementToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (positionOrBaseElement instanceof Position) {\n      const nodeBefore = positionOrBaseElement.nodeBefore;\n      const nodeAfter = positionOrBaseElement.nodeAfter;\n\n      if (!(nodeBefore instanceof Element)) {\n        /**\n         * The node before the merge position must be an element.\n         *\n         * @error schema-check-merge-no-element-before\n         */\n        throw new CKEditorError('schema-check-merge-no-element-before', this);\n      }\n\n      if (!(nodeAfter instanceof Element)) {\n        /**\n         * The node after the merge position must be an element.\n         *\n         * @error schema-check-merge-no-element-after\n         */\n        throw new CKEditorError('schema-check-merge-no-element-after', this);\n      }\n\n      return this.checkMerge(nodeBefore, nodeAfter);\n    }\n\n    for (const child of elementToMerge.getChildren()) {\n      if (!this.checkChild(positionOrBaseElement, child)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Allows registering a callback to the {@link #checkChild} method calls.\n   *\n   * Callbacks allow you to implement rules which are not otherwise possible to achieve\n   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n   * For example, by using this method you can disallow elements in specific contexts.\n   *\n   * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n   * you can use that event instead.\n   *\n   * Example:\n   *\n   *\t\t// Disallow heading1 directly inside a blockQuote.\n   *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n   *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n   *\t\t\t\treturn false;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Which translates to:\n   *\n   *\t\tschema.on( 'checkChild', ( evt, args ) => {\n   *\t\t\tconst context = args[ 0 ];\n   *\t\t\tconst childDefinition = args[ 1 ];\n   *\n   *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n   *\t\t\t\t// Prevent next listeners from being called.\n   *\t\t\t\tevt.stop();\n   *\t\t\t\t// Set the checkChild()'s return value.\n   *\t\t\t\tevt.return = false;\n   *\t\t\t}\n   *\t\t}, { priority: 'high' } );\n   *\n   * @param {Function} callback The callback to be called. It is called with two parameters:\n   * {@link module:engine/model/schema~SchemaContext} (context) instance and\n   * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n   * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n   * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n   */\n\n\n  addChildCheck(callback) {\n    this.on('checkChild', (evt, _ref) => {\n      let [ctx, childDef] = _ref;\n\n      // checkChild() was called with a non-registered child.\n      // In 99% cases such check should return false, so not to overcomplicate all callbacks\n      // don't even execute them.\n      if (!childDef) {\n        return;\n      }\n\n      const retValue = callback(ctx, childDef);\n\n      if (typeof retValue == 'boolean') {\n        evt.stop();\n        evt.return = retValue;\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Allows registering a callback to the {@link #checkAttribute} method calls.\n   *\n   * Callbacks allow you to implement rules which are not otherwise possible to achieve\n   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n   * For example, by using this method you can disallow attribute if node to which it is applied\n   * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n   *\n   * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n   * you can use that event instead.\n   *\n   * Example:\n   *\n   *\t\t// Disallow bold on $text inside heading1.\n   *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n   *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n   *\t\t\t\treturn false;\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Which translates to:\n   *\n   *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n   *\t\t\tconst context = args[ 0 ];\n   *\t\t\tconst attributeName = args[ 1 ];\n   *\n   *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n   *\t\t\t\t// Prevent next listeners from being called.\n   *\t\t\t\tevt.stop();\n   *\t\t\t\t// Set the checkAttribute()'s return value.\n   *\t\t\t\tevt.return = false;\n   *\t\t\t}\n   *\t\t}, { priority: 'high' } );\n   *\n   * @param {Function} callback The callback to be called. It is called with two parameters:\n   * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n   * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n   * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n   */\n\n\n  addAttributeCheck(callback) {\n    this.on('checkAttribute', (evt, _ref2) => {\n      let [ctx, attributeName] = _ref2;\n      const retValue = callback(ctx, attributeName);\n\n      if (typeof retValue == 'boolean') {\n        evt.stop();\n        evt.return = retValue;\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * This method allows assigning additional metadata to the model attributes. For example,\n   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n   * used to mark formatting attributes (like `bold` or `italic`).\n   *\n   *\t\t// Mark bold as a formatting attribute.\n   *\t\tschema.setAttributeProperties( 'bold', {\n   *\t\t\tisFormatting: true\n   *\t\t} );\n   *\n   *\t\t// Override code not to be considered a formatting markup.\n   *\t\tschema.setAttributeProperties( 'code', {\n   *\t\t\tisFormatting: false\n   *\t\t} );\n   *\n   * Properties are not limited to members defined in the\n   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\tcustomProperty: 'value'\n   *\t\t} );\n   *\n   * Subsequent calls with the same attribute will extend its custom properties:\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\tone: 1\n   *\t\t} );\n   *\n   *\t\tschema.setAttributeProperties( 'blockQuote', {\n   *\t\t\ttwo: 2\n   *\t\t} );\n   *\n   *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n   *\t\t// Logs: { one: 1, two: 2 }\n   *\n   * @param {String} attributeName A name of the attribute to receive the properties.\n   * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n   */\n\n\n  setAttributeProperties(attributeName, properties) {\n    this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);\n  }\n  /**\n   * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n   *\n   * @param {String} attributeName A name of the attribute.\n   * @returns {module:engine/model/schema~AttributeProperties}\n   */\n\n\n  getAttributeProperties(attributeName) {\n    return this._attributeProperties[attributeName] || {};\n  }\n  /**\n   * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n   * selection/range/position or the root otherwise.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n   * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n   * The selection/range/position to check.\n   * @returns {module:engine/model/element~Element} The lowest limit element containing\n   * the entire `selectionOrRangeOrPosition`.\n   */\n\n\n  getLimitElement(selectionOrRangeOrPosition) {\n    let element;\n\n    if (selectionOrRangeOrPosition instanceof Position) {\n      element = selectionOrRangeOrPosition.parent;\n    } else {\n      const ranges = selectionOrRangeOrPosition instanceof Range ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges()); // Find the common ancestor for all selection's ranges.\n\n      element = ranges.reduce((element, range) => {\n        const rangeCommonAncestor = range.getCommonAncestor();\n\n        if (!element) {\n          return rangeCommonAncestor;\n        }\n\n        return element.getCommonAncestor(rangeCommonAncestor, {\n          includeSelf: true\n        });\n      }, null);\n    }\n\n    while (!this.isLimit(element)) {\n      if (element.parent) {\n        element = element.parent;\n      } else {\n        break;\n      }\n    }\n\n    return element;\n  }\n  /**\n   * Checks whether the attribute is allowed in selection:\n   *\n   * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n   * * if the selection is collapsed, then checks if on the selection position there's a text with the\n   * specified attribute allowed.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * Selection which will be checked.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Boolean}\n   */\n\n\n  checkAttributeInSelection(selection, attribute) {\n    if (selection.isCollapsed) {\n      const firstPosition = selection.getFirstPosition();\n      const context = [...firstPosition.getAncestors(), new Text('', selection.getAttributes())]; // Check whether schema allows for a text with the attribute in the selection.\n\n      return this.checkAttribute(context, attribute);\n    } else {\n      const ranges = selection.getRanges(); // For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\n      for (const range of ranges) {\n        for (const value of range) {\n          if (this.checkAttribute(value.item, attribute)) {\n            // If we found a node that is allowed to have the attribute, return true.\n            return true;\n          }\n        }\n      }\n    } // If we haven't found such node, return false.\n\n\n    return false;\n  }\n  /**\n   * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n   *\n   * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n   */\n\n\n  *getValidRanges(ranges, attribute) {\n    ranges = convertToMinimalFlatRanges(ranges);\n\n    for (const range of ranges) {\n      yield* this._getValidRangesForRange(range, attribute);\n    }\n  }\n  /**\n   * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n   * nearest to that `position` and is a correct range for selection.\n   *\n   * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n   * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n   * the {@link module:engine/model/schema~Schema schema}.\n   *\n   * Direction of searching for the nearest correct selection range can be specified as:\n   *\n   * * `both` - searching will be performed in both ways,\n   * * `forward` - searching will be performed only forward,\n   * * `backward` - searching will be performed only backward.\n   *\n   * When valid selection range cannot be found, `null` is returned.\n   *\n   * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n   * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n   * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n   */\n\n\n  getNearestSelectionRange(position) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'both';\n\n    // Return collapsed range if provided position is valid.\n    if (this.checkChild(position, '$text')) {\n      return new Range(position);\n    }\n\n    let backwardWalker, forwardWalker; // Never leave a limit element.\n\n    const limitElement = position.getAncestors().reverse().find(item => this.isLimit(item)) || position.root;\n\n    if (direction == 'both' || direction == 'backward') {\n      backwardWalker = new TreeWalker({\n        boundaries: Range._createIn(limitElement),\n        startPosition: position,\n        direction: 'backward'\n      });\n    }\n\n    if (direction == 'both' || direction == 'forward') {\n      forwardWalker = new TreeWalker({\n        boundaries: Range._createIn(limitElement),\n        startPosition: position\n      });\n    }\n\n    for (const data of combineWalkers(backwardWalker, forwardWalker)) {\n      const type = data.walker == backwardWalker ? 'elementEnd' : 'elementStart';\n      const value = data.value;\n\n      if (value.type == type && this.isObject(value.item)) {\n        return Range._createOn(value.item);\n      }\n\n      if (this.checkChild(value.nextPosition, '$text')) {\n        return new Range(value.nextPosition);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Tries to find position ancestors that allow to insert a given node.\n   * It starts searching from the given position and goes node by node to the top of the model tree\n   * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n   * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n   *\n   * @param {module:engine/model/position~Position} position The position that the search will start from.\n   * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n   * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n   */\n\n\n  findAllowedParent(position, node) {\n    let parent = position.parent;\n\n    while (parent) {\n      if (this.checkChild(parent, node)) {\n        return parent;\n      } // Do not split limit elements.\n\n\n      if (this.isLimit(parent)) {\n        return null;\n      }\n\n      parent = parent.parent;\n    }\n\n    return null;\n  }\n  /**\n   * Removes attributes disallowed by the schema.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n   * @param {module:engine/model/writer~Writer} writer\n   */\n\n\n  removeDisallowedAttributes(nodes, writer) {\n    for (const node of nodes) {\n      // When node is a `Text` it has no children, so just filter it out.\n      if (node.is('$text')) {\n        removeDisallowedAttributeFromNode(this, node, writer);\n      } // In a case of `Element` iterates through positions between nodes inside this element\n      // and filter out node before the current position, or position parent when position\n      // is at start of an element. Using positions prevent from omitting merged nodes\n      // see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n      else {\n        const rangeInNode = Range._createIn(node);\n\n        const positionsInRange = rangeInNode.getPositions();\n\n        for (const position of positionsInRange) {\n          const item = position.nodeBefore || position.parent;\n          removeDisallowedAttributeFromNode(this, item, writer);\n        }\n      }\n    }\n  }\n  /**\n   * Creates an instance of the schema context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   * @returns {module:engine/model/schema~SchemaContext}\n   */\n\n\n  createContext(context) {\n    return new SchemaContext(context);\n  }\n  /**\n   * @private\n   */\n\n\n  _clearCache() {\n    this._compiledDefinitions = null;\n  }\n  /**\n   * @private\n   */\n\n\n  _compile() {\n    const compiledDefinitions = {};\n    const sourceRules = this._sourceDefinitions;\n    const itemNames = Object.keys(sourceRules);\n\n    for (const itemName of itemNames) {\n      compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowChildren(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowContentOf(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowWhere(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      compileAllowAttributesOf(compiledDefinitions, itemName);\n      compileInheritPropertiesFrom(compiledDefinitions, itemName);\n    }\n\n    for (const itemName of itemNames) {\n      cleanUpAllowIn(compiledDefinitions, itemName);\n      setupAllowChildren(compiledDefinitions, itemName);\n      cleanUpAllowAttributes(compiledDefinitions, itemName);\n    }\n\n    this._compiledDefinitions = compiledDefinitions;\n  }\n  /**\n   * @private\n   * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n   * @param {module:engine/model/schema~SchemaContext} context\n   * @param {Number} contextItemIndex\n   */\n\n\n  _checkContextMatch(def, context) {\n    let contextItemIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;\n    const contextItem = context.getItem(contextItemIndex);\n\n    if (def.allowIn.includes(contextItem.name)) {\n      if (contextItemIndex == 0) {\n        return true;\n      } else {\n        const parentRule = this.getDefinition(contextItem);\n        return this._checkContextMatch(parentRule, context, contextItemIndex - 1);\n      }\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n   * inside the given range on which the attribute can be applied.\n   *\n   * This is a helper function for {@link ~Schema#getValidRanges}.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The range to process.\n   * @param {String} attribute The name of the attribute to check.\n   * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n   */\n\n\n  *_getValidRangesForRange(range, attribute) {\n    let start = range.start;\n    let end = range.start;\n\n    for (const item of range.getItems({\n      shallow: true\n    })) {\n      if (item.is('element')) {\n        yield* this._getValidRangesForRange(Range._createIn(item), attribute);\n      }\n\n      if (!this.checkAttribute(item, attribute)) {\n        if (!start.isEqual(end)) {\n          yield new Range(start, end);\n        }\n\n        start = Position._createAfter(item);\n      }\n\n      end = Position._createAfter(item);\n    }\n\n    if (!start.isEqual(end)) {\n      yield new Range(start, end);\n    }\n  }\n\n}\nmix(Schema, ObservableMixin);\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding standard behavior of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you do not have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\", you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding the standard behavior of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you do not have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1`, you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * {@link ~SchemaItemDefinition#allowIn `allowIn`} &ndash; Defines in which other items this item will be allowed.\n * * {@link ~SchemaItemDefinition#allowChildren `allowChildren`} &ndash; Defines which other items are allowed inside this item.\n * * {@link ~SchemaItemDefinition#allowAttributes `allowAttributes`} &ndash; Defines allowed attributes of the given item.\n * * {@link ~SchemaItemDefinition#allowContentOf `allowContentOf`} &ndash; Inherits \"allowed children\" from other items.\n * * {@link ~SchemaItemDefinition#allowWhere `allowWhere`} &ndash; Inherits \"allowed in\" from other items.\n * * {@link ~SchemaItemDefinition#allowAttributesOf `allowAttributesOf`} &ndash; Inherits attributes from other items.\n * * {@link ~SchemaItemDefinition#inheritTypesFrom `inheritTypesFrom`} &ndash; Inherits `is*` properties of other items.\n * * {@link ~SchemaItemDefinition#inheritAllFrom `inheritAllFrom`} &ndash;\n * A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * # The `is*` properties\n *\n * There are a couple commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * {@link ~SchemaItemDefinition#isBlock `isBlock`} &ndash; Whether this item is paragraph-like.\n * Generally speaking, content is usually made out of blocks like paragraphs, list items, images, headings, etc.\n * * {@link ~SchemaItemDefinition#isInline `isInline`} &ndash; Whether an item is \"text-like\" and should be treated as an inline node.\n * Examples of inline elements: `$text`, `softBreak` (`<br>`), etc.\n * * {@link ~SchemaItemDefinition#isLimit `isLimit`} &ndash; It can be understood as whether this element\n * should not be split by <kbd>Enter</kbd>. Examples of limit elements: `$root`, table cell, image caption, etc.\n * In other words, all actions that happen inside a limit element are limited to its content.\n * All objects are treated as limit elements, too.\n * * {@link ~SchemaItemDefinition#isObject `isObject`} &ndash; Whether an item is \"self-contained\" and should be treated as a whole.\n * Examples of object elements: `imageBlock`, `table`, `video`, etc. An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the meaning of these types in the\n * {@glink framework/guides/deep-dive/schema#defining-additional-semantics dedicated section of the Schema deep dive} guide.\n *\n * # Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` inside a `$root` and allow `$text` as a `paragraph` child:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: '$root',\n *\t\t\tallowChildren: '$text',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Make `imageBlock` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'imageBlock', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n * Make `caption` allowed in `imageBlock` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'imageBlock',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about defining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n *\n * @property {String|Array.<String>} allowIn Defines in which other items this item will be allowed.\n * @property {String|Array.<String>} allowChildren Defines which other items are allowed inside this item.\n * @property {String|Array.<String>} allowAttributes Defines allowed attributes of the given item.\n * @property {String|Array.<String>} allowContentOf Inherits \"allowed children\" from other items.\n * @property {String|Array.<String>} allowWhere Inherits \"allowed in\" from other items.\n * @property {String|Array.<String>} allowAttributesOf Inherits attributes from other items.\n * @property {String|Array.<String>} inheritTypesFrom Inherits `is*` properties of other items.\n * @property {String} inheritAllFrom A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * @property {Boolean} isBlock\n * Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n *\n * Read more about the block elements in the\n * {@glink framework/guides/deep-dive/schema#block-elements Block elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive}.\n *\n * @property {Boolean} isInline\n * Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * Read more about the inline elements in the\n * {@glink framework/guides/deep-dive/schema#inline-elements Inline elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isLimit\n * It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content.\n *\n * Read more about the limit elements in the\n * {@glink framework/guides/deep-dive/schema#limit-elements Limit elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isObject\n * Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `imageBlock`, `table`, `video`, etc.\n *\n * **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the object elements in the\n * {@glink framework/guides/deep-dive/schema#object-elements Object elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isSelectable\n * `true` when an element should be selectable as a whole by the user. Examples of selectable elements: `imageBlock`, `table`, `tableCell`,\n * etc.\n *\n * **Note:** An object is also a selectable element, so\n * {@link module:engine/model/schema~Schema#isSelectable `isSelectable()`} returns `true` for object elements automatically.\n *\n * Read more about selectable elements in the\n * {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isContent\n * An item is a content when it always finds its way to the editor data output regardless of the number and type of its descendants.\n * Examples of content elements: `$text`, `imageBlock`, `table`, etc. (but not `paragraph`, `heading1` or `tableCell`).\n *\n * **Note:** An object is also a content element, so\n * {@link module:engine/model/schema~Schema#isContent `isContent()`} returns `true` for object elements automatically.\n *\n * Read more about content elements in the\n * {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefinition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowChildren` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\n\nexport class SchemaContext {\n  /**\n   * Creates an instance of the context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   */\n  constructor(context) {\n    if (context instanceof SchemaContext) {\n      return context;\n    }\n\n    if (typeof context == 'string') {\n      context = [context];\n    } else if (!Array.isArray(context)) {\n      // `context` is item or position.\n      // Position#getAncestors() doesn't accept any parameters but it works just fine here.\n      context = context.getAncestors({\n        includeSelf: true\n      });\n    }\n\n    this._items = context.map(mapContextItem);\n  }\n  /**\n   * The number of items.\n   *\n   * @type {Number}\n   */\n\n\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * The last item (the lowest node).\n   *\n   * @type {module:engine/model/schema~SchemaContextItem}\n   */\n\n\n  get last() {\n    return this._items[this._items.length - 1];\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all context items.\n   *\n   * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._items[Symbol.iterator]();\n  }\n  /**\n   * Returns a new schema context instance with an additional item.\n   *\n   * Item can be added as:\n   *\n   * \t\tconst context = new SchemaContext( [ '$root' ] );\n   *\n   * \t\t// An element.\n   * \t\tconst fooElement = writer.createElement( 'fooElement' );\n   * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n   *\n   * \t\t// A text node.\n   * \t\tconst text = writer.createText( 'foobar' );\n   * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n   *\n   * \t\t// A string (element name).\n   * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n   *\n   * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n   * (without ancestors).\n   *\n   * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n   * to the current context.\n   * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n   */\n\n\n  push(item) {\n    const ctx = new SchemaContext([item]);\n    ctx._items = [...this._items, ...ctx._items];\n    return ctx;\n  }\n  /**\n   * Gets an item on the given index.\n   *\n   * @returns {module:engine/model/schema~SchemaContextItem}\n   */\n\n\n  getItem(index) {\n    return this._items[index];\n  }\n  /**\n   * Returns the names of items.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  *getNames() {\n    yield* this._items.map(item => item.name);\n  }\n  /**\n   * Checks whether the context ends with the given nodes.\n   *\n   *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n   *\n   *\t\tctx.endsWith( '$text' ); // -> true\n   *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n   *\t\tctx.endsWith( '$root' ); // -> false\n   *\t\tctx.endsWith( 'paragraph' ); // -> false\n   *\n   * @param {String} query\n   * @returns {Boolean}\n   */\n\n\n  endsWith(query) {\n    return Array.from(this.getNames()).join(' ').endsWith(query);\n  }\n  /**\n   * Checks whether the context starts with the given nodes.\n   *\n   *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n   *\n   *\t\tctx.endsWith( '$root' ); // -> true\n   *\t\tctx.endsWith( '$root paragraph' ); // -> true\n   *\t\tctx.endsWith( '$text' ); // -> false\n   *\t\tctx.endsWith( 'paragraph' ); // -> false\n   *\n   * @param {String} query\n   * @returns {Boolean}\n   */\n\n\n  startsWith(query) {\n    return Array.from(this.getNames()).join(' ').startsWith(query);\n  }\n\n}\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node** – in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document – in this case all its ancestors will be used.\n * * By defining an **array of nodes** – in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes) – The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mixing in an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name` – the name of this item,\n * * `* getAttributeKeys()` – a generator of keys of item attributes,\n * * `getAttribute( keyName )` – a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule(sourceItemRules, itemName) {\n  const itemRule = {\n    name: itemName,\n    allowIn: [],\n    allowContentOf: [],\n    allowWhere: [],\n    allowAttributes: [],\n    allowAttributesOf: [],\n    allowChildren: [],\n    inheritTypesFrom: []\n  };\n  copyTypes(sourceItemRules, itemRule);\n  copyProperty(sourceItemRules, itemRule, 'allowIn');\n  copyProperty(sourceItemRules, itemRule, 'allowContentOf');\n  copyProperty(sourceItemRules, itemRule, 'allowWhere');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributes');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributesOf');\n  copyProperty(sourceItemRules, itemRule, 'allowChildren');\n  copyProperty(sourceItemRules, itemRule, 'inheritTypesFrom');\n  makeInheritAllWork(sourceItemRules, itemRule);\n  return itemRule;\n}\n\nfunction compileAllowChildren(compiledDefinitions, itemName) {\n  const item = compiledDefinitions[itemName];\n\n  for (const allowChildrenItem of item.allowChildren) {\n    const allowedChildren = compiledDefinitions[allowChildrenItem]; // The allowChildren property may point to an unregistered element.\n\n    if (!allowedChildren) {\n      continue;\n    }\n\n    allowedChildren.allowIn.push(itemName);\n  } // The allowIn property already includes correct items, reset the allowChildren property\n  // to avoid duplicates later when setting up compilation results.\n\n\n  item.allowChildren.length = 0;\n}\n\nfunction compileAllowContentOf(compiledDefinitions, itemName) {\n  for (const allowContentOfItemName of compiledDefinitions[itemName].allowContentOf) {\n    // The allowContentOf property may point to an unregistered element.\n    if (compiledDefinitions[allowContentOfItemName]) {\n      const allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);\n      allowedChildren.forEach(allowedItem => {\n        allowedItem.allowIn.push(itemName);\n      });\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowContentOf;\n}\n\nfunction compileAllowWhere(compiledDefinitions, itemName) {\n  for (const allowWhereItemName of compiledDefinitions[itemName].allowWhere) {\n    const inheritFrom = compiledDefinitions[allowWhereItemName]; // The allowWhere property may point to an unregistered element.\n\n    if (inheritFrom) {\n      const allowedIn = inheritFrom.allowIn;\n      compiledDefinitions[itemName].allowIn.push(...allowedIn);\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowWhere;\n}\n\nfunction compileAllowAttributesOf(compiledDefinitions, itemName) {\n  for (const allowAttributeOfItem of compiledDefinitions[itemName].allowAttributesOf) {\n    const inheritFrom = compiledDefinitions[allowAttributeOfItem];\n\n    if (inheritFrom) {\n      const inheritAttributes = inheritFrom.allowAttributes;\n      compiledDefinitions[itemName].allowAttributes.push(...inheritAttributes);\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom(compiledDefinitions, itemName) {\n  const item = compiledDefinitions[itemName];\n\n  for (const inheritPropertiesOfItem of item.inheritTypesFrom) {\n    const inheritFrom = compiledDefinitions[inheritPropertiesOfItem];\n\n    if (inheritFrom) {\n      const typeNames = Object.keys(inheritFrom).filter(name => name.startsWith('is'));\n\n      for (const name of typeNames) {\n        if (!(name in item)) {\n          item[name] = inheritFrom[name];\n        }\n      }\n    }\n  }\n\n  delete item.inheritTypesFrom;\n} // Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\n\n\nfunction cleanUpAllowIn(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  const existingItems = itemRule.allowIn.filter(itemToCheck => compiledDefinitions[itemToCheck]);\n  itemRule.allowIn = Array.from(new Set(existingItems));\n} // Setup allowChildren items based on allowIn.\n\n\nfunction setupAllowChildren(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n\n  for (const allowedParentItemName of itemRule.allowIn) {\n    const allowedParentItem = compiledDefinitions[allowedParentItemName];\n    allowedParentItem.allowChildren.push(itemName);\n  }\n}\n\nfunction cleanUpAllowAttributes(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));\n}\n\nfunction copyTypes(sourceItemRules, itemRule) {\n  for (const sourceItemRule of sourceItemRules) {\n    const typeNames = Object.keys(sourceItemRule).filter(name => name.startsWith('is'));\n\n    for (const name of typeNames) {\n      itemRule[name] = sourceItemRule[name];\n    }\n  }\n}\n\nfunction copyProperty(sourceItemRules, itemRule, propertyName) {\n  for (const sourceItemRule of sourceItemRules) {\n    if (typeof sourceItemRule[propertyName] == 'string') {\n      itemRule[propertyName].push(sourceItemRule[propertyName]);\n    } else if (Array.isArray(sourceItemRule[propertyName])) {\n      itemRule[propertyName].push(...sourceItemRule[propertyName]);\n    }\n  }\n}\n\nfunction makeInheritAllWork(sourceItemRules, itemRule) {\n  for (const sourceItemRule of sourceItemRules) {\n    const inheritFrom = sourceItemRule.inheritAllFrom;\n\n    if (inheritFrom) {\n      itemRule.allowContentOf.push(inheritFrom);\n      itemRule.allowWhere.push(inheritFrom);\n      itemRule.allowAttributesOf.push(inheritFrom);\n      itemRule.inheritTypesFrom.push(inheritFrom);\n    }\n  }\n}\n\nfunction getAllowedChildren(compiledDefinitions, itemName) {\n  const itemRule = compiledDefinitions[itemName];\n  return getValues(compiledDefinitions).filter(def => def.allowIn.includes(itemRule.name));\n}\n\nfunction getValues(obj) {\n  return Object.keys(obj).map(key => obj[key]);\n}\n\nfunction mapContextItem(ctxItem) {\n  if (typeof ctxItem == 'string' || ctxItem.is('documentFragment')) {\n    return {\n      name: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n\n      *getAttributeKeys() {},\n\n      getAttribute() {}\n\n    };\n  } else {\n    return {\n      // '$text' means text nodes and text proxies.\n      name: ctxItem.is('element') ? ctxItem.name : '$text',\n\n      *getAttributeKeys() {\n        yield* ctxItem.getAttributeKeys();\n      },\n\n      getAttribute(key) {\n        return ctxItem.getAttribute(key);\n      }\n\n    };\n  }\n} // Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\n\n\nfunction* combineWalkers(backward, forward) {\n  let done = false;\n\n  while (!done) {\n    done = true;\n\n    if (backward) {\n      const step = backward.next();\n\n      if (!step.done) {\n        done = false;\n        yield {\n          walker: backward,\n          value: step.value\n        };\n      }\n    }\n\n    if (forward) {\n      const step = forward.next();\n\n      if (!step.done) {\n        done = false;\n        yield {\n          walker: forward,\n          value: step.value\n        };\n      }\n    }\n  }\n} // Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\n\n\nfunction* convertToMinimalFlatRanges(ranges) {\n  for (const range of ranges) {\n    yield* range.getMinimalFlatRanges();\n  }\n}\n\nfunction removeDisallowedAttributeFromNode(schema, node, writer) {\n  for (const attribute of node.getAttributeKeys()) {\n    if (!schema.checkAttribute(node, attribute)) {\n      writer.removeAttribute(attribute, node);\n    }\n  }\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js"],"names":["CKEditorError","ObservableMixin","mix","Range","Position","Element","Text","TreeWalker","Schema","constructor","_sourceDefinitions","_attributeProperties","decorate","on","evt","args","SchemaContext","priority","getDefinition","register","itemName","definition","Object","assign","_clearCache","extend","push","getDefinitions","_compiledDefinitions","_compile","item","is","name","isRegistered","isBlock","def","isLimit","isObject","isSelectable","isContent","isInline","checkChild","context","_checkContextMatch","checkAttribute","attributeName","last","allowAttributes","includes","checkMerge","positionOrBaseElement","elementToMerge","nodeBefore","nodeAfter","child","getChildren","addChildCheck","callback","ctx","childDef","retValue","stop","return","addAttributeCheck","setAttributeProperties","properties","getAttributeProperties","getLimitElement","selectionOrRangeOrPosition","element","parent","ranges","Array","from","getRanges","reduce","range","rangeCommonAncestor","getCommonAncestor","includeSelf","checkAttributeInSelection","selection","attribute","isCollapsed","firstPosition","getFirstPosition","getAncestors","getAttributes","value","getValidRanges","convertToMinimalFlatRanges","_getValidRangesForRange","getNearestSelectionRange","position","direction","backwardWalker","forwardWalker","limitElement","reverse","find","root","boundaries","_createIn","startPosition","data","combineWalkers","type","walker","_createOn","nextPosition","findAllowedParent","node","removeDisallowedAttributes","nodes","writer","removeDisallowedAttributeFromNode","rangeInNode","positionsInRange","getPositions","createContext","compiledDefinitions","sourceRules","itemNames","keys","compileBaseItemRule","compileAllowChildren","compileAllowContentOf","compileAllowWhere","compileAllowAttributesOf","compileInheritPropertiesFrom","cleanUpAllowIn","setupAllowChildren","cleanUpAllowAttributes","contextItemIndex","length","contextItem","getItem","allowIn","parentRule","start","end","getItems","shallow","isEqual","_createAfter","isArray","_items","map","mapContextItem","Symbol","iterator","index","getNames","endsWith","query","join","startsWith","sourceItemRules","itemRule","allowContentOf","allowWhere","allowAttributesOf","allowChildren","inheritTypesFrom","copyTypes","copyProperty","makeInheritAllWork","allowChildrenItem","allowedChildren","allowContentOfItemName","getAllowedChildren","forEach","allowedItem","allowWhereItemName","inheritFrom","allowedIn","allowAttributeOfItem","inheritAttributes","inheritPropertiesOfItem","typeNames","filter","existingItems","itemToCheck","Set","allowedParentItemName","allowedParentItem","sourceItemRule","propertyName","inheritAllFrom","getValues","obj","key","ctxItem","getAttributeKeys","getAttribute","backward","forward","done","step","next","getMinimalFlatRanges","schema","removeAttribute"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMe,aAAN,CAAoB;AAC1B;AACD;AACA;AACA;AACA;AACCP,EAAAA,WAAW,CAAEiC,OAAF,EAAY;AACtB,QAAKA,OAAO,YAAY1B,aAAxB,EAAwC;AACvC,aAAO0B,OAAP;AACA;;AAED,QAAK,OAAOA,OAAP,IAAkB,QAAvB,EAAkC;AACjCA,MAAAA,OAAO,GAAG,CAAEA,OAAF,CAAV;AACA,KAFD,MAEO,IAAK,CAAC8B,KAAK,CAACyE,OAAN,CAAevG,OAAf,CAAN,EAAiC;AACvC;AACA;AACAA,MAAAA,OAAO,GAAGA,OAAO,CAAC4C,YAAR,CAAsB;AAAEP,QAAAA,WAAW,EAAE;AAAf,OAAtB,CAAV;AACA;;AAED,SAAKmE,MAAL,GAAcxG,OAAO,CAACyG,GAAR,CAAaC,cAAb,CAAd;AACA;AAED;AACD;AACA;AACA;AACA;;;AACW,MAANd,MAAM,GAAG;AACZ,WAAO,KAAKY,MAAL,CAAYZ,MAAnB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACS,MAAJxF,IAAI,GAAG;AACV,WAAO,KAAKoG,MAAL,CAAa,KAAKA,MAAL,CAAYZ,MAAZ,GAAqB,CAAlC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACkB,GAAfe,MAAM,CAACC,QAAQ,IAAK;AACrB,WAAO,KAAKJ,MAAL,CAAaG,MAAM,CAACC,QAApB,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC5H,EAAAA,IAAI,CAAEI,IAAF,EAAS;AACZ,UAAM4B,GAAG,GAAG,IAAI1C,aAAJ,CAAmB,CAAEc,IAAF,CAAnB,CAAZ;AAEA4B,IAAAA,GAAG,CAACwF,MAAJ,GAAa,CAAE,GAAG,KAAKA,MAAV,EAAkB,GAAGxF,GAAG,CAACwF,MAAzB,CAAb;AAEA,WAAOxF,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACC8E,EAAAA,OAAO,CAAEe,KAAF,EAAU;AAChB,WAAO,KAAKL,MAAL,CAAaK,KAAb,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACW,GAARC,QAAQ,GAAG;AACZ,WAAO,KAAKN,MAAL,CAAYC,GAAZ,CAAiBrH,IAAI,IAAIA,IAAI,CAACE,IAA9B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCyH,EAAAA,QAAQ,CAAEC,KAAF,EAAU;AACjB,WAAOlF,KAAK,CAACC,IAAN,CAAY,KAAK+E,QAAL,EAAZ,EAA8BG,IAA9B,CAAoC,GAApC,EAA0CF,QAA1C,CAAoDC,KAApD,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,UAAU,CAAEF,KAAF,EAAU;AACnB,WAAOlF,KAAK,CAACC,IAAN,CAAY,KAAK+E,QAAL,EAAZ,EAA8BG,IAA9B,CAAoC,GAApC,EAA0CC,UAA1C,CAAsDF,KAAtD,CAAP;AACA;;AAtIyB;AAyI3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n\n/**\n * The model's schema. It defines the allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by the features and based on them, the editing framework and features\n * make decisions on how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * The {@glink framework/guides/architecture/editing-engine#schema schema section} of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture} guide.\n * * The {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema {\n\t/**\n\t * Creates a schema instance.\n\t */\n\tconstructor() {\n\t\tthis._sourceDefinitions = {};\n\n\t\t/**\n\t\t * A dictionary containing attribute properties.\n\t\t *\n\t\t * @private\n\t\t * @member {Object.<String,String>}\n\t\t */\n\t\tthis._attributeProperties = {};\n\n\t\tthis.decorate( 'checkChild' );\n\t\tthis.decorate( 'checkAttribute' );\n\n\t\tthis.on( 'checkAttribute', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.on( 'checkChild', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t\targs[ 1 ] = this.getDefinition( args[ 1 ] );\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Registers a schema item. Can only be called once for every item name.\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tinheritAllFrom: '$block'\n\t *\t\t} );\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\tregister( itemName, definition ) {\n\t\tif ( this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * A single item cannot be registered twice in the schema.\n\t\t\t *\n\t\t\t * This situation may happen when:\n\t\t\t *\n\t\t\t * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n\t\t\t * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n\t\t\t * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n\t\t\t * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n\t\t\t * and usually means one or more of the following issues:\n\t\t\t *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n\t\t\t *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n\t\t\t *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n\t\t\t *\n\t\t\t * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element that is being registered twice.\n\t\t\t * @error schema-cannot-register-item-twice\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'schema-cannot-register-item-twice',\n\t\t\t\tthis,\n\t\t\t\t{\n\t\t\t\t\titemName\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ] = [\n\t\t\tObject.assign( {}, definition )\n\t\t];\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Extends a {@link #register registered} item's definition.\n\t *\n\t * Extending properties such as `allowIn` will add more items to the existing properties,\n\t * while redefining properties such as `isBlock` will override the previously defined ones.\n\t *\n\t *\t\tschema.register( 'foo', {\n\t *\t\t\tallowIn: '$root',\n\t *\t\t\tisBlock: true;\n\t *\t\t} );\n\t *\t\tschema.extend( 'foo', {\n\t *\t\t\tallowIn: 'blockQuote',\n\t *\t\t\tisBlock: false\n\t *\t\t} );\n\t *\n\t *\t\tschema.getDefinition( 'foo' );\n\t *\t\t//\t{\n\t *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n\t *\t\t// \t\tisBlock: false\n\t *\t\t//\t}\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\textend( itemName, definition ) {\n\t\tif ( !this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * Cannot extend an item which was not registered yet.\n\t\t\t *\n\t\t\t * This error happens when a plugin tries to extend the schema definition of an item which was not\n\t\t\t * {@link #register registered} yet.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element which is being extended.\n\t\t\t * @error schema-cannot-extend-missing-item\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'schema-cannot-extend-missing-item', this, {\n\t\t\t\titemName\n\t\t\t} );\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ].push( Object.assign( {}, definition ) );\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Returns data of all registered items.\n\t *\n\t * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n\t * checking a list of all block elements, etc).\n\t * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n\t * in other cases.\n\t *\n\t * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n\t */\n\tgetDefinitions() {\n\t\tif ( !this._compiledDefinitions ) {\n\t\t\tthis._compile();\n\t\t}\n\n\t\treturn this._compiledDefinitions;\n\t}\n\n\t/**\n\t * Returns a definition of the given item or `undefined` if an item is not registered.\n\t *\n\t * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n\t * checking a list of all block elements, etc).\n\t * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n\t * in other cases.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n\t */\n\tgetDefinition( item ) {\n\t\tlet itemName;\n\n\t\tif ( typeof item == 'string' ) {\n\t\t\titemName = item;\n\t\t} else if ( item.is && ( item.is( '$text' ) || item.is( '$textProxy' ) ) ) {\n\t\t\titemName = '$text';\n\t\t}\n\t\t// Element or module:engine/model/schema~SchemaContextItem.\n\t\telse {\n\t\t\titemName = item.name;\n\t\t}\n\n\t\treturn this.getDefinitions()[ itemName ];\n\t}\n\n\t/**\n\t * Returns `true` if the given item is registered in the schema.\n\t *\n\t *\t\tschema.isRegistered( 'paragraph' ); // -> true\n\t *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isRegistered( 'foo' ); // -> false\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n \t * @returns {Boolean}\n\t */\n\tisRegistered( item ) {\n\t\treturn !!this.getDefinition( item );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n\t *\n\t *\t\tschema.isBlock( 'paragraph' ); // -> true\n\t *\t\tschema.isBlock( '$root' ); // -> false\n\t *\n\t *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n\t *\t\tschema.isBlock( paragraphElement ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n\t */\n\tisBlock( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isBlock );\n\t}\n\n\t/**\n\t * Returns `true` if the given item should be treated as a limit element.\n\t *\n\t * It considers an item to be a limit element if its\n\t * {@link module:engine/model/schema~SchemaItemDefinition}'s\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n\t * was set to `true`.\n\t *\n\t *\t\tschema.isLimit( 'paragraph' ); // -> false\n\t *\t\tschema.isLimit( '$root' ); // -> true\n\t *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isLimit( 'imageBlock' ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n\t */\n\tisLimit( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isLimit || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item should be treated as an object element.\n\t *\n\t * It considers an item to be an object element if its\n\t * {@link module:engine/model/schema~SchemaItemDefinition}'s\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n\t * was set to `true`.\n\t *\n\t *\t\tschema.isObject( 'paragraph' ); // -> false\n\t *\t\tschema.isObject( 'imageBlock' ); // -> true\n\t *\n\t *\t\tconst imageElement = writer.createElement( 'imageBlock' );\n\t *\t\tschema.isObject( imageElement ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n  \t * @returns {Boolean}\n\t */\n\tisObject( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n\t\t// to understand why these three constitute an object.\n\t\treturn !!( def.isObject || ( def.isLimit && def.isSelectable && def.isContent ) );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n\t *\n\t *\t\tschema.isInline( 'paragraph' ); // -> false\n\t *\t\tschema.isInline( 'softBreak' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isInline( text ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {Boolean}\n\t */\n\tisInline( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isInline );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n\t *\n\t *\t\tschema.isSelectable( 'paragraph' ); // -> false\n\t *\t\tschema.isSelectable( 'heading1' ); // -> false\n\t *\t\tschema.isSelectable( 'imageBlock' ); // -> true\n\t *\t\tschema.isSelectable( 'tableCell' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isSelectable( text ); // -> false\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {Boolean}\n\t */\n\tisSelectable( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isSelectable || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n\t *\n\t *\t\tschema.isContent( 'paragraph' ); // -> false\n\t *\t\tschema.isContent( 'heading1' ); // -> false\n\t *\t\tschema.isContent( 'imageBlock' ); // -> true\n\t *\t\tschema.isContent( 'horizontalLine' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isContent( text ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n\t * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {Boolean}\n\t */\n\tisContent( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isContent || def.isObject );\n\t}\n\n\t/**\n\t * Checks whether the given node (`child`) can be a child of the given context.\n\t *\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tallowIn: '$root'\n\t *\t\t} );\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n\t *\n\t * Note: When verifying whether the given node can be a child of the given context, the\n\t * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n\t * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n\t * It happens if one of the context's elements does not allow its child.\n\t *\n\t * @fires checkChild\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n\t * @param {module:engine/model/node~Node|String} def The child to check.\n\t * @returns {Boolean}\n\t */\n\tcheckChild( context, def ) {\n\t\t// Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._checkContextMatch( def, context );\n\t}\n\n\t/**\n\t * Checks whether the given attribute can be applied in the given context (on the last\n\t * item of the context).\n\t *\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n\t *\n\t *\t\tschema.extend( '$text', {\n\t *\t\t\tallowAttributes: 'bold'\n\t *\t\t} );\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n\t *\n\t * @fires checkAttribute\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n\t * @param {String} attributeName\n\t * @returns {Boolean}\n\t */\n\tcheckAttribute( context, attributeName ) {\n\t\tconst def = this.getDefinition( context.last );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn def.allowAttributes.includes( attributeName );\n\t}\n\n\t/**\n\t * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n\t *\n\t * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n\t *\n\t * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n\t * will be valid.\n\t *\n\t * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n\t * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n\t *\n\t * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n\t * element to which the `elementToMerge` will be merged.\n\t * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n\t * @returns {Boolean}\n\t */\n\tcheckMerge( positionOrBaseElement, elementToMerge = null ) {\n\t\tif ( positionOrBaseElement instanceof Position ) {\n\t\t\tconst nodeBefore = positionOrBaseElement.nodeBefore;\n\t\t\tconst nodeAfter = positionOrBaseElement.nodeAfter;\n\n\t\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node before the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-before\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-before',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node after the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-after\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-after',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.checkMerge( nodeBefore, nodeAfter );\n\t\t}\n\n\t\tfor ( const child of elementToMerge.getChildren() ) {\n\t\t\tif ( !this.checkChild( positionOrBaseElement, child ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkChild} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow elements in specific contexts.\n\t *\n\t * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow heading1 directly inside a blockQuote.\n\t *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkChild', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst childDefinition = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkChild()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and\n\t * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n\t * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n\t */\n\taddChildCheck( callback ) {\n\t\tthis.on( 'checkChild', ( evt, [ ctx, childDef ] ) => {\n\t\t\t// checkChild() was called with a non-registered child.\n\t\t\t// In 99% cases such check should return false, so not to overcomplicate all callbacks\n\t\t\t// don't even execute them.\n\t\t\tif ( !childDef ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst retValue = callback( ctx, childDef );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkAttribute} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow attribute if node to which it is applied\n\t * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n\t *\n\t * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow bold on $text inside heading1.\n\t *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst attributeName = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkAttribute()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n\t * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n\t */\n\taddAttributeCheck( callback ) {\n\t\tthis.on( 'checkAttribute', ( evt, [ ctx, attributeName ] ) => {\n\t\t\tconst retValue = callback( ctx, attributeName );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * This method allows assigning additional metadata to the model attributes. For example,\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n\t * used to mark formatting attributes (like `bold` or `italic`).\n\t *\n\t *\t\t// Mark bold as a formatting attribute.\n\t *\t\tschema.setAttributeProperties( 'bold', {\n\t *\t\t\tisFormatting: true\n\t *\t\t} );\n\t *\n\t *\t\t// Override code not to be considered a formatting markup.\n\t *\t\tschema.setAttributeProperties( 'code', {\n\t *\t\t\tisFormatting: false\n\t *\t\t} );\n\t *\n\t * Properties are not limited to members defined in the\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tcustomProperty: 'value'\n\t *\t\t} );\n\t *\n\t * Subsequent calls with the same attribute will extend its custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tone: 1\n\t *\t\t} );\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\ttwo: 2\n\t *\t\t} );\n\t *\n\t *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n\t *\t\t// Logs: { one: 1, two: 2 }\n\t *\n\t * @param {String} attributeName A name of the attribute to receive the properties.\n\t * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n\t */\n\tsetAttributeProperties( attributeName, properties ) {\n\t\tthis._attributeProperties[ attributeName ] = Object.assign( this.getAttributeProperties( attributeName ), properties );\n\t}\n\n\t/**\n\t * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n\t *\n\t * @param {String} attributeName A name of the attribute.\n\t * @returns {module:engine/model/schema~AttributeProperties}\n\t */\n\tgetAttributeProperties( attributeName ) {\n\t\treturn this._attributeProperties[ attributeName ] || {};\n\t}\n\n\t/**\n\t * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n\t * selection/range/position or the root otherwise.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n\t * The selection/range/position to check.\n\t * @returns {module:engine/model/element~Element} The lowest limit element containing\n\t * the entire `selectionOrRangeOrPosition`.\n\t */\n\tgetLimitElement( selectionOrRangeOrPosition ) {\n\t\tlet element;\n\n\t\tif ( selectionOrRangeOrPosition instanceof Position ) {\n\t\t\telement = selectionOrRangeOrPosition.parent;\n\t\t} else {\n\t\t\tconst ranges = selectionOrRangeOrPosition instanceof Range ?\n\t\t\t\t[ selectionOrRangeOrPosition ] :\n\t\t\t\tArray.from( selectionOrRangeOrPosition.getRanges() );\n\n\t\t\t// Find the common ancestor for all selection's ranges.\n\t\t\telement = ranges\n\t\t\t\t.reduce( ( element, range ) => {\n\t\t\t\t\tconst rangeCommonAncestor = range.getCommonAncestor();\n\n\t\t\t\t\tif ( !element ) {\n\t\t\t\t\t\treturn rangeCommonAncestor;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element.getCommonAncestor( rangeCommonAncestor, { includeSelf: true } );\n\t\t\t\t}, null );\n\t\t}\n\n\t\twhile ( !this.isLimit( element ) ) {\n\t\t\tif ( element.parent ) {\n\t\t\t\telement = element.parent;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n\n\t/**\n\t * Checks whether the attribute is allowed in selection:\n\t *\n\t * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n\t * * if the selection is collapsed, then checks if on the selection position there's a text with the\n\t * specified attribute allowed.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection which will be checked.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Boolean}\n\t */\n\tcheckAttributeInSelection( selection, attribute ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\tconst firstPosition = selection.getFirstPosition();\n\t\t\tconst context = [\n\t\t\t\t...firstPosition.getAncestors(),\n\t\t\t\tnew Text( '', selection.getAttributes() )\n\t\t\t];\n\n\t\t\t// Check whether schema allows for a text with the attribute in the selection.\n\t\t\treturn this.checkAttribute( context, attribute );\n\t\t} else {\n\t\t\tconst ranges = selection.getRanges();\n\n\t\t\t// For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tif ( this.checkAttribute( value.item, attribute ) ) {\n\t\t\t\t\t\t// If we found a node that is allowed to have the attribute, return true.\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't found such node, return false.\n\t\treturn false;\n\t}\n\n\t/**\n\t * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* getValidRanges( ranges, attribute ) {\n\t\tranges = convertToMinimalFlatRanges( ranges );\n\n\t\tfor ( const range of ranges ) {\n\t\t\tyield* this._getValidRangesForRange( range, attribute );\n\t\t}\n\t}\n\n\t/**\n\t * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n\t * nearest to that `position` and is a correct range for selection.\n\t *\n\t * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n\t * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n\t * the {@link module:engine/model/schema~Schema schema}.\n\t *\n\t * Direction of searching for the nearest correct selection range can be specified as:\n\t *\n\t * * `both` - searching will be performed in both ways,\n\t * * `forward` - searching will be performed only forward,\n\t * * `backward` - searching will be performed only backward.\n\t *\n\t * When valid selection range cannot be found, `null` is returned.\n\t *\n\t * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n\t * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n\t * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n\t */\n\tgetNearestSelectionRange( position, direction = 'both' ) {\n\t\t// Return collapsed range if provided position is valid.\n\t\tif ( this.checkChild( position, '$text' ) ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\tlet backwardWalker, forwardWalker;\n\n\t\t// Never leave a limit element.\n\t\tconst limitElement = position.getAncestors().reverse().find( item => this.isLimit( item ) ) || position.root;\n\n\t\tif ( direction == 'both' || direction == 'backward' ) {\n\t\t\tbackwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position,\n\t\t\t\tdirection: 'backward'\n\t\t\t} );\n\t\t}\n\n\t\tif ( direction == 'both' || direction == 'forward' ) {\n\t\t\tforwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position\n\t\t\t} );\n\t\t}\n\n\t\tfor ( const data of combineWalkers( backwardWalker, forwardWalker ) ) {\n\t\t\tconst type = ( data.walker == backwardWalker ? 'elementEnd' : 'elementStart' );\n\t\t\tconst value = data.value;\n\n\t\t\tif ( value.type == type && this.isObject( value.item ) ) {\n\t\t\t\treturn Range._createOn( value.item );\n\t\t\t}\n\n\t\t\tif ( this.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\t\treturn new Range( value.nextPosition );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Tries to find position ancestors that allow to insert a given node.\n\t * It starts searching from the given position and goes node by node to the top of the model tree\n\t * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n\t * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n\t *\n\t * @param {module:engine/model/position~Position} position The position that the search will start from.\n\t * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n\t * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n\t */\n\tfindAllowedParent( position, node ) {\n\t\tlet parent = position.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( this.checkChild( parent, node ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\t// Do not split limit elements.\n\t\t\tif ( this.isLimit( parent ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes attributes disallowed by the schema.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\tremoveDisallowedAttributes( nodes, writer ) {\n\t\tfor ( const node of nodes ) {\n\t\t\t// When node is a `Text` it has no children, so just filter it out.\n\t\t\tif ( node.is( '$text' ) ) {\n\t\t\t\tremoveDisallowedAttributeFromNode( this, node, writer );\n\t\t\t}\n\t\t\t// In a case of `Element` iterates through positions between nodes inside this element\n\t\t\t// and filter out node before the current position, or position parent when position\n\t\t\t// is at start of an element. Using positions prevent from omitting merged nodes\n\t\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n\t\t\telse {\n\t\t\t\tconst rangeInNode = Range._createIn( node );\n\t\t\t\tconst positionsInRange = rangeInNode.getPositions();\n\n\t\t\t\tfor ( const position of positionsInRange ) {\n\t\t\t\t\tconst item = position.nodeBefore || position.parent;\n\n\t\t\t\t\tremoveDisallowedAttributeFromNode( this, item, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an instance of the schema context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t * @returns {module:engine/model/schema~SchemaContext}\n\t */\n\tcreateContext( context ) {\n\t\treturn new SchemaContext( context );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_clearCache() {\n\t\tthis._compiledDefinitions = null;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_compile() {\n\t\tconst compiledDefinitions = {};\n\t\tconst sourceRules = this._sourceDefinitions;\n\t\tconst itemNames = Object.keys( sourceRules );\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompiledDefinitions[ itemName ] = compileBaseItemRule( sourceRules[ itemName ], itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowChildren( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowContentOf( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowWhere( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowAttributesOf( compiledDefinitions, itemName );\n\t\t\tcompileInheritPropertiesFrom( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcleanUpAllowIn( compiledDefinitions, itemName );\n\t\t\tsetupAllowChildren( compiledDefinitions, itemName );\n\t\t\tcleanUpAllowAttributes( compiledDefinitions, itemName );\n\t\t}\n\n\t\tthis._compiledDefinitions = compiledDefinitions;\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n\t * @param {module:engine/model/schema~SchemaContext} context\n\t * @param {Number} contextItemIndex\n\t */\n\t_checkContextMatch( def, context, contextItemIndex = context.length - 1 ) {\n\t\tconst contextItem = context.getItem( contextItemIndex );\n\n\t\tif ( def.allowIn.includes( contextItem.name ) ) {\n\t\t\tif ( contextItemIndex == 0 ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst parentRule = this.getDefinition( contextItem );\n\n\t\t\t\treturn this._checkContextMatch( parentRule, context, contextItemIndex - 1 );\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n\t * inside the given range on which the attribute can be applied.\n\t *\n\t * This is a helper function for {@link ~Schema#getValidRanges}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range to process.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* _getValidRangesForRange( range, attribute ) {\n\t\tlet start = range.start;\n\t\tlet end = range.start;\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tyield* this._getValidRangesForRange( Range._createIn( item ), attribute );\n\t\t\t}\n\n\t\t\tif ( !this.checkAttribute( item, attribute ) ) {\n\t\t\t\tif ( !start.isEqual( end ) ) {\n\t\t\t\t\tyield new Range( start, end );\n\t\t\t\t}\n\n\t\t\t\tstart = Position._createAfter( item );\n\t\t\t}\n\n\t\t\tend = Position._createAfter( item );\n\t\t}\n\n\t\tif ( !start.isEqual( end ) ) {\n\t\t\tyield new Range( start, end );\n\t\t}\n\t}\n}\n\nmix( Schema, ObservableMixin );\n\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding standard behavior of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you do not have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\", you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding the standard behavior of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you do not have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1`, you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * {@link ~SchemaItemDefinition#allowIn `allowIn`} &ndash; Defines in which other items this item will be allowed.\n * * {@link ~SchemaItemDefinition#allowChildren `allowChildren`} &ndash; Defines which other items are allowed inside this item.\n * * {@link ~SchemaItemDefinition#allowAttributes `allowAttributes`} &ndash; Defines allowed attributes of the given item.\n * * {@link ~SchemaItemDefinition#allowContentOf `allowContentOf`} &ndash; Inherits \"allowed children\" from other items.\n * * {@link ~SchemaItemDefinition#allowWhere `allowWhere`} &ndash; Inherits \"allowed in\" from other items.\n * * {@link ~SchemaItemDefinition#allowAttributesOf `allowAttributesOf`} &ndash; Inherits attributes from other items.\n * * {@link ~SchemaItemDefinition#inheritTypesFrom `inheritTypesFrom`} &ndash; Inherits `is*` properties of other items.\n * * {@link ~SchemaItemDefinition#inheritAllFrom `inheritAllFrom`} &ndash;\n * A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * # The `is*` properties\n *\n * There are a couple commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * {@link ~SchemaItemDefinition#isBlock `isBlock`} &ndash; Whether this item is paragraph-like.\n * Generally speaking, content is usually made out of blocks like paragraphs, list items, images, headings, etc.\n * * {@link ~SchemaItemDefinition#isInline `isInline`} &ndash; Whether an item is \"text-like\" and should be treated as an inline node.\n * Examples of inline elements: `$text`, `softBreak` (`<br>`), etc.\n * * {@link ~SchemaItemDefinition#isLimit `isLimit`} &ndash; It can be understood as whether this element\n * should not be split by <kbd>Enter</kbd>. Examples of limit elements: `$root`, table cell, image caption, etc.\n * In other words, all actions that happen inside a limit element are limited to its content.\n * All objects are treated as limit elements, too.\n * * {@link ~SchemaItemDefinition#isObject `isObject`} &ndash; Whether an item is \"self-contained\" and should be treated as a whole.\n * Examples of object elements: `imageBlock`, `table`, `video`, etc. An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the meaning of these types in the\n * {@glink framework/guides/deep-dive/schema#defining-additional-semantics dedicated section of the Schema deep dive} guide.\n *\n * # Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` inside a `$root` and allow `$text` as a `paragraph` child:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: '$root',\n *\t\t\tallowChildren: '$text',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Make `imageBlock` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'imageBlock', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n * Make `caption` allowed in `imageBlock` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'imageBlock',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about defining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n *\n * @property {String|Array.<String>} allowIn Defines in which other items this item will be allowed.\n * @property {String|Array.<String>} allowChildren Defines which other items are allowed inside this item.\n * @property {String|Array.<String>} allowAttributes Defines allowed attributes of the given item.\n * @property {String|Array.<String>} allowContentOf Inherits \"allowed children\" from other items.\n * @property {String|Array.<String>} allowWhere Inherits \"allowed in\" from other items.\n * @property {String|Array.<String>} allowAttributesOf Inherits attributes from other items.\n * @property {String|Array.<String>} inheritTypesFrom Inherits `is*` properties of other items.\n * @property {String} inheritAllFrom A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * @property {Boolean} isBlock\n * Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n *\n * Read more about the block elements in the\n * {@glink framework/guides/deep-dive/schema#block-elements Block elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive}.\n *\n * @property {Boolean} isInline\n * Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * Read more about the inline elements in the\n * {@glink framework/guides/deep-dive/schema#inline-elements Inline elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isLimit\n * It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content.\n *\n * Read more about the limit elements in the\n * {@glink framework/guides/deep-dive/schema#limit-elements Limit elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isObject\n * Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `imageBlock`, `table`, `video`, etc.\n *\n * **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the object elements in the\n * {@glink framework/guides/deep-dive/schema#object-elements Object elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isSelectable\n * `true` when an element should be selectable as a whole by the user. Examples of selectable elements: `imageBlock`, `table`, `tableCell`,\n * etc.\n *\n * **Note:** An object is also a selectable element, so\n * {@link module:engine/model/schema~Schema#isSelectable `isSelectable()`} returns `true` for object elements automatically.\n *\n * Read more about selectable elements in the\n * {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isContent\n * An item is a content when it always finds its way to the editor data output regardless of the number and type of its descendants.\n * Examples of content elements: `$text`, `imageBlock`, `table`, etc. (but not `paragraph`, `heading1` or `tableCell`).\n *\n * **Note:** An object is also a content element, so\n * {@link module:engine/model/schema~Schema#isContent `isContent()`} returns `true` for object elements automatically.\n *\n * Read more about content elements in the\n * {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefinition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowChildren` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n\t/**\n\t * Creates an instance of the context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t */\n\tconstructor( context ) {\n\t\tif ( context instanceof SchemaContext ) {\n\t\t\treturn context;\n\t\t}\n\n\t\tif ( typeof context == 'string' ) {\n\t\t\tcontext = [ context ];\n\t\t} else if ( !Array.isArray( context ) ) {\n\t\t\t// `context` is item or position.\n\t\t\t// Position#getAncestors() doesn't accept any parameters but it works just fine here.\n\t\t\tcontext = context.getAncestors( { includeSelf: true } );\n\t\t}\n\n\t\tthis._items = context.map( mapContextItem );\n\t}\n\n\t/**\n\t * The number of items.\n\t *\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * The last item (the lowest node).\n\t *\n\t * @type {module:engine/model/schema~SchemaContextItem}\n\t */\n\tget last() {\n\t\treturn this._items[ this._items.length - 1 ];\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all context items.\n\t *\n\t * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns a new schema context instance with an additional item.\n\t *\n\t * Item can be added as:\n\t *\n\t * \t\tconst context = new SchemaContext( [ '$root' ] );\n\t *\n\t * \t\t// An element.\n\t * \t\tconst fooElement = writer.createElement( 'fooElement' );\n\t * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n\t *\n\t * \t\t// A text node.\n\t * \t\tconst text = writer.createText( 'foobar' );\n\t * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n\t *\n\t * \t\t// A string (element name).\n\t * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n\t *\n\t * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n\t * (without ancestors).\n\t *\n\t * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n\t * to the current context.\n\t * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n\t */\n\tpush( item ) {\n\t\tconst ctx = new SchemaContext( [ item ] );\n\n\t\tctx._items = [ ...this._items, ...ctx._items ];\n\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * Gets an item on the given index.\n\t *\n\t * @returns {module:engine/model/schema~SchemaContextItem}\n\t */\n\tgetItem( index ) {\n\t\treturn this._items[ index ];\n\t}\n\n\t/**\n\t * Returns the names of items.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* getNames() {\n\t\tyield* this._items.map( item => item.name );\n\t}\n\n\t/**\n\t * Checks whether the context ends with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$text' ); // -> true\n\t *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n\t *\t\tctx.endsWith( '$root' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tendsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).endsWith( query );\n\t}\n\n\t/**\n\t * Checks whether the context starts with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$root' ); // -> true\n\t *\t\tctx.endsWith( '$root paragraph' ); // -> true\n\t *\t\tctx.endsWith( '$text' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tstartsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).startsWith( query );\n\t}\n}\n\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node** – in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document – in this case all its ancestors will be used.\n * * By defining an **array of nodes** – in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes) – The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mixing in an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name` – the name of this item,\n * * `* getAttributeKeys()` – a generator of keys of item attributes,\n * * `getAttribute( keyName )` – a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule( sourceItemRules, itemName ) {\n\tconst itemRule = {\n\t\tname: itemName,\n\n\t\tallowIn: [],\n\t\tallowContentOf: [],\n\t\tallowWhere: [],\n\n\t\tallowAttributes: [],\n\t\tallowAttributesOf: [],\n\n\t\tallowChildren: [],\n\n\t\tinheritTypesFrom: []\n\t};\n\n\tcopyTypes( sourceItemRules, itemRule );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowIn' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowContentOf' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowWhere' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributes' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributesOf' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowChildren' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'inheritTypesFrom' );\n\n\tmakeInheritAllWork( sourceItemRules, itemRule );\n\n\treturn itemRule;\n}\n\nfunction compileAllowChildren( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const allowChildrenItem of item.allowChildren ) {\n\t\tconst allowedChildren = compiledDefinitions[ allowChildrenItem ];\n\n\t\t// The allowChildren property may point to an unregistered element.\n\t\tif ( !allowedChildren ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tallowedChildren.allowIn.push( itemName );\n\t}\n\n\t// The allowIn property already includes correct items, reset the allowChildren property\n\t// to avoid duplicates later when setting up compilation results.\n\titem.allowChildren.length = 0;\n}\n\nfunction compileAllowContentOf( compiledDefinitions, itemName ) {\n\tfor ( const allowContentOfItemName of compiledDefinitions[ itemName ].allowContentOf ) {\n\t\t// The allowContentOf property may point to an unregistered element.\n\t\tif ( compiledDefinitions[ allowContentOfItemName ] ) {\n\t\t\tconst allowedChildren = getAllowedChildren( compiledDefinitions, allowContentOfItemName );\n\n\t\t\tallowedChildren.forEach( allowedItem => {\n\t\t\t\tallowedItem.allowIn.push( itemName );\n\t\t\t} );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowContentOf;\n}\n\nfunction compileAllowWhere( compiledDefinitions, itemName ) {\n\tfor ( const allowWhereItemName of compiledDefinitions[ itemName ].allowWhere ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowWhereItemName ];\n\n\t\t// The allowWhere property may point to an unregistered element.\n\t\tif ( inheritFrom ) {\n\t\t\tconst allowedIn = inheritFrom.allowIn;\n\n\t\t\tcompiledDefinitions[ itemName ].allowIn.push( ...allowedIn );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowWhere;\n}\n\nfunction compileAllowAttributesOf( compiledDefinitions, itemName ) {\n\tfor ( const allowAttributeOfItem of compiledDefinitions[ itemName ].allowAttributesOf ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowAttributeOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst inheritAttributes = inheritFrom.allowAttributes;\n\n\t\t\tcompiledDefinitions[ itemName ].allowAttributes.push( ...inheritAttributes );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const inheritPropertiesOfItem of item.inheritTypesFrom ) {\n\t\tconst inheritFrom = compiledDefinitions[ inheritPropertiesOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst typeNames = Object.keys( inheritFrom ).filter( name => name.startsWith( 'is' ) );\n\n\t\t\tfor ( const name of typeNames ) {\n\t\t\t\tif ( !( name in item ) ) {\n\t\t\t\t\titem[ name ] = inheritFrom[ name ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete item.inheritTypesFrom;\n}\n\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\tconst existingItems = itemRule.allowIn.filter( itemToCheck => compiledDefinitions[ itemToCheck ] );\n\n\titemRule.allowIn = Array.from( new Set( existingItems ) );\n}\n\n// Setup allowChildren items based on allowIn.\nfunction setupAllowChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\tfor ( const allowedParentItemName of itemRule.allowIn ) {\n\t\tconst allowedParentItem = compiledDefinitions[ allowedParentItemName ];\n\n\t\tallowedParentItem.allowChildren.push( itemName );\n\t}\n}\n\nfunction cleanUpAllowAttributes( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\titemRule.allowAttributes = Array.from( new Set( itemRule.allowAttributes ) );\n}\n\nfunction copyTypes( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst typeNames = Object.keys( sourceItemRule ).filter( name => name.startsWith( 'is' ) );\n\n\t\tfor ( const name of typeNames ) {\n\t\t\titemRule[ name ] = sourceItemRule[ name ];\n\t\t}\n\t}\n}\n\nfunction copyProperty( sourceItemRules, itemRule, propertyName ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tif ( typeof sourceItemRule[ propertyName ] == 'string' ) {\n\t\t\titemRule[ propertyName ].push( sourceItemRule[ propertyName ] );\n\t\t} else if ( Array.isArray( sourceItemRule[ propertyName ] ) ) {\n\t\t\titemRule[ propertyName ].push( ...sourceItemRule[ propertyName ] );\n\t\t}\n\t}\n}\n\nfunction makeInheritAllWork( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst inheritFrom = sourceItemRule.inheritAllFrom;\n\n\t\tif ( inheritFrom ) {\n\t\t\titemRule.allowContentOf.push( inheritFrom );\n\t\t\titemRule.allowWhere.push( inheritFrom );\n\t\t\titemRule.allowAttributesOf.push( inheritFrom );\n\t\t\titemRule.inheritTypesFrom.push( inheritFrom );\n\t\t}\n\t}\n}\n\nfunction getAllowedChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\treturn getValues( compiledDefinitions ).filter( def => def.allowIn.includes( itemRule.name ) );\n}\n\nfunction getValues( obj ) {\n\treturn Object.keys( obj ).map( key => obj[ key ] );\n}\n\nfunction mapContextItem( ctxItem ) {\n\tif ( typeof ctxItem == 'string' || ctxItem.is( 'documentFragment' ) ) {\n\t\treturn {\n\t\t\tname: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n\n\t\t\t* getAttributeKeys() {},\n\n\t\t\tgetAttribute() {}\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\t// '$text' means text nodes and text proxies.\n\t\t\tname: ctxItem.is( 'element' ) ? ctxItem.name : '$text',\n\n\t\t\t* getAttributeKeys() {\n\t\t\t\tyield* ctxItem.getAttributeKeys();\n\t\t\t},\n\n\t\t\tgetAttribute( key ) {\n\t\t\t\treturn ctxItem.getAttribute( key );\n\t\t\t}\n\t\t};\n\t}\n}\n\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers( backward, forward ) {\n\tlet done = false;\n\n\twhile ( !done ) {\n\t\tdone = true;\n\n\t\tif ( backward ) {\n\t\t\tconst step = backward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: backward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( forward ) {\n\t\t\tconst step = forward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: forward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\nfunction* convertToMinimalFlatRanges( ranges ) {\n\tfor ( const range of ranges ) {\n\t\tyield* range.getMinimalFlatRanges();\n\t}\n}\n\nfunction removeDisallowedAttributeFromNode( schema, node, writer ) {\n\tfor ( const attribute of node.getAttributeKeys() ) {\n\t\tif ( !schema.checkAttribute( node, attribute ) ) {\n\t\t\twriter.removeAttribute( attribute, node );\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}