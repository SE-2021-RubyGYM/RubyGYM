{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/deletecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport ChangeBuffer from './utils/changebuffer';\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\n\nexport default class DeleteCommand extends Command {\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n   * should consume the content when the selection is collapsed.\n   */\n  constructor(editor, direction) {\n    super(editor);\n    /**\n     * The directionality of the delete describing in what direction it should\n     * consume the content when the selection is collapsed.\n     *\n     * @readonly\n     * @member {'forward'|'backward'} #direction\n     */\n\n    this.direction = direction;\n    /**\n     * Delete's change buffer used to group subsequent changes into batches.\n     *\n     * @readonly\n     * @private\n     * @type {module:typing/utils/changebuffer~ChangeBuffer}\n     */\n\n    this._buffer = new ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));\n  }\n  /**\n   * The current change buffer.\n   *\n   * @type {module:typing/utils/changebuffer~ChangeBuffer}\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n  /**\n   * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n   * or a piece of content in the {@link #direction defined direction}.\n   *\n   * @fires execute\n   * @param {Object} [options] The command options.\n   * @param {'character'} [options.unit='character'] See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n   * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n   * See the {@link module:engine/view/document~Document#event:delete} event data.\n   * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection\n   * will be used.\n   */\n\n\n  execute() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const model = this.editor.model;\n    const doc = model.document;\n    model.enqueueChange(this._buffer.batch, writer => {\n      this._buffer.lock();\n\n      const selection = writer.createSelection(options.selection || doc.selection);\n      const sequence = options.sequence || 1; // Do not replace the whole selected content if selection was collapsed.\n      // This prevents such situation:\n      //\n      // <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n      // starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n\n      const doNotResetEntireContent = selection.isCollapsed; // Try to extend the selection in the specified direction.\n\n      if (selection.isCollapsed) {\n        model.modifySelection(selection, {\n          direction: this.direction,\n          unit: options.unit\n        });\n      } // Check if deleting in an empty editor. See #61.\n\n\n      if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {\n        this._replaceEntireContentWithParagraph(writer);\n\n        return;\n      } // Check if deleting in the first empty block.\n      // See https://github.com/ckeditor/ckeditor5/issues/8137.\n\n\n      if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {\n        this.editor.execute('paragraph', {\n          selection\n        });\n        return;\n      } // If selection is still collapsed, then there's nothing to delete.\n\n\n      if (selection.isCollapsed) {\n        return;\n      }\n\n      let changeCount = 0;\n      selection.getFirstRange().getMinimalFlatRanges().forEach(range => {\n        changeCount += count(range.getWalker({\n          singleCharacters: true,\n          ignoreElementEnd: true,\n          shallow: true\n        }));\n      });\n      model.deleteContent(selection, {\n        doNotResetEntireContent,\n        direction: this.direction\n      });\n\n      this._buffer.input(changeCount);\n\n      writer.setSelection(selection);\n\n      this._buffer.unlock();\n    });\n  }\n  /**\n   * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n   * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n   * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n   *\n   * But, if the user pressed the key in an empty editable for the first time,\n   * we want to replace the entire content with a paragraph if:\n   *\n   * * the current limit element is empty,\n   * * the paragraph is allowed in the limit element,\n   * * the limit doesn't already have a paragraph inside.\n   *\n   * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n   *\n   * @private\n   * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n   * @returns {Boolean}\n   */\n\n\n  _shouldEntireContentBeReplacedWithParagraph(sequence) {\n    // Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n    if (sequence > 1) {\n      return false;\n    }\n\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const limitElement = model.schema.getLimitElement(selection); // If a collapsed selection contains the whole content it means that the content is empty\n    // (from the user perspective).\n\n    const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);\n\n    if (!limitElementIsEmpty) {\n      return false;\n    }\n\n    if (!model.schema.checkChild(limitElement, 'paragraph')) {\n      return false;\n    }\n\n    const limitElementFirstChild = limitElement.getChild(0); // Does nothing if the limit element already contains only a paragraph.\n    // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n    // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n\n    if (limitElementFirstChild && limitElementFirstChild.name === 'paragraph') {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n   *\n   * @private\n   * @param {module:engine/model/writer~Writer} writer The model writer.\n   */\n\n\n  _replaceEntireContentWithParagraph(writer) {\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const limitElement = model.schema.getLimitElement(selection);\n    const paragraph = writer.createElement('paragraph');\n    writer.remove(writer.createRangeIn(limitElement));\n    writer.insert(paragraph, limitElement);\n    writer.setSelection(paragraph, 0);\n  }\n  /**\n   * Checks if the selection is inside an empty element that is the first child of the limit element\n   * and should be replaced with a paragraph.\n   *\n   * @private\n   * @param {module:engine/model/selection~Selection} selection The selection.\n   * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n   * @returns {Boolean}\n   */\n\n\n  _shouldReplaceFirstBlockWithParagraph(selection, sequence) {\n    const model = this.editor.model; // Does nothing if user pressed and held the \"Backspace\" key or it was a \"Delete\" button.\n\n    if (sequence > 1 || this.direction != 'backward') {\n      return false;\n    }\n\n    if (!selection.isCollapsed) {\n      return false;\n    }\n\n    const position = selection.getFirstPosition();\n    const limitElement = model.schema.getLimitElement(position);\n    const limitElementFirstChild = limitElement.getChild(0); // Only elements that are direct children of the limit element can be replaced.\n    // Unwrapping from a block quote should be handled in a dedicated feature.\n\n    if (position.parent != limitElementFirstChild) {\n      return false;\n    } // A block should be replaced only if it was empty.\n\n\n    if (!selection.containsEntireContent(limitElementFirstChild)) {\n      return false;\n    } // Replace with a paragraph only if it's allowed there.\n\n\n    if (!model.schema.checkChild(limitElement, 'paragraph')) {\n      return false;\n    } // Does nothing if the limit element already contains only a paragraph.\n\n\n    if (limitElementFirstChild.name == 'paragraph') {\n      return false;\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-typing/src/deletecommand.js"],"names":["Command","count","ChangeBuffer","DeleteCommand","constructor","editor","direction","_buffer","model","config","get","buffer","execute","options","doc","document","enqueueChange","batch","writer","lock","selection","createSelection","sequence","doNotResetEntireContent","isCollapsed","modifySelection","unit","_shouldEntireContentBeReplacedWithParagraph","_replaceEntireContentWithParagraph","_shouldReplaceFirstBlockWithParagraph","changeCount","getFirstRange","getMinimalFlatRanges","forEach","range","getWalker","singleCharacters","ignoreElementEnd","shallow","deleteContent","input","setSelection","unlock","limitElement","schema","getLimitElement","limitElementIsEmpty","containsEntireContent","checkChild","limitElementFirstChild","getChild","name","paragraph","createElement","remove","createRangeIn","insert","position","getFirstPosition","parent"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/deletecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\n\nimport ChangeBuffer from './utils/changebuffer';\n\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\nexport default class DeleteCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n\t * should consume the content when the selection is collapsed.\n\t */\n\tconstructor( editor, direction ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The directionality of the delete describing in what direction it should\n\t\t * consume the content when the selection is collapsed.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'forward'|'backward'} #direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Delete's change buffer used to group subsequent changes into batches.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @type {module:typing/utils/changebuffer~ChangeBuffer}\n\t\t */\n\t\tthis._buffer = new ChangeBuffer( editor.model, editor.config.get( 'typing.undoStep' ) );\n\t}\n\n\t/**\n\t * The current change buffer.\n\t *\n\t * @type {module:typing/utils/changebuffer~ChangeBuffer}\n\t */\n\tget buffer() {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n\t * or a piece of content in the {@link #direction defined direction}.\n\t *\n\t * @fires execute\n\t * @param {Object} [options] The command options.\n\t * @param {'character'} [options.unit='character'] See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n\t * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n\t * See the {@link module:engine/view/document~Document#event:delete} event data.\n\t * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection\n\t * will be used.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\n\t\tmodel.enqueueChange( this._buffer.batch, writer => {\n\t\t\tthis._buffer.lock();\n\n\t\t\tconst selection = writer.createSelection( options.selection || doc.selection );\n\t\t\tconst sequence = options.sequence || 1;\n\n\t\t\t// Do not replace the whole selected content if selection was collapsed.\n\t\t\t// This prevents such situation:\n\t\t\t//\n\t\t\t// <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n\t\t\t// starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n\t\t\tconst doNotResetEntireContent = selection.isCollapsed;\n\n\t\t\t// Try to extend the selection in the specified direction.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\tmodel.modifySelection( selection, { direction: this.direction, unit: options.unit } );\n\t\t\t}\n\n\t\t\t// Check if deleting in an empty editor. See #61.\n\t\t\tif ( this._shouldEntireContentBeReplacedWithParagraph( sequence ) ) {\n\t\t\t\tthis._replaceEntireContentWithParagraph( writer );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if deleting in the first empty block.\n\t\t\t// See https://github.com/ckeditor/ckeditor5/issues/8137.\n\t\t\tif ( this._shouldReplaceFirstBlockWithParagraph( selection, sequence ) ) {\n\t\t\t\tthis.editor.execute( 'paragraph', { selection } );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If selection is still collapsed, then there's nothing to delete.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet changeCount = 0;\n\n\t\t\tselection.getFirstRange().getMinimalFlatRanges().forEach( range => {\n\t\t\t\tchangeCount += count(\n\t\t\t\t\trange.getWalker( { singleCharacters: true, ignoreElementEnd: true, shallow: true } )\n\t\t\t\t);\n\t\t\t} );\n\n\t\t\tmodel.deleteContent( selection, {\n\t\t\t\tdoNotResetEntireContent,\n\t\t\t\tdirection: this.direction\n\t\t\t} );\n\n\t\t\tthis._buffer.input( changeCount );\n\n\t\t\twriter.setSelection( selection );\n\n\t\t\tthis._buffer.unlock();\n\t\t} );\n\t}\n\n\t/**\n\t * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n\t * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n\t * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n\t *\n\t * But, if the user pressed the key in an empty editable for the first time,\n\t * we want to replace the entire content with a paragraph if:\n\t *\n\t * * the current limit element is empty,\n\t * * the paragraph is allowed in the limit element,\n\t * * the limit doesn't already have a paragraph inside.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n\t *\n\t * @private\n\t * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n\t * @returns {Boolean}\n\t */\n\t_shouldEntireContentBeReplacedWithParagraph( sequence ) {\n\t\t// Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n\t\tif ( sequence > 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\n\t\t// If a collapsed selection contains the whole content it means that the content is empty\n\t\t// (from the user perspective).\n\t\tconst limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent( limitElement );\n\n\t\tif ( !limitElementIsEmpty ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !model.schema.checkChild( limitElement, 'paragraph' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst limitElementFirstChild = limitElement.getChild( 0 );\n\n\t\t// Does nothing if the limit element already contains only a paragraph.\n\t\t// We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n\t\t// because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n\t\tif ( limitElementFirstChild && limitElementFirstChild.name === 'paragraph' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer The model writer.\n\t */\n\t_replaceEntireContentWithParagraph( writer ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\t\tconst paragraph = writer.createElement( 'paragraph' );\n\n\t\twriter.remove( writer.createRangeIn( limitElement ) );\n\t\twriter.insert( paragraph, limitElement );\n\n\t\twriter.setSelection( paragraph, 0 );\n\t}\n\n\t/**\n\t * Checks if the selection is inside an empty element that is the first child of the limit element\n\t * and should be replaced with a paragraph.\n\t *\n\t * @private\n\t * @param {module:engine/model/selection~Selection} selection The selection.\n\t * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n\t * @returns {Boolean}\n\t */\n\t_shouldReplaceFirstBlockWithParagraph( selection, sequence ) {\n\t\tconst model = this.editor.model;\n\n\t\t// Does nothing if user pressed and held the \"Backspace\" key or it was a \"Delete\" button.\n\t\tif ( sequence > 1 || this.direction != 'backward' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst position = selection.getFirstPosition();\n\t\tconst limitElement = model.schema.getLimitElement( position );\n\t\tconst limitElementFirstChild = limitElement.getChild( 0 );\n\n\t\t// Only elements that are direct children of the limit element can be replaced.\n\t\t// Unwrapping from a block quote should be handled in a dedicated feature.\n\t\tif ( position.parent != limitElementFirstChild ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// A block should be replaced only if it was empty.\n\t\tif ( !selection.containsEntireContent( limitElementFirstChild ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Replace with a paragraph only if it's allowed there.\n\t\tif ( !model.schema.checkChild( limitElement, 'paragraph' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Does nothing if the limit element already contains only a paragraph.\n\t\tif ( limitElementFirstChild.name == 'paragraph' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}