{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport Position, { getNodeAfterPosition, getTextNodeAtPosition } from '../model/position';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * The downcast dispatcher is a central point of downcasting (conversion from the model to the view), which is a process of reacting\n * to changes in the model and firing a set of events. Callbacks listening to these events are called converters. The\n * converters' role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During the conversion process, downcast dispatcher fires events basing on the state of the model and prepares\n * data for these events. It is important to understand that the events are connected with the changes done on the model,\n * for example: \"a node has been inserted\" or \"an attribute has changed\". This is in contrary to upcasting (a view-to-model conversion)\n * where you convert the view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to the downcast dispatcher as a diff between the old model state and the new model state.\n *\n * Note that because the changes are converted, there is a need to have a mapping between the model structure and the view structure.\n * To map positions and elements during the downcast (a model-to-view conversion), use {@link module:engine/conversion/mapper~Mapper}.\n *\n * Downcast dispatcher fires the following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} &ndash;\n * If a range of nodes was inserted to the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove `remove`} &ndash;\n * If a range of nodes was removed from the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} &ndash;\n * If an attribute was added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`},\n * downcast dispatcher generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have control over which changes have already been consumed. It is useful when some converters\n * overwrite others or convert multiple changes (for example, it converts an insertion of an element and also converts that\n * element's attributes during the insertion).\n *\n * Additionally, downcast dispatcher fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} &ndash; If a marker was added.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} &ndash; If a marker was removed.\n *\n * Note that changing a marker is done through removing the marker from the old range and adding it to the new range,\n * so both events are fired.\n *\n * Finally, downcast dispatcher also handles firing events for the {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection}\n * &ndash; Converts the selection from the model to the view.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute}\n * &ndash; Fired for every selection attribute.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}\n * &ndash; Fired for every marker that contains a selection.\n *\n * Unlike the model tree and the markers, the events for selection are not fired for changes but for a selection state.\n *\n * When providing custom listeners for a downcast dispatcher, remember to check whether a given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for downcast dispatcher, keep in mind that any callback that has\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from a consumable and\n * converted the change should also stop the event (for efficiency purposes).\n *\n * When providing custom listeners for downcast dispatcher, remember to use the provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * You can read more about conversion in the following guides:\n *\n * * {@glink framework/guides/deep-dive/conversion/conversion-introduction Advanced conversion concepts &mdash; attributes}\n * * {@glink framework/guides/deep-dive/conversion/conversion-extending-output Extending the editor output }\n * * {@glink framework/guides/deep-dive/conversion/custom-element-conversion Custom element conversion}\n *\n * An example of a custom converter for the downcast dispatcher:\n *\n *\t\t// You will convert inserting a \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate the position in the model to a position in the view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create a <p> element that will be inserted into the view at the `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to the model element so positions will map accordingly in the future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\n *\t\t\t// Remember to stop the event propagation.\n *\t\t\tevt.stop();\n *\t\t} );\n */\n\nexport default class DowncastDispatcher {\n  /**\n   * Creates a downcast dispatcher instance.\n   *\n   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n   * @param {Object} conversionApi Additional properties for an interface that will be passed to events fired\n   * by the downcast dispatcher.\n   */\n  constructor(conversionApi) {\n    /**\n     * An interface passed by the dispatcher to the event callbacks.\n     *\n     * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n     */\n    this.conversionApi = Object.assign({\n      dispatcher: this\n    }, conversionApi);\n    /**\n     * Maps conversion event names that will trigger element reconversion for a given element name.\n     *\n     * @type {Map<String, String>}\n     * @private\n     */\n\n    this._reconversionEventsMapping = new Map();\n  }\n  /**\n   * Takes a {@link module:engine/model/differ~Differ model differ} object with buffered changes and fires conversion basing on it.\n   *\n   * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   */\n\n\n  convertChanges(differ, markers, writer) {\n    // Before the view is updated, remove markers which have changed.\n    for (const change of differ.getMarkersToRemove()) {\n      this.convertMarkerRemove(change.name, change.range, writer);\n    }\n\n    const changes = this._mapChangesWithAutomaticReconversion(differ); // Convert changes that happened on model tree.\n\n\n    for (const entry of changes) {\n      if (entry.type === 'insert') {\n        this.convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), writer);\n      } else if (entry.type === 'remove') {\n        this.convertRemove(entry.position, entry.length, entry.name, writer);\n      } else if (entry.type === 'reconvert') {\n        this.reconvertElement(entry.element, writer);\n      } else {\n        // Defaults to 'attribute' change.\n        this.convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, writer);\n      }\n    }\n\n    for (const markerName of this.conversionApi.mapper.flushUnboundMarkerNames()) {\n      const markerRange = markers.get(markerName).getRange();\n      this.convertMarkerRemove(markerName, markerRange, writer);\n      this.convertMarkerAdd(markerName, markerRange, writer);\n    } // After the view is updated, convert markers which have changed.\n\n\n    for (const change of differ.getMarkersToAdd()) {\n      this.convertMarkerAdd(change.name, change.range, writer);\n    }\n  }\n  /**\n   * Starts a conversion of a range insertion.\n   *\n   * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,\n   * {@link #event:attribute `attribute` event is fired}.\n   *\n   * @fires insert\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range The inserted range.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   */\n\n\n  convertInsert(range, writer) {\n    this.conversionApi.writer = writer; // Create a list of things that can be consumed, consisting of nodes and their attributes.\n\n    this.conversionApi.consumable = this._createInsertConsumable(range); // Fire a separate insert event for each node and text fragment contained in the range.\n\n    for (const data of Array.from(range).map(walkerValueToEventData)) {\n      this._convertInsertWithAttributes(data);\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n   *\n   * @param {module:engine/model/position~Position} position Position from which node was removed.\n   * @param {Number} length Offset size of removed node.\n   * @param {String} name Name of removed node.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertRemove(position, length, name, writer) {\n    this.conversionApi.writer = writer;\n    this.fire('remove:' + name, {\n      position,\n      length\n    }, this.conversionApi);\n\n    this._clearConversionApi();\n  }\n  /**\n   * Starts a conversion of an attribute change on a given `range`.\n   *\n   * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n   *\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range Changed range.\n   * @param {String} key Key of the attribute that has changed.\n   * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n   * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertAttribute(range, key, oldValue, newValue, writer) {\n    this.conversionApi.writer = writer; // Create a list with attributes to consume.\n\n    this.conversionApi.consumable = this._createConsumableForRange(range, `attribute:${key}`); // Create a separate attribute event for each node in the range.\n\n    for (const value of range) {\n      const item = value.item;\n\n      const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n      const data = {\n        item,\n        range: itemRange,\n        attributeKey: key,\n        attributeOldValue: oldValue,\n        attributeNewValue: newValue\n      };\n\n      this._testAndFire(`attribute:${key}`, data);\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Starts the reconversion of an element. It will:\n   *\n   * * Fire an {@link #event:insert `insert` event} for the element to reconvert.\n   * * Fire an {@link #event:attribute `attribute` event} for element attributes.\n   *\n   * This will not reconvert children of the element if they have existing (already converted) views. For newly inserted child elements\n   * it will behave the same as {@link #convertInsert}.\n   *\n   * Element reconversion is defined by the `triggerBy` configuration for the\n   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} conversion helper.\n   *\n   * @fires insert\n   * @fires attribute\n   * @param {module:engine/model/element~Element} element The element to be reconverted.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   */\n\n\n  reconvertElement(element, writer) {\n    const elementRange = Range._createOn(element);\n\n    this.conversionApi.writer = writer; // Create a list of things that can be consumed, consisting of nodes and their attributes.\n\n    this.conversionApi.consumable = this._createInsertConsumable(elementRange);\n    const mapper = this.conversionApi.mapper;\n    const currentView = mapper.toViewElement(element); // Remove the old view but do not remove mapper mappings - those will be used to revive existing elements.\n\n    writer.remove(currentView); // Convert the element - without converting children.\n\n    this._convertInsertWithAttributes({\n      item: element,\n      range: elementRange\n    });\n\n    const convertedViewElement = mapper.toViewElement(element); // Iterate over children of reconverted element in order to...\n\n    for (const value of Range._createIn(element)) {\n      const {\n        item\n      } = value;\n      const view = elementOrTextProxyToView(item, mapper); // ...either bring back previously converted view...\n\n      if (view) {\n        // Do not move views that are already in converted element - those might be created by the main element converter in case\n        // when main element converts also its direct children.\n        if (view.root !== convertedViewElement.root) {\n          writer.move(writer.createRangeOn(view), mapper.toViewPosition(Position._createBefore(item)));\n        }\n      } // ... or by converting newly inserted elements.\n      else {\n        this._convertInsertWithAttributes(walkerValueToEventData(value));\n      }\n    } // After reconversion is done we can unbind the old view.\n\n\n    mapper.unbindViewElement(currentView);\n\n    this._clearConversionApi();\n  }\n  /**\n   * Starts the model selection conversion.\n   *\n   * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.\n   *\n   * @fires selection\n   * @fires addMarker\n   * @fires attribute\n   * @param {module:engine/model/selection~Selection} selection The selection to convert.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n   */\n\n\n  convertSelection(selection, markers, writer) {\n    const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));\n    this.conversionApi.writer = writer;\n    this.conversionApi.consumable = this._createSelectionConsumable(selection, markersAtSelection);\n    this.fire('selection', {\n      selection\n    }, this.conversionApi);\n\n    if (!selection.isCollapsed) {\n      this._clearConversionApi();\n\n      return;\n    }\n\n    for (const marker of markersAtSelection) {\n      const markerRange = marker.getRange();\n\n      if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, this.conversionApi.mapper)) {\n        continue;\n      }\n\n      const data = {\n        item: selection,\n        markerName: marker.name,\n        markerRange\n      };\n\n      if (this.conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {\n        this.fire('addMarker:' + marker.name, data, this.conversionApi);\n      }\n    }\n\n    for (const key of selection.getAttributeKeys()) {\n      const data = {\n        item: selection,\n        range: selection.getFirstRange(),\n        attributeKey: key,\n        attributeOldValue: null,\n        attributeNewValue: selection.getAttribute(key)\n      }; // Do not fire event if the attribute has been consumed.\n\n      if (this.conversionApi.consumable.test(selection, 'attribute:' + data.attributeKey)) {\n        this.fire('attribute:' + data.attributeKey + ':$text', data, this.conversionApi);\n      }\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item\n   * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.\n   *\n   * @fires addMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange The marker range.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n   */\n\n\n  convertMarkerAdd(markerName, markerRange, writer) {\n    // Do not convert if range is in graveyard.\n    if (markerRange.root.rootName == '$graveyard') {\n      return;\n    }\n\n    this.conversionApi.writer = writer; // In markers' case, event name == consumable name.\n\n    const eventName = 'addMarker:' + markerName; //\n    // First, fire an event for the whole marker.\n    //\n\n    const consumable = new Consumable();\n    consumable.add(markerRange, eventName);\n    this.conversionApi.consumable = consumable;\n    this.fire(eventName, {\n      markerName,\n      markerRange\n    }, this.conversionApi); //\n    // Do not fire events for each item inside the range if the range got consumed.\n    //\n\n    if (!consumable.test(markerRange, eventName)) {\n      this._clearConversionApi();\n\n      return;\n    } //\n    // Then, fire an event for each item inside the marker range.\n    //\n\n\n    this.conversionApi.consumable = this._createConsumableForRange(markerRange, eventName);\n\n    for (const item of markerRange.getItems()) {\n      // Do not fire event for already consumed items.\n      if (!this.conversionApi.consumable.test(item, eventName)) {\n        continue;\n      }\n\n      const data = {\n        item,\n        range: Range._createOn(item),\n        markerName,\n        markerRange\n      };\n      this.fire(eventName, data, this.conversionApi);\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.\n   *\n   * @fires removeMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange The marker range.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n   */\n\n\n  convertMarkerRemove(markerName, markerRange, writer) {\n    // Do not convert if range is in graveyard.\n    if (markerRange.root.rootName == '$graveyard') {\n      return;\n    }\n\n    this.conversionApi.writer = writer;\n    this.fire('removeMarker:' + markerName, {\n      markerName,\n      markerRange\n    }, this.conversionApi);\n\n    this._clearConversionApi();\n  }\n  /**\n   * Maps the model element \"insert\" reconversion for given event names. The event names must be fully specified:\n   *\n   * * For \"attribute\" change event, it should include the main element name, i.e: `'attribute:attributeName:elementName'`.\n   * * For child node change events, these should use the child event name as well, i.e:\n   *     * For adding a node: `'insert:childElementName'`.\n   *     * For removing a node: `'remove:childElementName'`.\n   *\n   * **Note**: This method should not be used directly. The reconversion is defined by the `triggerBy()` configuration of the\n   * `elementToElement()` conversion helper.\n   *\n   * @protected\n   * @param {String} modelName The name of the main model element for which the events will trigger the reconversion.\n   * @param {String} eventName The name of an event that would trigger conversion for a given model element.\n   */\n\n\n  _mapReconversionTriggerEvent(modelName, eventName) {\n    this._reconversionEventsMapping.set(eventName, modelName);\n  }\n  /**\n   * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,\n   * assuming that the range has just been inserted to the model.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The inserted range.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n\n\n  _createInsertConsumable(range) {\n    const consumable = new Consumable();\n\n    for (const value of range) {\n      const item = value.item;\n      consumable.add(item, 'insert');\n\n      for (const key of item.getAttributeKeys()) {\n        consumable.add(item, 'attribute:' + key);\n      }\n    }\n\n    return consumable;\n  }\n  /**\n   * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The affected range.\n   * @param {String} type Consumable type.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n\n\n  _createConsumableForRange(range, type) {\n    const consumable = new Consumable();\n\n    for (const item of range.getItems()) {\n      consumable.add(item, type);\n    }\n\n    return consumable;\n  }\n  /**\n   * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n   *\n   * @private\n   * @param {module:engine/model/selection~Selection} selection The selection to create the consumable from.\n   * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers that contain the selection.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n   */\n\n\n  _createSelectionConsumable(selection, markers) {\n    const consumable = new Consumable();\n    consumable.add(selection, 'selection');\n\n    for (const marker of markers) {\n      consumable.add(selection, 'addMarker:' + marker.name);\n    }\n\n    for (const key of selection.getAttributeKeys()) {\n      consumable.add(selection, 'attribute:' + key);\n    }\n\n    return consumable;\n  }\n  /**\n   * Tests passed `consumable` to check whether given event can be fired and if so, fires it.\n   *\n   * @private\n   * @fires insert\n   * @fires attribute\n   * @param {String} type Event type.\n   * @param {Object} data Event data.\n   */\n\n\n  _testAndFire(type, data) {\n    if (!this.conversionApi.consumable.test(data.item, type)) {\n      // Do not fire event if the item was consumed.\n      return;\n    }\n\n    this.fire(getEventName(type, data), data, this.conversionApi);\n  }\n  /**\n   * Clears the conversion API object.\n   *\n   * @private\n   */\n\n\n  _clearConversionApi() {\n    delete this.conversionApi.writer;\n    delete this.conversionApi.consumable;\n  }\n  /**\n   * Internal method for converting element insertion. It will fire events for the inserted element and events for its attributes.\n   *\n   * @private\n   * @fires insert\n   * @fires attribute\n   * @param {Object} data Event data.\n   */\n\n\n  _convertInsertWithAttributes(data) {\n    this._testAndFire('insert', data); // Fire a separate addAttribute event for each attribute that was set on inserted items.\n    // This is important because most attributes converters will listen only to add/change/removeAttribute events.\n    // If we would not add this part, attributes on inserted nodes would not be converted.\n\n\n    for (const key of data.item.getAttributeKeys()) {\n      data.attributeKey = key;\n      data.attributeOldValue = null;\n      data.attributeNewValue = data.item.getAttribute(key);\n\n      this._testAndFire(`attribute:${key}`, data);\n    }\n  }\n  /**\n   * Returns differ changes together with added \"reconvert\" type changes for {@link #reconvertElement}. These are defined by\n   * a the `triggerBy()` configuration for the\n   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} conversion helper.\n   *\n   * This method will remove every mapped insert or remove change with a single \"reconvert\" change.\n   *\n   * For instance: Having a `triggerBy()` configuration defined for the `<complex>` element that issues this element reconversion on\n   * `foo` and `bar` attributes change, and a set of changes for this element:\n   *\n   *\t\tconst differChanges = [\n   *\t\t\t{ type: 'attribute', attributeKey: 'foo', ... },\n   *\t\t\t{ type: 'attribute', attributeKey: 'bar', ... },\n   *\t\t\t{ type: 'attribute', attributeKey: 'baz', ... }\n   *\t\t];\n   *\n   * This method will return:\n   *\n   *\t\tconst updatedChanges = [\n   *\t\t\t{ type: 'reconvert', element: complexElementInstance },\n   *\t\t\t{ type: 'attribute', attributeKey: 'baz', ... }\n   *\t\t];\n   *\n   * In the example above, the `'baz'` attribute change will fire an {@link #event:attribute attribute event}\n   *\n   * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n   * @returns {Array.<Object>} Updated set of changes.\n   * @private\n   */\n\n\n  _mapChangesWithAutomaticReconversion(differ) {\n    const itemsToReconvert = new Set();\n    const updated = [];\n\n    for (const entry of differ.getChanges()) {\n      const position = entry.position || entry.range.start; // Cached parent - just in case. See https://github.com/ckeditor/ckeditor5/issues/6579.\n\n      const positionParent = position.parent;\n      const textNode = getTextNodeAtPosition(position, positionParent); // Reconversion is done only on elements so skip text changes.\n\n      if (textNode) {\n        updated.push(entry);\n        continue;\n      }\n\n      const element = entry.type === 'attribute' ? getNodeAfterPosition(position, positionParent, null) : positionParent; // Case of text node set directly in root. For now used only in tests but can be possible when enabled in paragraph-like roots.\n      // See: https://github.com/ckeditor/ckeditor5/issues/762.\n\n      if (element.is('$text')) {\n        updated.push(entry);\n        continue;\n      }\n\n      let eventName;\n\n      if (entry.type === 'attribute') {\n        eventName = `attribute:${entry.attributeKey}:${element.name}`;\n      } else {\n        eventName = `${entry.type}:${entry.name}`;\n      }\n\n      if (this._isReconvertTriggerEvent(eventName, element.name)) {\n        if (itemsToReconvert.has(element)) {\n          // Element is already reconverted, so skip this change.\n          continue;\n        }\n\n        itemsToReconvert.add(element); // Add special \"reconvert\" change.\n\n        updated.push({\n          type: 'reconvert',\n          element\n        });\n      } else {\n        updated.push(entry);\n      }\n    }\n\n    return updated;\n  }\n  /**\n   * Checks if the resulting change should trigger element reconversion.\n   *\n   * These are defined by a `triggerBy()` configuration for the\n   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} conversion helper.\n   *\n   * @private\n   * @param {String} eventName The event name to check.\n   * @param {String} elementName The element name to check.\n   * @returns {Boolean}\n   */\n\n\n  _isReconvertTriggerEvent(eventName, elementName) {\n    return this._reconversionEventsMapping.get(eventName) === elementName;\n  }\n  /**\n   * Fired for inserted nodes.\n   *\n   * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n   * or {@link module:engine/model/element~Element#name name} of inserted element.\n   *\n   * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n   *\n   * @event insert\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item} data.item Inserted item.\n   * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired for removed nodes.\n   *\n   * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `remove:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been removed,\n   * or the {@link module:engine/model/element~Element#name name} of removed element.\n   *\n   * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n   *\n   * @event remove\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n   * @param {Number} data.length Offset size of the removed node.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired in the following cases:\n   *\n   * * when an attribute has been added, changed, or removed from a node,\n   * * when a node with an attribute is inserted,\n   * * when collapsed model selection attribute is converted.\n   *\n   * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n   * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n   * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n   *\n   * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:imageBlock`).\n   *\n   * @event attribute\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n   * or converted selection.\n   * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n   * @param {String} data.attributeKey Attribute key.\n   * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n   * @param {*} data.attributeNewValue New attribute value.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired for {@link module:engine/model/selection~Selection selection} changes.\n   *\n   * @event selection\n   * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired when a new marker is added to the model. Also fired when a collapsed model selection that is inside a marker is converted.\n   *\n   * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n   * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n   * `addMarker:foo:bar` events.\n   *\n   * If the marker range is not collapsed:\n   *\n   * * the event is fired for each item in the marker range one by one,\n   * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as the event name.\n   *\n   * If the marker range is collapsed:\n   *\n   * * there is only one event,\n   * * `conversionApi.consumable` includes marker range with the event name.\n   *\n   * If the selection inside a marker is converted:\n   *\n   * * there is only one event,\n   * * `conversionApi.consumable` includes the selection instance with the event name.\n   *\n   * @event addMarker\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n   * the selection that is being converted.\n   * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n   * the marker range was not collapsed.\n   * @param {module:engine/model/range~Range} data.markerRange Marker range.\n   * @param {String} data.markerName Marker name.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired when a marker is removed from the model.\n   *\n   * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n   * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n   * `removeMarker:foo:bar` events.\n   *\n   * @event removeMarker\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/range~Range} data.markerRange Marker range.\n   * @param {String} data.markerName Marker name.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n\n}\nmix(DowncastDispatcher, EmitterMixin); // Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\n\nfunction shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {\n  const range = marker.getRange();\n  const ancestors = Array.from(modelPosition.getAncestors());\n  ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\n  ancestors.reverse();\n  const hasCustomHandling = ancestors.some(element => {\n    if (range.containsItem(element)) {\n      const viewElement = mapper.toViewElement(element);\n      return !!viewElement.getCustomProperty('addHighlight');\n    }\n  });\n  return !hasCustomHandling;\n}\n\nfunction getEventName(type, data) {\n  const name = data.item.name || '$text';\n  return `${type}:${name}`;\n}\n\nfunction walkerValueToEventData(value) {\n  const item = value.item;\n\n  const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n  return {\n    item,\n    range: itemRange\n  };\n}\n\nfunction elementOrTextProxyToView(item, mapper) {\n  if (item.is('textProxy')) {\n    const mappedPosition = mapper.toViewPosition(Position._createBefore(item));\n    const positionParent = mappedPosition.parent;\n    return positionParent.is('$text') ? positionParent : null;\n  }\n\n  return mapper.toViewElement(item);\n}\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires its events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores the information about what parts of a processed model item are still waiting to be handled. After a piece of a model item was\n * converted, an appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/model/schema~Schema} instance set for the model that is downcast.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n\n/**\n * An object with an additional configuration which can be used during the conversion process. Available only for data downcast conversion.\n *\n * @member {Object} #options\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js"],"names":["Consumable","Range","Position","getNodeAfterPosition","getTextNodeAtPosition","EmitterMixin","mix","DowncastDispatcher","constructor","conversionApi","Object","assign","dispatcher","_reconversionEventsMapping","Map","convertChanges","differ","markers","writer","change","getMarkersToRemove","convertMarkerRemove","name","range","changes","_mapChangesWithAutomaticReconversion","entry","type","convertInsert","_createFromPositionAndShift","position","length","convertRemove","reconvertElement","element","convertAttribute","attributeKey","attributeOldValue","attributeNewValue","markerName","mapper","flushUnboundMarkerNames","markerRange","get","getRange","convertMarkerAdd","getMarkersToAdd","consumable","_createInsertConsumable","data","Array","from","map","walkerValueToEventData","_convertInsertWithAttributes","_clearConversionApi","fire","key","oldValue","newValue","_createConsumableForRange","value","item","itemRange","previousPosition","_testAndFire","elementRange","_createOn","currentView","toViewElement","remove","convertedViewElement","_createIn","view","elementOrTextProxyToView","root","move","createRangeOn","toViewPosition","_createBefore","unbindViewElement","convertSelection","selection","markersAtSelection","getMarkersAtPosition","getFirstPosition","_createSelectionConsumable","isCollapsed","marker","shouldMarkerChangeBeConverted","test","getAttributeKeys","getFirstRange","getAttribute","rootName","eventName","add","getItems","_mapReconversionTriggerEvent","modelName","set","getEventName","itemsToReconvert","Set","updated","getChanges","start","positionParent","parent","textNode","push","is","_isReconvertTriggerEvent","has","elementName","modelPosition","ancestors","getAncestors","shift","reverse","hasCustomHandling","some","containsItem","viewElement","getCustomProperty","mappedPosition"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,mBAAvB;AACA,OAAOC,KAAP,MAAkB,gBAAlB;AACA,OAAOC,QAAP,IAAmBC,oBAAnB,EAAyCC,qBAAzC,QAAsE,mBAAtE;AAEA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,kBAAN,CAAyB;AACvC;AACD;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,aAAF,EAAkB;AAC5B;AACF;AACA;AACA;AACA;AACE,SAAKA,aAAL,GAAqBC,MAAM,CAACC,MAAP,CAAe;AAAEC,MAAAA,UAAU,EAAE;AAAd,KAAf,EAAqCH,aAArC,CAArB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKI,0BAAL,GAAkC,IAAIC,GAAJ,EAAlC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,cAAc,CAAEC,MAAF,EAAUC,OAAV,EAAmBC,MAAnB,EAA4B;AACzC;AACA,SAAM,MAAMC,MAAZ,IAAsBH,MAAM,CAACI,kBAAP,EAAtB,EAAoD;AACnD,WAAKC,mBAAL,CAA0BF,MAAM,CAACG,IAAjC,EAAuCH,MAAM,CAACI,KAA9C,E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;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAhsBwC;AAmsBxC5G,GAAG,CAAEC,kBAAF,EAAsBF,YAAtB,CAAH,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASoF,6BAAT,CAAwC0B,aAAxC,EAAuD3B,MAAvD,EAA+DhD,MAA/D,EAAwE;AACvE,QAAMjB,KAAK,GAAGiE,MAAM,CAAC5C,QAAP,EAAd;AACA,QAAMwE,SAAS,GAAGlE,KAAK,CAACC,IAAN,CAAYgE,aAAa,CAACE,YAAd,EAAZ,CAAlB;AACAD,EAAAA,SAAS,CAACE,KAAV,GAHuE,CAGpD;;AACnBF,EAAAA,SAAS,CAACG,OAAV;AAEA,QAAMC,iBAAiB,GAAGJ,SAAS,CAACK,IAAV,CAAgBvF,OAAO,IAAI;AACpD,QAAKX,KAAK,CAACmG,YAAN,CAAoBxF,OAApB,CAAL,EAAqC;AACpC,YAAMyF,WAAW,GAAGnF,MAAM,CAAC6B,aAAP,CAAsBnC,OAAtB,CAApB;AAEA,aAAO,CAAC,CAACyF,WAAW,CAACC,iBAAZ,CAA+B,cAA/B,CAAT;AACA;AACD,GANyB,CAA1B;AAQA,SAAO,CAACJ,iBAAR;AACA;;AAED,SAASnB,YAAT,CAAuB1E,IAAvB,EAA6BsB,IAA7B,EAAoC;AACnC,QAAM3B,IAAI,GAAG2B,IAAI,CAACa,IAAL,CAAUxC,IAAV,IAAkB,OAA/B;AAEA,SAAQ,GAAGK,IAAM,IAAIL,IAAM,EAA3B;AACA;;AAED,SAAS+B,sBAAT,CAAiCQ,KAAjC,EAAyC;AACxC,QAAMC,IAAI,GAAGD,KAAK,CAACC,IAAnB;;AACA,QAAMC,SAAS,GAAG9D,KAAK,CAAC4B,2BAAN,CAAmCgC,KAAK,CAACG,gBAAzC,EAA2DH,KAAK,CAAC9B,MAAjE,CAAlB;;AAEA,SAAO;AACN+B,IAAAA,IADM;AAENvC,IAAAA,KAAK,EAAEwC;AAFD,GAAP;AAIA;;AAED,SAASW,wBAAT,CAAmCZ,IAAnC,EAAyCtB,MAAzC,EAAkD;AACjD,MAAKsB,IAAI,CAACiD,EAAL,CAAS,WAAT,CAAL,EAA8B;AAC7B,UAAMc,cAAc,GAAGrF,MAAM,CAACsC,cAAP,CAAuB5E,QAAQ,CAAC6E,aAAT,CAAwBjB,IAAxB,CAAvB,CAAvB;AACA,UAAM6C,cAAc,GAAGkB,cAAc,CAACjB,MAAtC;AAEA,WAAOD,cAAc,CAACI,EAAf,CAAmB,OAAnB,IAA+BJ,cAA/B,GAAgD,IAAvD;AACA;;AAED,SAAOnE,MAAM,CAAC6B,aAAP,CAAsBP,IAAtB,CAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\n\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport Position, { getNodeAfterPosition, getTextNodeAtPosition } from '../model/position';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * The downcast dispatcher is a central point of downcasting (conversion from the model to the view), which is a process of reacting\n * to changes in the model and firing a set of events. Callbacks listening to these events are called converters. The\n * converters' role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During the conversion process, downcast dispatcher fires events basing on the state of the model and prepares\n * data for these events. It is important to understand that the events are connected with the changes done on the model,\n * for example: \"a node has been inserted\" or \"an attribute has changed\". This is in contrary to upcasting (a view-to-model conversion)\n * where you convert the view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to the downcast dispatcher as a diff between the old model state and the new model state.\n *\n * Note that because the changes are converted, there is a need to have a mapping between the model structure and the view structure.\n * To map positions and elements during the downcast (a model-to-view conversion), use {@link module:engine/conversion/mapper~Mapper}.\n *\n * Downcast dispatcher fires the following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} &ndash;\n * If a range of nodes was inserted to the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove `remove`} &ndash;\n * If a range of nodes was removed from the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} &ndash;\n * If an attribute was added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`},\n * downcast dispatcher generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have control over which changes have already been consumed. It is useful when some converters\n * overwrite others or convert multiple changes (for example, it converts an insertion of an element and also converts that\n * element's attributes during the insertion).\n *\n * Additionally, downcast dispatcher fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} &ndash; If a marker was added.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} &ndash; If a marker was removed.\n *\n * Note that changing a marker is done through removing the marker from the old range and adding it to the new range,\n * so both events are fired.\n *\n * Finally, downcast dispatcher also handles firing events for the {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection}\n * &ndash; Converts the selection from the model to the view.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute}\n * &ndash; Fired for every selection attribute.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}\n * &ndash; Fired for every marker that contains a selection.\n *\n * Unlike the model tree and the markers, the events for selection are not fired for changes but for a selection state.\n *\n * When providing custom listeners for a downcast dispatcher, remember to check whether a given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for downcast dispatcher, keep in mind that any callback that has\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from a consumable and\n * converted the change should also stop the event (for efficiency purposes).\n *\n * When providing custom listeners for downcast dispatcher, remember to use the provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * You can read more about conversion in the following guides:\n *\n * * {@glink framework/guides/deep-dive/conversion/conversion-introduction Advanced conversion concepts &mdash; attributes}\n * * {@glink framework/guides/deep-dive/conversion/conversion-extending-output Extending the editor output }\n * * {@glink framework/guides/deep-dive/conversion/custom-element-conversion Custom element conversion}\n *\n * An example of a custom converter for the downcast dispatcher:\n *\n *\t\t// You will convert inserting a \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate the position in the model to a position in the view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create a <p> element that will be inserted into the view at the `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to the model element so positions will map accordingly in the future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\n *\t\t\t// Remember to stop the event propagation.\n *\t\t\tevt.stop();\n *\t\t} );\n */\nexport default class DowncastDispatcher {\n\t/**\n\t * Creates a downcast dispatcher instance.\n\t *\n\t * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n\t * @param {Object} conversionApi Additional properties for an interface that will be passed to events fired\n\t * by the downcast dispatcher.\n\t */\n\tconstructor( conversionApi ) {\n\t\t/**\n\t\t * An interface passed by the dispatcher to the event callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n\t\t */\n\t\tthis.conversionApi = Object.assign( { dispatcher: this }, conversionApi );\n\n\t\t/**\n\t\t * Maps conversion event names that will trigger element reconversion for a given element name.\n\t\t *\n\t\t * @type {Map<String, String>}\n\t\t * @private\n\t\t */\n\t\tthis._reconversionEventsMapping = new Map();\n\t}\n\n\t/**\n\t * Takes a {@link module:engine/model/differ~Differ model differ} object with buffered changes and fires conversion basing on it.\n\t *\n\t * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n\t * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n\t */\n\tconvertChanges( differ, markers, writer ) {\n\t\t// Before the view is updated, remove markers which have changed.\n\t\tfor ( const change of differ.getMarkersToRemove() ) {\n\t\t\tthis.convertMarkerRemove( change.name, change.range, writer );\n\t\t}\n\n\t\tconst changes = this._mapChangesWithAutomaticReconversion( differ );\n\n\t\t// Convert changes that happened on model tree.\n\t\tfor ( const entry of changes ) {\n\t\t\tif ( entry.type === 'insert' ) {\n\t\t\t\tthis.convertInsert( Range._createFromPositionAndShift( entry.position, entry.length ), writer );\n\t\t\t} else if ( entry.type === 'remove' ) {\n\t\t\t\tthis.convertRemove( entry.position, entry.length, entry.name, writer );\n\t\t\t} else if ( entry.type === 'reconvert' ) {\n\t\t\t\tthis.reconvertElement( entry.element, writer );\n\t\t\t} else {\n\t\t\t\t// Defaults to 'attribute' change.\n\t\t\t\tthis.convertAttribute( entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, writer );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const markerName of this.conversionApi.mapper.flushUnboundMarkerNames() ) {\n\t\t\tconst markerRange = markers.get( markerName ).getRange();\n\n\t\t\tthis.convertMarkerRemove( markerName, markerRange, writer );\n\t\t\tthis.convertMarkerAdd( markerName, markerRange, writer );\n\t\t}\n\n\t\t// After the view is updated, convert markers which have changed.\n\t\tfor ( const change of differ.getMarkersToAdd() ) {\n\t\t\tthis.convertMarkerAdd( change.name, change.range, writer );\n\t\t}\n\t}\n\n\t/**\n\t * Starts a conversion of a range insertion.\n\t *\n\t * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,\n\t * {@link #event:attribute `attribute` event is fired}.\n\t *\n\t * @fires insert\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range The inserted range.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n\t */\n\tconvertInsert( range, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create a list of things that can be consumed, consisting of nodes and their attributes.\n\t\tthis.conversionApi.consumable = this._createInsertConsumable( range );\n\n\t\t// Fire a separate insert event for each node and text fragment contained in the range.\n\t\tfor ( const data of Array.from( range ).map( walkerValueToEventData ) ) {\n\t\t\tthis._convertInsertWithAttributes( data );\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n\t *\n\t * @param {module:engine/model/position~Position} position Position from which node was removed.\n\t * @param {Number} length Offset size of removed node.\n\t * @param {String} name Name of removed node.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertRemove( position, length, name, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\tthis.fire( 'remove:' + name, { position, length }, this.conversionApi );\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Starts a conversion of an attribute change on a given `range`.\n\t *\n\t * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n\t *\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range Changed range.\n\t * @param {String} key Key of the attribute that has changed.\n\t * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n\t * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertAttribute( range, key, oldValue, newValue, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create a list with attributes to consume.\n\t\tthis.conversionApi.consumable = this._createConsumableForRange( range, `attribute:${ key }` );\n\n\t\t// Create a separate attribute event for each node in the range.\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\t\t\tconst itemRange = Range._createFromPositionAndShift( value.previousPosition, value.length );\n\t\t\tconst data = {\n\t\t\t\titem,\n\t\t\t\trange: itemRange,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\tattributeNewValue: newValue\n\t\t\t};\n\n\t\t\tthis._testAndFire( `attribute:${ key }`, data );\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Starts the reconversion of an element. It will:\n\t *\n\t * * Fire an {@link #event:insert `insert` event} for the element to reconvert.\n\t * * Fire an {@link #event:attribute `attribute` event} for element attributes.\n\t *\n\t * This will not reconvert children of the element if they have existing (already converted) views. For newly inserted child elements\n\t * it will behave the same as {@link #convertInsert}.\n\t *\n\t * Element reconversion is defined by the `triggerBy` configuration for the\n\t * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} conversion helper.\n\t *\n\t * @fires insert\n\t * @fires attribute\n\t * @param {module:engine/model/element~Element} element The element to be reconverted.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n\t */\n\treconvertElement( element, writer ) {\n\t\tconst elementRange = Range._createOn( element );\n\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create a list of things that can be consumed, consisting of nodes and their attributes.\n\t\tthis.conversionApi.consumable = this._createInsertConsumable( elementRange );\n\n\t\tconst mapper = this.conversionApi.mapper;\n\t\tconst currentView = mapper.toViewElement( element );\n\n\t\t// Remove the old view but do not remove mapper mappings - those will be used to revive existing elements.\n\t\twriter.remove( currentView );\n\n\t\t// Convert the element - without converting children.\n\t\tthis._convertInsertWithAttributes( {\n\t\t\titem: element,\n\t\t\trange: elementRange\n\t\t} );\n\n\t\tconst convertedViewElement = mapper.toViewElement( element );\n\n\t\t// Iterate over children of reconverted element in order to...\n\t\tfor ( const value of Range._createIn( element ) ) {\n\t\t\tconst { item } = value;\n\n\t\t\tconst view = elementOrTextProxyToView( item, mapper );\n\n\t\t\t// ...either bring back previously converted view...\n\t\t\tif ( view ) {\n\t\t\t\t// Do not move views that are already in converted element - those might be created by the main element converter in case\n\t\t\t\t// when main element converts also its direct children.\n\t\t\t\tif ( view.root !== convertedViewElement.root ) {\n\t\t\t\t\twriter.move(\n\t\t\t\t\t\twriter.createRangeOn( view ),\n\t\t\t\t\t\tmapper.toViewPosition( Position._createBefore( item ) )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ... or by converting newly inserted elements.\n\t\t\telse {\n\t\t\t\tthis._convertInsertWithAttributes( walkerValueToEventData( value ) );\n\t\t\t}\n\t\t}\n\n\t\t// After reconversion is done we can unbind the old view.\n\t\tmapper.unbindViewElement( currentView );\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Starts the model selection conversion.\n\t *\n\t * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.\n\t *\n\t * @fires selection\n\t * @fires addMarker\n\t * @fires attribute\n\t * @param {module:engine/model/selection~Selection} selection The selection to convert.\n\t * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n\t */\n\tconvertSelection( selection, markers, writer ) {\n\t\tconst markersAtSelection = Array.from( markers.getMarkersAtPosition( selection.getFirstPosition() ) );\n\n\t\tthis.conversionApi.writer = writer;\n\t\tthis.conversionApi.consumable = this._createSelectionConsumable( selection, markersAtSelection );\n\n\t\tthis.fire( 'selection', { selection }, this.conversionApi );\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\tthis._clearConversionApi();\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const marker of markersAtSelection ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tif ( !shouldMarkerChangeBeConverted( selection.getFirstPosition(), marker, this.conversionApi.mapper ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\tmarkerName: marker.name,\n\t\t\t\tmarkerRange\n\t\t\t};\n\n\t\t\tif ( this.conversionApi.consumable.test( selection, 'addMarker:' + marker.name ) ) {\n\t\t\t\tthis.fire( 'addMarker:' + marker.name, data, this.conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\trange: selection.getFirstRange(),\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: selection.getAttribute( key )\n\t\t\t};\n\n\t\t\t// Do not fire event if the attribute has been consumed.\n\t\t\tif ( this.conversionApi.consumable.test( selection, 'attribute:' + data.attributeKey ) ) {\n\t\t\t\tthis.fire( 'attribute:' + data.attributeKey + ':$text', data, this.conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item\n\t * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.\n\t *\n\t * @fires addMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange The marker range.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n\t */\n\tconvertMarkerAdd( markerName, markerRange, writer ) {\n\t\t// Do not convert if range is in graveyard.\n\t\tif ( markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// In markers' case, event name == consumable name.\n\t\tconst eventName = 'addMarker:' + markerName;\n\n\t\t//\n\t\t// First, fire an event for the whole marker.\n\t\t//\n\t\tconst consumable = new Consumable();\n\t\tconsumable.add( markerRange, eventName );\n\n\t\tthis.conversionApi.consumable = consumable;\n\n\t\tthis.fire( eventName, { markerName, markerRange }, this.conversionApi );\n\n\t\t//\n\t\t// Do not fire events for each item inside the range if the range got consumed.\n\t\t//\n\t\tif ( !consumable.test( markerRange, eventName ) ) {\n\t\t\tthis._clearConversionApi();\n\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\t// Then, fire an event for each item inside the marker range.\n\t\t//\n\t\tthis.conversionApi.consumable = this._createConsumableForRange( markerRange, eventName );\n\n\t\tfor ( const item of markerRange.getItems() ) {\n\t\t\t// Do not fire event for already consumed items.\n\t\t\tif ( !this.conversionApi.consumable.test( item, eventName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = { item, range: Range._createOn( item ), markerName, markerRange };\n\n\t\t\tthis.fire( eventName, data, this.conversionApi );\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.\n\t *\n\t * @fires removeMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange The marker range.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n\t */\n\tconvertMarkerRemove( markerName, markerRange, writer ) {\n\t\t// Do not convert if range is in graveyard.\n\t\tif ( markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.conversionApi.writer = writer;\n\n\t\tthis.fire( 'removeMarker:' + markerName, { markerName, markerRange }, this.conversionApi );\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Maps the model element \"insert\" reconversion for given event names. The event names must be fully specified:\n\t *\n\t * * For \"attribute\" change event, it should include the main element name, i.e: `'attribute:attributeName:elementName'`.\n\t * * For child node change events, these should use the child event name as well, i.e:\n\t *     * For adding a node: `'insert:childElementName'`.\n\t *     * For removing a node: `'remove:childElementName'`.\n\t *\n\t * **Note**: This method should not be used directly. The reconversion is defined by the `triggerBy()` configuration of the\n\t * `elementToElement()` conversion helper.\n\t *\n\t * @protected\n\t * @param {String} modelName The name of the main model element for which the events will trigger the reconversion.\n\t * @param {String} eventName The name of an event that would trigger conversion for a given model element.\n\t */\n\t_mapReconversionTriggerEvent( modelName, eventName ) {\n\t\tthis._reconversionEventsMapping.set( eventName, modelName );\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,\n\t * assuming that the range has just been inserted to the model.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The inserted range.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n\t */\n\t_createInsertConsumable( range ) {\n\t\tconst consumable = new Consumable();\n\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\n\t\t\tconsumable.add( item, 'insert' );\n\n\t\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\t\tconsumable.add( item, 'attribute:' + key );\n\t\t\t}\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The affected range.\n\t * @param {String} type Consumable type.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n\t */\n\t_createConsumableForRange( range, type ) {\n\t\tconst consumable = new Consumable();\n\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tconsumable.add( item, type );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n\t *\n\t * @private\n\t * @param {module:engine/model/selection~Selection} selection The selection to create the consumable from.\n\t * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers that contain the selection.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n\t */\n\t_createSelectionConsumable( selection, markers ) {\n\t\tconst consumable = new Consumable();\n\n\t\tconsumable.add( selection, 'selection' );\n\n\t\tfor ( const marker of markers ) {\n\t\t\tconsumable.add( selection, 'addMarker:' + marker.name );\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconsumable.add( selection, 'attribute:' + key );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Tests passed `consumable` to check whether given event can be fired and if so, fires it.\n\t *\n\t * @private\n\t * @fires insert\n\t * @fires attribute\n\t * @param {String} type Event type.\n\t * @param {Object} data Event data.\n\t */\n\t_testAndFire( type, data ) {\n\t\tif ( !this.conversionApi.consumable.test( data.item, type ) ) {\n\t\t\t// Do not fire event if the item was consumed.\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fire( getEventName( type, data ), data, this.conversionApi );\n\t}\n\n\t/**\n\t * Clears the conversion API object.\n\t *\n\t * @private\n\t */\n\t_clearConversionApi() {\n\t\tdelete this.conversionApi.writer;\n\t\tdelete this.conversionApi.consumable;\n\t}\n\n\t/**\n\t * Internal method for converting element insertion. It will fire events for the inserted element and events for its attributes.\n\t *\n\t * @private\n\t * @fires insert\n\t * @fires attribute\n\t * @param {Object} data Event data.\n\t */\n\t_convertInsertWithAttributes( data ) {\n\t\tthis._testAndFire( 'insert', data );\n\n\t\t// Fire a separate addAttribute event for each attribute that was set on inserted items.\n\t\t// This is important because most attributes converters will listen only to add/change/removeAttribute events.\n\t\t// If we would not add this part, attributes on inserted nodes would not be converted.\n\t\tfor ( const key of data.item.getAttributeKeys() ) {\n\t\t\tdata.attributeKey = key;\n\t\t\tdata.attributeOldValue = null;\n\t\t\tdata.attributeNewValue = data.item.getAttribute( key );\n\n\t\t\tthis._testAndFire( `attribute:${ key }`, data );\n\t\t}\n\t}\n\n\t/**\n\t * Returns differ changes together with added \"reconvert\" type changes for {@link #reconvertElement}. These are defined by\n\t * a the `triggerBy()` configuration for the\n\t * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} conversion helper.\n\t *\n\t * This method will remove every mapped insert or remove change with a single \"reconvert\" change.\n\t *\n\t * For instance: Having a `triggerBy()` configuration defined for the `<complex>` element that issues this element reconversion on\n\t * `foo` and `bar` attributes change, and a set of changes for this element:\n\t *\n\t *\t\tconst differChanges = [\n\t *\t\t\t{ type: 'attribute', attributeKey: 'foo', ... },\n\t *\t\t\t{ type: 'attribute', attributeKey: 'bar', ... },\n\t *\t\t\t{ type: 'attribute', attributeKey: 'baz', ... }\n\t *\t\t];\n\t *\n\t * This method will return:\n\t *\n\t *\t\tconst updatedChanges = [\n\t *\t\t\t{ type: 'reconvert', element: complexElementInstance },\n\t *\t\t\t{ type: 'attribute', attributeKey: 'baz', ... }\n\t *\t\t];\n\t *\n\t * In the example above, the `'baz'` attribute change will fire an {@link #event:attribute attribute event}\n\t *\n\t * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n\t * @returns {Array.<Object>} Updated set of changes.\n\t * @private\n\t */\n\t_mapChangesWithAutomaticReconversion( differ ) {\n\t\tconst itemsToReconvert = new Set();\n\t\tconst updated = [];\n\n\t\tfor ( const entry of differ.getChanges() ) {\n\t\t\tconst position = entry.position || entry.range.start;\n\t\t\t// Cached parent - just in case. See https://github.com/ckeditor/ckeditor5/issues/6579.\n\t\t\tconst positionParent = position.parent;\n\t\t\tconst textNode = getTextNodeAtPosition( position, positionParent );\n\n\t\t\t// Reconversion is done only on elements so skip text changes.\n\t\t\tif ( textNode ) {\n\t\t\t\tupdated.push( entry );\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst element = entry.type === 'attribute' ? getNodeAfterPosition( position, positionParent, null ) : positionParent;\n\n\t\t\t// Case of text node set directly in root. For now used only in tests but can be possible when enabled in paragraph-like roots.\n\t\t\t// See: https://github.com/ckeditor/ckeditor5/issues/762.\n\t\t\tif ( element.is( '$text' ) ) {\n\t\t\t\tupdated.push( entry );\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet eventName;\n\n\t\t\tif ( entry.type === 'attribute' ) {\n\t\t\t\teventName = `attribute:${ entry.attributeKey }:${ element.name }`;\n\t\t\t} else {\n\t\t\t\teventName = `${ entry.type }:${ entry.name }`;\n\t\t\t}\n\n\t\t\tif ( this._isReconvertTriggerEvent( eventName, element.name ) ) {\n\t\t\t\tif ( itemsToReconvert.has( element ) ) {\n\t\t\t\t\t// Element is already reconverted, so skip this change.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\titemsToReconvert.add( element );\n\n\t\t\t\t// Add special \"reconvert\" change.\n\t\t\t\tupdated.push( { type: 'reconvert', element } );\n\t\t\t} else {\n\t\t\t\tupdated.push( entry );\n\t\t\t}\n\t\t}\n\n\t\treturn updated;\n\t}\n\n\t/**\n\t * Checks if the resulting change should trigger element reconversion.\n\t *\n\t * These are defined by a `triggerBy()` configuration for the\n\t * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} conversion helper.\n\t *\n\t * @private\n\t * @param {String} eventName The event name to check.\n\t * @param {String} elementName The element name to check.\n\t * @returns {Boolean}\n\t */\n\t_isReconvertTriggerEvent( eventName, elementName ) {\n\t\treturn this._reconversionEventsMapping.get( eventName ) === elementName;\n\t}\n\n\t/**\n\t * Fired for inserted nodes.\n\t *\n\t * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n\t * or {@link module:engine/model/element~Element#name name} of inserted element.\n\t *\n\t * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n\t *\n\t * @event insert\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item} data.item Inserted item.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for removed nodes.\n\t *\n\t * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `remove:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been removed,\n\t * or the {@link module:engine/model/element~Element#name name} of removed element.\n\t *\n\t * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n\t *\n\t * @event remove\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n\t * @param {Number} data.length Offset size of the removed node.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired in the following cases:\n\t *\n\t * * when an attribute has been added, changed, or removed from a node,\n\t * * when a node with an attribute is inserted,\n\t * * when collapsed model selection attribute is converted.\n\t *\n\t * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n\t * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n\t * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n\t *\n\t * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:imageBlock`).\n\t *\n\t * @event attribute\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n\t * or converted selection.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n\t * @param {String} data.attributeKey Attribute key.\n\t * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n\t * @param {*} data.attributeNewValue New attribute value.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for {@link module:engine/model/selection~Selection selection} changes.\n\t *\n\t * @event selection\n\t * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when a new marker is added to the model. Also fired when a collapsed model selection that is inside a marker is converted.\n\t *\n\t * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n\t * `addMarker:foo:bar` events.\n\t *\n\t * If the marker range is not collapsed:\n\t *\n\t * * the event is fired for each item in the marker range one by one,\n\t * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as the event name.\n\t *\n\t * If the marker range is collapsed:\n\t *\n\t * * there is only one event,\n\t * * `conversionApi.consumable` includes marker range with the event name.\n\t *\n\t * If the selection inside a marker is converted:\n\t *\n\t * * there is only one event,\n\t * * `conversionApi.consumable` includes the selection instance with the event name.\n\t *\n\t * @event addMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n\t * the selection that is being converted.\n\t * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n\t * the marker range was not collapsed.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when a marker is removed from the model.\n\t *\n\t * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n\t * `removeMarker:foo:bar` events.\n\t *\n\t * @event removeMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n}\n\nmix( DowncastDispatcher, EmitterMixin );\n\n// Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\nfunction shouldMarkerChangeBeConverted( modelPosition, marker, mapper ) {\n\tconst range = marker.getRange();\n\tconst ancestors = Array.from( modelPosition.getAncestors() );\n\tancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\tancestors.reverse();\n\n\tconst hasCustomHandling = ancestors.some( element => {\n\t\tif ( range.containsItem( element ) ) {\n\t\t\tconst viewElement = mapper.toViewElement( element );\n\n\t\t\treturn !!viewElement.getCustomProperty( 'addHighlight' );\n\t\t}\n\t} );\n\n\treturn !hasCustomHandling;\n}\n\nfunction getEventName( type, data ) {\n\tconst name = data.item.name || '$text';\n\n\treturn `${ type }:${ name }`;\n}\n\nfunction walkerValueToEventData( value ) {\n\tconst item = value.item;\n\tconst itemRange = Range._createFromPositionAndShift( value.previousPosition, value.length );\n\n\treturn {\n\t\titem,\n\t\trange: itemRange\n\t};\n}\n\nfunction elementOrTextProxyToView( item, mapper ) {\n\tif ( item.is( 'textProxy' ) ) {\n\t\tconst mappedPosition = mapper.toViewPosition( Position._createBefore( item ) );\n\t\tconst positionParent = mappedPosition.parent;\n\n\t\treturn positionParent.is( '$text' ) ? positionParent : null;\n\t}\n\n\treturn mapper.toViewElement( item );\n}\n\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires its events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores the information about what parts of a processed model item are still waiting to be handled. After a piece of a model item was\n * converted, an appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/model/schema~Schema} instance set for the model that is downcast.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n\n/**\n * An object with an additional configuration which can be used during the conversion process. Available only for data downcast conversion.\n *\n * @member {Object} #options\n */\n"]},"metadata":{},"sourceType":"module"}