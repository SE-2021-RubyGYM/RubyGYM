{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\nimport Position from './position';\nimport Range from './range';\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\n\nexport default class Differ {\n  /**\n   * Creates a `Differ` instance.\n   *\n   * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n   */\n  constructor(markerCollection) {\n    /**\n     * Reference to the model's marker collection.\n     *\n     * @private\n     * @type {module:engine/model/markercollection~MarkerCollection}\n     */\n    this._markerCollection = markerCollection;\n    /**\n     * A map that stores changes that happened in a given element.\n     *\n     * The keys of the map are references to the model elements.\n     * The values of the map are arrays with changes that were done on this element.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._changesInElement = new Map();\n    /**\n     * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n     * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n     * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._elementSnapshots = new Map();\n    /**\n     * A map that stores all changed markers.\n     *\n     * The keys of the map are marker names.\n     * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range\n     * state before and after the change.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._changedMarkers = new Map();\n    /**\n     * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n     * when changes are sorted.\n     *\n     * @private\n     * @type {Number}\n     */\n\n    this._changeCount = 0;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n     * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores those changes that did not take place in graveyard root.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChanges = null;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n     * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChangesWithGraveyard = null;\n  }\n  /**\n   * Informs whether there are any changes buffered in `Differ`.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isEmpty() {\n    return this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n  }\n  /**\n   * Marks given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted in the differ changes\n   * set, so it will be effectively re-converted when differ changes will be handled by a dispatcher.\n   *\n   * @param {module:engine/model/item~Item} item Item to refresh.\n   */\n\n\n  refreshItem(item) {\n    if (this._isInInsertedElement(item.parent)) {\n      return;\n    }\n\n    this._markRemove(item.parent, item.startOffset, item.offsetSize);\n\n    this._markInsert(item.parent, item.startOffset, item.offsetSize);\n\n    const range = Range._createOn(item);\n\n    for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n      const markerRange = marker.getRange();\n      this.bufferMarkerChange(marker.name, markerRange, markerRange, marker.affectsData);\n    } // Clear cache after each buffered operation as it is no longer valid.\n\n\n    this._cachedChanges = null;\n  }\n  /**\n   * Buffers the given operation. An operation has to be buffered before it is executed.\n   *\n   * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n   * in the state before the operation is executed.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n   */\n\n\n  bufferOperation(operation) {\n    // Below we take an operation, check its type, then use its parameters in marking (private) methods.\n    // The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n    // Marking changes in them would cause a \"double\" changing then.\n    //\n    switch (operation.type) {\n      case 'insert':\n        {\n          if (this._isInInsertedElement(operation.position.parent)) {\n            return;\n          }\n\n          this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);\n\n          break;\n        }\n\n      case 'addAttribute':\n      case 'removeAttribute':\n      case 'changeAttribute':\n        {\n          for (const item of operation.range.getItems({\n            shallow: true\n          })) {\n            if (this._isInInsertedElement(item.parent)) {\n              continue;\n            }\n\n            this._markAttribute(item);\n          }\n\n          break;\n        }\n\n      case 'remove':\n      case 'move':\n      case 'reinsert':\n        {\n          // When range is moved to the same position then not mark it as a change.\n          // See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n          if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {\n            return;\n          }\n\n          const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);\n\n          const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);\n\n          if (!sourceParentInserted) {\n            this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);\n          }\n\n          if (!targetParentInserted) {\n            this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);\n          }\n\n          break;\n        }\n\n      case 'rename':\n        {\n          if (this._isInInsertedElement(operation.position.parent)) {\n            return;\n          }\n\n          this._markRemove(operation.position.parent, operation.position.offset, 1);\n\n          this._markInsert(operation.position.parent, operation.position.offset, 1);\n\n          const range = Range._createFromPositionAndShift(operation.position, 1);\n\n          for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {\n            const markerRange = marker.getRange();\n            this.bufferMarkerChange(marker.name, markerRange, markerRange, marker.affectsData);\n          }\n\n          break;\n        }\n\n      case 'split':\n        {\n          const splitElement = operation.splitPosition.parent; // Mark that children of the split element were removed.\n\n          if (!this._isInInsertedElement(splitElement)) {\n            this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);\n          } // Mark that the new element (split copy) was inserted.\n\n\n          if (!this._isInInsertedElement(operation.insertionPosition.parent)) {\n            this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);\n          } // If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\n\n          if (operation.graveyardPosition) {\n            this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);\n          }\n\n          break;\n        }\n\n      case 'merge':\n        {\n          // Mark that the merged element was removed.\n          const mergedElement = operation.sourcePosition.parent;\n\n          if (!this._isInInsertedElement(mergedElement.parent)) {\n            this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);\n          } // Mark that the merged element was inserted into graveyard.\n\n\n          const graveyardParent = operation.graveyardPosition.parent;\n\n          this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1); // Mark that children of merged element were inserted at new parent.\n\n\n          const mergedIntoElement = operation.targetPosition.parent;\n\n          if (!this._isInInsertedElement(mergedIntoElement)) {\n            this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);\n          }\n\n          break;\n        }\n    } // Clear cache after each buffered operation as it is no longer valid.\n\n\n    this._cachedChanges = null;\n  }\n  /**\n   * Buffers a marker change.\n   *\n   * @param {String} markerName The name of the marker that changed.\n   * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just\n   * been created.\n   * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.\n   * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.\n   */\n\n\n  bufferMarkerChange(markerName, oldRange, newRange, affectsData) {\n    const buffered = this._changedMarkers.get(markerName);\n\n    if (!buffered) {\n      this._changedMarkers.set(markerName, {\n        oldRange,\n        newRange,\n        affectsData\n      });\n    } else {\n      buffered.newRange = newRange;\n      buffered.affectsData = affectsData;\n\n      if (buffered.oldRange == null && buffered.newRange == null) {\n        // The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change\n        // (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.\n        this._changedMarkers.delete(markerName);\n      }\n    }\n  }\n  /**\n   * Returns all markers that should be removed as a result of buffered changes.\n   *\n   * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n   */\n\n\n  getMarkersToRemove() {\n    const result = [];\n\n    for (const [name, change] of this._changedMarkers) {\n      if (change.oldRange != null) {\n        result.push({\n          name,\n          range: change.oldRange\n        });\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns all markers which should be added as a result of buffered changes.\n   *\n   * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n   */\n\n\n  getMarkersToAdd() {\n    const result = [];\n\n    for (const [name, change] of this._changedMarkers) {\n      if (change.newRange != null) {\n        result.push({\n          name,\n          range: change.newRange\n        });\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns all markers which changed.\n   *\n   * @returns {Array.<Object>}\n   */\n\n\n  getChangedMarkers() {\n    return Array.from(this._changedMarkers).map(item => ({\n      name: item[0],\n      data: {\n        oldRange: item[1].oldRange,\n        newRange: item[1].newRange\n      }\n    }));\n  }\n  /**\n   * Checks whether some of the buffered changes affect the editor data.\n   *\n   * Types of changes which affect the editor data:\n   *\n   * * model structure changes,\n   * * attribute changes,\n   * * changes of markers which were defined as `affectingData`.\n   *\n   * @returns {Boolean}\n   */\n\n\n  hasDataChanges() {\n    for (const [, change] of this._changedMarkers) {\n      if (change.affectsData) {\n        return true;\n      }\n    } // If markers do not affect the data, check whether there are some changes in elements.\n\n\n    return this._changesInElement.size > 0;\n  }\n  /**\n   * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n   * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n   *\n   * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n   * on the model. The items are sorted by the position on which the change happened. If a position\n   * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n   *\n   * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n   *\n   * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n   * previous {@link #getChanges} call, the next call will return the cached value.\n   *\n   * @param {Object} options Additional options.\n   * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n   * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n   * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n   */\n\n\n  getChanges() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      includeChangesInGraveyard: false\n    };\n\n    // If there are cached changes, just return them instead of calculating changes again.\n    if (this._cachedChanges) {\n      if (options.includeChangesInGraveyard) {\n        return this._cachedChangesWithGraveyard.slice();\n      } else {\n        return this._cachedChanges.slice();\n      }\n    } // Will contain returned results.\n\n\n    let diffSet = []; // Check all changed elements.\n\n    for (const element of this._changesInElement.keys()) {\n      // Get changes for this element and sort them.\n      const changes = this._changesInElement.get(element).sort((a, b) => {\n        if (a.offset === b.offset) {\n          if (a.type != b.type) {\n            // If there are multiple changes at the same position, \"remove\" change should be first.\n            // If the order is different, for example, we would first add some nodes and then removed them\n            // (instead of the nodes that we should remove).\n            return a.type == 'remove' ? -1 : 1;\n          }\n\n          return 0;\n        }\n\n        return a.offset < b.offset ? -1 : 1;\n      }); // Get children of this element before any change was applied on it.\n\n\n      const snapshotChildren = this._elementSnapshots.get(element); // Get snapshot of current element's children.\n\n\n      const elementChildren = _getChildrenSnapshot(element.getChildren()); // Generate actions basing on changes done on element.\n\n\n      const actions = _generateActionsFromChanges(snapshotChildren.length, changes);\n\n      let i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\n      let j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n      // Process every action.\n\n      for (const action of actions) {\n        if (action === 'i') {\n          // Generate diff item for this element and insert it into the diff set.\n          diffSet.push(this._getInsertDiff(element, i, elementChildren[i].name));\n          i++;\n        } else if (action === 'r') {\n          // Generate diff item for this element and insert it into the diff set.\n          diffSet.push(this._getRemoveDiff(element, i, snapshotChildren[j].name));\n          j++;\n        } else if (action === 'a') {\n          // Take attributes from saved and current children.\n          const elementAttributes = elementChildren[i].attributes;\n          const snapshotAttributes = snapshotChildren[j].attributes;\n          let range;\n\n          if (elementChildren[i].name == '$text') {\n            range = new Range(Position._createAt(element, i), Position._createAt(element, i + 1));\n          } else {\n            const index = element.offsetToIndex(i);\n            range = new Range(Position._createAt(element, i), Position._createAt(element.getChild(index), 0));\n          } // Generate diff items for this change (there might be multiple attributes changed and\n          // there is a single diff for each of them) and insert them into the diff set.\n\n\n          diffSet.push(...this._getAttributesDiff(range, snapshotAttributes, elementAttributes));\n          i++;\n          j++;\n        } else {\n          // `action` is 'equal'. Child not changed.\n          i++;\n          j++;\n        }\n      }\n    } // Then, sort the changes by the position (change at position before other changes is first).\n\n\n    diffSet.sort((a, b) => {\n      // If the change is in different root, we don't care much, but we'd like to have all changes in given\n      // root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n      // will be processed first.\n      if (a.position.root != b.position.root) {\n        return a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n      } // If change happens at the same position...\n\n\n      if (a.position.isEqual(b.position)) {\n        // Keep chronological order of operations.\n        return a.changeCount - b.changeCount;\n      } // If positions differ, position \"on the left\" should be earlier in the result.\n\n\n      return a.position.isBefore(b.position) ? -1 : 1;\n    }); // Glue together multiple changes (mostly on text nodes).\n\n    for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {\n      const prevDiff = diffSet[prevIndex];\n      const thisDiff = diffSet[i]; // Glue remove changes if they happen on text on same position.\n\n      const isConsecutiveTextRemove = prevDiff.type == 'remove' && thisDiff.type == 'remove' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.isEqual(thisDiff.position); // Glue insert changes if they happen on text on consecutive fragments.\n\n      const isConsecutiveTextAdd = prevDiff.type == 'insert' && thisDiff.type == 'insert' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset; // Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\n      const isConsecutiveAttributeChange = prevDiff.type == 'attribute' && thisDiff.type == 'attribute' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n      if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {\n        prevDiff.length++;\n\n        if (isConsecutiveAttributeChange) {\n          prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);\n        }\n\n        diffSet[i] = null;\n      } else {\n        prevIndex = i;\n      }\n    }\n\n    diffSet = diffSet.filter(v => v); // Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\n    for (const item of diffSet) {\n      delete item.changeCount;\n\n      if (item.type == 'attribute') {\n        delete item.position;\n        delete item.length;\n      }\n    }\n\n    this._changeCount = 0; // Cache changes.\n\n    this._cachedChangesWithGraveyard = diffSet.slice();\n    this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);\n\n    if (options.includeChangesInGraveyard) {\n      return this._cachedChangesWithGraveyard;\n    } else {\n      return this._cachedChanges;\n    }\n  }\n  /**\n   * Resets `Differ`. Removes all buffered changes.\n   */\n\n\n  reset() {\n    this._changesInElement.clear();\n\n    this._elementSnapshots.clear();\n\n    this._changedMarkers.clear();\n\n    this._cachedChanges = null;\n  }\n  /**\n   * Saves and handles an insert change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n\n\n  _markInsert(parent, offset, howMany) {\n    const changeItem = {\n      type: 'insert',\n      offset,\n      howMany,\n      count: this._changeCount++\n    };\n\n    this._markChange(parent, changeItem);\n  }\n  /**\n   * Saves and handles a remove change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n\n\n  _markRemove(parent, offset, howMany) {\n    const changeItem = {\n      type: 'remove',\n      offset,\n      howMany,\n      count: this._changeCount++\n    };\n\n    this._markChange(parent, changeItem);\n\n    this._removeAllNestedChanges(parent, offset, howMany);\n  }\n  /**\n   * Saves and handles an attribute change.\n   *\n   * @private\n   * @param {module:engine/model/item~Item} item\n   */\n\n\n  _markAttribute(item) {\n    const changeItem = {\n      type: 'attribute',\n      offset: item.startOffset,\n      howMany: item.offsetSize,\n      count: this._changeCount++\n    };\n\n    this._markChange(item.parent, changeItem);\n  }\n  /**\n   * Saves and handles a model change.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Object} changeItem\n   */\n\n\n  _markChange(parent, changeItem) {\n    // First, make a snapshot of this parent's children (it will be made only if it was not made before).\n    this._makeSnapshot(parent); // Then, get all changes that already were done on the element (empty array if this is the first change).\n\n\n    const changes = this._getChangesForElement(parent); // Then, look through all the changes, and transform them or the new change.\n\n\n    this._handleChange(changeItem, changes); // Add the new change.\n\n\n    changes.push(changeItem); // Remove incorrect changes. During transformation some change might be, for example, included in another.\n    // In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\n    for (let i = 0; i < changes.length; i++) {\n      if (changes[i].howMany < 1) {\n        changes.splice(i, 1);\n        i--;\n      }\n    }\n  }\n  /**\n   * Gets an array of changes that have already been saved for a given element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element\n   * @returns {Array.<Object>}\n   */\n\n\n  _getChangesForElement(element) {\n    let changes;\n\n    if (this._changesInElement.has(element)) {\n      changes = this._changesInElement.get(element);\n    } else {\n      changes = [];\n\n      this._changesInElement.set(element, changes);\n    }\n\n    return changes;\n  }\n  /**\n   * Saves a children snapshot for a given element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element\n   */\n\n\n  _makeSnapshot(element) {\n    if (!this._elementSnapshots.has(element)) {\n      this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));\n    }\n  }\n  /**\n   * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n   * change and/or the old change.\n   *\n   * @private\n   * @param {Object} inc Incoming (new) change.\n   * @param {Array.<Object>} changes An array containing all the changes done on that element.\n   */\n\n\n  _handleChange(inc, changes) {\n    // We need a helper variable that will store how many nodes are to be still handled for this change item.\n    // `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n    // needs to be differentiated.\n    //\n    // This comes up when there are multiple changes that are affected by `inc` change item.\n    //\n    // For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n    // Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n    //\n    // Then, we:\n    // - \"forget\" about first insert change (it is \"eaten\" by remove),\n    // - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n    // - but still we have to change offset of the second insert change from `5` to `3`!\n    //\n    // So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n    // while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n    inc.nodesToHandle = inc.howMany;\n\n    for (const old of changes) {\n      const incEnd = inc.offset + inc.howMany;\n      const oldEnd = old.offset + old.howMany;\n\n      if (inc.type == 'insert') {\n        if (old.type == 'insert') {\n          if (inc.offset <= old.offset) {\n            old.offset += inc.howMany;\n          } else if (inc.offset < oldEnd) {\n            old.howMany += inc.nodesToHandle;\n            inc.nodesToHandle = 0;\n          }\n        }\n\n        if (old.type == 'remove') {\n          if (inc.offset < old.offset) {\n            old.offset += inc.howMany;\n          }\n        }\n\n        if (old.type == 'attribute') {\n          if (inc.offset <= old.offset) {\n            old.offset += inc.howMany;\n          } else if (inc.offset < oldEnd) {\n            // This case is more complicated, because attribute change has to be split into two.\n            // Example (assume that uppercase and lowercase letters mean different attributes):\n            //\n            // initial state:\t\tabcxyz\n            // attribute change:\taBCXYz\n            // incoming insert:\t\taBCfooXYz\n            //\n            // Change ranges cannot intersect because each item has to be described exactly (it was either\n            // not changed, inserted, removed, or its attribute was changed). That's why old attribute\n            // change has to be split and both parts has to be handled separately from now on.\n            const howMany = old.howMany;\n            old.howMany = inc.offset - old.offset; // Add the second part of attribute change to the beginning of processed array so it won't\n            // be processed again in this loop.\n\n            changes.unshift({\n              type: 'attribute',\n              offset: incEnd,\n              howMany: howMany - old.howMany,\n              count: this._changeCount++\n            });\n          }\n        }\n      }\n\n      if (inc.type == 'remove') {\n        if (old.type == 'insert') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (incEnd <= oldEnd) {\n            if (inc.offset < old.offset) {\n              const intersectionLength = incEnd - old.offset;\n              old.offset = inc.offset;\n              old.howMany -= intersectionLength;\n              inc.nodesToHandle -= intersectionLength;\n            } else {\n              old.howMany -= inc.nodesToHandle;\n              inc.nodesToHandle = 0;\n            }\n          } else {\n            if (inc.offset <= old.offset) {\n              inc.nodesToHandle -= old.howMany;\n              old.howMany = 0;\n            } else if (inc.offset < oldEnd) {\n              const intersectionLength = oldEnd - inc.offset;\n              old.howMany -= intersectionLength;\n              inc.nodesToHandle -= intersectionLength;\n            }\n          }\n        }\n\n        if (old.type == 'remove') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (inc.offset < old.offset) {\n            inc.nodesToHandle += old.howMany;\n            old.howMany = 0;\n          }\n        }\n\n        if (old.type == 'attribute') {\n          if (incEnd <= old.offset) {\n            old.offset -= inc.howMany;\n          } else if (inc.offset < old.offset) {\n            const intersectionLength = incEnd - old.offset;\n            old.offset = inc.offset;\n            old.howMany -= intersectionLength;\n          } else if (inc.offset < oldEnd) {\n            if (incEnd <= oldEnd) {\n              // On first sight in this case we don't need to split attribute operation into two.\n              // However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n              // For that reason, no two changes may intersect.\n              // So we cannot have an attribute change that \"contains\" remove change.\n              // Attribute change needs to be split.\n              const howMany = old.howMany;\n              old.howMany = inc.offset - old.offset;\n              const howManyAfter = howMany - old.howMany - inc.nodesToHandle; // Add the second part of attribute change to the beginning of processed array so it won't\n              // be processed again in this loop.\n\n              changes.unshift({\n                type: 'attribute',\n                offset: inc.offset,\n                howMany: howManyAfter,\n                count: this._changeCount++\n              });\n            } else {\n              old.howMany -= oldEnd - inc.offset;\n            }\n          }\n        }\n      }\n\n      if (inc.type == 'attribute') {\n        // In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n        if (old.type == 'insert') {\n          if (inc.offset < old.offset && incEnd > old.offset) {\n            if (incEnd > oldEnd) {\n              // This case is similar to a case described when incoming change was insert and old change was attribute.\n              // See comment above.\n              //\n              // This time incoming change is attribute. We need to split incoming change in this case too.\n              // However this time, the second part of the attribute change needs to be processed further\n              // because there might be other changes that it collides with.\n              const attributePart = {\n                type: 'attribute',\n                offset: oldEnd,\n                howMany: incEnd - oldEnd,\n                count: this._changeCount++\n              };\n\n              this._handleChange(attributePart, changes);\n\n              changes.push(attributePart);\n            }\n\n            inc.nodesToHandle = old.offset - inc.offset;\n            inc.howMany = inc.nodesToHandle;\n          } else if (inc.offset >= old.offset && inc.offset < oldEnd) {\n            if (incEnd > oldEnd) {\n              inc.nodesToHandle = incEnd - oldEnd;\n              inc.offset = oldEnd;\n            } else {\n              inc.nodesToHandle = 0;\n            }\n          }\n        }\n\n        if (old.type == 'remove') {\n          // This is a case when attribute change \"contains\" remove change.\n          // The attribute change needs to be split into two because changes cannot intersect.\n          if (inc.offset < old.offset && incEnd > old.offset) {\n            const attributePart = {\n              type: 'attribute',\n              offset: old.offset,\n              howMany: incEnd - old.offset,\n              count: this._changeCount++\n            };\n\n            this._handleChange(attributePart, changes);\n\n            changes.push(attributePart);\n            inc.nodesToHandle = old.offset - inc.offset;\n            inc.howMany = inc.nodesToHandle;\n          }\n        }\n\n        if (old.type == 'attribute') {\n          // There are only two conflicting scenarios possible here:\n          if (inc.offset >= old.offset && incEnd <= oldEnd) {\n            // `old` change includes `inc` change, or they are the same.\n            inc.nodesToHandle = 0;\n            inc.howMany = 0;\n            inc.offset = 0;\n          } else if (inc.offset <= old.offset && incEnd >= oldEnd) {\n            // `inc` change includes `old` change.\n            old.howMany = 0;\n          }\n        }\n      }\n    }\n\n    inc.howMany = inc.nodesToHandle;\n    delete inc.nodesToHandle;\n  }\n  /**\n   * Returns an object with a single insert change description.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent The element in which the change happened.\n   * @param {Number} offset The offset at which change happened.\n   * @param {String} name The name of the removed element or `'$text'` for a character.\n   * @returns {Object} The diff item.\n   */\n\n\n  _getInsertDiff(parent, offset, name) {\n    return {\n      type: 'insert',\n      position: Position._createAt(parent, offset),\n      name,\n      length: 1,\n      changeCount: this._changeCount++\n    };\n  }\n  /**\n   * Returns an object with a single remove change description.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent The element in which change happened.\n   * @param {Number} offset The offset at which change happened.\n   * @param {String} name The name of the removed element or `'$text'` for a character.\n   * @returns {Object} The diff item.\n   */\n\n\n  _getRemoveDiff(parent, offset, name) {\n    return {\n      type: 'remove',\n      position: Position._createAt(parent, offset),\n      name,\n      length: 1,\n      changeCount: this._changeCount++\n    };\n  }\n  /**\n   * Returns an array of objects where each one is a single attribute change description.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range The range where the change happened.\n   * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n   * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n   * @returns {Array.<Object>} An array containing one or more diff items.\n   */\n\n\n  _getAttributesDiff(range, oldAttributes, newAttributes) {\n    // Results holder.\n    const diffs = []; // Clone new attributes as we will be performing changes on this object.\n\n    newAttributes = new Map(newAttributes); // Look through old attributes.\n\n    for (const [key, oldValue] of oldAttributes) {\n      // Check what is the new value of the attribute (or if it was removed).\n      const newValue = newAttributes.has(key) ? newAttributes.get(key) : null; // If values are different (or attribute was removed)...\n\n      if (newValue !== oldValue) {\n        // Add diff item.\n        diffs.push({\n          type: 'attribute',\n          position: range.start,\n          range: range.clone(),\n          length: 1,\n          attributeKey: key,\n          attributeOldValue: oldValue,\n          attributeNewValue: newValue,\n          changeCount: this._changeCount++\n        });\n      } // Prevent returning two diff items for the same change.\n\n\n      newAttributes.delete(key);\n    } // Look through new attributes that weren't handled above.\n\n\n    for (const [key, newValue] of newAttributes) {\n      // Each of them is a new attribute. Add diff item.\n      diffs.push({\n        type: 'attribute',\n        position: range.start,\n        range: range.clone(),\n        length: 1,\n        attributeKey: key,\n        attributeOldValue: null,\n        attributeNewValue: newValue,\n        changeCount: this._changeCount++\n      });\n    }\n\n    return diffs;\n  }\n  /**\n   * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element Element to check.\n   * @returns {Boolean}\n   */\n\n\n  _isInInsertedElement(element) {\n    const parent = element.parent;\n\n    if (!parent) {\n      return false;\n    }\n\n    const changes = this._changesInElement.get(parent);\n\n    const offset = element.startOffset;\n\n    if (changes) {\n      for (const change of changes) {\n        if (change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany) {\n          return true;\n        }\n      }\n    }\n\n    return this._isInInsertedElement(parent);\n  }\n  /**\n   * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n   * and `howMany`.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} parent\n   * @param {Number} offset\n   * @param {Number} howMany\n   */\n\n\n  _removeAllNestedChanges(parent, offset, howMany) {\n    const range = new Range(Position._createAt(parent, offset), Position._createAt(parent, offset + howMany));\n\n    for (const item of range.getItems({\n      shallow: true\n    })) {\n      if (item.is('element')) {\n        this._elementSnapshots.delete(item);\n\n        this._changesInElement.delete(item);\n\n        this._removeAllNestedChanges(item, 0, item.maxOffset);\n      }\n    }\n  }\n\n} // Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\n\nfunction _getChildrenSnapshot(children) {\n  const snapshot = [];\n\n  for (const child of children) {\n    if (child.is('$text')) {\n      for (let i = 0; i < child.data.length; i++) {\n        snapshot.push({\n          name: '$text',\n          attributes: new Map(child.getAttributes())\n        });\n      }\n    } else {\n      snapshot.push({\n        name: child.name,\n        attributes: new Map(child.getAttributes())\n      });\n    }\n  }\n\n  return snapshot;\n} // Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\n\n\nfunction _generateActionsFromChanges(oldChildrenLength, changes) {\n  const actions = [];\n  let offset = 0;\n  let oldChildrenHandled = 0; // Go through all buffered changes.\n\n  for (const change of changes) {\n    // First, fill \"holes\" between changes with \"equal\" actions.\n    if (change.offset > offset) {\n      for (let i = 0; i < change.offset - offset; i++) {\n        actions.push('e');\n      }\n\n      oldChildrenHandled += change.offset - offset;\n    } // Then, fill up actions accordingly to change type.\n\n\n    if (change.type == 'insert') {\n      for (let i = 0; i < change.howMany; i++) {\n        actions.push('i');\n      } // The last handled offset is after inserted range.\n\n\n      offset = change.offset + change.howMany;\n    } else if (change.type == 'remove') {\n      for (let i = 0; i < change.howMany; i++) {\n        actions.push('r');\n      } // The last handled offset is at the position where the nodes were removed.\n\n\n      offset = change.offset; // We removed `howMany` old nodes, update `oldChildrenHandled`.\n\n      oldChildrenHandled += change.howMany;\n    } else {\n      actions.push(...'a'.repeat(change.howMany).split('')); // The last handled offset is at the position after the changed range.\n\n      offset = change.offset + change.howMany; // We changed `howMany` old nodes, update `oldChildrenHandled`.\n\n      oldChildrenHandled += change.howMany;\n    }\n  } // Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n  // has not been changed / removed at the end of their parent.\n\n\n  if (oldChildrenHandled < oldChildrenLength) {\n    for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {\n      actions.push('e');\n    }\n  }\n\n  return actions;\n} // Filter callback for Array.filter that filters out change entries that are in graveyard.\n\n\nfunction _changesInGraveyardFilter(entry) {\n  const posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n  const rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n  return !posInGy && !rangeInGy;\n}\n/**\n * The single diff item.\n *\n * Could be one of:\n *\n * * {@link module:engine/model/differ~DiffItemInsert `DiffItemInsert`},\n * * {@link module:engine/model/differ~DiffItemRemove `DiffItemRemove`},\n * * {@link module:engine/model/differ~DiffItemAttribute `DiffItemAttribute`}.\n *\n * @interface DiffItem\n */\n\n/**\n * The single diff item for inserted nodes.\n *\n * @class DiffItemInsert\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'insert'} module:engine/model/differ~DiffItemInsert#type\n */\n\n/**\n * The name of the inserted elements or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemInsert#name\n */\n\n/**\n * The position where the node was inserted.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemInsert#position\n */\n\n/**\n * The length of an inserted text node. For elements it is always 1 as each inserted element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemInsert#length\n */\n\n/**\n * The single diff item for removed nodes.\n *\n * @class DiffItemRemove\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'remove'} module:engine/model/differ~DiffItemRemove#type\n */\n\n/**\n * The name of the removed element or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemRemove#name\n */\n\n/**\n * The position where the node was removed.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemRemove#position\n */\n\n/**\n * The length of a removed text node. For elements it is always 1 as each removed element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemRemove#length\n */\n\n/**\n * The single diff item for attribute change.\n *\n * @class DiffItemAttribute\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js"],"names":["Position","Range","Differ","constructor","markerCollection","_markerCollection","_changesInElement","Map","_elementSnapshots","_changedMarkers","_changeCount","_cachedChanges","_cachedChangesWithGraveyard","isEmpty","size","refreshItem","item","_isInInsertedElement","parent","_markRemove","startOffset","offsetSize","_markInsert","range","_createOn","marker","getMarkersIntersectingRange","markerRange","getRange","bufferMarkerChange","name","affectsData","bufferOperation","operation","type","position","offset","nodes","maxOffset","getItems","shallow","_markAttribute","sourcePosition","isEqual","targetPosition","getShiftedBy","howMany","sourceParentInserted","targetParentInserted","getMovedRangeStart","_createFromPositionAndShift","splitElement","splitPosition","insertionPosition","graveyardPosition","mergedElement","graveyardParent","mergedIntoElement","markerName","oldRange","newRange","buffered","get","set","delete","getMarkersToRemove","result","change","push","getMarkersToAdd","getChangedMarkers","Array","from","map","data","hasDataChanges","getChanges","options","includeChangesInGraveyard","slice","diffSet","element","keys","changes","sort","a","b","snapshotChildren","elementChildren","_getChildrenSnapshot","getChildren","actions","_generateActionsFromChanges","length","i","j","action","_getInsertDiff","_getRemoveDiff","elementAttributes","attributes","snapshotAttributes","_createAt","index","offsetToIndex","getChild","_getAttributesDiff","root","rootName","changeCount","isBefore","prevIndex","prevDiff","thisDiff","isConsecutiveTextRemove","isConsecutiveTextAdd","isConsecutiveAttributeChange","isFlat","attributeKey","attributeOldValue","attributeNewValue","end","filter","v","_changesInGraveyardFilter","reset","clear","changeItem","count","_markChange","_removeAllNestedChanges","_makeSnapshot","_getChangesForElement","_handleChange","splice","has","inc","nodesToHandle","old","incEnd","oldEnd","unshift","intersectionLength","howManyAfter","attributePart","oldAttributes","newAttributes","diffs","key","oldValue","newValue","start","clone","is","children","snapshot","child","getAttributes","oldChildrenLength","oldChildrenHandled","repeat","split","entry","posInGy","rangeInGy"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\n\nimport Position from './position';\nimport Range from './range';\n\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n\t/**\n\t * Creates a `Differ` instance.\n\t *\n\t * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n\t */\n\tconstructor( markerCollection ) {\n\t\t/**\n\t\t * Reference to the model's marker collection.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis._markerCollection = markerCollection;\n\n\t\t/**\n\t\t * A map that stores changes that happened in a given element.\n\t\t *\n\t\t * The keys of the map are references to the model elements.\n\t\t * The values of the map are arrays with changes that were done on this element.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changesInElement = new Map();\n\n\t\t/**\n\t\t * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n\t\t * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n\t\t * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._elementSnapshots = new Map();\n\n\t\t/**\n\t\t * A map that stores all changed markers.\n\t\t *\n\t\t * The keys of the map are marker names.\n\t\t * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range\n\t\t * state before and after the change.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changedMarkers = new Map();\n\n\t\t/**\n\t\t * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n\t\t * when changes are sorted.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._changeCount = 0;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n\t\t * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores those changes that did not take place in graveyard root.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChanges = null;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n\t\t * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChangesWithGraveyard = null;\n\t}\n\n\t/**\n\t * Informs whether there are any changes buffered in `Differ`.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n\t}\n\n\t/**\n\t * Marks given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted in the differ changes\n\t * set, so it will be effectively re-converted when differ changes will be handled by a dispatcher.\n\t *\n\t * @param {module:engine/model/item~Item} item Item to refresh.\n\t */\n\trefreshItem( item ) {\n\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._markRemove( item.parent, item.startOffset, item.offsetSize );\n\t\tthis._markInsert( item.parent, item.startOffset, item.offsetSize );\n\n\t\tconst range = Range._createOn( item );\n\n\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers the given operation. An operation has to be buffered before it is executed.\n\t *\n\t * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n\t * in the state before the operation is executed.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n\t */\n\tbufferOperation( operation ) {\n\t\t// Below we take an operation, check its type, then use its parameters in marking (private) methods.\n\t\t// The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n\t\t// Marking changes in them would cause a \"double\" changing then.\n\t\t//\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, operation.nodes.maxOffset );\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'addAttribute':\n\t\t\tcase 'removeAttribute':\n\t\t\tcase 'changeAttribute': {\n\t\t\t\tfor ( const item of operation.range.getItems( { shallow: true } ) ) {\n\t\t\t\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._markAttribute( item );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'remove':\n\t\t\tcase 'move':\n\t\t\tcase 'reinsert': {\n\t\t\t\t// When range is moved to the same position then not mark it as a change.\n\t\t\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n\t\t\t\tif (\n\t\t\t\t\toperation.sourcePosition.isEqual( operation.targetPosition ) ||\n\t\t\t\t\toperation.sourcePosition.getShiftedBy( operation.howMany ).isEqual( operation.targetPosition )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceParentInserted = this._isInInsertedElement( operation.sourcePosition.parent );\n\t\t\t\tconst targetParentInserted = this._isInInsertedElement( operation.targetPosition.parent );\n\n\t\t\t\tif ( !sourceParentInserted ) {\n\t\t\t\t\tthis._markRemove( operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tif ( !targetParentInserted ) {\n\t\t\t\t\tthis._markInsert( operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'rename': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markRemove( operation.position.parent, operation.position.offset, 1 );\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, 1 );\n\n\t\t\t\tconst range = Range._createFromPositionAndShift( operation.position, 1 );\n\n\t\t\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\t\t\tconst markerRange = marker.getRange();\n\n\t\t\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'split': {\n\t\t\t\tconst splitElement = operation.splitPosition.parent;\n\n\t\t\t\t// Mark that children of the split element were removed.\n\t\t\t\tif ( !this._isInInsertedElement( splitElement ) ) {\n\t\t\t\t\tthis._markRemove( splitElement, operation.splitPosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the new element (split copy) was inserted.\n\t\t\t\tif ( !this._isInInsertedElement( operation.insertionPosition.parent ) ) {\n\t\t\t\t\tthis._markInsert( operation.insertionPosition.parent, operation.insertionPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\t\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\t\tthis._markRemove( operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'merge': {\n\t\t\t\t// Mark that the merged element was removed.\n\t\t\t\tconst mergedElement = operation.sourcePosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedElement.parent ) ) {\n\t\t\t\t\tthis._markRemove( mergedElement.parent, mergedElement.startOffset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the merged element was inserted into graveyard.\n\t\t\t\tconst graveyardParent = operation.graveyardPosition.parent;\n\n\t\t\t\tthis._markInsert( graveyardParent, operation.graveyardPosition.offset, 1 );\n\n\t\t\t\t// Mark that children of merged element were inserted at new parent.\n\t\t\t\tconst mergedIntoElement = operation.targetPosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedIntoElement ) ) {\n\t\t\t\t\tthis._markInsert( mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers a marker change.\n\t *\n\t * @param {String} markerName The name of the marker that changed.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just\n\t * been created.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.\n\t * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.\n\t */\n\tbufferMarkerChange( markerName, oldRange, newRange, affectsData ) {\n\t\tconst buffered = this._changedMarkers.get( markerName );\n\n\t\tif ( !buffered ) {\n\t\t\tthis._changedMarkers.set( markerName, {\n\t\t\t\toldRange,\n\t\t\t\tnewRange,\n\t\t\t\taffectsData\n\t\t\t} );\n\t\t} else {\n\t\t\tbuffered.newRange = newRange;\n\t\t\tbuffered.affectsData = affectsData;\n\n\t\t\tif ( buffered.oldRange == null && buffered.newRange == null ) {\n\t\t\t\t// The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change\n\t\t\t\t// (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.\n\t\t\t\tthis._changedMarkers.delete( markerName );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all markers that should be removed as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToRemove() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.oldRange != null ) {\n\t\t\t\tresult.push( { name, range: change.oldRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which should be added as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToAdd() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.newRange != null ) {\n\t\t\t\tresult.push( { name, range: change.newRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which changed.\n\t *\n\t * @returns {Array.<Object>}\n\t */\n\tgetChangedMarkers() {\n\t\treturn Array.from( this._changedMarkers ).map( item => (\n\t\t\t{\n\t\t\t\tname: item[ 0 ],\n\t\t\t\tdata: {\n\t\t\t\t\toldRange: item[ 1 ].oldRange,\n\t\t\t\t\tnewRange: item[ 1 ].newRange\n\t\t\t\t}\n\t\t\t}\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether some of the buffered changes affect the editor data.\n\t *\n\t * Types of changes which affect the editor data:\n\t *\n\t * * model structure changes,\n\t * * attribute changes,\n\t * * changes of markers which were defined as `affectingData`.\n\t *\n\t * @returns {Boolean}\n\t */\n\thasDataChanges() {\n\t\tfor ( const [ , change ] of this._changedMarkers ) {\n\t\t\tif ( change.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// If markers do not affect the data, check whether there are some changes in elements.\n\t\treturn this._changesInElement.size > 0;\n\t}\n\n\t/**\n\t * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n\t * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n\t *\n\t * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n\t * on the model. The items are sorted by the position on which the change happened. If a position\n\t * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n\t *\n\t * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n\t *\n\t * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n\t * previous {@link #getChanges} call, the next call will return the cached value.\n\t *\n\t * @param {Object} options Additional options.\n\t * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n\t * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n\t * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n\t */\n\tgetChanges( options = { includeChangesInGraveyard: false } ) {\n\t\t// If there are cached changes, just return them instead of calculating changes again.\n\t\tif ( this._cachedChanges ) {\n\t\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\t\treturn this._cachedChangesWithGraveyard.slice();\n\t\t\t} else {\n\t\t\t\treturn this._cachedChanges.slice();\n\t\t\t}\n\t\t}\n\n\t\t// Will contain returned results.\n\t\tlet diffSet = [];\n\n\t\t// Check all changed elements.\n\t\tfor ( const element of this._changesInElement.keys() ) {\n\t\t\t// Get changes for this element and sort them.\n\t\t\tconst changes = this._changesInElement.get( element ).sort( ( a, b ) => {\n\t\t\t\tif ( a.offset === b.offset ) {\n\t\t\t\t\tif ( a.type != b.type ) {\n\t\t\t\t\t\t// If there are multiple changes at the same position, \"remove\" change should be first.\n\t\t\t\t\t\t// If the order is different, for example, we would first add some nodes and then removed them\n\t\t\t\t\t\t// (instead of the nodes that we should remove).\n\t\t\t\t\t\treturn a.type == 'remove' ? -1 : 1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn a.offset < b.offset ? -1 : 1;\n\t\t\t} );\n\n\t\t\t// Get children of this element before any change was applied on it.\n\t\t\tconst snapshotChildren = this._elementSnapshots.get( element );\n\t\t\t// Get snapshot of current element's children.\n\t\t\tconst elementChildren = _getChildrenSnapshot( element.getChildren() );\n\n\t\t\t// Generate actions basing on changes done on element.\n\t\t\tconst actions = _generateActionsFromChanges( snapshotChildren.length, changes );\n\n\t\t\tlet i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\t\t\tlet j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n\n\t\t\t// Process every action.\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'i' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getInsertDiff( element, i, elementChildren[ i ].name ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t} else if ( action === 'r' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getRemoveDiff( element, i, snapshotChildren[ j ].name ) );\n\n\t\t\t\t\tj++;\n\t\t\t\t} else if ( action === 'a' ) {\n\t\t\t\t\t// Take attributes from saved and current children.\n\t\t\t\t\tconst elementAttributes = elementChildren[ i ].attributes;\n\t\t\t\t\tconst snapshotAttributes = snapshotChildren[ j ].attributes;\n\t\t\t\t\tlet range;\n\n\t\t\t\t\tif ( elementChildren[ i ].name == '$text' ) {\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element, i + 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index = element.offsetToIndex( i );\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element.getChild( index ), 0 ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Generate diff items for this change (there might be multiple attributes changed and\n\t\t\t\t\t// there is a single diff for each of them) and insert them into the diff set.\n\t\t\t\t\tdiffSet.push( ...this._getAttributesDiff( range, snapshotAttributes, elementAttributes ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\t// `action` is 'equal'. Child not changed.\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Then, sort the changes by the position (change at position before other changes is first).\n\t\tdiffSet.sort( ( a, b ) => {\n\t\t\t// If the change is in different root, we don't care much, but we'd like to have all changes in given\n\t\t\t// root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n\t\t\t// will be processed first.\n\t\t\tif ( a.position.root != b.position.root ) {\n\t\t\t\treturn a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n\t\t\t}\n\n\t\t\t// If change happens at the same position...\n\t\t\tif ( a.position.isEqual( b.position ) ) {\n\t\t\t\t// Keep chronological order of operations.\n\t\t\t\treturn a.changeCount - b.changeCount;\n\t\t\t}\n\n\t\t\t// If positions differ, position \"on the left\" should be earlier in the result.\n\t\t\treturn a.position.isBefore( b.position ) ? -1 : 1;\n\t\t} );\n\n\t\t// Glue together multiple changes (mostly on text nodes).\n\t\tfor ( let i = 1, prevIndex = 0; i < diffSet.length; i++ ) {\n\t\t\tconst prevDiff = diffSet[ prevIndex ];\n\t\t\tconst thisDiff = diffSet[ i ];\n\n\t\t\t// Glue remove changes if they happen on text on same position.\n\t\t\tconst isConsecutiveTextRemove =\n\t\t\t\tprevDiff.type == 'remove' && thisDiff.type == 'remove' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.isEqual( thisDiff.position );\n\n\t\t\t// Glue insert changes if they happen on text on consecutive fragments.\n\t\t\tconst isConsecutiveTextAdd =\n\t\t\t\tprevDiff.type == 'insert' && thisDiff.type == 'insert' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n\n\t\t\t// Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\t\t\tconst isConsecutiveAttributeChange =\n\t\t\t\tprevDiff.type == 'attribute' && thisDiff.type == 'attribute' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.range.isFlat && thisDiff.range.isFlat &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset &&\n\t\t\t\tprevDiff.attributeKey == thisDiff.attributeKey &&\n\t\t\t\tprevDiff.attributeOldValue == thisDiff.attributeOldValue &&\n\t\t\t\tprevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n\t\t\tif ( isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange ) {\n\t\t\t\tprevDiff.length++;\n\n\t\t\t\tif ( isConsecutiveAttributeChange ) {\n\t\t\t\t\tprevDiff.range.end = prevDiff.range.end.getShiftedBy( 1 );\n\t\t\t\t}\n\n\t\t\t\tdiffSet[ i ] = null;\n\t\t\t} else {\n\t\t\t\tprevIndex = i;\n\t\t\t}\n\t\t}\n\n\t\tdiffSet = diffSet.filter( v => v );\n\n\t\t// Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\t\tfor ( const item of diffSet ) {\n\t\t\tdelete item.changeCount;\n\n\t\t\tif ( item.type == 'attribute' ) {\n\t\t\t\tdelete item.position;\n\t\t\t\tdelete item.length;\n\t\t\t}\n\t\t}\n\n\t\tthis._changeCount = 0;\n\n\t\t// Cache changes.\n\t\tthis._cachedChangesWithGraveyard = diffSet.slice();\n\t\tthis._cachedChanges = diffSet.filter( _changesInGraveyardFilter );\n\n\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\treturn this._cachedChangesWithGraveyard;\n\t\t} else {\n\t\t\treturn this._cachedChanges;\n\t\t}\n\t}\n\n\t/**\n\t * Resets `Differ`. Removes all buffered changes.\n\t */\n\treset() {\n\t\tthis._changesInElement.clear();\n\t\tthis._elementSnapshots.clear();\n\t\tthis._changedMarkers.clear();\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Saves and handles an insert change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markInsert( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'insert', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a remove change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markRemove( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'remove', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\n\t\tthis._removeAllNestedChanges( parent, offset, howMany );\n\t}\n\n\t/**\n\t * Saves and handles an attribute change.\n\t *\n\t * @private\n\t * @param {module:engine/model/item~Item} item\n\t */\n\t_markAttribute( item ) {\n\t\tconst changeItem = { type: 'attribute', offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };\n\n\t\tthis._markChange( item.parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a model change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Object} changeItem\n\t */\n\t_markChange( parent, changeItem ) {\n\t\t// First, make a snapshot of this parent's children (it will be made only if it was not made before).\n\t\tthis._makeSnapshot( parent );\n\n\t\t// Then, get all changes that already were done on the element (empty array if this is the first change).\n\t\tconst changes = this._getChangesForElement( parent );\n\n\t\t// Then, look through all the changes, and transform them or the new change.\n\t\tthis._handleChange( changeItem, changes );\n\n\t\t// Add the new change.\n\t\tchanges.push( changeItem );\n\n\t\t// Remove incorrect changes. During transformation some change might be, for example, included in another.\n\t\t// In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\t\tfor ( let i = 0; i < changes.length; i++ ) {\n\t\t\tif ( changes[ i ].howMany < 1 ) {\n\t\t\t\tchanges.splice( i, 1 );\n\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of changes that have already been saved for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t * @returns {Array.<Object>}\n\t */\n\t_getChangesForElement( element ) {\n\t\tlet changes;\n\n\t\tif ( this._changesInElement.has( element ) ) {\n\t\t\tchanges = this._changesInElement.get( element );\n\t\t} else {\n\t\t\tchanges = [];\n\n\t\t\tthis._changesInElement.set( element, changes );\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * Saves a children snapshot for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_makeSnapshot( element ) {\n\t\tif ( !this._elementSnapshots.has( element ) ) {\n\t\t\tthis._elementSnapshots.set( element, _getChildrenSnapshot( element.getChildren() ) );\n\t\t}\n\t}\n\n\t/**\n\t * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n\t * change and/or the old change.\n\t *\n\t * @private\n\t * @param {Object} inc Incoming (new) change.\n\t * @param {Array.<Object>} changes An array containing all the changes done on that element.\n\t */\n\t_handleChange( inc, changes ) {\n\t\t// We need a helper variable that will store how many nodes are to be still handled for this change item.\n\t\t// `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n\t\t// needs to be differentiated.\n\t\t//\n\t\t// This comes up when there are multiple changes that are affected by `inc` change item.\n\t\t//\n\t\t// For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n\t\t// Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n\t\t//\n\t\t// Then, we:\n\t\t// - \"forget\" about first insert change (it is \"eaten\" by remove),\n\t\t// - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n\t\t// - but still we have to change offset of the second insert change from `5` to `3`!\n\t\t//\n\t\t// So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n\t\t// while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n\t\tinc.nodesToHandle = inc.howMany;\n\n\t\tfor ( const old of changes ) {\n\t\t\tconst incEnd = inc.offset + inc.howMany;\n\t\t\tconst oldEnd = old.offset + old.howMany;\n\n\t\t\tif ( inc.type == 'insert' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\told.howMany += inc.nodesToHandle;\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t// This case is more complicated, because attribute change has to be split into two.\n\t\t\t\t\t\t// Example (assume that uppercase and lowercase letters mean different attributes):\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// initial state:\t\tabcxyz\n\t\t\t\t\t\t// attribute change:\taBCXYz\n\t\t\t\t\t\t// incoming insert:\t\taBCfooXYz\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Change ranges cannot intersect because each item has to be described exactly (it was either\n\t\t\t\t\t\t// not changed, inserted, removed, or its attribute was changed). That's why old attribute\n\t\t\t\t\t\t// change has to be split and both parts has to be handled separately from now on.\n\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: incEnd,\n\t\t\t\t\t\t\thowMany: howMany - old.howMany,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'remove' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( incEnd <= oldEnd ) {\n\t\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\t\told.offset = inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= inc.nodesToHandle;\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\t\tinc.nodesToHandle -= old.howMany;\n\t\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t\tconst intersectionLength = oldEnd - inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tinc.nodesToHandle += old.howMany;\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\told.offset = inc.offset;\n\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd <= oldEnd ) {\n\t\t\t\t\t\t\t// On first sight in this case we don't need to split attribute operation into two.\n\t\t\t\t\t\t\t// However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n\t\t\t\t\t\t\t// For that reason, no two changes may intersect.\n\t\t\t\t\t\t\t// So we cannot have an attribute change that \"contains\" remove change.\n\t\t\t\t\t\t\t// Attribute change needs to be split.\n\t\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t\tconst howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n\n\t\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: inc.offset,\n\t\t\t\t\t\t\t\thowMany: howManyAfter,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= oldEnd - inc.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'attribute' ) {\n\t\t\t\t// In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\t// This case is similar to a case described when incoming change was insert and old change was attribute.\n\t\t\t\t\t\t\t// See comment above.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// This time incoming change is attribute. We need to split incoming change in this case too.\n\t\t\t\t\t\t\t// However this time, the second part of the attribute change needs to be processed further\n\t\t\t\t\t\t\t// because there might be other changes that it collides with.\n\t\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: oldEnd,\n\t\t\t\t\t\t\t\thowMany: incEnd - oldEnd,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\t\tchanges.push( attributePart );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t} else if ( inc.offset >= old.offset && inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\tinc.nodesToHandle = incEnd - oldEnd;\n\t\t\t\t\t\t\tinc.offset = oldEnd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\t// This is a case when attribute change \"contains\" remove change.\n\t\t\t\t\t// The attribute change needs to be split into two because changes cannot intersect.\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: old.offset,\n\t\t\t\t\t\t\thowMany: incEnd - old.offset,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\tchanges.push( attributePart );\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\t// There are only two conflicting scenarios possible here:\n\t\t\t\t\tif ( inc.offset >= old.offset && incEnd <= oldEnd ) {\n\t\t\t\t\t\t// `old` change includes `inc` change, or they are the same.\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\tinc.howMany = 0;\n\t\t\t\t\t\tinc.offset = 0;\n\t\t\t\t\t} else if ( inc.offset <= old.offset && incEnd >= oldEnd ) {\n\t\t\t\t\t\t// `inc` change includes `old` change.\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinc.howMany = inc.nodesToHandle;\n\t\tdelete inc.nodesToHandle;\n\t}\n\n\t/**\n\t * Returns an object with a single insert change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which the change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getInsertDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'insert',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an object with a single remove change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getRemoveDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'remove',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an array of objects where each one is a single attribute change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range where the change happened.\n\t * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n\t * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n\t * @returns {Array.<Object>} An array containing one or more diff items.\n\t */\n\t_getAttributesDiff( range, oldAttributes, newAttributes ) {\n\t\t// Results holder.\n\t\tconst diffs = [];\n\n\t\t// Clone new attributes as we will be performing changes on this object.\n\t\tnewAttributes = new Map( newAttributes );\n\n\t\t// Look through old attributes.\n\t\tfor ( const [ key, oldValue ] of oldAttributes ) {\n\t\t\t// Check what is the new value of the attribute (or if it was removed).\n\t\t\tconst newValue = newAttributes.has( key ) ? newAttributes.get( key ) : null;\n\n\t\t\t// If values are different (or attribute was removed)...\n\t\t\tif ( newValue !== oldValue ) {\n\t\t\t\t// Add diff item.\n\t\t\t\tdiffs.push( {\n\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\tposition: range.start,\n\t\t\t\t\trange: range.clone(),\n\t\t\t\t\tlength: 1,\n\t\t\t\t\tattributeKey: key,\n\t\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\t\tattributeNewValue: newValue,\n\t\t\t\t\tchangeCount: this._changeCount++\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Prevent returning two diff items for the same change.\n\t\t\tnewAttributes.delete( key );\n\t\t}\n\n\t\t// Look through new attributes that weren't handled above.\n\t\tfor ( const [ key, newValue ] of newAttributes ) {\n\t\t\t// Each of them is a new attribute. Add diff item.\n\t\t\tdiffs.push( {\n\t\t\t\ttype: 'attribute',\n\t\t\t\tposition: range.start,\n\t\t\t\trange: range.clone(),\n\t\t\t\tlength: 1,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: newValue,\n\t\t\t\tchangeCount: this._changeCount++\n\t\t\t} );\n\t\t}\n\n\t\treturn diffs;\n\t}\n\n\t/**\n\t * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element Element to check.\n\t * @returns {Boolean}\n\t */\n\t_isInInsertedElement( element ) {\n\t\tconst parent = element.parent;\n\n\t\tif ( !parent ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst changes = this._changesInElement.get( parent );\n\t\tconst offset = element.startOffset;\n\n\t\tif ( changes ) {\n\t\t\tfor ( const change of changes ) {\n\t\t\t\tif ( change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._isInInsertedElement( parent );\n\t}\n\n\t/**\n\t * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n\t * and `howMany`.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_removeAllNestedChanges( parent, offset, howMany ) {\n\t\tconst range = new Range( Position._createAt( parent, offset ), Position._createAt( parent, offset + howMany ) );\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tthis._elementSnapshots.delete( item );\n\t\t\t\tthis._changesInElement.delete( item );\n\n\t\t\t\tthis._removeAllNestedChanges( item, 0, item.maxOffset );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot( children ) {\n\tconst snapshot = [];\n\n\tfor ( const child of children ) {\n\t\tif ( child.is( '$text' ) ) {\n\t\t\tfor ( let i = 0; i < child.data.length; i++ ) {\n\t\t\t\tsnapshot.push( {\n\t\t\t\t\tname: '$text',\n\t\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\tsnapshot.push( {\n\t\t\t\tname: child.name,\n\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn snapshot;\n}\n\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges( oldChildrenLength, changes ) {\n\tconst actions = [];\n\n\tlet offset = 0;\n\tlet oldChildrenHandled = 0;\n\n\t// Go through all buffered changes.\n\tfor ( const change of changes ) {\n\t\t// First, fill \"holes\" between changes with \"equal\" actions.\n\t\tif ( change.offset > offset ) {\n\t\t\tfor ( let i = 0; i < change.offset - offset; i++ ) {\n\t\t\t\tactions.push( 'e' );\n\t\t\t}\n\n\t\t\toldChildrenHandled += change.offset - offset;\n\t\t}\n\n\t\t// Then, fill up actions accordingly to change type.\n\t\tif ( change.type == 'insert' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'i' );\n\t\t\t}\n\n\t\t\t// The last handled offset is after inserted range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t} else if ( change.type == 'remove' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'r' );\n\t\t\t}\n\n\t\t\t// The last handled offset is at the position where the nodes were removed.\n\t\t\toffset = change.offset;\n\t\t\t// We removed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t} else {\n\t\t\tactions.push( ...'a'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset is at the position after the changed range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t\t// We changed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t}\n\t}\n\n\t// Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n\t// has not been changed / removed at the end of their parent.\n\tif ( oldChildrenHandled < oldChildrenLength ) {\n\t\tfor ( let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++ ) {\n\t\t\tactions.push( 'e' );\n\t\t}\n\t}\n\n\treturn actions;\n}\n\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter( entry ) {\n\tconst posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n\tconst rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n\n\treturn !posInGy && !rangeInGy;\n}\n\n/**\n * The single diff item.\n *\n * Could be one of:\n *\n * * {@link module:engine/model/differ~DiffItemInsert `DiffItemInsert`},\n * * {@link module:engine/model/differ~DiffItemRemove `DiffItemRemove`},\n * * {@link module:engine/model/differ~DiffItemAttribute `DiffItemAttribute`}.\n *\n * @interface DiffItem\n */\n\n/**\n * The single diff item for inserted nodes.\n *\n * @class DiffItemInsert\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'insert'} module:engine/model/differ~DiffItemInsert#type\n */\n\n/**\n * The name of the inserted elements or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemInsert#name\n */\n\n/**\n * The position where the node was inserted.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemInsert#position\n */\n\n/**\n * The length of an inserted text node. For elements it is always 1 as each inserted element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemInsert#length\n */\n\n/**\n * The single diff item for removed nodes.\n *\n * @class DiffItemRemove\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'remove'} module:engine/model/differ~DiffItemRemove#type\n */\n\n/**\n * The name of the removed element or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemRemove#name\n */\n\n/**\n * The position where the node was removed.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemRemove#position\n */\n\n/**\n * The length of a removed text node. For elements it is always 1 as each removed element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemRemove#length\n */\n\n/**\n * The single diff item for attribute change.\n *\n * @class DiffItemAttribute\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */\n"]},"metadata":{},"sourceType":"module"}