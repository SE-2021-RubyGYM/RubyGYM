{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/fakeselectionobserver\n */\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { debounce } from 'lodash-es';\n/**\n * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens\n * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place\n * if arrow keys are pressed.\n * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of\n * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\n\nexport default class FakeSelectionObserver extends Observer {\n  /**\n   * Creates new FakeSelectionObserver instance.\n   *\n   * @param {module:engine/view/view~View} view\n   */\n  constructor(view) {\n    super(view);\n    /**\n     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n     *\n     * @private\n     * @param {Object} data Selection change data.\n     * @method #_fireSelectionChangeDoneDebounced\n     */\n\n    this._fireSelectionChangeDoneDebounced = debounce(data => this.document.fire('selectionChangeDone', data), 200);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  observe() {\n    const document = this.document;\n    document.on('arrowKey', (eventInfo, data) => {\n      const selection = document.selection;\n\n      if (selection.isFake && this.isEnabled) {\n        // Prevents default key down handling - no selection change will occur.\n        data.preventDefault();\n      }\n    }, {\n      context: '$capture'\n    });\n    document.on('arrowKey', (eventInfo, data) => {\n      const selection = document.selection;\n\n      if (selection.isFake && this.isEnabled) {\n        this._handleSelectionMove(data.keyCode);\n      }\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    super.destroy();\n\n    this._fireSelectionChangeDoneDebounced.cancel();\n  }\n  /**\n   * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be\n   * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.\n   *\n   * This method fires {@link module:engine/view/document~Document#event:selectionChange} and\n   * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of\n   * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n   *\n   * @private\n   * @param {Number} keyCode\n   * @fires module:engine/view/document~Document#event:selectionChange\n   * @fires module:engine/view/document~Document#event:selectionChangeDone\n   */\n\n\n  _handleSelectionMove(keyCode) {\n    const selection = this.document.selection;\n    const newSelection = new ViewSelection(selection.getRanges(), {\n      backward: selection.isBackward,\n      fake: false\n    }); // Left or up arrow pressed - move selection to start.\n\n    if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {\n      newSelection.setTo(newSelection.getFirstPosition());\n    } // Right or down arrow pressed - move selection to end.\n\n\n    if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {\n      newSelection.setTo(newSelection.getLastPosition());\n    }\n\n    const data = {\n      oldSelection: selection,\n      newSelection,\n      domSelection: null\n    }; // Fire dummy selection change event.\n\n    this.document.fire('selectionChange', data); // Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n    // This function is debounced what means that `selectionChangeDone` event will be fired only when\n    // defined int the function time will elapse since the last time the function was called.\n    // So `selectionChangeDone` will be fired when selection will stop changing.\n\n    this._fireSelectionChangeDoneDebounced(data);\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/fakeselectionobserver.js"],"names":["Observer","ViewSelection","keyCodes","debounce","FakeSelectionObserver","constructor","view","_fireSelectionChangeDoneDebounced","data","document","fire","observe","on","eventInfo","selection","isFake","isEnabled","preventDefault","context","_handleSelectionMove","keyCode","priority","destroy","cancel","newSelection","getRanges","backward","isBackward","fake","arrowleft","arrowup","setTo","getFirstPosition","arrowright","arrowdown","getLastPosition","oldSelection","domSelection"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/fakeselectionobserver\n */\n\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { debounce } from 'lodash-es';\n\n/**\n * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens\n * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place\n * if arrow keys are pressed.\n * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of\n * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class FakeSelectionObserver extends Observer {\n\t/**\n\t * Creates new FakeSelectionObserver instance.\n\t *\n\t * @param {module:engine/view/view~View} view\n\t */\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n\t\t *\n\t\t * @private\n\t\t * @param {Object} data Selection change data.\n\t\t * @method #_fireSelectionChangeDoneDebounced\n\t\t */\n\t\tthis._fireSelectionChangeDoneDebounced = debounce( data => this.document.fire( 'selectionChangeDone', data ), 200 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve() {\n\t\tconst document = this.document;\n\n\t\tdocument.on( 'arrowKey', ( eventInfo, data ) => {\n\t\t\tconst selection = document.selection;\n\n\t\t\tif ( selection.isFake && this.isEnabled ) {\n\t\t\t\t// Prevents default key down handling - no selection change will occur.\n\t\t\t\tdata.preventDefault();\n\t\t\t}\n\t\t}, { context: '$capture' } );\n\n\t\tdocument.on( 'arrowKey', ( eventInfo, data ) => {\n\t\t\tconst selection = document.selection;\n\n\t\t\tif ( selection.isFake && this.isEnabled ) {\n\t\t\t\tthis._handleSelectionMove( data.keyCode );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._fireSelectionChangeDoneDebounced.cancel();\n\t}\n\n\t/**\n\t * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be\n\t * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.\n\t *\n\t * This method fires {@link module:engine/view/document~Document#event:selectionChange} and\n\t * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of\n\t * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n\t *\n\t * @private\n\t * @param {Number} keyCode\n\t * @fires module:engine/view/document~Document#event:selectionChange\n\t * @fires module:engine/view/document~Document#event:selectionChangeDone\n\t */\n\t_handleSelectionMove( keyCode ) {\n\t\tconst selection = this.document.selection;\n\t\tconst newSelection = new ViewSelection( selection.getRanges(), { backward: selection.isBackward, fake: false } );\n\n\t\t// Left or up arrow pressed - move selection to start.\n\t\tif ( keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup ) {\n\t\t\tnewSelection.setTo( newSelection.getFirstPosition() );\n\t\t}\n\n\t\t// Right or down arrow pressed - move selection to end.\n\t\tif ( keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown ) {\n\t\t\tnewSelection.setTo( newSelection.getLastPosition() );\n\t\t}\n\n\t\tconst data = {\n\t\t\toldSelection: selection,\n\t\t\tnewSelection,\n\t\t\tdomSelection: null\n\t\t};\n\n\t\t// Fire dummy selection change event.\n\t\tthis.document.fire( 'selectionChange', data );\n\n\t\t// Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n\t\t// This function is debounced what means that `selectionChangeDone` event will be fired only when\n\t\t// defined int the function time will elapse since the last time the function was called.\n\t\t// So `selectionChangeDone` will be fired when selection will stop changing.\n\t\tthis._fireSelectionChangeDoneDebounced( data );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}