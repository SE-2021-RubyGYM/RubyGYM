{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/writer\n */\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MoveOperation from './operation/moveoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\nimport SplitOperation from './operation/splitoperation';\nimport MergeOperation from './operation/mergeoperation';\nimport DocumentFragment from './documentfragment';\nimport Text from './text';\nimport Element from './element';\nimport RootElement from './rootelement';\nimport Position from './position';\nimport Range from './range.js';\nimport DocumentSelection from './documentselection';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\n\nexport default class Writer {\n  /**\n   * Creates a writer instance.\n   *\n   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n   *\n   * @protected\n   * @param {module:engine/model/model~Model} model\n   * @param {module:engine/model/batch~Batch} batch\n   */\n  constructor(model, batch) {\n    /**\n     * Instance of the model on which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The batch to which this writer will add changes.\n     *\n     * @readonly\n     * @type {module:engine/model/batch~Batch}\n     */\n\n    this.batch = batch;\n  }\n  /**\n   * Creates a new {@link module:engine/model/text~Text text node}.\n   *\n   *\t\twriter.createText( 'foo' );\n   *\t\twriter.createText( 'foo', { bold: true } );\n   *\n   * @param {String} data Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @returns {module:engine/model/text~Text} Created text node.\n   */\n\n\n  createText(data, attributes) {\n    return new Text(data, attributes);\n  }\n  /**\n   * Creates a new {@link module:engine/model/element~Element element}.\n   *\n   *\t\twriter.createElement( 'paragraph' );\n   *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @returns {module:engine/model/element~Element} Created element.\n   */\n\n\n  createElement(name, attributes) {\n    return new Element(name, attributes);\n  }\n  /**\n   * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n   *\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n   */\n\n\n  createDocumentFragment() {\n    return new DocumentFragment();\n  }\n  /**\n   * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.\n   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n   *\n   * @param {module:engine/model/element~Element} element The element to clone.\n   * @param {Boolean} [deep=true] If set to `true` clones element and all its children recursively. When set to `false`,\n   * element will be cloned without any child.\n   */\n\n\n  cloneElement(element) {\n    let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return element._clone(deep);\n  }\n  /**\n   * Inserts item on given position.\n   *\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\twriter.insert( paragraph, position );\n   *\n   * Instead of using position you can use parent and offset:\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\twriter.insert( text, paragraph, 5 );\n   *\n   * You can also use `end` instead of the offset to insert at the end:\n   *\n   *\t\tconst text = writer.createText( 'foo' );\n   *\t\twriter.insert( text, paragraph, 'end' );\n   *\n   * Or insert before or after another element:\n   *\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n   *\n   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * Note that if the item already has parent it will be removed from the previous parent.\n   *\n   * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n   * `model-writer-insert-forbidden-move` is thrown.\n   *\n   * If you want to move {@link module:engine/model/range~Range range} instead of an\n   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n   *\n   * **Note:** For a paste-like content insertion mechanism see\n   * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n   * fragment to insert.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * second parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  insert(item, itemOrPosition) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    this._assertWriterUsedCorrectly();\n\n    if (item instanceof Text && item.data == '') {\n      return;\n    }\n\n    const position = Position._createAt(itemOrPosition, offset); // If item has a parent already.\n\n\n    if (item.parent) {\n      // We need to check if item is going to be inserted within the same document.\n      if (isSameTree(item.root, position.root)) {\n        // If it's we just need to move it.\n        this.move(Range._createOn(item), position);\n        return;\n      } // If it isn't the same root.\n      else {\n        if (item.root.document) {\n          /**\n           * Cannot move a node from a document to a different tree.\n           * It is forbidden to move a node that was already in a document outside of it.\n           *\n           * @error model-writer-insert-forbidden-move\n           */\n          throw new CKEditorError('model-writer-insert-forbidden-move', this);\n        } else {\n          // Move between two different document fragments or from document fragment to a document is possible.\n          // In that case, remove the item from it's original parent.\n          this.remove(item);\n        }\n      }\n    }\n\n    const version = position.root.document ? position.root.document.version : null;\n    const insert = new InsertOperation(position, item, version);\n\n    if (item instanceof Text) {\n      insert.shouldReceiveAttributes = true;\n    }\n\n    this.batch.addOperation(insert);\n    this.model.applyOperation(insert); // When element is a DocumentFragment we need to move its markers to Document#markers.\n\n    if (item instanceof DocumentFragment) {\n      for (const [markerName, markerRange] of item.markers) {\n        // We need to migrate marker range from DocumentFragment to Document.\n        const rangeRootPosition = Position._createAt(markerRange.root, 0);\n\n        const range = new Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));\n        const options = {\n          range,\n          usingOperation: true,\n          affectsData: true\n        };\n\n        if (this.model.markers.has(markerName)) {\n          this.updateMarker(markerName, options);\n        } else {\n          this.addMarker(markerName, options);\n        }\n      }\n    }\n  }\n  /**\n   * Creates and inserts text on given position. You can optionally set text attributes:\n   *\n   *\t\twriter.insertText( 'foo', position );\n   *\t\twriter.insertText( 'foo', { bold: true }, position );\n   *\n   * Instead of using position you can use parent and offset or define that text should be inserted at the end\n   * or before or after other node:\n   *\n   *\t\t// Inserts 'foo' in paragraph, at offset 5:\n   *\t\twriter.insertText( 'foo', paragraph, 5 );\n   *\t\t// Inserts 'foo' at the end of a paragraph:\n   *\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t// Inserts 'foo' after an image:\n   *\t\twriter.insertText( 'foo', image, 'after' );\n   *\n   * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * @param {String} data Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * third parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  insertText(text, attributes, itemOrPosition, offset) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n      this.insert(this.createText(text), attributes, itemOrPosition);\n    } else {\n      this.insert(this.createText(text, attributes), itemOrPosition, offset);\n    }\n  }\n  /**\n   * Creates and inserts element on given position. You can optionally set attributes:\n   *\n   *\t\twriter.insertElement( 'paragraph', position );\n   *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n   *\n   * Instead of using position you can use parent and offset or define that text should be inserted at the end\n   * or before or after other node:\n   *\n   *\t\t// Inserts paragraph in the root at offset 5:\n   *\t\twriter.insertElement( 'paragraph', root, 5 );\n   *\t\t// Inserts paragraph at the end of a blockquote:\n   *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n   *\t\t// Inserts after an image:\n   *\t\twriter.insertElement( 'paragraph', image, 'after' );\n   *\n   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * third parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  insertElement(name, attributes, itemOrPosition, offset) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n      this.insert(this.createElement(name), attributes, itemOrPosition);\n    } else {\n      this.insert(this.createElement(name, attributes), itemOrPosition, offset);\n    }\n  }\n  /**\n   * Inserts item at the end of the given parent.\n   *\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\twriter.append( paragraph, root );\n   *\n   * Note that if the item already has parent it will be removed from the previous parent.\n   *\n   * If you want to move {@link module:engine/model/range~Range range} instead of an\n   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n   * item Item or document fragment to insert.\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n   */\n\n\n  append(item, parent) {\n    this.insert(item, parent, 'end');\n  }\n  /**\n   * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n   *\n   *\t\twriter.appendText( 'foo', paragraph );\n   *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n   *\n   * @param {String} text Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n   */\n\n\n  appendText(text, attributes, parent) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n      this.insert(this.createText(text), attributes, 'end');\n    } else {\n      this.insert(this.createText(text, attributes), parent, 'end');\n    }\n  }\n  /**\n   * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n   *\n   *\t\twriter.appendElement( 'paragraph', root );\n   *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n   */\n\n\n  appendElement(name, attributes, parent) {\n    if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n      this.insert(this.createElement(name), attributes, 'end');\n    } else {\n      this.insert(this.createElement(name, attributes), parent, 'end');\n    }\n  }\n  /**\n   * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n   * or on a {@link module:engine/model/range~Range range}.\n   *\n   * @param {String} key Attribute key.\n   * @param {*} value Attribute new value.\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range on which the attribute will be set.\n   */\n\n\n  setAttribute(key, value, itemOrRange) {\n    this._assertWriterUsedCorrectly();\n\n    if (itemOrRange instanceof Range) {\n      const ranges = itemOrRange.getMinimalFlatRanges();\n\n      for (const range of ranges) {\n        setAttributeOnRange(this, key, value, range);\n      }\n    } else {\n      setAttributeOnItem(this, key, value, itemOrRange);\n    }\n  }\n  /**\n   * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n   * or on a {@link module:engine/model/range~Range range}.\n   *\n   *\t\twriter.setAttributes( {\n   *\t\t\tbold: true,\n   *\t\t\titalic: true\n   *\t\t}, range );\n   *\n   * @param {Object} attributes Attributes keys and values.\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range on which the attributes will be set.\n   */\n\n\n  setAttributes(attributes, itemOrRange) {\n    for (const [key, val] of toMap(attributes)) {\n      this.setAttribute(key, val, itemOrRange);\n    }\n  }\n  /**\n   * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n   * or from a {@link module:engine/model/range~Range range}.\n   *\n   * @param {String} key Attribute key.\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range from which the attribute will be removed.\n   */\n\n\n  removeAttribute(key, itemOrRange) {\n    this._assertWriterUsedCorrectly();\n\n    if (itemOrRange instanceof Range) {\n      const ranges = itemOrRange.getMinimalFlatRanges();\n\n      for (const range of ranges) {\n        setAttributeOnRange(this, key, null, range);\n      }\n    } else {\n      setAttributeOnItem(this, key, null, itemOrRange);\n    }\n  }\n  /**\n   * Removes all attributes from all elements in the range or from the given item.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n   * Model item or range from which all attributes will be removed.\n   */\n\n\n  clearAttributes(itemOrRange) {\n    this._assertWriterUsedCorrectly();\n\n    const removeAttributesFromItem = item => {\n      for (const attribute of item.getAttributeKeys()) {\n        this.removeAttribute(attribute, item);\n      }\n    };\n\n    if (!(itemOrRange instanceof Range)) {\n      removeAttributesFromItem(itemOrRange);\n    } else {\n      for (const item of itemOrRange.getItems()) {\n        removeAttributesFromItem(item);\n      }\n    }\n  }\n  /**\n   * Moves all items in the source range to the target position.\n   *\n   *\t\twriter.move( sourceRange, targetPosition );\n   *\n   * Instead of the target position you can use parent and offset or define that range should be moved to the end\n   * or before or after chosen item:\n   *\n   *\t\t// Moves all items in the range to the paragraph at offset 5:\n   *\t\twriter.move( sourceRange, paragraph, 5 );\n   *\t\t// Moves all items in the range to the end of a blockquote:\n   *\t\twriter.move( sourceRange, blockquote, 'end' );\n   *\t\t// Moves all items in the range to a position after an image:\n   *\t\twriter.move( sourceRange, image, 'after' );\n   *\n   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n   *\n   * Note that items can be moved only within the same tree. It means that you can move items within the same root\n   * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n   * but you can not move items from document fragment to the document or from one detached element to another. Use\n   * {@link module:engine/model/writer~Writer#insert} in such cases.\n   *\n   * @param {module:engine/model/range~Range} range Source range.\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * second parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  move(range, itemOrPosition, offset) {\n    this._assertWriterUsedCorrectly();\n\n    if (!(range instanceof Range)) {\n      /**\n       * Invalid range to move.\n       *\n       * @error writer-move-invalid-range\n       */\n      throw new CKEditorError('writer-move-invalid-range', this);\n    }\n\n    if (!range.isFlat) {\n      /**\n       * Range to move is not flat.\n       *\n       * @error writer-move-range-not-flat\n       */\n      throw new CKEditorError('writer-move-range-not-flat', this);\n    }\n\n    const position = Position._createAt(itemOrPosition, offset); // Do not move anything if the move target is same as moved range start.\n\n\n    if (position.isEqual(range.start)) {\n      return;\n    } // If part of the marker is removed, create additional marker operation for undo purposes.\n\n\n    this._addOperationForAffectedMarkers('move', range);\n\n    if (!isSameTree(range.root, position.root)) {\n      /**\n       * Range is going to be moved within not the same document. Please use\n       * {@link module:engine/model/writer~Writer#insert insert} instead.\n       *\n       * @error writer-move-different-document\n       */\n      throw new CKEditorError('writer-move-different-document', this);\n    }\n\n    const version = range.root.document ? range.root.document.version : null;\n    const operation = new MoveOperation(range.start, range.end.offset - range.start.offset, position, version);\n    this.batch.addOperation(operation);\n    this.model.applyOperation(operation);\n  }\n  /**\n   * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n   */\n\n\n  remove(itemOrRange) {\n    this._assertWriterUsedCorrectly();\n\n    const rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn(itemOrRange);\n    const ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n\n    for (const flat of ranges) {\n      // If part of the marker is removed, create additional marker operation for undo purposes.\n      this._addOperationForAffectedMarkers('move', flat);\n\n      applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);\n    }\n  }\n  /**\n   * Merges two siblings at the given position.\n   *\n   * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n   * `writer-merge-no-element-after` error will be thrown.\n   *\n   * @param {module:engine/model/position~Position} position Position between merged elements.\n   */\n\n\n  merge(position) {\n    this._assertWriterUsedCorrectly();\n\n    const nodeBefore = position.nodeBefore;\n    const nodeAfter = position.nodeAfter; // If part of the marker is removed, create additional marker operation for undo purposes.\n\n    this._addOperationForAffectedMarkers('merge', position);\n\n    if (!(nodeBefore instanceof Element)) {\n      /**\n       * Node before merge position must be an element.\n       *\n       * @error writer-merge-no-element-before\n       */\n      throw new CKEditorError('writer-merge-no-element-before', this);\n    }\n\n    if (!(nodeAfter instanceof Element)) {\n      /**\n       * Node after merge position must be an element.\n       *\n       * @error writer-merge-no-element-after\n       */\n      throw new CKEditorError('writer-merge-no-element-after', this);\n    }\n\n    if (!position.root.document) {\n      this._mergeDetached(position);\n    } else {\n      this._merge(position);\n    }\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  createPositionFromPath(root, path, stickiness) {\n    return this.model.createPositionFromPath(root, path, stickiness);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  createPositionAt(itemOrPosition, offset) {\n    return this.model.createPositionAt(itemOrPosition, offset);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  createPositionAfter(item) {\n    return this.model.createPositionAfter(item);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  createPositionBefore(item) {\n    return this.model.createPositionBefore(item);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n   *\n   * @param {module:engine/model/position~Position} start Start position.\n   * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  createRange(start, end) {\n    return this.model.createRange(start, end);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n   *\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  createRangeIn(element) {\n    return this.model.createRangeIn(element);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n   *\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  createRangeOn(element) {\n    return this.model.createRangeOn(element);\n  }\n  /**\n   * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @returns {module:engine/model/selection~Selection}\n   */\n\n\n  createSelection(selectable, placeOrOffset, options) {\n    return this.model.createSelection(selectable, placeOrOffset, options);\n  }\n  /**\n   * Performs merge action in a detached tree.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position Position between merged elements.\n   */\n\n\n  _mergeDetached(position) {\n    const nodeBefore = position.nodeBefore;\n    const nodeAfter = position.nodeAfter;\n    this.move(Range._createIn(nodeAfter), Position._createAt(nodeBefore, 'end'));\n    this.remove(nodeAfter);\n  }\n  /**\n   * Performs merge action in a non-detached tree.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position Position between merged elements.\n   */\n\n\n  _merge(position) {\n    const targetPosition = Position._createAt(position.nodeBefore, 'end');\n\n    const sourcePosition = Position._createAt(position.nodeAfter, 0);\n\n    const graveyard = position.root.document.graveyard;\n    const graveyardPosition = new Position(graveyard, [0]);\n    const version = position.root.document.version;\n    const merge = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version);\n    this.batch.addOperation(merge);\n    this.model.applyOperation(merge);\n  }\n  /**\n   * Renames the given element.\n   *\n   * @param {module:engine/model/element~Element} element The element to rename.\n   * @param {String} newName New element name.\n   */\n\n\n  rename(element, newName) {\n    this._assertWriterUsedCorrectly();\n\n    if (!(element instanceof Element)) {\n      /**\n       * Trying to rename an object which is not an instance of Element.\n       *\n       * @error writer-rename-not-element-instance\n       */\n      throw new CKEditorError('writer-rename-not-element-instance', this);\n    }\n\n    const version = element.root.document ? element.root.document.version : null;\n    const renameOperation = new RenameOperation(Position._createBefore(element), element.name, newName, version);\n    this.batch.addOperation(renameOperation);\n    this.model.applyOperation(renameOperation);\n  }\n  /**\n   * Splits elements starting from the given position and going to the top of the model tree as long as given\n   * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n   *\n   * The element needs to have a parent. It cannot be a root element nor a document fragment.\n   * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n   *\n   * @param {module:engine/model/position~Position} position Position of split.\n   * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n   * @returns {Object} result Split result.\n   * @returns {module:engine/model/position~Position} result.position Position between split elements.\n   * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n   * at the beginning of the first copy element.\n   */\n\n\n  split(position, limitElement) {\n    this._assertWriterUsedCorrectly();\n\n    let splitElement = position.parent;\n\n    if (!splitElement.parent) {\n      /**\n       * Element with no parent can not be split.\n       *\n       * @error writer-split-element-no-parent\n       */\n      throw new CKEditorError('writer-split-element-no-parent', this);\n    } // When limit element is not defined lets set splitElement parent as limit.\n\n\n    if (!limitElement) {\n      limitElement = splitElement.parent;\n    }\n\n    if (!position.parent.getAncestors({\n      includeSelf: true\n    }).includes(limitElement)) {\n      /**\n       * Limit element is not a position ancestor.\n       *\n       * @error writer-split-invalid-limit-element\n       */\n      throw new CKEditorError('writer-split-invalid-limit-element', this);\n    } // We need to cache elements that will be created as a result of the first split because\n    // we need to create a range from the end of the first split element to the beginning of the\n    // first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n\n\n    let firstSplitElement, firstCopyElement;\n\n    do {\n      const version = splitElement.root.document ? splitElement.root.document.version : null;\n      const howMany = splitElement.maxOffset - position.offset;\n      const insertionPosition = SplitOperation.getInsertionPosition(position);\n      const split = new SplitOperation(position, howMany, insertionPosition, null, version);\n      this.batch.addOperation(split);\n      this.model.applyOperation(split); // Cache result of the first split.\n\n      if (!firstSplitElement && !firstCopyElement) {\n        firstSplitElement = splitElement;\n        firstCopyElement = position.parent.nextSibling;\n      }\n\n      position = this.createPositionAfter(position.parent);\n      splitElement = position.parent;\n    } while (splitElement !== limitElement);\n\n    return {\n      position,\n      range: new Range(Position._createAt(firstSplitElement, 'end'), Position._createAt(firstCopyElement, 0))\n    };\n  }\n  /**\n   * Wraps the given range with the given element or with a new element (if a string was passed).\n   *\n   * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n   * If not, an error will be thrown.\n   *\n   * @param {module:engine/model/range~Range} range Range to wrap.\n   * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n   */\n\n\n  wrap(range, elementOrString) {\n    this._assertWriterUsedCorrectly();\n\n    if (!range.isFlat) {\n      /**\n       * Range to wrap is not flat.\n       *\n       * @error writer-wrap-range-not-flat\n       */\n      throw new CKEditorError('writer-wrap-range-not-flat', this);\n    }\n\n    const element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);\n\n    if (element.childCount > 0) {\n      /**\n       * Element to wrap with is not empty.\n       *\n       * @error writer-wrap-element-not-empty\n       */\n      throw new CKEditorError('writer-wrap-element-not-empty', this);\n    }\n\n    if (element.parent !== null) {\n      /**\n       * Element to wrap with is already attached to a tree model.\n       *\n       * @error writer-wrap-element-attached\n       */\n      throw new CKEditorError('writer-wrap-element-attached', this);\n    }\n\n    this.insert(element, range.start); // Shift the range-to-wrap because we just inserted an element before that range.\n\n    const shiftedRange = new Range(range.start.getShiftedBy(1), range.end.getShiftedBy(1));\n    this.move(shiftedRange, Position._createAt(element, 0));\n  }\n  /**\n   * Unwraps children of the given element – all its children are moved before it and then the element is removed.\n   * Throws error if you try to unwrap an element which does not have a parent.\n   *\n   * @param {module:engine/model/element~Element} element Element to unwrap.\n   */\n\n\n  unwrap(element) {\n    this._assertWriterUsedCorrectly();\n\n    if (element.parent === null) {\n      /**\n       * Trying to unwrap an element which has no parent.\n       *\n       * @error writer-unwrap-element-no-parent\n       */\n      throw new CKEditorError('writer-unwrap-element-no-parent', this);\n    }\n\n    this.move(Range._createIn(element), this.createPositionAfter(element));\n    this.remove(element);\n  }\n  /**\n   * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n   * changes in the document and updates its range automatically, when model tree changes.\n   *\n   * As the first parameter you can set marker name.\n   *\n   * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n   * markers managed by operations and not-managed by operations.\n   *\n   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n   * `true` when the marker change changes the data returned by the\n   * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n   *\n   * Create marker directly base on marker's name:\n   *\n   *\t\taddMarker( markerName, { range, usingOperation: false } );\n   *\n   * Create marker using operation:\n   *\n   *\t\taddMarker( markerName, { range, usingOperation: true } );\n   *\n   * Create marker that affects the editor data:\n   *\n   *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n   *\n   * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n   *\n   * @see module:engine/model/markercollection~Marker\n   * @param {String} name Name of a marker to create - must be unique.\n   * @param {Object} options\n   * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n   * @param {module:engine/model/range~Range} options.range Marker range.\n   * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n   * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n   */\n\n\n  addMarker(name, options) {\n    this._assertWriterUsedCorrectly();\n\n    if (!options || typeof options.usingOperation != 'boolean') {\n      /**\n       * The `options.usingOperation` parameter is required when adding a new marker.\n       *\n       * @error writer-addmarker-no-usingoperation\n       */\n      throw new CKEditorError('writer-addmarker-no-usingoperation', this);\n    }\n\n    const usingOperation = options.usingOperation;\n    const range = options.range;\n    const affectsData = options.affectsData === undefined ? false : options.affectsData;\n\n    if (this.model.markers.has(name)) {\n      /**\n       * Marker with provided name already exists.\n       *\n       * @error writer-addmarker-marker-exists\n       */\n      throw new CKEditorError('writer-addmarker-marker-exists', this);\n    }\n\n    if (!range) {\n      /**\n       * Range parameter is required when adding a new marker.\n       *\n       * @error writer-addmarker-no-range\n       */\n      throw new CKEditorError('writer-addmarker-no-range', this);\n    }\n\n    if (!usingOperation) {\n      return this.model.markers._set(name, range, usingOperation, affectsData);\n    }\n\n    applyMarkerOperation(this, name, null, range, affectsData);\n    return this.model.markers.get(name);\n  }\n  /**\n   * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n   * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n   * marker's range directly using this method.\n   *\n   * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n   * name is created and returned.\n   *\n   * As the second parameter you can set the new marker data or leave this parameter as empty which will just refresh\n   * the marker by triggering downcast conversion for it. Refreshing the marker is useful when you want to change\n   * the marker {@link module:engine/view/element~Element view element} without changing any marker data.\n   *\n   * \t\tlet isCommentActive = false;\n   *\n   * \t\tmodel.conversion.markerToHighlight( {\n   * \t\t\tmodel: 'comment',\n   *\t\t\tview: data => {\n   *\t\t\t\tconst classes = [ 'comment-marker' ];\n   *\n   *\t\t\t\tif ( isCommentActive ) {\n   *\t\t\t\t\tclasses.push( 'comment-marker--active' );\n   *\t\t\t\t}\n   *\n   *\t\t\t\treturn { classes };\n   *\t\t\t}\n   * \t\t} );\n   *\n   * \t\t// Change the property that indicates if marker is displayed as active or not.\n   * \t\tisCommentActive = true;\n   *\n   * \t\t// And refresh the marker to convert it with additional class.\n   * \t\tmodel.change( writer => writer.updateMarker( 'comment' ) );\n   *\n   * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n   * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n   *\n   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n   * `true` when the marker change changes the data returned by\n   * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n   *\n   * Update marker directly base on marker's name:\n   *\n   *\t\tupdateMarker( markerName, { range } );\n   *\n   * Update marker using operation:\n   *\n   *\t\tupdateMarker( marker, { range, usingOperation: true } );\n   *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n   *\n   * Change marker's option (start using operations to manage it):\n   *\n   *\t\tupdateMarker( marker, { usingOperation: true } );\n   *\n   * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n   *\n   *\t\tupdateMarker( markerName, { affectsData: false } );\n   *\n   * @see module:engine/model/markercollection~Marker\n   * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n   * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n   * downcast conversion for this marker with the same data.\n   * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n   * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n   * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n   */\n\n\n  updateMarker(markerOrName, options) {\n    this._assertWriterUsedCorrectly();\n\n    const markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n    const currentMarker = this.model.markers.get(markerName);\n\n    if (!currentMarker) {\n      /**\n       * Marker with provided name does not exists.\n       *\n       * @error writer-updatemarker-marker-not-exists\n       */\n      throw new CKEditorError('writer-updatemarker-marker-not-exists', this);\n    }\n\n    if (!options) {\n      this.model.markers._refresh(currentMarker);\n\n      return;\n    }\n\n    const hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n    const affectsDataDefined = typeof options.affectsData == 'boolean'; // Use previously defined marker's affectsData if the property is not provided.\n\n    const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n\n    if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {\n      /**\n       * One of the options is required - provide range, usingOperations or affectsData.\n       *\n       * @error writer-updatemarker-wrong-options\n       */\n      throw new CKEditorError('writer-updatemarker-wrong-options', this);\n    }\n\n    const currentRange = currentMarker.getRange();\n    const updatedRange = options.range ? options.range : currentRange;\n\n    if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {\n      // The marker type is changed so it's necessary to create proper operations.\n      if (options.usingOperation) {\n        // If marker changes to a managed one treat this as synchronizing existing marker.\n        // Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n        applyMarkerOperation(this, markerName, null, updatedRange, affectsData);\n      } else {\n        // If marker changes to a marker that do not use operations then we need to create additional operation\n        // that removes that marker first.\n        applyMarkerOperation(this, markerName, currentRange, null, affectsData); // Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n\n        this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n      }\n\n      return;\n    } // Marker's type doesn't change so update it accordingly.\n\n\n    if (currentMarker.managedUsingOperations) {\n      applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);\n    } else {\n      this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n    }\n  }\n  /**\n   * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n   * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n   * it will be destroyed using operation.\n   *\n   * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n   */\n\n\n  removeMarker(markerOrName) {\n    this._assertWriterUsedCorrectly();\n\n    const name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\n    if (!this.model.markers.has(name)) {\n      /**\n       * Trying to remove marker which does not exist.\n       *\n       * @error writer-removemarker-no-marker\n       */\n      throw new CKEditorError('writer-removemarker-no-marker', this);\n    }\n\n    const marker = this.model.markers.get(name);\n\n    if (!marker.managedUsingOperations) {\n      this.model.markers._remove(name);\n\n      return;\n    }\n\n    const oldRange = marker.getRange();\n    applyMarkerOperation(this, name, oldRange, null, marker.affectsData);\n  }\n  /**\n   * Sets the document's selection (ranges and direction) to the specified location based on the given\n   * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\twriter.setSelection( ranges );\n   *\n   *\t\t// Sets selection to other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\twriter.setSelection( otherSelection );\n   *\n   *\t\t// Sets selection to the given document selection.\n   *\t\tconst documentSelection = model.document.selection;\n   *\t\twriter.setSelection( documentSelection );\n   *\n   *\t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPosition( root, path );\n   *\t\twriter.setSelection( position );\n   *\n   *\t\t// Sets collapsed selection at the position of the given node and an offset.\n   *\t\twriter.setSelection( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n  \t * that element and ends after the last child of that element.\n   *\n   *\t\twriter.setSelection( paragraph, 'in' );\n   *\n   * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\twriter.setSelection( paragraph, 'on' );\n   *\n   *\t\t// Removes all selection's ranges.\n   *\t\twriter.setSelection( null );\n   *\n   * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\twriter.setSelection( range, { backward: true } );\n   *\n   * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n\n\n  setSelection(selectable, placeOrOffset, options) {\n    this._assertWriterUsedCorrectly();\n\n    this.model.document.selection._setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n   *\n   * The location can be specified in the same form as\n   * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  setSelectionFocus(itemOrPosition, offset) {\n    this._assertWriterUsedCorrectly();\n\n    this.model.document.selection._setFocus(itemOrPosition, offset);\n  }\n  /**\n   * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n   *\n   * Using key and value pair:\n   *\n   * \twriter.setSelectionAttribute( 'italic', true );\n   *\n   * Using key-value object:\n   *\n   * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n   *\n   * Using iterable object:\n   *\n   * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n   *\n   * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n   * or object / iterable of key => value attribute pairs.\n   * @param {*} [value] Attribute value.\n   */\n\n\n  setSelectionAttribute(keyOrObjectOrIterable, value) {\n    this._assertWriterUsedCorrectly();\n\n    if (typeof keyOrObjectOrIterable === 'string') {\n      this._setSelectionAttribute(keyOrObjectOrIterable, value);\n    } else {\n      for (const [key, value] of toMap(keyOrObjectOrIterable)) {\n        this._setSelectionAttribute(key, value);\n      }\n    }\n  }\n  /**\n   * Removes attribute(s) with given key(s) from the selection.\n   *\n   * Remove one attribute:\n   *\n   *\t\twriter.removeSelectionAttribute( 'italic' );\n   *\n   * Remove multiple attributes:\n   *\n   *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n   *\n   * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n   */\n\n\n  removeSelectionAttribute(keyOrIterableOfKeys) {\n    this._assertWriterUsedCorrectly();\n\n    if (typeof keyOrIterableOfKeys === 'string') {\n      this._removeSelectionAttribute(keyOrIterableOfKeys);\n    } else {\n      for (const key of keyOrIterableOfKeys) {\n        this._removeSelectionAttribute(key);\n      }\n    }\n  }\n  /**\n   * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n   * of the selection from left to right.\n   *\n   * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n   * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n   * This method allows to temporarily override this behavior by forcing the gravity to the right.\n   *\n   * For the following model fragment:\n   *\n   *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n   *\n   * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n   * * Overridden gravity: selection will have `bold` attribute.\n   *\n   * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n   * of the process.\n   *\n   * @returns {String} The unique id which allows restoring the gravity.\n   */\n\n\n  overrideSelectionGravity() {\n    return this.model.document.selection._overrideGravity();\n  }\n  /**\n   * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n   *\n   * Restoring the gravity is only possible using the unique identifier returned by\n   * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n   * the same number of times it was overridden.\n   *\n   * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n   */\n\n\n  restoreSelectionGravity(uid) {\n    this.model.document.selection._restoreGravity(uid);\n  }\n  /**\n   * @private\n   * @param {String} key Key of the attribute to remove.\n   * @param {*} value Attribute value.\n   */\n\n\n  _setSelectionAttribute(key, value) {\n    const selection = this.model.document.selection; // Store attribute in parent element if the selection is collapsed in an empty node.\n\n    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n      const storeKey = DocumentSelection._getStoreAttributeKey(key);\n\n      this.setAttribute(storeKey, value, selection.anchor.parent);\n    }\n\n    selection._setAttribute(key, value);\n  }\n  /**\n   * @private\n   * @param {String} key Key of the attribute to remove.\n   */\n\n\n  _removeSelectionAttribute(key) {\n    const selection = this.model.document.selection; // Remove stored attribute from parent element if the selection is collapsed in an empty node.\n\n    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n      const storeKey = DocumentSelection._getStoreAttributeKey(key);\n\n      this.removeAttribute(storeKey, selection.anchor.parent);\n    }\n\n    selection._removeAttribute(key);\n  }\n  /**\n   * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n   *\n   * @private\n   */\n\n\n  _assertWriterUsedCorrectly() {\n    /**\n     * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or\n     * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n     *\n     * The writer can only be used inside these blocks which ensures that the model\n     * can only be changed during such \"sessions\".\n     *\n     * @error writer-incorrect-use\n     */\n    if (this.model._currentWriter !== this) {\n      throw new CKEditorError('writer-incorrect-use', this);\n    }\n  }\n  /**\n   * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n   * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n   * can be later correctly processed during undo.\n   *\n   * @private\n   * @param {'move'|'merge'} type Writer action type.\n   * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n   * where the writer action happens.\n   */\n\n\n  _addOperationForAffectedMarkers(type, positionOrRange) {\n    for (const marker of this.model.markers) {\n      if (!marker.managedUsingOperations) {\n        continue;\n      }\n\n      const markerRange = marker.getRange();\n      let isAffected = false;\n\n      if (type === 'move') {\n        isAffected = positionOrRange.containsPosition(markerRange.start) || positionOrRange.start.isEqual(markerRange.start) || positionOrRange.containsPosition(markerRange.end) || positionOrRange.end.isEqual(markerRange.end);\n      } else {\n        // if type === 'merge'.\n        const elementBefore = positionOrRange.nodeBefore;\n        const elementAfter = positionOrRange.nodeAfter; //               Start:  <p>Foo[</p><p>Bar]</p>\n        //         After merge:  <p>Foo[Bar]</p>\n        // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n        //\n\n        const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd; //               Start:  <p>[Foo</p><p>]Bar</p>\n        //         After merge:  <p>[Foo]Bar</p>\n        // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n        //\n\n        const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0; //               Start:  <p>[Foo</p>]<p>Bar</p>\n        //         After merge:  <p>[Foo]Bar</p>\n        // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n        //\n\n        const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter; //               Start:  <p>Foo</p>[<p>Bar]</p>\n        //         After merge:  <p>Foo[Bar]</p>\n        // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n        //\n\n        const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n        isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n      }\n\n      if (isAffected) {\n        this.updateMarker(marker.name, {\n          range: markerRange\n        });\n      }\n    }\n  }\n\n} // Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\n\nfunction setAttributeOnRange(writer, key, value, range) {\n  const model = writer.model;\n  const doc = model.document; // Position of the last split, the beginning of the new range.\n\n  let lastSplitPosition = range.start; // Currently position in the scanning range. Because we need value after the position, it is not a current\n  // position of the iterator but the previous one (we need to iterate one more time to get the value after).\n\n  let position; // Value before the currently position.\n\n  let valueBefore; // Value after the currently position.\n\n  let valueAfter;\n\n  for (const val of range.getWalker({\n    shallow: true\n  })) {\n    valueAfter = val.item.getAttribute(key); // At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n    // because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n\n    if (position && valueBefore != valueAfter) {\n      // if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n      if (valueBefore != value) {\n        addOperation();\n      }\n\n      lastSplitPosition = position;\n    }\n\n    position = val.nextPosition;\n    valueBefore = valueAfter;\n  } // Because position in the loop is not the iterator position (see let position comment), the last position in\n  // the while loop will be last but one position in the range. We need to check the last position manually.\n\n\n  if (position instanceof Position && position != lastSplitPosition && valueBefore != value) {\n    addOperation();\n  }\n\n  function addOperation() {\n    const range = new Range(lastSplitPosition, position);\n    const version = range.root.document ? doc.version : null;\n    const operation = new AttributeOperation(range, key, valueBefore, value, version);\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n} // Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\n\n\nfunction setAttributeOnItem(writer, key, value, item) {\n  const model = writer.model;\n  const doc = model.document;\n  const previousValue = item.getAttribute(key);\n  let range, operation;\n\n  if (previousValue != value) {\n    const isRootChanged = item.root === item;\n\n    if (isRootChanged) {\n      // If we change attributes of root element, we have to use `RootAttributeOperation`.\n      const version = item.document ? doc.version : null;\n      operation = new RootAttributeOperation(item, key, previousValue, value, version);\n    } else {\n      range = new Range(Position._createBefore(item), writer.createPositionAfter(item));\n      const version = range.root.document ? doc.version : null;\n      operation = new AttributeOperation(range, key, previousValue, value, version);\n    }\n\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n} // Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\n\n\nfunction applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {\n  const model = writer.model;\n  const doc = model.document;\n  const operation = new MarkerOperation(name, oldRange, newRange, model.markers, affectsData, doc.version);\n  writer.batch.addOperation(operation);\n  model.applyOperation(operation);\n} // Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\n\n\nfunction applyRemoveOperation(position, howMany, batch, model) {\n  let operation;\n\n  if (position.root.document) {\n    const doc = model.document;\n    const graveyardPosition = new Position(doc.graveyard, [0]);\n    operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);\n  } else {\n    operation = new DetachOperation(position, howMany);\n  }\n\n  batch.addOperation(operation);\n  model.applyOperation(operation);\n} // Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\n\n\nfunction isSameTree(rootA, rootB) {\n  // If it is the same root this is the same tree.\n  if (rootA === rootB) {\n    return true;\n  } // If both roots are documents root it is operation within the document what we still treat as the same tree.\n\n\n  if (rootA instanceof RootElement && rootB instanceof RootElement) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js"],"names":["AttributeOperation","DetachOperation","InsertOperation","MarkerOperation","MoveOperation","RenameOperation","RootAttributeOperation","SplitOperation","MergeOperation","DocumentFragment","Text","Element","RootElement","Position","Range","DocumentSelection","toMap","CKEditorError","Writer","constructor","model","batch","createText","data","attributes","createElement","name","createDocumentFragment","cloneElement","element","deep","_clone","insert","item","itemOrPosition","offset","_assertWriterUsedCorrectly","position","_createAt","parent","isSameTree","root","move","_createOn","document","remove","version","shouldReceiveAttributes","addOperation","applyOperation","markerName","markerRange","markers","rangeRootPosition","range","start","_getCombined","end","options","usingOperation","affectsData","has","updateMarker","addMarker","insertText","text","insertElement","append","appendText","appendElement","setAttribute","key","value","itemOrRange","ranges","getMinimalFlatRanges","setAttributeOnRange","setAttributeOnItem","setAttributes","val","removeAttribute","clearAttributes","removeAttributesFromItem","attribute","getAttributeKeys","getItems","isFlat","isEqual","_addOperationForAffectedMarkers","operation","rangeToRemove","reverse","flat","applyRemoveOperation","merge","nodeBefore","nodeAfter","_mergeDetached","_merge","createPositionFromPath","path","stickiness","createPositionAt","createPositionAfter","createPositionBefore","createRange","createRangeIn","createRangeOn","createSelection","selectable","placeOrOffset","_createIn","targetPosition","sourcePosition","graveyard","graveyardPosition","maxOffset","rename","newName","renameOperation","_createBefore","split","limitElement","splitElement","getAncestors","includeSelf","includes","firstSplitElement","firstCopyElement","howMany","insertionPosition","getInsertionPosition","nextSibling","wrap","elementOrString","childCount","shiftedRange","getShiftedBy","unwrap","undefined","_set","applyMarkerOperation","get","markerOrName","currentMarker","_refresh","hasUsingOperationDefined","affectsDataDefined","currentRange","getRange","updatedRange","managedUsingOperations","removeMarker","marker","_remove","oldRange","setSelection","selection","_setTo","setSelectionFocus","_setFocus","setSelectionAttribute","keyOrObjectOrIterable","_setSelectionAttribute","removeSelectionAttribute","keyOrIterableOfKeys","_removeSelectionAttribute","overrideSelectionGravity","_overrideGravity","restoreSelectionGravity","uid","_restoreGravity","isCollapsed","anchor","isEmpty","storeKey","_getStoreAttributeKey","_setAttribute","_removeAttribute","_currentWriter","type","positionOrRange","isAffected","containsPosition","elementBefore","elementAfter","affectedInLeftElement","isAtEnd","affectedInRightElement","affectedAfterLeftElement","affectedBeforeRightElement","writer","doc","lastSplitPosition","valueBefore","valueAfter","getWalker","shallow","getAttribute","nextPosition","previousValue","isRootChanged","newRange","rootA","rootB"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/writer\n */\n\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MoveOperation from './operation/moveoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\nimport SplitOperation from './operation/splitoperation';\nimport MergeOperation from './operation/mergeoperation';\n\nimport DocumentFragment from './documentfragment';\nimport Text from './text';\nimport Element from './element';\nimport RootElement from './rootelement';\nimport Position from './position';\nimport Range from './range.js';\nimport DocumentSelection from './documentselection';\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\nexport default class Writer {\n\t/**\n\t * Creates a writer instance.\n\t *\n\t * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n\t * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/model~Model} model\n\t * @param {module:engine/model/batch~Batch} batch\n\t */\n\tconstructor( model, batch ) {\n\t\t/**\n\t\t * Instance of the model on which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The batch to which this writer will add changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/batch~Batch}\n\t\t */\n\t\tthis.batch = batch;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\t\twriter.createText( 'foo', { bold: true } );\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @returns {module:engine/model/text~Text} Created text node.\n\t */\n\tcreateText( data, attributes ) {\n\t\treturn new Text( data, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/element~Element element}.\n\t *\n\t *\t\twriter.createElement( 'paragraph' );\n\t *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/model/element~Element} Created element.\n\t */\n\tcreateElement( name, attributes ) {\n\t\treturn new Element( name, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n\t *\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n\t */\n\tcreateDocumentFragment() {\n\t\treturn new DocumentFragment();\n\t}\n\n\t/**\n\t * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.\n\t * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n\t *\n\t * @param {module:engine/model/element~Element} element The element to clone.\n\t * @param {Boolean} [deep=true] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any child.\n\t */\n\tcloneElement( element, deep = true ) {\n\t\treturn element._clone( deep );\n\t}\n\n\t/**\n\t * Inserts item on given position.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, position );\n\t *\n\t * Instead of using position you can use parent and offset:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 5 );\n\t *\n\t * You can also use `end` instead of the offset to insert at the end:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 'end' );\n\t *\n\t * Or insert before or after another element:\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n\t * `model-writer-insert-forbidden-move` is thrown.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * **Note:** For a paste-like content insertion mechanism see\n\t * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n\t * fragment to insert.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsert( item, itemOrPosition, offset = 0 ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( item instanceof Text && item.data == '' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position = Position._createAt( itemOrPosition, offset );\n\n\t\t// If item has a parent already.\n\t\tif ( item.parent ) {\n\t\t\t// We need to check if item is going to be inserted within the same document.\n\t\t\tif ( isSameTree( item.root, position.root ) ) {\n\t\t\t\t// If it's we just need to move it.\n\t\t\t\tthis.move( Range._createOn( item ), position );\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If it isn't the same root.\n\t\t\telse {\n\t\t\t\tif ( item.root.document ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Cannot move a node from a document to a different tree.\n\t\t\t\t\t * It is forbidden to move a node that was already in a document outside of it.\n\t\t\t\t\t *\n\t\t\t\t\t * @error model-writer-insert-forbidden-move\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t'model-writer-insert-forbidden-move',\n\t\t\t\t\t\tthis\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Move between two different document fragments or from document fragment to a document is possible.\n\t\t\t\t\t// In that case, remove the item from it's original parent.\n\t\t\t\t\tthis.remove( item );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst version = position.root.document ? position.root.document.version : null;\n\n\t\tconst insert = new InsertOperation( position, item, version );\n\n\t\tif ( item instanceof Text ) {\n\t\t\tinsert.shouldReceiveAttributes = true;\n\t\t}\n\n\t\tthis.batch.addOperation( insert );\n\t\tthis.model.applyOperation( insert );\n\n\t\t// When element is a DocumentFragment we need to move its markers to Document#markers.\n\t\tif ( item instanceof DocumentFragment ) {\n\t\t\tfor ( const [ markerName, markerRange ] of item.markers ) {\n\t\t\t\t// We need to migrate marker range from DocumentFragment to Document.\n\t\t\t\tconst rangeRootPosition = Position._createAt( markerRange.root, 0 );\n\t\t\t\tconst range = new Range(\n\t\t\t\t\tmarkerRange.start._getCombined( rangeRootPosition, position ),\n\t\t\t\t\tmarkerRange.end._getCombined( rangeRootPosition, position )\n\t\t\t\t);\n\n\t\t\t\tconst options = { range, usingOperation: true, affectsData: true };\n\n\t\t\t\tif ( this.model.markers.has( markerName ) ) {\n\t\t\t\t\tthis.updateMarker( markerName, options );\n\t\t\t\t} else {\n\t\t\t\t\tthis.addMarker( markerName, options );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts text on given position. You can optionally set text attributes:\n\t *\n\t *\t\twriter.insertText( 'foo', position );\n\t *\t\twriter.insertText( 'foo', { bold: true }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts 'foo' in paragraph, at offset 5:\n\t *\t\twriter.insertText( 'foo', paragraph, 5 );\n\t *\t\t// Inserts 'foo' at the end of a paragraph:\n\t *\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t// Inserts 'foo' after an image:\n\t *\t\twriter.insertText( 'foo', image, 'after' );\n\t *\n\t * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertText( text, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createText( text ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts element on given position. You can optionally set attributes:\n\t *\n\t *\t\twriter.insertElement( 'paragraph', position );\n\t *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts paragraph in the root at offset 5:\n\t *\t\twriter.insertElement( 'paragraph', root, 5 );\n\t *\t\t// Inserts paragraph at the end of a blockquote:\n\t *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n\t *\t\t// Inserts after an image:\n\t *\t\twriter.insertElement( 'paragraph', image, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertElement( name, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Inserts item at the end of the given parent.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.append( paragraph, root );\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n\t * item Item or document fragment to insert.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappend( item, parent ) {\n\t\tthis.insert( item, parent, 'end' );\n\t}\n\n\t/**\n\t * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n\t *\n\t *\t\twriter.appendText( 'foo', paragraph );\n\t *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n\t *\n\t * @param {String} text Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendText( text, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createText( text ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n\t *\n\t *\t\twriter.appendElement( 'paragraph', root );\n\t *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendElement( name, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {*} value Attribute new value.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attribute will be set.\n\t */\n\tsetAttribute( key, value, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tconst ranges = itemOrRange.getMinimalFlatRanges();\n\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tsetAttributeOnRange( this, key, value, range );\n\t\t\t}\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, value, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t *\t\twriter.setAttributes( {\n\t *\t\t\tbold: true,\n\t *\t\t\titalic: true\n\t *\t\t}, range );\n\t *\n\t * @param {Object} attributes Attributes keys and values.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attributes will be set.\n\t */\n\tsetAttributes( attributes, itemOrRange ) {\n\t\tfor ( const [ key, val ] of toMap( attributes ) ) {\n\t\t\tthis.setAttribute( key, val, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n\t * or from a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which the attribute will be removed.\n\t */\n\tremoveAttribute( key, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tconst ranges = itemOrRange.getMinimalFlatRanges();\n\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tsetAttributeOnRange( this, key, null, range );\n\t\t\t}\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, null, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from all elements in the range or from the given item.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which all attributes will be removed.\n\t */\n\tclearAttributes( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst removeAttributesFromItem = item => {\n\t\t\tfor ( const attribute of item.getAttributeKeys() ) {\n\t\t\t\tthis.removeAttribute( attribute, item );\n\t\t\t}\n\t\t};\n\n\t\tif ( !( itemOrRange instanceof Range ) ) {\n\t\t\tremoveAttributesFromItem( itemOrRange );\n\t\t} else {\n\t\t\tfor ( const item of itemOrRange.getItems() ) {\n\t\t\t\tremoveAttributesFromItem( item );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves all items in the source range to the target position.\n\t *\n\t *\t\twriter.move( sourceRange, targetPosition );\n\t *\n\t * Instead of the target position you can use parent and offset or define that range should be moved to the end\n\t * or before or after chosen item:\n\t *\n\t *\t\t// Moves all items in the range to the paragraph at offset 5:\n\t *\t\twriter.move( sourceRange, paragraph, 5 );\n\t *\t\t// Moves all items in the range to the end of a blockquote:\n\t *\t\twriter.move( sourceRange, blockquote, 'end' );\n\t *\t\t// Moves all items in the range to a position after an image:\n\t *\t\twriter.move( sourceRange, image, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * Note that items can be moved only within the same tree. It means that you can move items within the same root\n\t * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n\t * but you can not move items from document fragment to the document or from one detached element to another. Use\n\t * {@link module:engine/model/writer~Writer#insert} in such cases.\n\t *\n\t * @param {module:engine/model/range~Range} range Source range.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tmove( range, itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( range instanceof Range ) ) {\n\t\t\t/**\n\t\t\t * Invalid range to move.\n\t\t\t *\n\t\t\t * @error writer-move-invalid-range\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-invalid-range', this );\n\t\t}\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to move is not flat.\n\t\t\t *\n\t\t\t * @error writer-move-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-range-not-flat', this );\n\t\t}\n\n\t\tconst position = Position._createAt( itemOrPosition, offset );\n\n\t\t// Do not move anything if the move target is same as moved range start.\n\t\tif ( position.isEqual( range.start ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\tthis._addOperationForAffectedMarkers( 'move', range );\n\n\t\tif ( !isSameTree( range.root, position.root ) ) {\n\t\t\t/**\n\t\t\t * Range is going to be moved within not the same document. Please use\n\t\t\t * {@link module:engine/model/writer~Writer#insert insert} instead.\n\t\t\t *\n\t\t\t * @error writer-move-different-document\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-different-document', this );\n\t\t}\n\n\t\tconst version = range.root.document ? range.root.document.version : null;\n\t\tconst operation = new MoveOperation( range.start, range.end.offset - range.start.offset, position, version );\n\n\t\tthis.batch.addOperation( operation );\n\t\tthis.model.applyOperation( operation );\n\t}\n\n\t/**\n\t * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n\t */\n\tremove( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn( itemOrRange );\n\t\tconst ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n\n\t\tfor ( const flat of ranges ) {\n\t\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\t\tthis._addOperationForAffectedMarkers( 'move', flat );\n\n\t\t\tapplyRemoveOperation( flat.start, flat.end.offset - flat.start.offset, this.batch, this.model );\n\t\t}\n\t}\n\n\t/**\n\t * Merges two siblings at the given position.\n\t *\n\t * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n\t * `writer-merge-no-element-after` error will be thrown.\n\t *\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\tmerge( position ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst nodeBefore = position.nodeBefore;\n\t\tconst nodeAfter = position.nodeAfter;\n\n\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\tthis._addOperationForAffectedMarkers( 'merge', position );\n\n\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node before merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-before\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-before', this );\n\t\t}\n\n\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node after merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-after\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-after', this );\n\t\t}\n\n\t\tif ( !position.root.document ) {\n\t\t\tthis._mergeDetached( position );\n\t\t} else {\n\t\t\tthis._merge( position );\n\t\t}\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionFromPath( root, path, stickiness ) {\n\t\treturn this.model.createPositionFromPath( root, path, stickiness );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn this.model.createPositionAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn this.model.createPositionAfter( item );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn this.model.createPositionBefore( item );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn this.model.createRange( start, end );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn this.model.createRangeIn( element );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeOn( element ) {\n\t\treturn this.model.createRangeOn( element );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @returns {module:engine/model/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn this.model.createSelection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Performs merge action in a detached tree.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\t_mergeDetached( position ) {\n\t\tconst nodeBefore = position.nodeBefore;\n\t\tconst nodeAfter = position.nodeAfter;\n\n\t\tthis.move( Range._createIn( nodeAfter ), Position._createAt( nodeBefore, 'end' ) );\n\t\tthis.remove( nodeAfter );\n\t}\n\n\t/**\n\t * Performs merge action in a non-detached tree.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\t_merge( position ) {\n\t\tconst targetPosition = Position._createAt( position.nodeBefore, 'end' );\n\t\tconst sourcePosition = Position._createAt( position.nodeAfter, 0 );\n\n\t\tconst graveyard = position.root.document.graveyard;\n\t\tconst graveyardPosition = new Position( graveyard, [ 0 ] );\n\n\t\tconst version = position.root.document.version;\n\n\t\tconst merge = new MergeOperation( sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version );\n\n\t\tthis.batch.addOperation( merge );\n\t\tthis.model.applyOperation( merge );\n\t}\n\n\t/**\n\t * Renames the given element.\n\t *\n\t * @param {module:engine/model/element~Element} element The element to rename.\n\t * @param {String} newName New element name.\n\t */\n\trename( element, newName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( element instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Trying to rename an object which is not an instance of Element.\n\t\t\t *\n\t\t\t * @error writer-rename-not-element-instance\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-rename-not-element-instance',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tconst version = element.root.document ? element.root.document.version : null;\n\t\tconst renameOperation = new RenameOperation( Position._createBefore( element ), element.name, newName, version );\n\n\t\tthis.batch.addOperation( renameOperation );\n\t\tthis.model.applyOperation( renameOperation );\n\t}\n\n\t/**\n\t * Splits elements starting from the given position and going to the top of the model tree as long as given\n\t * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n\t *\n\t * The element needs to have a parent. It cannot be a root element nor a document fragment.\n\t * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n\t *\n\t * @param {module:engine/model/position~Position} position Position of split.\n\t * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n\t * @returns {Object} result Split result.\n\t * @returns {module:engine/model/position~Position} result.position Position between split elements.\n\t * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n\t * at the beginning of the first copy element.\n\t */\n\tsplit( position, limitElement ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tlet splitElement = position.parent;\n\n\t\tif ( !splitElement.parent ) {\n\t\t\t/**\n\t\t\t * Element with no parent can not be split.\n\t\t\t *\n\t\t\t * @error writer-split-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-split-element-no-parent', this );\n\t\t}\n\n\t\t// When limit element is not defined lets set splitElement parent as limit.\n\t\tif ( !limitElement ) {\n\t\t\tlimitElement = splitElement.parent;\n\t\t}\n\n\t\tif ( !position.parent.getAncestors( { includeSelf: true } ).includes( limitElement ) ) {\n\t\t\t/**\n\t\t\t * Limit element is not a position ancestor.\n\t\t\t *\n\t\t\t * @error writer-split-invalid-limit-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-split-invalid-limit-element', this );\n\t\t}\n\n\t\t// We need to cache elements that will be created as a result of the first split because\n\t\t// we need to create a range from the end of the first split element to the beginning of the\n\t\t// first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n\t\tlet firstSplitElement, firstCopyElement;\n\n\t\tdo {\n\t\t\tconst version = splitElement.root.document ? splitElement.root.document.version : null;\n\t\t\tconst howMany = splitElement.maxOffset - position.offset;\n\n\t\t\tconst insertionPosition = SplitOperation.getInsertionPosition( position );\n\t\t\tconst split = new SplitOperation( position, howMany, insertionPosition, null, version );\n\n\t\t\tthis.batch.addOperation( split );\n\t\t\tthis.model.applyOperation( split );\n\n\t\t\t// Cache result of the first split.\n\t\t\tif ( !firstSplitElement && !firstCopyElement ) {\n\t\t\t\tfirstSplitElement = splitElement;\n\t\t\t\tfirstCopyElement = position.parent.nextSibling;\n\t\t\t}\n\n\t\t\tposition = this.createPositionAfter( position.parent );\n\t\t\tsplitElement = position.parent;\n\t\t} while ( splitElement !== limitElement );\n\n\t\treturn {\n\t\t\tposition,\n\t\t\trange: new Range( Position._createAt( firstSplitElement, 'end' ), Position._createAt( firstCopyElement, 0 ) )\n\t\t};\n\t}\n\n\t/**\n\t * Wraps the given range with the given element or with a new element (if a string was passed).\n\t *\n\t * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n\t * If not, an error will be thrown.\n\t *\n\t * @param {module:engine/model/range~Range} range Range to wrap.\n\t * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n\t */\n\twrap( range, elementOrString ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to wrap is not flat.\n\t\t\t *\n\t\t\t * @error writer-wrap-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-range-not-flat', this );\n\t\t}\n\n\t\tconst element = elementOrString instanceof Element ? elementOrString : new Element( elementOrString );\n\n\t\tif ( element.childCount > 0 ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is not empty.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-not-empty', this );\n\t\t}\n\n\t\tif ( element.parent !== null ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is already attached to a tree model.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-attached\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-attached', this );\n\t\t}\n\n\t\tthis.insert( element, range.start );\n\n\t\t// Shift the range-to-wrap because we just inserted an element before that range.\n\t\tconst shiftedRange = new Range( range.start.getShiftedBy( 1 ), range.end.getShiftedBy( 1 ) );\n\n\t\tthis.move( shiftedRange, Position._createAt( element, 0 ) );\n\t}\n\n\t/**\n\t * Unwraps children of the given element – all its children are moved before it and then the element is removed.\n\t * Throws error if you try to unwrap an element which does not have a parent.\n\t *\n\t * @param {module:engine/model/element~Element} element Element to unwrap.\n\t */\n\tunwrap( element ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( element.parent === null ) {\n\t\t\t/**\n\t\t\t * Trying to unwrap an element which has no parent.\n\t\t\t *\n\t\t\t * @error writer-unwrap-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-unwrap-element-no-parent', this );\n\t\t}\n\n\t\tthis.move( Range._createIn( element ), this.createPositionAfter( element ) );\n\t\tthis.remove( element );\n\t}\n\n\t/**\n\t * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes.\n\t *\n\t * As the first parameter you can set marker name.\n\t *\n\t * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by the\n\t * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Create marker directly base on marker's name:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false } );\n\t *\n\t * Create marker using operation:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Create marker that affects the editor data:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n\t *\n\t * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String} name Name of a marker to create - must be unique.\n\t * @param {Object} options\n\t * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {module:engine/model/range~Range} options.range Marker range.\n\t * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n\t * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n\t */\n\taddMarker( name, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !options || typeof options.usingOperation != 'boolean' ) {\n\t\t\t/**\n\t\t\t * The `options.usingOperation` parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addmarker-no-usingoperation\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addmarker-no-usingoperation', this );\n\t\t}\n\n\t\tconst usingOperation = options.usingOperation;\n\t\tconst range = options.range;\n\t\tconst affectsData = options.affectsData === undefined ? false : options.affectsData;\n\n\t\tif ( this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Marker with provided name already exists.\n\t\t\t *\n\t\t\t * @error writer-addmarker-marker-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addmarker-marker-exists', this );\n\t\t}\n\n\t\tif ( !range ) {\n\t\t\t/**\n\t\t\t * Range parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addmarker-no-range\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addmarker-no-range', this );\n\t\t}\n\n\t\tif ( !usingOperation ) {\n\t\t\treturn this.model.markers._set( name, range, usingOperation, affectsData );\n\t\t}\n\n\t\tapplyMarkerOperation( this, name, null, range, affectsData );\n\n\t\treturn this.model.markers.get( name );\n\t}\n\n\t/**\n\t * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n\t * marker's range directly using this method.\n\t *\n\t * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n\t * name is created and returned.\n\t *\n\t * As the second parameter you can set the new marker data or leave this parameter as empty which will just refresh\n\t * the marker by triggering downcast conversion for it. Refreshing the marker is useful when you want to change\n\t * the marker {@link module:engine/view/element~Element view element} without changing any marker data.\n\t *\n\t * \t\tlet isCommentActive = false;\n\t *\n\t * \t\tmodel.conversion.markerToHighlight( {\n\t * \t\t\tmodel: 'comment',\n\t *\t\t\tview: data => {\n\t *\t\t\t\tconst classes = [ 'comment-marker' ];\n\t *\n\t *\t\t\t\tif ( isCommentActive ) {\n\t *\t\t\t\t\tclasses.push( 'comment-marker--active' );\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\treturn { classes };\n\t *\t\t\t}\n\t * \t\t} );\n\t *\n\t * \t\t// Change the property that indicates if marker is displayed as active or not.\n\t * \t\tisCommentActive = true;\n\t *\n\t * \t\t// And refresh the marker to convert it with additional class.\n\t * \t\tmodel.change( writer => writer.updateMarker( 'comment' ) );\n\t *\n\t * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by\n\t * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Update marker directly base on marker's name:\n\t *\n\t *\t\tupdateMarker( markerName, { range } );\n\t *\n\t * Update marker using operation:\n\t *\n\t *\t\tupdateMarker( marker, { range, usingOperation: true } );\n\t *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Change marker's option (start using operations to manage it):\n\t *\n\t *\t\tupdateMarker( marker, { usingOperation: true } );\n\t *\n\t * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n\t *\n\t *\t\tupdateMarker( markerName, { affectsData: false } );\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n\t * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n\t * downcast conversion for this marker with the same data.\n\t * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n\t * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n\t */\n\tupdateMarker( markerOrName, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\t\tconst currentMarker = this.model.markers.get( markerName );\n\n\t\tif ( !currentMarker ) {\n\t\t\t/**\n\t\t\t * Marker with provided name does not exists.\n\t\t\t *\n\t\t\t * @error writer-updatemarker-marker-not-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-updatemarker-marker-not-exists', this );\n\t\t}\n\n\t\tif ( !options ) {\n\t\t\tthis.model.markers._refresh( currentMarker );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n\t\tconst affectsDataDefined = typeof options.affectsData == 'boolean';\n\n\t\t// Use previously defined marker's affectsData if the property is not provided.\n\t\tconst affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n\n\t\tif ( !hasUsingOperationDefined && !options.range && !affectsDataDefined ) {\n\t\t\t/**\n\t\t\t * One of the options is required - provide range, usingOperations or affectsData.\n\t\t\t *\n\t\t\t * @error writer-updatemarker-wrong-options\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-updatemarker-wrong-options', this );\n\t\t}\n\n\t\tconst currentRange = currentMarker.getRange();\n\t\tconst updatedRange = options.range ? options.range : currentRange;\n\n\t\tif ( hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations ) {\n\t\t\t// The marker type is changed so it's necessary to create proper operations.\n\t\t\tif ( options.usingOperation ) {\n\t\t\t\t// If marker changes to a managed one treat this as synchronizing existing marker.\n\t\t\t\t// Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n\t\t\t\tapplyMarkerOperation( this, markerName, null, updatedRange, affectsData );\n\t\t\t} else {\n\t\t\t\t// If marker changes to a marker that do not use operations then we need to create additional operation\n\t\t\t\t// that removes that marker first.\n\t\t\t\tapplyMarkerOperation( this, markerName, currentRange, null, affectsData );\n\n\t\t\t\t// Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n\t\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Marker's type doesn't change so update it accordingly.\n\t\tif ( currentMarker.managedUsingOperations ) {\n\t\t\tapplyMarkerOperation( this, markerName, currentRange, updatedRange, affectsData );\n\t\t} else {\n\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t}\n\t}\n\n\t/**\n\t * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n\t * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n\t * it will be destroyed using operation.\n\t *\n\t * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n\t */\n\tremoveMarker( markerOrName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\n\t\tif ( !this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Trying to remove marker which does not exist.\n\t\t\t *\n\t\t\t * @error writer-removemarker-no-marker\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-removemarker-no-marker', this );\n\t\t}\n\n\t\tconst marker = this.model.markers.get( name );\n\n\t\tif ( !marker.managedUsingOperations ) {\n\t\t\tthis.model.markers._remove( name );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldRange = marker.getRange();\n\n\t\tapplyMarkerOperation( this, name, oldRange, null, marker.affectsData );\n\t}\n\n\t/**\n\t * Sets the document's selection (ranges and direction) to the specified location based on the given\n\t * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\twriter.setSelection( ranges );\n\t *\n\t *\t\t// Sets selection to other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t *\t\t// Sets selection to the given document selection.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\twriter.setSelection( documentSelection );\n\t *\n\t *\t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPosition( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t *\t\t// Sets collapsed selection at the position of the given node and an offset.\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Removes all selection's ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * Using key and value pair:\n\t *\n\t * \twriter.setSelectionAttribute( 'italic', true );\n\t *\n\t * Using key-value object:\n\t *\n\t * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n\t *\n\t * Using iterable object:\n\t *\n\t * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n\t *\n\t * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n\t * or object / iterable of key => value attribute pairs.\n\t * @param {*} [value] Attribute value.\n\t */\n\tsetSelectionAttribute( keyOrObjectOrIterable, value ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrObjectOrIterable === 'string' ) {\n\t\t\tthis._setSelectionAttribute( keyOrObjectOrIterable, value );\n\t\t} else {\n\t\t\tfor ( const [ key, value ] of toMap( keyOrObjectOrIterable ) ) {\n\t\t\t\tthis._setSelectionAttribute( key, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute(s) with given key(s) from the selection.\n\t *\n\t * Remove one attribute:\n\t *\n\t *\t\twriter.removeSelectionAttribute( 'italic' );\n\t *\n\t * Remove multiple attributes:\n\t *\n\t *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n\t *\n\t * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n\t */\n\tremoveSelectionAttribute( keyOrIterableOfKeys ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrIterableOfKeys === 'string' ) {\n\t\t\tthis._removeSelectionAttribute( keyOrIterableOfKeys );\n\t\t} else {\n\t\t\tfor ( const key of keyOrIterableOfKeys ) {\n\t\t\t\tthis._removeSelectionAttribute( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n\t * of the selection from left to right.\n\t *\n\t * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n\t * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n\t * This method allows to temporarily override this behavior by forcing the gravity to the right.\n\t *\n\t * For the following model fragment:\n\t *\n\t *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n\t *\n\t * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n\t * * Overridden gravity: selection will have `bold` attribute.\n\t *\n\t * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n\t * of the process.\n\t *\n\t * @returns {String} The unique id which allows restoring the gravity.\n\t */\n\toverrideSelectionGravity() {\n\t\treturn this.model.document.selection._overrideGravity();\n\t}\n\n\t/**\n\t * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n\t *\n\t * Restoring the gravity is only possible using the unique identifier returned by\n\t * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n\t * the same number of times it was overridden.\n\t *\n\t * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n\t */\n\trestoreSelectionGravity( uid ) {\n\t\tthis.model.document.selection._restoreGravity( uid );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t * @param {*} value Attribute value.\n\t */\n\t_setSelectionAttribute( key, value ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Store attribute in parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.setAttribute( storeKey, value, selection.anchor.parent );\n\t\t}\n\n\t\tselection._setAttribute( key, value );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t */\n\t_removeSelectionAttribute( key ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Remove stored attribute from parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.removeAttribute( storeKey, selection.anchor.parent );\n\t\t}\n\n\t\tselection._removeAttribute( key );\n\t}\n\n\t/**\n\t * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n\t *\n\t * @private\n\t */\n\t_assertWriterUsedCorrectly() {\n\t\t/**\n\t\t * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n\t\t *\n\t\t * The writer can only be used inside these blocks which ensures that the model\n\t\t * can only be changed during such \"sessions\".\n\t\t *\n\t\t * @error writer-incorrect-use\n\t\t */\n\t\tif ( this.model._currentWriter !== this ) {\n\t\t\tthrow new CKEditorError( 'writer-incorrect-use', this );\n\t\t}\n\t}\n\n\t/**\n\t * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n\t * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n\t * can be later correctly processed during undo.\n\t *\n\t * @private\n\t * @param {'move'|'merge'} type Writer action type.\n\t * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n\t * where the writer action happens.\n\t */\n\t_addOperationForAffectedMarkers( type, positionOrRange ) {\n\t\tfor ( const marker of this.model.markers ) {\n\t\t\tif ( !marker.managedUsingOperations ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst markerRange = marker.getRange();\n\t\t\tlet isAffected = false;\n\n\t\t\tif ( type === 'move' ) {\n\t\t\t\tisAffected =\n\t\t\t\t\tpositionOrRange.containsPosition( markerRange.start ) ||\n\t\t\t\t\tpositionOrRange.start.isEqual( markerRange.start ) ||\n\t\t\t\t\tpositionOrRange.containsPosition( markerRange.end ) ||\n\t\t\t\t\tpositionOrRange.end.isEqual( markerRange.end );\n\t\t\t} else {\n\t\t\t\t// if type === 'merge'.\n\t\t\t\tconst elementBefore = positionOrRange.nodeBefore;\n\t\t\t\tconst elementAfter = positionOrRange.nodeAfter;\n\n\t\t\t\t//               Start:  <p>Foo[</p><p>Bar]</p>\n\t\t\t\t//         After merge:  <p>Foo[Bar]</p>\n\t\t\t\t// After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;\n\n\t\t\t\t//               Start:  <p>[Foo</p><p>]Bar</p>\n\t\t\t\t//         After merge:  <p>[Foo]Bar</p>\n\t\t\t\t// After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;\n\n\t\t\t\t//               Start:  <p>[Foo</p>]<p>Bar</p>\n\t\t\t\t//         After merge:  <p>[Foo]Bar</p>\n\t\t\t\t// After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;\n\n\t\t\t\t//               Start:  <p>Foo</p>[<p>Bar]</p>\n\t\t\t\t//         After merge:  <p>Foo[Bar]</p>\n\t\t\t\t// After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n\n\t\t\t\tisAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n\t\t\t}\n\n\t\t\tif ( isAffected ) {\n\t\t\t\tthis.updateMarker( marker.name, { range: markerRange } );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\nfunction setAttributeOnRange( writer, key, value, range ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\n\t// Position of the last split, the beginning of the new range.\n\tlet lastSplitPosition = range.start;\n\n\t// Currently position in the scanning range. Because we need value after the position, it is not a current\n\t// position of the iterator but the previous one (we need to iterate one more time to get the value after).\n\tlet position;\n\n\t// Value before the currently position.\n\tlet valueBefore;\n\n\t// Value after the currently position.\n\tlet valueAfter;\n\n\tfor ( const val of range.getWalker( { shallow: true } ) ) {\n\t\tvalueAfter = val.item.getAttribute( key );\n\n\t\t// At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n\t\t// because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n\t\tif ( position && valueBefore != valueAfter ) {\n\t\t\t// if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n\t\t\tif ( valueBefore != value ) {\n\t\t\t\taddOperation();\n\t\t\t}\n\n\t\t\tlastSplitPosition = position;\n\t\t}\n\n\t\tposition = val.nextPosition;\n\t\tvalueBefore = valueAfter;\n\t}\n\n\t// Because position in the loop is not the iterator position (see let position comment), the last position in\n\t// the while loop will be last but one position in the range. We need to check the last position manually.\n\tif ( position instanceof Position && position != lastSplitPosition && valueBefore != value ) {\n\t\taddOperation();\n\t}\n\n\tfunction addOperation() {\n\t\tconst range = new Range( lastSplitPosition, position );\n\t\tconst version = range.root.document ? doc.version : null;\n\t\tconst operation = new AttributeOperation( range, key, valueBefore, value, version );\n\n\t\twriter.batch.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\nfunction setAttributeOnItem( writer, key, value, item ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\tconst previousValue = item.getAttribute( key );\n\tlet range, operation;\n\n\tif ( previousValue != value ) {\n\t\tconst isRootChanged = item.root === item;\n\n\t\tif ( isRootChanged ) {\n\t\t\t// If we change attributes of root element, we have to use `RootAttributeOperation`.\n\t\t\tconst version = item.document ? doc.version : null;\n\n\t\t\toperation = new RootAttributeOperation( item, key, previousValue, value, version );\n\t\t} else {\n\t\t\trange = new Range( Position._createBefore( item ), writer.createPositionAfter( item ) );\n\n\t\t\tconst version = range.root.document ? doc.version : null;\n\n\t\t\toperation = new AttributeOperation( range, key, previousValue, value, version );\n\t\t}\n\n\t\twriter.batch.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\nfunction applyMarkerOperation( writer, name, oldRange, newRange, affectsData ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\n\tconst operation = new MarkerOperation( name, oldRange, newRange, model.markers, affectsData, doc.version );\n\n\twriter.batch.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\nfunction applyRemoveOperation( position, howMany, batch, model ) {\n\tlet operation;\n\n\tif ( position.root.document ) {\n\t\tconst doc = model.document;\n\t\tconst graveyardPosition = new Position( doc.graveyard, [ 0 ] );\n\n\t\toperation = new MoveOperation( position, howMany, graveyardPosition, doc.version );\n\t} else {\n\t\toperation = new DetachOperation( position, howMany );\n\t}\n\n\tbatch.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\nfunction isSameTree( rootA, rootB ) {\n\t// If it is the same root this is the same tree.\n\tif ( rootA === rootB ) {\n\t\treturn true;\n\t}\n\n\t// If both roots are documents root it is operation within the document what we still treat as the same tree.\n\tif ( rootA instanceof RootElement && rootB instanceof RootElement ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]},"metadata":{},"sourceType":"module"}