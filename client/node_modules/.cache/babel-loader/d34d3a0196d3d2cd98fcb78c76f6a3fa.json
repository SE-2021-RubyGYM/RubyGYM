{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/selection\n */\nimport Position from './position';\nimport Node from './node';\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n/**\n * Selection is a set of {@link module:engine/model/range~Range ranges}. It has a direction specified by its\n * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}\n * (it can be {@link module:engine/model/selection~Selection#isBackward forward or backward}).\n * Additionally, selection may have its own attributes (think – whether text typed in in this selection\n * should have those attributes – e.g. whether you type a bolded text).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Selection {\n  /**\n   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n   * or creates an empty selection if no arguments were passed.\n   *\n   *\t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the given document selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst documentSelection = model.document.selection;\n   *\t\tconst selection = writer.createSelection( documentSelection );\n   *\n   *\t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates selection at the given offset in the given element.\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * Selection's constructor allow passing additional options (`'backward'`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * @param {module:engine/model/selection~Selectable} [selectable]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n  constructor(selectable, placeOrOffset, options) {\n    /**\n     * Specifies whether the last added range was added as a backward or forward range.\n     *\n     * @private\n     * @type {Boolean}\n     */\n    this._lastRangeBackward = false;\n    /**\n     * Stores selection ranges.\n     *\n     * @protected\n     * @type {Array.<module:engine/model/range~Range>}\n     */\n\n    this._ranges = [];\n    /**\n     * List of attributes set on current selection.\n     *\n     * @protected\n     * @type {Map.<String,*>}\n     */\n\n    this._attrs = new Map();\n\n    if (selectable) {\n      this.setTo(selectable, placeOrOffset, options);\n    }\n  }\n  /**\n   * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection\n   * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).\n   *\n   * Anchor and {@link #focus} define the direction of the selection, which is important\n   * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.\n   *\n   * Anchor is always set to the {@link module:engine/model/range~Range#start start} or\n   * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is\n   * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.\n   *\n   * May be set to `null` if there are no ranges in the selection.\n   *\n   * @see #focus\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n\n\n  get anchor() {\n    if (this._ranges.length > 0) {\n      const range = this._ranges[this._ranges.length - 1];\n      return this._lastRangeBackward ? range.end : range.start;\n    }\n\n    return null;\n  }\n  /**\n   * Selection focus. Focus is the position where the selection ends. If a user is making a selection\n   * by dragging the mouse, the focus is where the mouse cursor is.\n   *\n   * May be set to `null` if there are no ranges in the selection.\n   *\n   * @see #anchor\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n\n\n  get focus() {\n    if (this._ranges.length > 0) {\n      const range = this._ranges[this._ranges.length - 1];\n      return this._lastRangeBackward ? range.start : range.end;\n    }\n\n    return null;\n  }\n  /**\n   * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it\n   * and it is collapsed.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isCollapsed() {\n    const length = this._ranges.length;\n\n    if (length === 1) {\n      return this._ranges[0].isCollapsed;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Returns the number of ranges in the selection.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get rangeCount() {\n    return this._ranges.length;\n  }\n  /**\n   * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isBackward() {\n    return !this.isCollapsed && this._lastRangeBackward;\n  }\n  /**\n   * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,\n   * the same number of ranges and all ranges from one selection equal to ranges from the another selection.\n   *\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection\n   * Selection to compare with.\n   * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n   */\n\n\n  isEqual(otherSelection) {\n    if (this.rangeCount != otherSelection.rangeCount) {\n      return false;\n    } else if (this.rangeCount === 0) {\n      return true;\n    }\n\n    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n      return false;\n    }\n\n    for (const thisRange of this._ranges) {\n      let found = false;\n\n      for (const otherRange of otherSelection._ranges) {\n        if (thisRange.isEqual(otherRange)) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns an iterable object that iterates over copies of selection ranges.\n   *\n   * @returns {Iterable.<module:engine/model/range~Range>}\n   */\n\n\n  *getRanges() {\n    for (const range of this._ranges) {\n      yield new Range(range.start, range.end);\n    }\n  }\n  /**\n   * Returns a copy of the first range in the selection.\n   * First range is the one which {@link module:engine/model/range~Range#start start} position\n   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n   * (not to confuse with the first range added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getFirstRange() {\n    let first = null;\n\n    for (const range of this._ranges) {\n      if (!first || range.start.isBefore(first.start)) {\n        first = range;\n      }\n    }\n\n    return first ? new Range(first.start, first.end) : null;\n  }\n  /**\n   * Returns a copy of the last range in the selection.\n   * Last range is the one which {@link module:engine/model/range~Range#end end} position\n   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n   * recently added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getLastRange() {\n    let last = null;\n\n    for (const range of this._ranges) {\n      if (!last || range.end.isAfter(last.end)) {\n        last = range;\n      }\n    }\n\n    return last ? new Range(last.start, last.end) : null;\n  }\n  /**\n   * Returns the first position in the selection.\n   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n\n\n  getFirstPosition() {\n    const first = this.getFirstRange();\n    return first ? first.start.clone() : null;\n  }\n  /**\n   * Returns the last position in the selection.\n   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n\n\n  getLastPosition() {\n    const lastRange = this.getLastRange();\n    return lastRange ? lastRange.end.clone() : null;\n  }\n  /**\n   * Sets this selection's ranges and direction to the specified location based on the given\n   * {@link module:engine/model/selection~Selectable selectable}.\n   *\n   *\t\t// Removes all selection's ranges.\n   *\t\tselection.setTo( null );\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tselection.setTo( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tselection.setTo( ranges );\n   *\n   *\t\t// Sets selection to other selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tselection.setTo( otherSelection );\n   *\n   *\t\t// Sets selection to the given document selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst documentSelection = new DocumentSelection( doc );\n   *\t\tselection.setTo( documentSelection );\n   *\n   *\t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tselection.setTo( position );\n   *\n   *\t\t// Sets collapsed selection at the position of the given node and an offset.\n   *\t\tselection.setTo( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n  \t * that element and ends after the last child of that element.\n   *\n   *\t\tselection.setTo( paragraph, 'in' );\n   *\n   * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\tselection.setTo( paragraph, 'on' );\n   *\n   * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.\n   *\n   *\t\t// Sets backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n\n\n  setTo(selectable, placeOrOffset, options) {\n    if (selectable === null) {\n      this._setRanges([]);\n    } else if (selectable instanceof Selection) {\n      this._setRanges(selectable.getRanges(), selectable.isBackward);\n    } else if (selectable && typeof selectable.getRanges == 'function') {\n      // We assume that the selectable is a DocumentSelection.\n      // It can't be imported here, because it would lead to circular imports.\n      this._setRanges(selectable.getRanges(), selectable.isBackward);\n    } else if (selectable instanceof Range) {\n      this._setRanges([selectable], !!placeOrOffset && !!placeOrOffset.backward);\n    } else if (selectable instanceof Position) {\n      this._setRanges([new Range(selectable)]);\n    } else if (selectable instanceof Node) {\n      const backward = !!options && !!options.backward;\n      let range;\n\n      if (placeOrOffset == 'in') {\n        range = Range._createIn(selectable);\n      } else if (placeOrOffset == 'on') {\n        range = Range._createOn(selectable);\n      } else if (placeOrOffset !== undefined) {\n        range = new Range(Position._createAt(selectable, placeOrOffset));\n      } else {\n        /**\n         * selection.setTo requires the second parameter when the first parameter is a node.\n         *\n         * @error model-selection-setto-required-second-parameter\n         */\n        throw new CKEditorError('model-selection-setto-required-second-parameter', [this, selectable]);\n      }\n\n      this._setRanges([range], backward);\n    } else if (isIterable(selectable)) {\n      // We assume that the selectable is an iterable of ranges.\n      this._setRanges(selectable, placeOrOffset && !!placeOrOffset.backward);\n    } else {\n      /**\n       * Cannot set the selection to the given place.\n       *\n       * Invalid parameters were specified when setting the selection. Common issues:\n       *\n       * * A {@link module:engine/model/textproxy~TextProxy} instance was passed instead of\n       * a real {@link module:engine/model/text~Text}.\n       * * View nodes were passed instead of model nodes.\n       * * `null`/`undefined` was passed.\n       *\n       * @error model-selection-setto-not-selectable\n       */\n      throw new CKEditorError('model-selection-setto-not-selectable', [this, selectable]);\n    }\n  }\n  /**\n   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n   * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and\n   * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.\n   *\n   * @protected\n   * @fires change:range\n   * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.\n   * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)\n   * or backward - from end to start (`true`).\n   */\n\n\n  _setRanges(newRanges) {\n    let isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    newRanges = Array.from(newRanges); // Check whether there is any range in new ranges set that is different than all already added ranges.\n\n    const anyNewRange = newRanges.some(newRange => {\n      if (!(newRange instanceof Range)) {\n        /**\n         * Selection range set to an object that is not an instance of {@link module:engine/model/range~Range}.\n         *\n         * Only {@link module:engine/model/range~Range} instances can be used to set a selection.\n         * Common mistakes leading to this error are:\n         *\n         * * using DOM `Range` object,\n         * * incorrect CKEditor 5 installation with multiple `ckeditor5-engine` packages having different versions.\n         *\n         * @error model-selection-set-ranges-not-range\n         */\n        throw new CKEditorError('model-selection-set-ranges-not-range', [this, newRanges]);\n      }\n\n      return this._ranges.every(oldRange => {\n        return !oldRange.isEqual(newRange);\n      });\n    }); // Don't do anything if nothing changed.\n\n    if (newRanges.length === this._ranges.length && !anyNewRange) {\n      return;\n    }\n\n    this._removeAllRanges();\n\n    for (const range of newRanges) {\n      this._pushRange(range);\n    }\n\n    this._lastRangeBackward = !!isLastBackward;\n    this.fire('change:range', {\n      directChange: true\n    });\n  }\n  /**\n   * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.\n   *\n   * The location can be specified in the same form as\n   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n   *\n   * @fires change:range\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  setFocus(itemOrPosition, offset) {\n    if (this.anchor === null) {\n      /**\n       * Cannot set selection focus if there are no ranges in selection.\n       *\n       * @error model-selection-setfocus-no-ranges\n       */\n      throw new CKEditorError('model-selection-setfocus-no-ranges', [this, itemOrPosition]);\n    }\n\n    const newFocus = Position._createAt(itemOrPosition, offset);\n\n    if (newFocus.compareWith(this.focus) == 'same') {\n      return;\n    }\n\n    const anchor = this.anchor;\n\n    if (this._ranges.length) {\n      this._popRange();\n    }\n\n    if (newFocus.compareWith(anchor) == 'before') {\n      this._pushRange(new Range(newFocus, anchor));\n\n      this._lastRangeBackward = true;\n    } else {\n      this._pushRange(new Range(anchor, newFocus));\n\n      this._lastRangeBackward = false;\n    }\n\n    this.fire('change:range', {\n      directChange: true\n    });\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n\n\n  getAttribute(key) {\n    return this._attrs.get(key);\n  }\n  /**\n   * Returns iterable that iterates over this selection's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  getAttributes() {\n    return this._attrs.entries();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  getAttributeKeys() {\n    return this._attrs.keys();\n  }\n  /**\n   * Checks if the selection has an attribute for given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n   */\n\n\n  hasAttribute(key) {\n    return this._attrs.has(key);\n  }\n  /**\n   * Removes an attribute with given key from the selection.\n   *\n   * If given attribute was set on the selection, fires the {@link #event:change:range} event with\n   * removed attribute key.\n   *\n   * @fires change:attribute\n   * @param {String} key Key of attribute to remove.\n   */\n\n\n  removeAttribute(key) {\n    if (this.hasAttribute(key)) {\n      this._attrs.delete(key);\n\n      this.fire('change:attribute', {\n        attributeKeys: [key],\n        directChange: true\n      });\n    }\n  }\n  /**\n   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n   *\n   * If the attribute value has changed, fires the {@link #event:change:range} event with\n   * the attribute key.\n   *\n   * @fires change:attribute\n   * @param {String} key Key of attribute to set.\n   * @param {*} value Attribute value.\n   */\n\n\n  setAttribute(key, value) {\n    if (this.getAttribute(key) !== value) {\n      this._attrs.set(key, value);\n\n      this.fire('change:attribute', {\n        attributeKeys: [key],\n        directChange: true\n      });\n    }\n  }\n  /**\n   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n   * one range in the selection, and that range contains exactly one element.\n   * Returns `null` if there is no selected element.\n   *\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  getSelectedElement() {\n    if (this.rangeCount !== 1) {\n      return null;\n    }\n\n    return this.getFirstRange().getContainedElement();\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\tselection.is( 'selection' ); // -> true\n   *\t\tselection.is( 'model:selection' ); // -> true\n   *\n   *\t\tselection.is( 'view:selection' ); // -> false\n   *\t\tselection.is( 'range' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'selection' || type === 'model:selection';\n  }\n  /**\n   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n   *\n   * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n   *\n   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n   * but will not return blocks nested in other blocks.\n   *\n   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<blockQuote>\n   *\t\t\t<paragraph>b</paragraph>\n   *\t\t</blockQuote>\n   *\t\t<paragraph>c]d</paragraph>\n   *\n   * In this case the paragraph will also be returned, despite the collapsed selection:\n   *\n   *\t\t<paragraph>[]a</paragraph>\n   *\n   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n   *\n   *\t\t[<blockA></blockA>\n   *\t\t<blockB>\n   *\t\t\t<blockC></blockC>\n   *\t\t\t<blockD></blockD>\n   *\t\t</blockB>\n   *\t\t<blockE></blockE>]\n   *\n   * If the selection is inside a block all the inner blocks (A & B) are returned:\n   *\n   * \t\t<block>\n   *\t\t\t<blockA>[a</blockA>\n   * \t\t\t<blockB>b]</blockB>\n   * \t\t</block>\n   *\n   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<paragraph>b</paragraph>\n   *\t\t<paragraph>]c</paragraph> // this block will not be returned\n   *\n   * @returns {Iterable.<module:engine/model/element~Element>}\n   */\n\n\n  *getSelectedBlocks() {\n    const visited = new WeakSet();\n\n    for (const range of this.getRanges()) {\n      // Get start block of range in case of a collapsed range.\n      const startBlock = getParentBlock(range.start, visited);\n\n      if (startBlock && isTopBlockInRange(startBlock, range)) {\n        yield startBlock;\n      }\n\n      for (const value of range.getWalker()) {\n        const block = value.item;\n\n        if (value.type == 'elementEnd' && isUnvisitedTopBlock(block, visited, range)) {\n          yield block;\n        }\n      }\n\n      const endBlock = getParentBlock(range.end, visited); // #984. Don't return the end block if the range ends right at its beginning.\n\n      if (endBlock && !range.end.isTouching(Position._createAt(endBlock, 0)) && isTopBlockInRange(endBlock, range)) {\n        yield endBlock;\n      }\n    }\n  }\n  /**\n   * Checks whether the selection contains the entire content of the given element. This means that selection must start\n   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n   * touching the element's end.\n   *\n   * By default, this method will check whether the entire content of the selection's current root is selected.\n   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n   *\n   * @param {module:engine/model/element~Element} [element=this.anchor.root]\n   * @returns {Boolean}\n   */\n\n\n  containsEntireContent() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.anchor.root;\n\n    const limitStartPosition = Position._createAt(element, 0);\n\n    const limitEndPosition = Position._createAt(element, 'end');\n\n    return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());\n  }\n  /**\n   * Adds given range to internal {@link #_ranges ranges array}. Throws an error\n   * if given range is intersecting with any range that is already stored in this selection.\n   *\n   * @protected\n   * @param {module:engine/model/range~Range} range Range to add.\n   */\n\n\n  _pushRange(range) {\n    this._checkRange(range);\n\n    this._ranges.push(new Range(range.start, range.end));\n  }\n  /**\n   * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.\n   *\n   * @protected\n   * @param {module:engine/model/range~Range} range Range to check.\n   */\n\n\n  _checkRange(range) {\n    for (let i = 0; i < this._ranges.length; i++) {\n      if (range.isIntersecting(this._ranges[i])) {\n        /**\n         * Trying to add a range that intersects with another range in the selection.\n         *\n         * @error model-selection-range-intersects\n         * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.\n         * @param {module:engine/model/range~Range} intersectingRange Range in the selection that intersects with `addedRange`.\n         */\n        throw new CKEditorError('model-selection-range-intersects', [this, range], {\n          addedRange: range,\n          intersectingRange: this._ranges[i]\n        });\n      }\n    }\n  }\n  /**\n   * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to\n   * ensure proper ranges removal.\n   *\n   * @protected\n   */\n\n\n  _removeAllRanges() {\n    while (this._ranges.length > 0) {\n      this._popRange();\n    }\n  }\n  /**\n   * Removes most recently added range from the selection.\n   *\n   * @protected\n   */\n\n\n  _popRange() {\n    this._ranges.pop();\n  }\n  /**\n   * Fired when selection range(s) changed.\n   *\n   * @event change:range\n   * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n   * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n   * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n   * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n   * changed because the structure of the model has been changed (which means an indirect change).\n   * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n   * which mean that they are not updated once the document changes.\n   */\n\n  /**\n   * Fired when selection attribute changed.\n   *\n   * @event change:attribute\n   * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n   * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n   * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n   * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n   * changed in the model and its attributes were refreshed (which means an indirect change).\n   * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n   * which mean that they are not updated once the document changes.\n   * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n   */\n\n\n}\nmix(Selection, EmitterMixin); // Checks whether the given element extends $block in the schema and has a parent (is not a root).\n// Marks it as already visited.\n\nfunction isUnvisitedBlock(element, visited) {\n  if (visited.has(element)) {\n    return false;\n  }\n\n  visited.add(element);\n  return element.root.document.model.schema.isBlock(element) && element.parent;\n} // Checks if the given element is a $block was not previously visited and is a top block in a range.\n\n\nfunction isUnvisitedTopBlock(element, visited, range) {\n  return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);\n} // Finds the lowest element in position's ancestors which is a block.\n// It will search until first ancestor that is a limit element.\n// Marks all ancestors as already visited to not include any of them later on.\n\n\nfunction getParentBlock(position, visited) {\n  const element = position.parent;\n  const schema = element.root.document.model.schema;\n  const ancestors = position.parent.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n  let hasParentLimit = false;\n  const block = ancestors.find(element => {\n    // Stop searching after first parent node that is limit element.\n    if (hasParentLimit) {\n      return false;\n    }\n\n    hasParentLimit = schema.isLimit(element);\n    return !hasParentLimit && isUnvisitedBlock(element, visited);\n  }); // Mark all ancestors of this position's parent, because find() might've stopped early and\n  // the found block may be a child of another block.\n\n  ancestors.forEach(element => visited.add(element));\n  return block;\n} // Checks if the blocks is not nested in other block inside a range.\n//\n// @param {module:engine/model/element~Element} block Block to check.\n// @param {module:engine/model/range~Range} range Range to check.\n\n\nfunction isTopBlockInRange(block, range) {\n  const parentBlock = findAncestorBlock(block);\n\n  if (!parentBlock) {\n    return true;\n  } // Add loose flag to check as parentRange can be equal to range.\n\n\n  const isParentInRange = range.containsRange(Range._createOn(parentBlock), true);\n  return !isParentInRange;\n} // Returns first ancestor block of a node.\n//\n// @param {module:engine/model/node~Node} node\n// @returns {module:engine/model/node~Node|undefined}\n\n\nfunction findAncestorBlock(node) {\n  const schema = node.root.document.model.schema;\n  let parent = node.parent;\n\n  while (parent) {\n    if (schema.isBlock(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n}\n/**\n * An entity that is used to set selection.\n *\n * See also {@link module:engine/model/selection~Selection#setTo}\n *\n * @typedef {\n *     module:engine/model/selection~Selection|\n *     module:engine/model/documentselection~DocumentSelection|\n *     module:engine/model/position~Position|\n *     module:engine/model/range~Range|\n *     module:engine/model/node~Node|\n *     Iterable.<module:engine/model/range~Range>|\n *     null\n * } module:engine/model/selection~Selectable\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/selection.js"],"names":["Position","Node","Range","EmitterMixin","CKEditorError","mix","isIterable","Selection","constructor","selectable","placeOrOffset","options","_lastRangeBackward","_ranges","_attrs","Map","setTo","anchor","length","range","end","start","focus","isCollapsed","rangeCount","isBackward","isEqual","otherSelection","thisRange","found","otherRange","getRanges","getFirstRange","first","isBefore","getLastRange","last","isAfter","getFirstPosition","clone","getLastPosition","lastRange","_setRanges","backward","_createIn","_createOn","undefined","_createAt","newRanges","isLastBackward","Array","from","anyNewRange","some","newRange","every","oldRange","_removeAllRanges","_pushRange","fire","directChange","setFocus","itemOrPosition","offset","newFocus","compareWith","_popRange","getAttribute","key","get","getAttributes","entries","getAttributeKeys","keys","hasAttribute","has","removeAttribute","delete","attributeKeys","setAttribute","value","set","getSelectedElement","getContainedElement","is","type","getSelectedBlocks","visited","WeakSet","startBlock","getParentBlock","isTopBlockInRange","getWalker","block","item","isUnvisitedTopBlock","endBlock","isTouching","containsEntireContent","element","root","limitStartPosition","limitEndPosition","_checkRange","push","i","isIntersecting","addedRange","intersectingRange","pop","isUnvisitedBlock","add","document","model","schema","isBlock","parent","position","ancestors","getAncestors","parentFirst","includeSelf","hasParentLimit","find","isLimit","forEach","parentBlock","findAncestorBlock","isParentInRange","containsRange","node"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,SAAN,CAAgB;AAC9B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,UAAF,EAAcC,aAAd,EAA6BC,OAA7B,EAAuC;AACjD;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,kBAAL,GAA0B,KAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,OAAL,GAAe,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd;;AAEA,QAAKN,UAAL,EAAkB;AACjB,WAAKO,KAAL,CAAYP,UAAZ,EAAwBC,aAAxB,EAAuCC,OAAvC;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACW,MAANM,MAAM,GAAG;AACZ,QAAK,KAAKJ,OAAL,CAAaK,MAAb,GAAsB,CAA3B,EAA+B;AAC9B,YAAMC,KAAK,GAAG,KAAKN,OAAL,CAAc,KAAKA,OAAL,CAAaK,MAAb,GAAsB,CAApC,CAAd;AAEA,aAAO,KAAKN,kBAAL,GAA0BO,KAAK,CAACC,GAAhC,GAAsCD,KAAK,CAACE,KAAnD;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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/selection\n */\n\nimport Position from './position';\nimport Node from './node';\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n/**\n * Selection is a set of {@link module:engine/model/range~Range ranges}. It has a direction specified by its\n * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}\n * (it can be {@link module:engine/model/selection~Selection#isBackward forward or backward}).\n * Additionally, selection may have its own attributes (think – whether text typed in in this selection\n * should have those attributes – e.g. whether you type a bolded text).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Selection {\n\t/**\n\t * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n\t * or creates an empty selection if no arguments were passed.\n\t *\n\t *\t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\tconst selection = writer.createSelection( documentSelection );\n\t *\n\t *\t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates selection at the given offset in the given element.\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * Selection's constructor allow passing additional options (`'backward'`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} [selectable]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tconstructor( selectable, placeOrOffset, options ) {\n\t\t/**\n\t\t * Specifies whether the last added range was added as a backward or forward range.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._lastRangeBackward = false;\n\n\t\t/**\n\t\t * Stores selection ranges.\n\t\t *\n\t\t * @protected\n\t\t * @type {Array.<module:engine/model/range~Range>}\n\t\t */\n\t\tthis._ranges = [];\n\n\t\t/**\n\t\t * List of attributes set on current selection.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map.<String,*>}\n\t\t */\n\t\tthis._attrs = new Map();\n\n\t\tif ( selectable ) {\n\t\t\tthis.setTo( selectable, placeOrOffset, options );\n\t\t}\n\t}\n\n\t/**\n\t * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection\n\t * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).\n\t *\n\t * Anchor and {@link #focus} define the direction of the selection, which is important\n\t * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.\n\t *\n\t * Anchor is always set to the {@link module:engine/model/range~Range#start start} or\n\t * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is\n\t * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.\n\t *\n\t * May be set to `null` if there are no ranges in the selection.\n\t *\n\t * @see #focus\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget anchor() {\n\t\tif ( this._ranges.length > 0 ) {\n\t\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\n\t\t\treturn this._lastRangeBackward ? range.end : range.start;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Selection focus. Focus is the position where the selection ends. If a user is making a selection\n\t * by dragging the mouse, the focus is where the mouse cursor is.\n\t *\n\t * May be set to `null` if there are no ranges in the selection.\n\t *\n\t * @see #anchor\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget focus() {\n\t\tif ( this._ranges.length > 0 ) {\n\t\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\n\t\t\treturn this._lastRangeBackward ? range.start : range.end;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it\n\t * and it is collapsed.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\tconst length = this._ranges.length;\n\n\t\tif ( length === 1 ) {\n\t\t\treturn this._ranges[ 0 ].isCollapsed;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of ranges in the selection.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._ranges.length;\n\t}\n\n\t/**\n\t * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn !this.isCollapsed && this._lastRangeBackward;\n\t}\n\n\t/**\n\t * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,\n\t * the same number of ranges and all ranges from one selection equal to ranges from the another selection.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n\t */\n\tisEqual( otherSelection ) {\n\t\tif ( this.rangeCount != otherSelection.rangeCount ) {\n\t\t\treturn false;\n\t\t} else if ( this.rangeCount === 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( !this.anchor.isEqual( otherSelection.anchor ) || !this.focus.isEqual( otherSelection.focus ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor ( const thisRange of this._ranges ) {\n\t\t\tlet found = false;\n\n\t\t\tfor ( const otherRange of otherSelection._ranges ) {\n\t\t\t\tif ( thisRange.isEqual( otherRange ) ) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !found ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns an iterable object that iterates over copies of selection ranges.\n\t *\n\t * @returns {Iterable.<module:engine/model/range~Range>}\n\t */\n\t* getRanges() {\n\t\tfor ( const range of this._ranges ) {\n\t\t\tyield new Range( range.start, range.end );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of the first range in the selection.\n\t * First range is the one which {@link module:engine/model/range~Range#start start} position\n\t * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n\t * (not to confuse with the first range added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\tlet first = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !first || range.start.isBefore( first.start ) ) {\n\t\t\t\tfirst = range;\n\t\t\t}\n\t\t}\n\n\t\treturn first ? new Range( first.start, first.end ) : null;\n\t}\n\n\t/**\n\t * Returns a copy of the last range in the selection.\n\t * Last range is the one which {@link module:engine/model/range~Range#end end} position\n\t * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n\t * recently added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\tlet last = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !last || range.end.isAfter( last.end ) ) {\n\t\t\t\tlast = range;\n\t\t\t}\n\t\t}\n\n\t\treturn last ? new Range( last.start, last.end ) : null;\n\t}\n\n\t/**\n\t * Returns the first position in the selection.\n\t * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\tconst first = this.getFirstRange();\n\n\t\treturn first ? first.start.clone() : null;\n\t}\n\n\t/**\n\t * Returns the last position in the selection.\n\t * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\tconst lastRange = this.getLastRange();\n\n\t\treturn lastRange ? lastRange.end.clone() : null;\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/model/selection~Selectable selectable}.\n\t *\n\t *\t\t// Removes all selection's ranges.\n\t *\t\tselection.setTo( null );\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tselection.setTo( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tselection.setTo( ranges );\n\t *\n\t *\t\t// Sets selection to other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tselection.setTo( otherSelection );\n\t *\n\t *\t\t// Sets selection to the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = new DocumentSelection( doc );\n\t *\t\tselection.setTo( documentSelection );\n\t *\n\t *\t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tselection.setTo( position );\n\t *\n\t *\t\t// Sets collapsed selection at the position of the given node and an offset.\n\t *\t\tselection.setTo( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t *\t\tselection.setTo( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\tselection.setTo( paragraph, 'on' );\n\t *\n\t * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.\n\t *\n\t *\t\t// Sets backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tsetTo( selectable, placeOrOffset, options ) {\n\t\tif ( selectable === null ) {\n\t\t\tthis._setRanges( [] );\n\t\t} else if ( selectable instanceof Selection ) {\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t} else if ( selectable && typeof selectable.getRanges == 'function' ) {\n\t\t\t// We assume that the selectable is a DocumentSelection.\n\t\t\t// It can't be imported here, because it would lead to circular imports.\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t} else if ( selectable instanceof Range ) {\n\t\t\tthis._setRanges( [ selectable ], !!placeOrOffset && !!placeOrOffset.backward );\n\t\t} else if ( selectable instanceof Position ) {\n\t\t\tthis._setRanges( [ new Range( selectable ) ] );\n\t\t} else if ( selectable instanceof Node ) {\n\t\t\tconst backward = !!options && !!options.backward;\n\t\t\tlet range;\n\n\t\t\tif ( placeOrOffset == 'in' ) {\n\t\t\t\trange = Range._createIn( selectable );\n\t\t\t} else if ( placeOrOffset == 'on' ) {\n\t\t\t\trange = Range._createOn( selectable );\n\t\t\t} else if ( placeOrOffset !== undefined ) {\n\t\t\t\trange = new Range( Position._createAt( selectable, placeOrOffset ) );\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * selection.setTo requires the second parameter when the first parameter is a node.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-setto-required-second-parameter\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-selection-setto-required-second-parameter', [ this, selectable ] );\n\t\t\t}\n\n\t\t\tthis._setRanges( [ range ], backward );\n\t\t} else if ( isIterable( selectable ) ) {\n\t\t\t// We assume that the selectable is an iterable of ranges.\n\t\t\tthis._setRanges( selectable, placeOrOffset && !!placeOrOffset.backward );\n\t\t} else {\n\t\t\t/**\n\t\t\t * Cannot set the selection to the given place.\n\t\t\t *\n\t\t\t * Invalid parameters were specified when setting the selection. Common issues:\n\t\t\t *\n\t\t\t * * A {@link module:engine/model/textproxy~TextProxy} instance was passed instead of\n\t\t\t * a real {@link module:engine/model/text~Text}.\n\t\t\t * * View nodes were passed instead of model nodes.\n\t\t\t * * `null`/`undefined` was passed.\n\t\t\t *\n\t\t\t * @error model-selection-setto-not-selectable\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-selection-setto-not-selectable', [ this, selectable ] );\n\t\t}\n\t}\n\n\t/**\n\t * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n\t * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and\n\t * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.\n\t *\n\t * @protected\n\t * @fires change:range\n\t * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.\n\t * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)\n\t * or backward - from end to start (`true`).\n\t */\n\t_setRanges( newRanges, isLastBackward = false ) {\n\t\tnewRanges = Array.from( newRanges );\n\n\t\t// Check whether there is any range in new ranges set that is different than all already added ranges.\n\t\tconst anyNewRange = newRanges.some( newRange => {\n\t\t\tif ( !( newRange instanceof Range ) ) {\n\t\t\t\t/**\n\t\t\t\t * Selection range set to an object that is not an instance of {@link module:engine/model/range~Range}.\n\t\t\t\t *\n\t\t\t\t * Only {@link module:engine/model/range~Range} instances can be used to set a selection.\n\t\t\t\t * Common mistakes leading to this error are:\n\t\t\t\t *\n\t\t\t\t * * using DOM `Range` object,\n\t\t\t\t * * incorrect CKEditor 5 installation with multiple `ckeditor5-engine` packages having different versions.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-set-ranges-not-range\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-selection-set-ranges-not-range',\n\t\t\t\t\t[ this, newRanges ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this._ranges.every( oldRange => {\n\t\t\t\treturn !oldRange.isEqual( newRange );\n\t\t\t} );\n\t\t} );\n\n\t\t// Don't do anything if nothing changed.\n\t\tif ( newRanges.length === this._ranges.length && !anyNewRange ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._removeAllRanges();\n\n\t\tfor ( const range of newRanges ) {\n\t\t\tthis._pushRange( range );\n\t\t}\n\n\t\tthis._lastRangeBackward = !!isLastBackward;\n\n\t\tthis.fire( 'change:range', { directChange: true } );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n\t *\n\t * @fires change:range\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tsetFocus( itemOrPosition, offset ) {\n\t\tif ( this.anchor === null ) {\n\t\t\t/**\n\t\t\t * Cannot set selection focus if there are no ranges in selection.\n\t\t\t *\n\t\t\t * @error model-selection-setfocus-no-ranges\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-selection-setfocus-no-ranges', [ this, itemOrPosition ] );\n\t\t}\n\n\t\tconst newFocus = Position._createAt( itemOrPosition, offset );\n\n\t\tif ( newFocus.compareWith( this.focus ) == 'same' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst anchor = this.anchor;\n\n\t\tif ( this._ranges.length ) {\n\t\t\tthis._popRange();\n\t\t}\n\n\t\tif ( newFocus.compareWith( anchor ) == 'before' ) {\n\t\t\tthis._pushRange( new Range( newFocus, anchor ) );\n\t\t\tthis._lastRangeBackward = true;\n\t\t} else {\n\t\t\tthis._pushRange( new Range( anchor, newFocus ) );\n\t\t\tthis._lastRangeBackward = false;\n\t\t}\n\n\t\tthis.fire( 'change:range', { directChange: true } );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Checks if the selection has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the selection.\n\t *\n\t * If given attribute was set on the selection, fires the {@link #event:change:range} event with\n\t * removed attribute key.\n\t *\n\t * @fires change:attribute\n\t * @param {String} key Key of attribute to remove.\n\t */\n\tremoveAttribute( key ) {\n\t\tif ( this.hasAttribute( key ) ) {\n\t\t\tthis._attrs.delete( key );\n\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * If the attribute value has changed, fires the {@link #event:change:range} event with\n\t * the attribute key.\n\t *\n\t * @fires change:attribute\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\tsetAttribute( key, value ) {\n\t\tif ( this.getAttribute( key ) !== value ) {\n\t\t\tthis._attrs.set( key, value );\n\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\tif ( this.rangeCount !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.getFirstRange().getContainedElement();\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tselection.is( 'selection' ); // -> true\n\t *\t\tselection.is( 'model:selection' ); // -> true\n\t *\n\t *\t\tselection.is( 'view:selection' ); // -> false\n\t *\t\tselection.is( 'range' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'selection' || type === 'model:selection';\n\t}\n\n\t/**\n\t * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n\t *\n\t * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n\t *\n\t * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n\t * but will not return blocks nested in other blocks.\n\t *\n\t * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<blockQuote>\n\t *\t\t\t<paragraph>b</paragraph>\n\t *\t\t</blockQuote>\n\t *\t\t<paragraph>c]d</paragraph>\n\t *\n\t * In this case the paragraph will also be returned, despite the collapsed selection:\n\t *\n\t *\t\t<paragraph>[]a</paragraph>\n\t *\n\t * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n\t *\n\t *\t\t[<blockA></blockA>\n\t *\t\t<blockB>\n\t *\t\t\t<blockC></blockC>\n\t *\t\t\t<blockD></blockD>\n\t *\t\t</blockB>\n\t *\t\t<blockE></blockE>]\n\t *\n\t * If the selection is inside a block all the inner blocks (A & B) are returned:\n\t *\n\t * \t\t<block>\n\t *\t\t\t<blockA>[a</blockA>\n\t * \t\t\t<blockB>b]</blockB>\n\t * \t\t</block>\n\t *\n\t * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n\t * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<paragraph>b</paragraph>\n\t *\t\t<paragraph>]c</paragraph> // this block will not be returned\n\t *\n\t * @returns {Iterable.<module:engine/model/element~Element>}\n\t */\n\t* getSelectedBlocks() {\n\t\tconst visited = new WeakSet();\n\n\t\tfor ( const range of this.getRanges() ) {\n\t\t\t// Get start block of range in case of a collapsed range.\n\t\t\tconst startBlock = getParentBlock( range.start, visited );\n\n\t\t\tif ( startBlock && isTopBlockInRange( startBlock, range ) ) {\n\t\t\t\tyield startBlock;\n\t\t\t}\n\n\t\t\tfor ( const value of range.getWalker() ) {\n\t\t\t\tconst block = value.item;\n\n\t\t\t\tif ( value.type == 'elementEnd' && isUnvisitedTopBlock( block, visited, range ) ) {\n\t\t\t\t\tyield block;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst endBlock = getParentBlock( range.end, visited );\n\n\t\t\t// #984. Don't return the end block if the range ends right at its beginning.\n\t\t\tif ( endBlock && !range.end.isTouching( Position._createAt( endBlock, 0 ) ) && isTopBlockInRange( endBlock, range ) ) {\n\t\t\t\tyield endBlock;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether the selection contains the entire content of the given element. This means that selection must start\n\t * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n\t * touching the element's end.\n\t *\n\t * By default, this method will check whether the entire content of the selection's current root is selected.\n\t * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n\t *\n\t * @param {module:engine/model/element~Element} [element=this.anchor.root]\n\t * @returns {Boolean}\n\t */\n\tcontainsEntireContent( element = this.anchor.root ) {\n\t\tconst limitStartPosition = Position._createAt( element, 0 );\n\t\tconst limitEndPosition = Position._createAt( element, 'end' );\n\n\t\treturn limitStartPosition.isTouching( this.getFirstPosition() ) &&\n\t\t\tlimitEndPosition.isTouching( this.getLastPosition() );\n\t}\n\n\t/**\n\t * Adds given range to internal {@link #_ranges ranges array}. Throws an error\n\t * if given range is intersecting with any range that is already stored in this selection.\n\t *\n\t * @protected\n\t * @param {module:engine/model/range~Range} range Range to add.\n\t */\n\t_pushRange( range ) {\n\t\tthis._checkRange( range );\n\t\tthis._ranges.push( new Range( range.start, range.end ) );\n\t}\n\n\t/**\n\t * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.\n\t *\n\t * @protected\n\t * @param {module:engine/model/range~Range} range Range to check.\n\t */\n\t_checkRange( range ) {\n\t\tfor ( let i = 0; i < this._ranges.length; i++ ) {\n\t\t\tif ( range.isIntersecting( this._ranges[ i ] ) ) {\n\t\t\t\t/**\n\t\t\t\t * Trying to add a range that intersects with another range in the selection.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-range-intersects\n\t\t\t\t * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.\n\t\t\t\t * @param {module:engine/model/range~Range} intersectingRange Range in the selection that intersects with `addedRange`.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-selection-range-intersects',\n\t\t\t\t\t[ this, range ],\n\t\t\t\t\t{ addedRange: range, intersectingRange: this._ranges[ i ] }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to\n\t * ensure proper ranges removal.\n\t *\n\t * @protected\n\t */\n\t_removeAllRanges() {\n\t\twhile ( this._ranges.length > 0 ) {\n\t\t\tthis._popRange();\n\t\t}\n\t}\n\n\t/**\n\t * Removes most recently added range from the selection.\n\t *\n\t * @protected\n\t */\n\t_popRange() {\n\t\tthis._ranges.pop();\n\t}\n\n\t/**\n\t * Fired when selection range(s) changed.\n\t *\n\t * @event change:range\n\t * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n\t * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n\t * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n\t * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n\t * changed because the structure of the model has been changed (which means an indirect change).\n\t * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n\t * which mean that they are not updated once the document changes.\n\t */\n\n\t/**\n\t * Fired when selection attribute changed.\n\t *\n\t * @event change:attribute\n\t * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n\t * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n\t * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n\t * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n\t * changed in the model and its attributes were refreshed (which means an indirect change).\n\t * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n\t * which mean that they are not updated once the document changes.\n\t * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n\t */\n}\n\nmix( Selection, EmitterMixin );\n\n// Checks whether the given element extends $block in the schema and has a parent (is not a root).\n// Marks it as already visited.\nfunction isUnvisitedBlock( element, visited ) {\n\tif ( visited.has( element ) ) {\n\t\treturn false;\n\t}\n\n\tvisited.add( element );\n\n\treturn element.root.document.model.schema.isBlock( element ) && element.parent;\n}\n\n// Checks if the given element is a $block was not previously visited and is a top block in a range.\nfunction isUnvisitedTopBlock( element, visited, range ) {\n\treturn isUnvisitedBlock( element, visited ) && isTopBlockInRange( element, range );\n}\n\n// Finds the lowest element in position's ancestors which is a block.\n// It will search until first ancestor that is a limit element.\n// Marks all ancestors as already visited to not include any of them later on.\nfunction getParentBlock( position, visited ) {\n\tconst element = position.parent;\n\tconst schema = element.root.document.model.schema;\n\n\tconst ancestors = position.parent.getAncestors( { parentFirst: true, includeSelf: true } );\n\n\tlet hasParentLimit = false;\n\n\tconst block = ancestors.find( element => {\n\t\t// Stop searching after first parent node that is limit element.\n\t\tif ( hasParentLimit ) {\n\t\t\treturn false;\n\t\t}\n\n\t\thasParentLimit = schema.isLimit( element );\n\n\t\treturn !hasParentLimit && isUnvisitedBlock( element, visited );\n\t} );\n\n\t// Mark all ancestors of this position's parent, because find() might've stopped early and\n\t// the found block may be a child of another block.\n\tancestors.forEach( element => visited.add( element ) );\n\n\treturn block;\n}\n\n// Checks if the blocks is not nested in other block inside a range.\n//\n// @param {module:engine/model/element~Element} block Block to check.\n// @param {module:engine/model/range~Range} range Range to check.\nfunction isTopBlockInRange( block, range ) {\n\tconst parentBlock = findAncestorBlock( block );\n\n\tif ( !parentBlock ) {\n\t\treturn true;\n\t}\n\n\t// Add loose flag to check as parentRange can be equal to range.\n\tconst isParentInRange = range.containsRange( Range._createOn( parentBlock ), true );\n\n\treturn !isParentInRange;\n}\n\n// Returns first ancestor block of a node.\n//\n// @param {module:engine/model/node~Node} node\n// @returns {module:engine/model/node~Node|undefined}\nfunction findAncestorBlock( node ) {\n\tconst schema = node.root.document.model.schema;\n\n\tlet parent = node.parent;\n\n\twhile ( parent ) {\n\t\tif ( schema.isBlock( parent ) ) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tparent = parent.parent;\n\t}\n}\n\n/**\n * An entity that is used to set selection.\n *\n * See also {@link module:engine/model/selection~Selection#setTo}\n *\n * @typedef {\n *     module:engine/model/selection~Selection|\n *     module:engine/model/documentselection~DocumentSelection|\n *     module:engine/model/position~Position|\n *     module:engine/model/range~Range|\n *     module:engine/model/node~Node|\n *     Iterable.<module:engine/model/range~Range>|\n *     null\n * } module:engine/model/selection~Selectable\n */\n"]},"metadata":{},"sourceType":"module"}