{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and\n * {@link module:engine/model/model the model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map complex model to/from view relations, you may provide custom callbacks for\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Mapper {\n  /**\n   * Creates an instance of the mapper.\n   */\n  constructor() {\n    /**\n     * Model element to view element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n    this._modelToViewMapping = new WeakMap();\n    /**\n     * View element to model element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n\n    this._viewToModelMapping = new WeakMap();\n    /**\n     * A map containing callbacks between view element names and functions evaluating length of view elements\n     * in model.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._viewToModelLengthCallbacks = new Map();\n    /**\n     * Model marker name to view elements mapping.\n     *\n     * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n     * One marker (name) can be mapped to multiple elements.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._markerNameToElements = new Map();\n    /**\n     * View element to model marker names mapping.\n     *\n     * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._elementToMarkerNames = new Map();\n    /**\n     * Stores marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n     * has been removed, moved or renamed).\n     *\n     * @private\n     * @member {Set.<module:engine/model/markercollection~Marker>}\n     */\n\n    this._unboundMarkerNames = new Set(); // Default mapper algorithm for mapping model position to view position.\n\n    this.on('modelToViewPosition', (evt, data) => {\n      if (data.viewPosition) {\n        return;\n      }\n\n      const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);\n\n      data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);\n    }, {\n      priority: 'low'\n    }); // Default mapper algorithm for mapping view position to model position.\n\n    this.on('viewToModelPosition', (evt, data) => {\n      if (data.modelPosition) {\n        return;\n      }\n\n      const viewBlock = this.findMappedViewAncestor(data.viewPosition);\n\n      const modelParent = this._viewToModelMapping.get(viewBlock);\n\n      const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);\n\n      data.modelPosition = ModelPosition._createAt(modelParent, modelOffset);\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n   * The information that elements are bound is also used to translate positions.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element.\n   * @param {module:engine/view/element~Element} viewElement View element.\n   */\n\n\n  bindElements(modelElement, viewElement) {\n    this._modelToViewMapping.set(modelElement, viewElement);\n\n    this._viewToModelMapping.set(viewElement, modelElement);\n  }\n  /**\n   * Unbinds given {@link module:engine/view/element~Element view element} from the map.\n   *\n   * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n   * will be removed only if model element is still bound to passed `viewElement`.\n   *\n   * This behavior lets for re-binding model element to another view element without fear of losing the new binding\n   * when the previously bound view element is unbound.\n   *\n   * @param {module:engine/view/element~Element} viewElement View element to unbind.\n   */\n\n\n  unbindViewElement(viewElement) {\n    const modelElement = this.toModelElement(viewElement);\n\n    this._viewToModelMapping.delete(viewElement);\n\n    if (this._elementToMarkerNames.has(viewElement)) {\n      for (const markerName of this._elementToMarkerNames.get(viewElement)) {\n        this._unboundMarkerNames.add(markerName);\n      }\n    }\n\n    if (this._modelToViewMapping.get(modelElement) == viewElement) {\n      this._modelToViewMapping.delete(modelElement);\n    }\n  }\n  /**\n   * Unbinds given {@link module:engine/model/element~Element model element} from the map.\n   *\n   * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding\n   * will be removed only if view element is still bound to passed `modelElement`.\n   *\n   * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n   * when the previously bound model element is unbound.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n   */\n\n\n  unbindModelElement(modelElement) {\n    const viewElement = this.toViewElement(modelElement);\n\n    this._modelToViewMapping.delete(modelElement);\n\n    if (this._viewToModelMapping.get(viewElement) == modelElement) {\n      this._viewToModelMapping.delete(viewElement);\n    }\n  }\n  /**\n   * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element\n   * will be added to the current set of elements bound with given marker name.\n   *\n   * @param {module:engine/view/element~Element} element Element to bind.\n   * @param {String} name Marker name.\n   */\n\n\n  bindElementToMarker(element, name) {\n    const elements = this._markerNameToElements.get(name) || new Set();\n    elements.add(element);\n    const names = this._elementToMarkerNames.get(element) || new Set();\n    names.add(name);\n\n    this._markerNameToElements.set(name, elements);\n\n    this._elementToMarkerNames.set(element, names);\n  }\n  /**\n   * Unbinds an element from given marker name.\n   *\n   * @param {module:engine/view/element~Element} element Element to unbind.\n   * @param {String} name Marker name.\n   */\n\n\n  unbindElementFromMarkerName(element, name) {\n    const nameToElements = this._markerNameToElements.get(name);\n\n    if (nameToElements) {\n      nameToElements.delete(element);\n\n      if (nameToElements.size == 0) {\n        this._markerNameToElements.delete(name);\n      }\n    }\n\n    const elementToNames = this._elementToMarkerNames.get(element);\n\n    if (elementToNames) {\n      elementToNames.delete(name);\n\n      if (elementToNames.size == 0) {\n        this._elementToMarkerNames.delete(element);\n      }\n    }\n  }\n  /**\n   * Returns all marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n   * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n   *\n   * @returns {Array.<String>}\n   */\n\n\n  flushUnboundMarkerNames() {\n    const markerNames = Array.from(this._unboundMarkerNames);\n\n    this._unboundMarkerNames.clear();\n\n    return markerNames;\n  }\n  /**\n   * Removes all model to view and view to model bindings.\n   */\n\n\n  clearBindings() {\n    this._modelToViewMapping = new WeakMap();\n    this._viewToModelMapping = new WeakMap();\n    this._markerNameToElements = new Map();\n    this._elementToMarkerNames = new Map();\n    this._unboundMarkerNames = new Set();\n  }\n  /**\n   * Gets the corresponding model element.\n   *\n   * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n   *\n   * @param {module:engine/view/element~Element} viewElement View element.\n   * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n   */\n\n\n  toModelElement(viewElement) {\n    return this._viewToModelMapping.get(viewElement);\n  }\n  /**\n   * Gets the corresponding view element.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element.\n   * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n   */\n\n\n  toViewElement(modelElement) {\n    return this._modelToViewMapping.get(modelElement);\n  }\n  /**\n   * Gets the corresponding model range.\n   *\n   * @param {module:engine/view/range~Range} viewRange View range.\n   * @returns {module:engine/model/range~Range} Corresponding model range.\n   */\n\n\n  toModelRange(viewRange) {\n    return new ModelRange(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));\n  }\n  /**\n   * Gets the corresponding view range.\n   *\n   * @param {module:engine/model/range~Range} modelRange Model range.\n   * @returns {module:engine/view/range~Range} Corresponding view range.\n   */\n\n\n  toViewRange(modelRange) {\n    return new ViewRange(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));\n  }\n  /**\n   * Gets the corresponding model position.\n   *\n   * @fires viewToModelPosition\n   * @param {module:engine/view/position~Position} viewPosition View position.\n   * @returns {module:engine/model/position~Position} Corresponding model position.\n   */\n\n\n  toModelPosition(viewPosition) {\n    const data = {\n      viewPosition,\n      mapper: this\n    };\n    this.fire('viewToModelPosition', data);\n    return data.modelPosition;\n  }\n  /**\n   * Gets the corresponding view position.\n   *\n   * @fires modelToViewPosition\n   * @param {module:engine/model/position~Position} modelPosition Model position.\n   * @param {Object} [options] Additional options for position mapping process.\n   * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n   * in model tree which no longer exists. For example, it could be an end of a removed model range.\n   * @returns {module:engine/view/position~Position} Corresponding view position.\n   */\n\n\n  toViewPosition(modelPosition) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      isPhantom: false\n    };\n    const data = {\n      modelPosition,\n      mapper: this,\n      isPhantom: options.isPhantom\n    };\n    this.fire('modelToViewPosition', data);\n    return data.viewPosition;\n  }\n  /**\n   * Gets all view elements bound to the given marker name.\n   *\n   * @param {String} name Marker name.\n   * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`\n   * if no elements are bound to given marker name.\n   */\n\n\n  markerNameToElements(name) {\n    const boundElements = this._markerNameToElements.get(name);\n\n    if (!boundElements) {\n      return null;\n    }\n\n    const elements = new Set();\n\n    for (const element of boundElements) {\n      if (element.is('attributeElement')) {\n        for (const clone of element.getElementsWithSameId()) {\n          elements.add(clone);\n        }\n      } else {\n        elements.add(element);\n      }\n    }\n\n    return elements;\n  }\n  /**\n   * Registers a callback that evaluates the length in the model of a view element with given name.\n   *\n   * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n   * a number representing the length of view element in model.\n   *\n   *\t\t// List item in view may contain nested list, which have other list items. In model though,\n   *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n   *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n   *\n   *\t\tfunction getViewListItemLength( element ) {\n   *\t\t\tlet length = 1;\n   *\n   *\t\t\tfor ( let child of element.getChildren() ) {\n   *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n   *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n   *\t\t\t\t\t\tlength += getViewListItemLength( item );\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t}\n   *\n   *\t\t\treturn length;\n   *\t\t}\n   *\n   *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n   *\n   * @param {String} viewElementName Name of view element for which callback is registered.\n   * @param {Function} lengthCallback Function return a length of view element instance in model.\n   */\n\n\n  registerViewToModelLength(viewElementName, lengthCallback) {\n    this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);\n  }\n  /**\n   * For given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n   * the model.\n   *\n   * @param {module:engine/view/position~Position} viewPosition Position for which mapped ancestor should be found.\n   * @returns {module:engine/view/element~Element}\n   */\n\n\n  findMappedViewAncestor(viewPosition) {\n    let parent = viewPosition.parent;\n\n    while (!this._viewToModelMapping.has(parent)) {\n      parent = parent.parent;\n    }\n\n    return parent;\n  }\n  /**\n   * Calculates model offset based on the view position and the block element.\n   *\n   * Example:\n   *\n   *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n   *\n   * Is a sum of:\n   *\n   *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n   *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewParent Position parent.\n   * @param {Number} viewOffset Position offset.\n   * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n   * @returns {Number} Offset in the model.\n   */\n\n\n  _toModelOffset(viewParent, viewOffset, viewBlock) {\n    if (viewBlock != viewParent) {\n      // See example.\n      const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);\n\n      const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);\n\n      return offsetToParentStart + offsetInParent;\n    } // viewBlock == viewParent, so we need to calculate the offset in the parent element.\n    // If the position is a text it is simple (\"ba|r\" -> 2).\n\n\n    if (viewParent.is('$text')) {\n      return viewOffset;\n    } // If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\n\n    let modelOffset = 0;\n\n    for (let i = 0; i < viewOffset; i++) {\n      modelOffset += this.getModelLength(viewParent.getChild(i));\n    }\n\n    return modelOffset;\n  }\n  /**\n   * Gets the length of the view element in the model.\n   *\n   * The length is calculated as follows:\n   * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to\n   * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),\n   * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's\n   * {@link module:engine/view/text~Text#data data},\n   * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n   * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n   * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.\n   *\n   * Examples:\n   *\n   *\t\tfoo                          -> 3 // Text length is equal to it's data length.\n   *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n   *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n   *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n   *\n   * @param {module:engine/view/element~Element} viewNode View node.\n   * @returns {Number} Length of the node in the tree model.\n   */\n\n\n  getModelLength(viewNode) {\n    if (this._viewToModelLengthCallbacks.get(viewNode.name)) {\n      const callback = this._viewToModelLengthCallbacks.get(viewNode.name);\n\n      return callback(viewNode);\n    } else if (this._viewToModelMapping.has(viewNode)) {\n      return 1;\n    } else if (viewNode.is('$text')) {\n      return viewNode.data.length;\n    } else if (viewNode.is('uiElement')) {\n      return 0;\n    } else {\n      let len = 0;\n\n      for (const child of viewNode.getChildren()) {\n        len += this.getModelLength(child);\n      }\n\n      return len;\n    }\n  }\n  /**\n   * Finds the position in the view node (or its children) with the expected model offset.\n   *\n   * Example:\n   *\n   *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n   *\n   *\t\tfindPositionIn( p, 4 ):\n   *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n   *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n   *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n   *\n   *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n   *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n   *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n   *\n   *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n   *\t\tWe are in the text node so we can simple find the offset.\n   *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n   *\n   * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n   * @param {Number} expectedOffset Expected offset.\n   * @returns {module:engine/view/position~Position} Found position.\n   */\n\n\n  findPositionIn(viewParent, expectedOffset) {\n    // Last scanned view node.\n    let viewNode; // Length of the last scanned view node.\n\n    let lastLength = 0;\n    let modelOffset = 0;\n    let viewOffset = 0; // In the text node it is simple: offset in the model equals offset in the text.\n\n    if (viewParent.is('$text')) {\n      return new ViewPosition(viewParent, expectedOffset);\n    } // In other cases we add lengths of child nodes to find the proper offset.\n    // If it is smaller we add the length.\n\n\n    while (modelOffset < expectedOffset) {\n      viewNode = viewParent.getChild(viewOffset);\n      lastLength = this.getModelLength(viewNode);\n      modelOffset += lastLength;\n      viewOffset++;\n    } // If it equals we found the position.\n\n\n    if (modelOffset == expectedOffset) {\n      return this._moveViewPositionToTextNode(new ViewPosition(viewParent, viewOffset));\n    } // If it is higher we need to enter last child.\n    else {\n      // ( modelOffset - lastLength ) is the offset to the child we enter,\n      // so we subtract it from the expected offset to fine the offset in the child.\n      return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));\n    }\n  }\n  /**\n   * Because we prefer positions in text nodes over positions next to text node moves view position to the text node\n   * if it was next to it.\n   *\n   *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n   *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n   *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n   *\n   * @private\n   * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.\n   * @returns {module:engine/view/position~Position} Position in text node if possible.\n   */\n\n\n  _moveViewPositionToTextNode(viewPosition) {\n    // If the position is just after text node, put it at the end of that text node.\n    // If the position is just before text node, put it at the beginning of that text node.\n    const nodeBefore = viewPosition.nodeBefore;\n    const nodeAfter = viewPosition.nodeAfter;\n\n    if (nodeBefore instanceof ViewText) {\n      return new ViewPosition(nodeBefore, nodeBefore.data.length);\n    } else if (nodeAfter instanceof ViewText) {\n      return new ViewPosition(nodeAfter, 0);\n    } // Otherwise, just return the given position.\n\n\n    return viewPosition;\n  }\n  /**\n   * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n   * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n   * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`\n   * value in `data` object that is passed as one of parameters to the event callback.\n   *\n   * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n   * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n   * \t\t// <span> element.\n   *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n   *\t\t\tconst positionParent = modelPosition.parent;\n   *\n   *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n   *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n   *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n   *\n   *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n   *\n   *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n   *\t\t\t\tevt.stop();\n   *\t\t\t}\n   *\t\t} );\n   *\n   * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. \"Phantom\" model position is\n   * a position that points to a non-existing place in model. Such position might still be valid for conversion, though\n   * (it would point to a correct place in view when converted). One example of such situation is when a range is\n   * removed from model, there may be a need to map the range's end (which is no longer valid model position). To\n   * handle such situation, check `data.isPhantom` flag:\n   *\n   * \t\t// Assume that there is \"customElement\" model element and whenever position is before it, we want to move it\n   * \t\t// to the inside of the view element bound to \"customElement\".\n   *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n   *\t\t\tif ( data.isPhantom ) {\n   *\t\t\t\treturn;\n   *\t\t\t}\n   *\n   *\t\t\t// Below line might crash for phantom position that does not exist in model.\n   *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n   *\n   *\t\t\t// Check if this is the element we are interested in.\n   *\t\t\tif ( !sibling.is( 'element', 'customElement' ) ) {\n   *\t\t\t\treturn;\n   *\t\t\t}\n   *\n   *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n   *\n   *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n   *\n   *\t\t\tevt.stop();\n   *\t\t} );\n   *\n   * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n   * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback\n   * (for example to fix it).\n   *\n   * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.\n   *\n   * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n   * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n   * the condition that checks if special case scenario happened should be as simple as possible.\n   *\n   * @event modelToViewPosition\n   * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n   * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.\n   * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n   */\n\n  /**\n   * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n   *\n   * \t\t// See example in `modelToViewPosition` event description.\n   * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n   *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n   *\t\t\tconst positionParent = viewPosition.parent;\n   *\n   *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n   *\t\t\t\tconst viewImg = positionParent.previousSibling;\n   *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n   *\n   *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n   *\t\t\t\tevt.stop();\n   *\t\t\t}\n   *\t\t} );\n   *\n   * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n   * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback\n   * (for example to fix it).\n   *\n   * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.\n   *\n   * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n   * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n   * the condition that checks if special case scenario happened should be as simple as possible.\n   *\n   * @event viewToModelPosition\n   * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n   * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n   * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n   */\n\n\n}\nmix(Mapper, EmitterMixin);","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js"],"names":["ModelPosition","ModelRange","ViewPosition","ViewRange","ViewText","EmitterMixin","mix","Mapper","constructor","_modelToViewMapping","WeakMap","_viewToModelMapping","_viewToModelLengthCallbacks","Map","_markerNameToElements","_elementToMarkerNames","_unboundMarkerNames","Set","on","evt","data","viewPosition","viewContainer","get","modelPosition","parent","findPositionIn","offset","priority","viewBlock","findMappedViewAncestor","modelParent","modelOffset","_toModelOffset","_createAt","bindElements","modelElement","viewElement","set","unbindViewElement","toModelElement","delete","has","markerName","add","unbindModelElement","toViewElement","bindElementToMarker","element","name","elements","names","unbindElementFromMarkerName","nameToElements","size","elementToNames","flushUnboundMarkerNames","markerNames","Array","from","clear","clearBindings","toModelRange","viewRange","toModelPosition","start","end","toViewRange","modelRange","toViewPosition","mapper","fire","options","isPhantom","markerNameToElements","boundElements","is","clone","getElementsWithSameId","registerViewToModelLength","viewElementName","lengthCallback","viewParent","viewOffset","offsetToParentStart","index","offsetInParent","i","getModelLength","getChild","viewNode","callback","length","len","child","getChildren","expectedOffset","lastLength","_moveViewPositionToTextNode","nodeBefore","nodeAfter"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\n\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\n\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and\n * {@link module:engine/model/model the model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map complex model to/from view relations, you may provide custom callbacks for\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Mapper {\n\t/**\n\t * Creates an instance of the mapper.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Model element to view element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._modelToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View element to model element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._viewToModelMapping = new WeakMap();\n\n\t\t/**\n\t\t * A map containing callbacks between view element names and functions evaluating length of view elements\n\t\t * in model.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._viewToModelLengthCallbacks = new Map();\n\n\t\t/**\n\t\t * Model marker name to view elements mapping.\n\t\t *\n\t\t * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n\t\t * One marker (name) can be mapped to multiple elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._markerNameToElements = new Map();\n\n\t\t/**\n\t\t * View element to model marker names mapping.\n\t\t *\n\t\t * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._elementToMarkerNames = new Map();\n\n\t\t/**\n\t\t * Stores marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t\t * has been removed, moved or renamed).\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/markercollection~Marker>}\n\t\t */\n\t\tthis._unboundMarkerNames = new Set();\n\n\t\t// Default mapper algorithm for mapping model position to view position.\n\t\tthis.on( 'modelToViewPosition', ( evt, data ) => {\n\t\t\tif ( data.viewPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewContainer = this._modelToViewMapping.get( data.modelPosition.parent );\n\n\t\t\tdata.viewPosition = this.findPositionIn( viewContainer, data.modelPosition.offset );\n\t\t}, { priority: 'low' } );\n\n\t\t// Default mapper algorithm for mapping view position to model position.\n\t\tthis.on( 'viewToModelPosition', ( evt, data ) => {\n\t\t\tif ( data.modelPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewBlock = this.findMappedViewAncestor( data.viewPosition );\n\t\t\tconst modelParent = this._viewToModelMapping.get( viewBlock );\n\t\t\tconst modelOffset = this._toModelOffset( data.viewPosition.parent, data.viewPosition.offset, viewBlock );\n\n\t\t\tdata.modelPosition = ModelPosition._createAt( modelParent, modelOffset );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n\t * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n\t * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n\t * The information that elements are bound is also used to translate positions.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t */\n\tbindElements( modelElement, viewElement ) {\n\t\tthis._modelToViewMapping.set( modelElement, viewElement );\n\t\tthis._viewToModelMapping.set( viewElement, modelElement );\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/view/element~Element view element} from the map.\n\t *\n\t * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n\t * will be removed only if model element is still bound to passed `viewElement`.\n\t *\n\t * This behavior lets for re-binding model element to another view element without fear of losing the new binding\n\t * when the previously bound view element is unbound.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element to unbind.\n\t */\n\tunbindViewElement( viewElement ) {\n\t\tconst modelElement = this.toModelElement( viewElement );\n\n\t\tthis._viewToModelMapping.delete( viewElement );\n\n\t\tif ( this._elementToMarkerNames.has( viewElement ) ) {\n\t\t\tfor ( const markerName of this._elementToMarkerNames.get( viewElement ) ) {\n\t\t\t\tthis._unboundMarkerNames.add( markerName );\n\t\t\t}\n\t\t}\n\n\t\tif ( this._modelToViewMapping.get( modelElement ) == viewElement ) {\n\t\t\tthis._modelToViewMapping.delete( modelElement );\n\t\t}\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/model/element~Element model element} from the map.\n\t *\n\t * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding\n\t * will be removed only if view element is still bound to passed `modelElement`.\n\t *\n\t * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n\t * when the previously bound model element is unbound.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n\t */\n\tunbindModelElement( modelElement ) {\n\t\tconst viewElement = this.toViewElement( modelElement );\n\n\t\tthis._modelToViewMapping.delete( modelElement );\n\n\t\tif ( this._viewToModelMapping.get( viewElement ) == modelElement ) {\n\t\t\tthis._viewToModelMapping.delete( viewElement );\n\t\t}\n\t}\n\n\t/**\n\t * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element\n\t * will be added to the current set of elements bound with given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to bind.\n\t * @param {String} name Marker name.\n\t */\n\tbindElementToMarker( element, name ) {\n\t\tconst elements = this._markerNameToElements.get( name ) || new Set();\n\t\telements.add( element );\n\n\t\tconst names = this._elementToMarkerNames.get( element ) || new Set();\n\t\tnames.add( name );\n\n\t\tthis._markerNameToElements.set( name, elements );\n\t\tthis._elementToMarkerNames.set( element, names );\n\t}\n\n\t/**\n\t * Unbinds an element from given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to unbind.\n\t * @param {String} name Marker name.\n\t */\n\tunbindElementFromMarkerName( element, name ) {\n\t\tconst nameToElements = this._markerNameToElements.get( name );\n\n\t\tif ( nameToElements ) {\n\t\t\tnameToElements.delete( element );\n\n\t\t\tif ( nameToElements.size == 0 ) {\n\t\t\t\tthis._markerNameToElements.delete( name );\n\t\t\t}\n\t\t}\n\n\t\tconst elementToNames = this._elementToMarkerNames.get( element );\n\n\t\tif ( elementToNames ) {\n\t\t\telementToNames.delete( name );\n\n\t\t\tif ( elementToNames.size == 0 ) {\n\t\t\t\tthis._elementToMarkerNames.delete( element );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tflushUnboundMarkerNames() {\n\t\tconst markerNames = Array.from( this._unboundMarkerNames );\n\n\t\tthis._unboundMarkerNames.clear();\n\n\t\treturn markerNames;\n\t}\n\n\t/**\n\t * Removes all model to view and view to model bindings.\n\t */\n\tclearBindings() {\n\t\tthis._modelToViewMapping = new WeakMap();\n\t\tthis._viewToModelMapping = new WeakMap();\n\t\tthis._markerNameToElements = new Map();\n\t\tthis._elementToMarkerNames = new Map();\n\t\tthis._unboundMarkerNames = new Set();\n\t}\n\n\t/**\n\t * Gets the corresponding model element.\n\t *\n\t * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n\t */\n\ttoModelElement( viewElement ) {\n\t\treturn this._viewToModelMapping.get( viewElement );\n\t}\n\n\t/**\n\t * Gets the corresponding view element.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n\t */\n\ttoViewElement( modelElement ) {\n\t\treturn this._modelToViewMapping.get( modelElement );\n\t}\n\n\t/**\n\t * Gets the corresponding model range.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {module:engine/model/range~Range} Corresponding model range.\n\t */\n\ttoModelRange( viewRange ) {\n\t\treturn new ModelRange( this.toModelPosition( viewRange.start ), this.toModelPosition( viewRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding view range.\n\t *\n\t * @param {module:engine/model/range~Range} modelRange Model range.\n\t * @returns {module:engine/view/range~Range} Corresponding view range.\n\t */\n\ttoViewRange( modelRange ) {\n\t\treturn new ViewRange( this.toViewPosition( modelRange.start ), this.toViewPosition( modelRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding model position.\n\t *\n\t * @fires viewToModelPosition\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {module:engine/model/position~Position} Corresponding model position.\n\t */\n\ttoModelPosition( viewPosition ) {\n\t\tconst data = {\n\t\t\tviewPosition,\n\t\t\tmapper: this\n\t\t};\n\n\t\tthis.fire( 'viewToModelPosition', data );\n\n\t\treturn data.modelPosition;\n\t}\n\n\t/**\n\t * Gets the corresponding view position.\n\t *\n\t * @fires modelToViewPosition\n\t * @param {module:engine/model/position~Position} modelPosition Model position.\n\t * @param {Object} [options] Additional options for position mapping process.\n\t * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n\t * in model tree which no longer exists. For example, it could be an end of a removed model range.\n\t * @returns {module:engine/view/position~Position} Corresponding view position.\n\t */\n\ttoViewPosition( modelPosition, options = { isPhantom: false } ) {\n\t\tconst data = {\n\t\t\tmodelPosition,\n\t\t\tmapper: this,\n\t\t\tisPhantom: options.isPhantom\n\t\t};\n\n\t\tthis.fire( 'modelToViewPosition', data );\n\n\t\treturn data.viewPosition;\n\t}\n\n\t/**\n\t * Gets all view elements bound to the given marker name.\n\t *\n\t * @param {String} name Marker name.\n\t * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`\n\t * if no elements are bound to given marker name.\n\t */\n\tmarkerNameToElements( name ) {\n\t\tconst boundElements = this._markerNameToElements.get( name );\n\n\t\tif ( !boundElements ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements = new Set();\n\n\t\tfor ( const element of boundElements ) {\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tfor ( const clone of element.getElementsWithSameId() ) {\n\t\t\t\t\telements.add( clone );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements.add( element );\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Registers a callback that evaluates the length in the model of a view element with given name.\n\t *\n\t * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n\t * a number representing the length of view element in model.\n\t *\n\t *\t\t// List item in view may contain nested list, which have other list items. In model though,\n\t *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n\t *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n\t *\n\t *\t\tfunction getViewListItemLength( element ) {\n\t *\t\t\tlet length = 1;\n\t *\n\t *\t\t\tfor ( let child of element.getChildren() ) {\n\t *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n\t *\t\t\t\t\t\tlength += getViewListItemLength( item );\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn length;\n\t *\t\t}\n\t *\n\t *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n\t *\n\t * @param {String} viewElementName Name of view element for which callback is registered.\n\t * @param {Function} lengthCallback Function return a length of view element instance in model.\n\t */\n\tregisterViewToModelLength( viewElementName, lengthCallback ) {\n\t\tthis._viewToModelLengthCallbacks.set( viewElementName, lengthCallback );\n\t}\n\n\t/**\n\t * For given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n\t * the model.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition Position for which mapped ancestor should be found.\n\t * @returns {module:engine/view/element~Element}\n\t */\n\tfindMappedViewAncestor( viewPosition ) {\n\t\tlet parent = viewPosition.parent;\n\n\t\twhile ( !this._viewToModelMapping.has( parent ) ) {\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Calculates model offset based on the view position and the block element.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n\t *\n\t * Is a sum of:\n\t *\n\t *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Position parent.\n\t * @param {Number} viewOffset Position offset.\n\t * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n\t * @returns {Number} Offset in the model.\n\t */\n\t_toModelOffset( viewParent, viewOffset, viewBlock ) {\n\t\tif ( viewBlock != viewParent ) {\n\t\t\t// See example.\n\t\t\tconst offsetToParentStart = this._toModelOffset( viewParent.parent, viewParent.index, viewBlock );\n\t\t\tconst offsetInParent = this._toModelOffset( viewParent, viewOffset, viewParent );\n\n\t\t\treturn offsetToParentStart + offsetInParent;\n\t\t}\n\n\t\t// viewBlock == viewParent, so we need to calculate the offset in the parent element.\n\n\t\t// If the position is a text it is simple (\"ba|r\" -> 2).\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\treturn viewOffset;\n\t\t}\n\n\t\t// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\t\tlet modelOffset = 0;\n\n\t\tfor ( let i = 0; i < viewOffset; i++ ) {\n\t\t\tmodelOffset += this.getModelLength( viewParent.getChild( i ) );\n\t\t}\n\n\t\treturn modelOffset;\n\t}\n\n\t/**\n\t * Gets the length of the view element in the model.\n\t *\n\t * The length is calculated as follows:\n\t * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to\n\t * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),\n\t * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's\n\t * {@link module:engine/view/text~Text#data data},\n\t * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n\t * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n\t * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.\n\t *\n\t * Examples:\n\t *\n\t *\t\tfoo                          -> 3 // Text length is equal to it's data length.\n\t *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n\t *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n\t *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n\t *\n\t * @param {module:engine/view/element~Element} viewNode View node.\n\t * @returns {Number} Length of the node in the tree model.\n\t */\n\tgetModelLength( viewNode ) {\n\t\tif ( this._viewToModelLengthCallbacks.get( viewNode.name ) ) {\n\t\t\tconst callback = this._viewToModelLengthCallbacks.get( viewNode.name );\n\n\t\t\treturn callback( viewNode );\n\t\t} else if ( this._viewToModelMapping.has( viewNode ) ) {\n\t\t\treturn 1;\n\t\t} else if ( viewNode.is( '$text' ) ) {\n\t\t\treturn viewNode.data.length;\n\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tlet len = 0;\n\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tlen += this.getModelLength( child );\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t}\n\n\t/**\n\t * Finds the position in the view node (or its children) with the expected model offset.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n\t *\n\t *\t\tfindPositionIn( p, 4 ):\n\t *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n\t *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n\t *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n\t *\n\t *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n\t *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n\t *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n\t *\n\t *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n\t *\t\tWe are in the text node so we can simple find the offset.\n\t *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n\t *\n\t * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n\t * @param {Number} expectedOffset Expected offset.\n\t * @returns {module:engine/view/position~Position} Found position.\n\t */\n\tfindPositionIn( viewParent, expectedOffset ) {\n\t\t// Last scanned view node.\n\t\tlet viewNode;\n\t\t// Length of the last scanned view node.\n\t\tlet lastLength = 0;\n\n\t\tlet modelOffset = 0;\n\t\tlet viewOffset = 0;\n\n\t\t// In the text node it is simple: offset in the model equals offset in the text.\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\treturn new ViewPosition( viewParent, expectedOffset );\n\t\t}\n\n\t\t// In other cases we add lengths of child nodes to find the proper offset.\n\n\t\t// If it is smaller we add the length.\n\t\twhile ( modelOffset < expectedOffset ) {\n\t\t\tviewNode = viewParent.getChild( viewOffset );\n\t\t\tlastLength = this.getModelLength( viewNode );\n\t\t\tmodelOffset += lastLength;\n\t\t\tviewOffset++;\n\t\t}\n\n\t\t// If it equals we found the position.\n\t\tif ( modelOffset == expectedOffset ) {\n\t\t\treturn this._moveViewPositionToTextNode( new ViewPosition( viewParent, viewOffset ) );\n\t\t}\n\t\t// If it is higher we need to enter last child.\n\t\telse {\n\t\t\t// ( modelOffset - lastLength ) is the offset to the child we enter,\n\t\t\t// so we subtract it from the expected offset to fine the offset in the child.\n\t\t\treturn this.findPositionIn( viewNode, expectedOffset - ( modelOffset - lastLength ) );\n\t\t}\n\t}\n\n\t/**\n\t * Because we prefer positions in text nodes over positions next to text node moves view position to the text node\n\t * if it was next to it.\n\t *\n\t *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n\t *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n\t *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.\n\t * @returns {module:engine/view/position~Position} Position in text node if possible.\n\t */\n\t_moveViewPositionToTextNode( viewPosition ) {\n\t\t// If the position is just after text node, put it at the end of that text node.\n\t\t// If the position is just before text node, put it at the beginning of that text node.\n\t\tconst nodeBefore = viewPosition.nodeBefore;\n\t\tconst nodeAfter = viewPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeBefore, nodeBefore.data.length );\n\t\t} else if ( nodeAfter instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeAfter, 0 );\n\t\t}\n\n\t\t// Otherwise, just return the given position.\n\t\treturn viewPosition;\n\t}\n\n\t/**\n\t * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n\t * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n\t * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`\n\t * value in `data` object that is passed as one of parameters to the event callback.\n\t *\n\t * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n\t * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n\t * \t\t// <span> element.\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = modelPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n\t *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n\t *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n\t *\n\t *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n\t *\n\t *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. \"Phantom\" model position is\n\t * a position that points to a non-existing place in model. Such position might still be valid for conversion, though\n\t * (it would point to a correct place in view when converted). One example of such situation is when a range is\n\t * removed from model, there may be a need to map the range's end (which is no longer valid model position). To\n\t * handle such situation, check `data.isPhantom` flag:\n\t *\n\t * \t\t// Assume that there is \"customElement\" model element and whenever position is before it, we want to move it\n\t * \t\t// to the inside of the view element bound to \"customElement\".\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tif ( data.isPhantom ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\t// Below line might crash for phantom position that does not exist in model.\n\t *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n\t *\n\t *\t\t\t// Check if this is the element we are interested in.\n\t *\t\t\tif ( !sibling.is( 'element', 'customElement' ) ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n\t *\n\t *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n\t *\n\t *\t\t\tevt.stop();\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event modelToViewPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n\n\t/**\n\t * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n\t *\n\t * \t\t// See example in `modelToViewPosition` event description.\n\t * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n\t *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = viewPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n\t *\t\t\t\tconst viewImg = positionParent.previousSibling;\n\t *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n\t *\n\t *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event viewToModelPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n}\n\nmix( Mapper, EmitterMixin );\n"]},"metadata":{},"sourceType":"module"}