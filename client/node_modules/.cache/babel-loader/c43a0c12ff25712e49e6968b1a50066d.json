{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\nimport Differ from './differ';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es'; // @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\nconst graveyardName = '$graveyard';\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Document {\n  /**\n   * Creates an empty document instance with no {@link #roots} (other than\n   * the {@link #graveyard graveyard root}).\n   */\n  constructor(model) {\n    /**\n     * The {@link module:engine/model/model~Model model} that the document is a part of.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The document version. It starts from `0` and every operation increases the version number. It is used to ensure that\n     * operations are applied on a proper document version.\n     *\n     * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n     * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n     *\n     * @type {Number}\n     */\n\n    this.version = 0;\n    /**\n     * The document's history.\n     *\n     * @readonly\n     * @type {module:engine/model/history~History}\n     */\n\n    this.history = new History(this);\n    /**\n     * The selection in this document.\n     *\n     * @readonly\n     * @type {module:engine/model/documentselection~DocumentSelection}\n     */\n\n    this.selection = new DocumentSelection(this);\n    /**\n     * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n     * {@link #getRoot} to manipulate it.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n     *\n     * @readonly\n     * @type {module:engine/model/differ~Differ}\n     */\n\n    this.differ = new Differ(model.markers);\n    /**\n     * Post-fixer callbacks registered to the model document.\n     *\n     * @private\n     * @type {Set.<Function>}\n     */\n\n    this._postFixers = new Set();\n    /**\n     * A boolean indicates whether the selection has changed until\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._hasSelectionChangedFromTheLastChangeBlock = false; // Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\n    this.createRoot('$root', graveyardName); // First, if the operation is a document operation check if it's base version is correct.\n\n    this.listenTo(model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      if (operation.isDocumentOperation && operation.baseVersion !== this.version) {\n        /**\n         * Only operations with matching versions can be applied.\n         *\n         * @error model-document-applyoperation-wrong-version\n         * @param {module:engine/model/operation/operation~Operation} operation\n         */\n        throw new CKEditorError('model-document-applyoperation-wrong-version', this, {\n          operation\n        });\n      }\n    }, {\n      priority: 'highest'\n    }); // Then, still before an operation is applied on model, buffer the change in differ.\n\n    this.listenTo(model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        this.differ.bufferOperation(operation);\n      }\n    }, {\n      priority: 'high'\n    }); // After the operation is applied, bump document's version and add the operation to the history.\n\n    this.listenTo(model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        this.version++;\n        this.history.addOperation(operation);\n      }\n    }, {\n      priority: 'low'\n    }); // Listen to selection changes. If selection changed, mark it.\n\n    this.listenTo(this.selection, 'change', () => {\n      this._hasSelectionChangedFromTheLastChangeBlock = true;\n    }); // Buffer marker changes.\n    // This is not covered in buffering operations because markers may change outside of them (when they\n    // are modified using `model.markers` collection, not through `MarkerOperation`).\n\n    this.listenTo(model.markers, 'update', (evt, marker, oldRange, newRange) => {\n      // Whenever marker is updated, buffer that change.\n      this.differ.bufferMarkerChange(marker.name, oldRange, newRange, marker.affectsData);\n\n      if (oldRange === null) {\n        // If this is a new marker, add a listener that will buffer change whenever marker changes.\n        marker.on('change', (evt, oldRange) => {\n          this.differ.bufferMarkerChange(marker.name, oldRange, marker.getRange(), marker.affectsData);\n        });\n      }\n    });\n  }\n  /**\n   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n   *\n   * @readonly\n   * @member {module:engine/model/rootelement~RootElement}\n   */\n\n\n  get graveyard() {\n    return this.getRoot(graveyardName);\n  }\n  /**\n   * Creates a new root.\n   *\n   * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n   * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n   * @param {String} [rootName='main'] A unique root name.\n   * @returns {module:engine/model/rootelement~RootElement} The created root.\n   */\n\n\n  createRoot() {\n    let elementName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$root';\n    let rootName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';\n\n    if (this.roots.get(rootName)) {\n      /**\n       * A root with the specified name already exists.\n       *\n       * @error model-document-createroot-name-exists\n       * @param {module:engine/model/document~Document} doc\n       * @param {String} name\n       */\n      throw new CKEditorError('model-document-createroot-name-exists', this, {\n        name: rootName\n      });\n    }\n\n    const root = new RootElement(this, elementName, rootName);\n    this.roots.add(root);\n    return root;\n  }\n  /**\n   * Removes all event listeners set by the document instance.\n   */\n\n\n  destroy() {\n    this.selection.destroy();\n    this.stopListening();\n  }\n  /**\n   * Returns a root by its name.\n   *\n   * @param {String} [name='main'] A unique root name.\n   * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n   * there is no root with the given name.\n   */\n\n\n  getRoot() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n    return this.roots.get(name);\n  }\n  /**\n   * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n   *\n   * @returns {Array.<String>} Roots names.\n   */\n\n\n  getRootNames() {\n    return Array.from(this.roots, root => root.rootName).filter(name => name != graveyardName);\n  }\n  /**\n   * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n   * will operate on a correct model state.\n   *\n   * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n   * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n   * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n   * not be fixed in the new document tree state.\n   *\n   * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n   * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n   * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n   * for the user.\n   *\n   * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n   * callback should add an empty paragraph so that the editor is never empty:\n   *\n   *\t\tdocument.registerPostFixer( writer => {\n   *\t\t\tconst changes = document.differ.getChanges();\n   *\n   *\t\t\t// Check if the changes lead to an empty root in the editor.\n   *\t\t\tfor ( const entry of changes ) {\n   *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n   *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n   *\n   *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n   *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n   *\t\t\t\t\treturn true;\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   * @param {Function} postFixer\n   */\n\n\n  registerPostFixer(postFixer) {\n    this._postFixers.add(postFixer);\n  }\n  /**\n   * A custom `toJSON()` method to solve child-parent circular dependencies.\n   *\n   * @returns {Object} A clone of this object with the document property changed to a string.\n   */\n\n\n  toJSON() {\n    const json = clone(this); // Due to circular references we need to remove parent reference.\n\n    json.selection = '[engine.model.DocumentSelection]';\n    json.model = '[engine.model.Model]';\n    return json;\n  }\n  /**\n   * Check if there were any changes done on document, and if so, call post-fixers,\n   * fire `change` event for features and conversion and then reset the differ.\n   * Fire `change:data` event when at least one operation or buffered marker changes the data.\n   *\n   * @protected\n   * @fires change\n   * @fires change:data\n   * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n   */\n\n\n  _handleChangeBlock(writer) {\n    if (this._hasDocumentChangedFromTheLastChangeBlock()) {\n      this._callPostFixers(writer); // Refresh selection attributes according to the final position in the model after the change.\n\n\n      this.selection.refresh();\n\n      if (this.differ.hasDataChanges()) {\n        this.fire('change:data', writer.batch);\n      } else {\n        this.fire('change', writer.batch);\n      } // Theoretically, it is not necessary to refresh selection after change event because\n      // post-fixers are the last who should change the model, but just in case...\n\n\n      this.selection.refresh();\n      this.differ.reset();\n    }\n\n    this._hasSelectionChangedFromTheLastChangeBlock = false;\n  }\n  /**\n   * Returns whether there is a buffered change or if the selection has changed from the last\n   * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n   * or {@link module:engine/model/model~Model#change `change()` block}.\n   *\n   * @protected\n   * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n   */\n\n\n  _hasDocumentChangedFromTheLastChangeBlock() {\n    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n  }\n  /**\n   * Returns the default root for this document which is either the first root that was added to the document using\n   * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n   *\n   * @protected\n   * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n   */\n\n\n  _getDefaultRoot() {\n    for (const root of this.roots) {\n      if (root !== this.graveyard) {\n        return root;\n      }\n    }\n\n    return this.graveyard;\n  }\n  /**\n   * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n   * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n   *\n   * @protected\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  _getDefaultRange() {\n    const defaultRoot = this._getDefaultRoot();\n\n    const model = this.model;\n    const schema = model.schema; // Find the first position where the selection can be put.\n\n    const position = model.createPositionFromPath(defaultRoot, [0]);\n    const nearestRange = schema.getNearestSelectionRange(position); // If valid selection range is not found - return range collapsed at the beginning of the root.\n\n    return nearestRange || model.createRange(position);\n  }\n  /**\n   * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n   * the {@link #selection document's selection}.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range A range to check.\n   * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n   */\n\n\n  _validateSelectionRange(range) {\n    return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);\n  }\n  /**\n   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n   *\n   * @private\n   * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n   */\n\n\n  _callPostFixers(writer) {\n    let wasFixed = false;\n\n    do {\n      for (const callback of this._postFixers) {\n        // Ensure selection attributes are up to date before each post-fixer.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n        //\n        // It might be good to refresh the selection after each operation but at the moment it leads\n        // to losing attributes for composition or and spell checking\n        // https://github.com/ckeditor/ckeditor5-typing/issues/188\n        this.selection.refresh();\n        wasFixed = callback(writer);\n\n        if (wasFixed) {\n          break;\n        }\n      }\n    } while (wasFixed);\n  }\n  /**\n   * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n   * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n   * during that block's execution.\n   *\n   * The changes which this event will cover include:\n   *\n   * * document structure changes,\n   * * selection changes,\n   * * marker changes.\n   *\n   * If you want to be notified about all these changes, then simply listen to this event like this:\n   *\n   *\t\tmodel.document.on( 'change', () => {\n   *\t\t\tconsole.log( 'The document has changed!' );\n   *\t\t} );\n   *\n   * If, however, you only want to be notified about the data changes, then use the\n   * {@link module:engine/model/document~Document#event:change:data change:data} event,\n   * which is fired for document structure changes and marker changes (which affects the data).\n   *\n   *\t\tmodel.document.on( 'change:data', () => {\n   *\t\t\tconsole.log( 'The data has changed!' );\n   *\t\t} );\n   *\n   * @event change\n   * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n   */\n\n  /**\n   * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n   * affect the editor data. This is:\n   *\n   * * document structure changes,\n   * * marker changes (which affects the data).\n   *\n   * If you want to be notified about the data changes, then listen to this event:\n   *\n   *\t\tmodel.document.on( 'change:data', () => {\n   *\t\t\tconsole.log( 'The data has changed!' );\n   *\t\t} );\n   *\n   * If you would like to listen to all document changes, then check out the\n   * {@link module:engine/model/document~Document#event:change change} event.\n   *\n   * @event change:data\n   * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n   */\n  // @if CK_DEBUG_ENGINE // log( version = null ) {\n  // @if CK_DEBUG_ENGINE // \tversion = version === null ? this.version : version;\n  // @if CK_DEBUG_ENGINE // \tlogDocument( this, version );\n  // @if CK_DEBUG_ENGINE // }\n\n\n}\nmix(Document, EmitterMixin); // Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\n\nfunction validateTextNodePosition(rangeBoundary) {\n  const textNode = rangeBoundary.textNode;\n\n  if (textNode) {\n    const data = textNode.data;\n    const offset = rangeBoundary.offset - textNode.startOffset;\n    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js"],"names":["Differ","RootElement","History","DocumentSelection","Collection","EmitterMixin","CKEditorError","mix","isInsideSurrogatePair","isInsideCombinedSymbol","clone","graveyardName","Document","constructor","model","version","history","selection","roots","idProperty","differ","markers","_postFixers","Set","_hasSelectionChangedFromTheLastChangeBlock","createRoot","listenTo","evt","args","operation","isDocumentOperation","baseVersion","priority","bufferOperation","addOperation","marker","oldRange","newRange","bufferMarkerChange","name","affectsData","on","getRange","graveyard","getRoot","elementName","rootName","get","root","add","destroy","stopListening","getRootNames","Array","from","filter","registerPostFixer","postFixer","toJSON","json","_handleChangeBlock","writer","_hasDocumentChangedFromTheLastChangeBlock","_callPostFixers","refresh","hasDataChanges","fire","batch","reset","isEmpty","_getDefaultRoot","_getDefaultRange","defaultRoot","schema","position","createPositionFromPath","nearestRange","getNearestSelectionRange","createRange","_validateSelectionRange","range","validateTextNodePosition","start","end","wasFixed","callback","rangeBoundary","textNode","data","offset","startOffset"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\n\nimport Differ from './differ';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es';\n\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\nconst graveyardName = '$graveyard';\n\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Document {\n\t/**\n\t * Creates an empty document instance with no {@link #roots} (other than\n\t * the {@link #graveyard graveyard root}).\n\t */\n\tconstructor( model ) {\n\t\t/**\n\t\t * The {@link module:engine/model/model~Model model} that the document is a part of.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The document version. It starts from `0` and every operation increases the version number. It is used to ensure that\n\t\t * operations are applied on a proper document version.\n\t\t *\n\t\t * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n\t\t * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * The document's history.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/history~History}\n\t\t */\n\t\tthis.history = new History( this );\n\n\t\t/**\n\t\t * The selection in this document.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = new DocumentSelection( this );\n\n\t\t/**\n\t\t * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n\t\t * {@link #getRoot} to manipulate it.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:utils/collection~Collection}\n\t\t */\n\t\tthis.roots = new Collection( { idProperty: 'rootName' } );\n\n\t\t/**\n\t\t * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/differ~Differ}\n\t\t */\n\t\tthis.differ = new Differ( model.markers );\n\n\t\t/**\n\t\t * Post-fixer callbacks registered to the model document.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<Function>}\n\t\t */\n\t\tthis._postFixers = new Set();\n\n\t\t/**\n\t\t * A boolean indicates whether the selection has changed until\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\n\t\t// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\t\tthis.createRoot( '$root', graveyardName );\n\n\t\t// First, if the operation is a document operation check if it's base version is correct.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation && operation.baseVersion !== this.version ) {\n\t\t\t\t/**\n\t\t\t\t * Only operations with matching versions can be applied.\n\t\t\t\t *\n\t\t\t\t * @error model-document-applyoperation-wrong-version\n\t\t\t\t * @param {module:engine/model/operation/operation~Operation} operation\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-document-applyoperation-wrong-version', this, { operation } );\n\t\t\t}\n\t\t}, { priority: 'highest' } );\n\n\t\t// Then, still before an operation is applied on model, buffer the change in differ.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.differ.bufferOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// After the operation is applied, bump document's version and add the operation to the history.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.version++;\n\t\t\t\tthis.history.addOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// Listen to selection changes. If selection changed, mark it.\n\t\tthis.listenTo( this.selection, 'change', () => {\n\t\t\tthis._hasSelectionChangedFromTheLastChangeBlock = true;\n\t\t} );\n\n\t\t// Buffer marker changes.\n\t\t// This is not covered in buffering operations because markers may change outside of them (when they\n\t\t// are modified using `model.markers` collection, not through `MarkerOperation`).\n\t\tthis.listenTo( model.markers, 'update', ( evt, marker, oldRange, newRange ) => {\n\t\t\t// Whenever marker is updated, buffer that change.\n\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, newRange, marker.affectsData );\n\n\t\t\tif ( oldRange === null ) {\n\t\t\t\t// If this is a new marker, add a listener that will buffer change whenever marker changes.\n\t\t\t\tmarker.on( 'change', ( evt, oldRange ) => {\n\t\t\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, marker.getRange(), marker.affectsData );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n\t *\n\t * @readonly\n\t * @member {module:engine/model/rootelement~RootElement}\n\t */\n\tget graveyard() {\n\t\treturn this.getRoot( graveyardName );\n\t}\n\n\t/**\n\t * Creates a new root.\n\t *\n\t * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n\t * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n\t * @param {String} [rootName='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement} The created root.\n\t */\n\tcreateRoot( elementName = '$root', rootName = 'main' ) {\n\t\tif ( this.roots.get( rootName ) ) {\n\t\t\t/**\n\t\t\t * A root with the specified name already exists.\n\t\t\t *\n\t\t\t * @error model-document-createroot-name-exists\n\t\t\t * @param {module:engine/model/document~Document} doc\n\t\t\t * @param {String} name\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-document-createroot-name-exists', this, { name: rootName } );\n\t\t}\n\n\t\tconst root = new RootElement( this, elementName, rootName );\n\t\tthis.roots.add( root );\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Removes all event listeners set by the document instance.\n\t */\n\tdestroy() {\n\t\tthis.selection.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Returns a root by its name.\n\t *\n\t * @param {String} [name='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n\t * there is no root with the given name.\n\t */\n\tgetRoot( name = 'main' ) {\n\t\treturn this.roots.get( name );\n\t}\n\n\t/**\n\t * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n\t *\n\t * @returns {Array.<String>} Roots names.\n\t */\n\tgetRootNames() {\n\t\treturn Array.from( this.roots, root => root.rootName ).filter( name => name != graveyardName );\n\t}\n\n\t/**\n\t * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n\t * will operate on a correct model state.\n\t *\n\t * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n\t * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n\t * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n\t * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n\t * not be fixed in the new document tree state.\n\t *\n\t * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n\t * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n\t * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n\t * for the user.\n\t *\n\t * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n\t * callback should add an empty paragraph so that the editor is never empty:\n\t *\n\t *\t\tdocument.registerPostFixer( writer => {\n\t *\t\t\tconst changes = document.differ.getChanges();\n\t *\n\t *\t\t\t// Check if the changes lead to an empty root in the editor.\n\t *\t\t\tfor ( const entry of changes ) {\n\t *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n\t *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n\t *\n\t *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n\t *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n\t *\t\t\t\t\treturn true;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {Function} postFixer\n\t */\n\tregisterPostFixer( postFixer ) {\n\t\tthis._postFixers.add( postFixer );\n\t}\n\n\t/**\n\t * A custom `toJSON()` method to solve child-parent circular dependencies.\n\t *\n\t * @returns {Object} A clone of this object with the document property changed to a string.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this );\n\n\t\t// Due to circular references we need to remove parent reference.\n\t\tjson.selection = '[engine.model.DocumentSelection]';\n\t\tjson.model = '[engine.model.Model]';\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Check if there were any changes done on document, and if so, call post-fixers,\n\t * fire `change` event for features and conversion and then reset the differ.\n\t * Fire `change:data` event when at least one operation or buffered marker changes the data.\n\t *\n\t * @protected\n\t * @fires change\n\t * @fires change:data\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n\t */\n\t_handleChangeBlock( writer ) {\n\t\tif ( this._hasDocumentChangedFromTheLastChangeBlock() ) {\n\t\t\tthis._callPostFixers( writer );\n\n\t\t\t// Refresh selection attributes according to the final position in the model after the change.\n\t\t\tthis.selection.refresh();\n\n\t\t\tif ( this.differ.hasDataChanges() ) {\n\t\t\t\tthis.fire( 'change:data', writer.batch );\n\t\t\t} else {\n\t\t\t\tthis.fire( 'change', writer.batch );\n\t\t\t}\n\n\t\t\t// Theoretically, it is not necessary to refresh selection after change event because\n\t\t\t// post-fixers are the last who should change the model, but just in case...\n\t\t\tthis.selection.refresh();\n\n\t\t\tthis.differ.reset();\n\t\t}\n\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\t}\n\n\t/**\n\t * Returns whether there is a buffered change or if the selection has changed from the last\n\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n\t * or {@link module:engine/model/model~Model#change `change()` block}.\n\t *\n\t * @protected\n\t * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n\t */\n\t_hasDocumentChangedFromTheLastChangeBlock() {\n\t\treturn !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n\t}\n\n\t/**\n\t * Returns the default root for this document which is either the first root that was added to the document using\n\t * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n\t */\n\t_getDefaultRoot() {\n\t\tfor ( const root of this.roots ) {\n\t\t\tif ( root !== this.graveyard ) {\n\t\t\t\treturn root;\n\t\t\t}\n\t\t}\n\n\t\treturn this.graveyard;\n\t}\n\n\t/**\n\t * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n\t * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getDefaultRange() {\n\t\tconst defaultRoot = this._getDefaultRoot();\n\t\tconst model = this.model;\n\t\tconst schema = model.schema;\n\n\t\t// Find the first position where the selection can be put.\n\t\tconst position = model.createPositionFromPath( defaultRoot, [ 0 ] );\n\t\tconst nearestRange = schema.getNearestSelectionRange( position );\n\n\t\t// If valid selection range is not found - return range collapsed at the beginning of the root.\n\t\treturn nearestRange || model.createRange( position );\n\t}\n\n\t/**\n\t * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n\t * the {@link #selection document's selection}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range A range to check.\n\t * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n\t */\n\t_validateSelectionRange( range ) {\n\t\treturn validateTextNodePosition( range.start ) && validateTextNodePosition( range.end );\n\t}\n\n\t/**\n\t * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n\t */\n\t_callPostFixers( writer ) {\n\t\tlet wasFixed = false;\n\n\t\tdo {\n\t\t\tfor ( const callback of this._postFixers ) {\n\t\t\t\t// Ensure selection attributes are up to date before each post-fixer.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n\t\t\t\t//\n\t\t\t\t// It might be good to refresh the selection after each operation but at the moment it leads\n\t\t\t\t// to losing attributes for composition or and spell checking\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-typing/issues/188\n\t\t\t\tthis.selection.refresh();\n\n\t\t\t\twasFixed = callback( writer );\n\n\t\t\t\tif ( wasFixed ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( wasFixed );\n\t}\n\n\t/**\n\t * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n\t * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n\t * during that block's execution.\n\t *\n\t * The changes which this event will cover include:\n\t *\n\t * * document structure changes,\n\t * * selection changes,\n\t * * marker changes.\n\t *\n\t * If you want to be notified about all these changes, then simply listen to this event like this:\n\t *\n\t *\t\tmodel.document.on( 'change', () => {\n\t *\t\t\tconsole.log( 'The document has changed!' );\n\t *\t\t} );\n\t *\n\t * If, however, you only want to be notified about the data changes, then use the\n\t * {@link module:engine/model/document~Document#event:change:data change:data} event,\n\t * which is fired for document structure changes and marker changes (which affects the data).\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * @event change\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t/**\n\t * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n\t * affect the editor data. This is:\n\t *\n\t * * document structure changes,\n\t * * marker changes (which affects the data).\n\t *\n\t * If you want to be notified about the data changes, then listen to this event:\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * If you would like to listen to all document changes, then check out the\n\t * {@link module:engine/model/document~Document#event:change change} event.\n\t *\n\t * @event change:data\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t// @if CK_DEBUG_ENGINE // log( version = null ) {\n\t// @if CK_DEBUG_ENGINE // \tversion = version === null ? this.version : version;\n\t// @if CK_DEBUG_ENGINE // \tlogDocument( this, version );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\nmix( Document, EmitterMixin );\n\n// Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\nfunction validateTextNodePosition( rangeBoundary ) {\n\tconst textNode = rangeBoundary.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tconst offset = rangeBoundary.offset - textNode.startOffset;\n\n\t\treturn !isInsideSurrogatePair( data, offset ) && !isInsideCombinedSymbol( data, offset );\n\t}\n\n\treturn true;\n}\n"]},"metadata":{},"sourceType":"module"}