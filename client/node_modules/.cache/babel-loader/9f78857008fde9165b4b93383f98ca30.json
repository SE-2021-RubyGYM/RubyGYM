{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/uielement\n */\nimport Element from './element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Node from './node';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n/**\n * UI element class. It should be used to represent editing UI which needs to be injected into the editing view\n * If possible, you should keep your UI outside the editing view. However, if that is not possible,\n * UI elements can be used.\n *\n * How a UI element is rendered is in your control (you pass a callback to\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}).\n * The editor will ignore your UI element â€“ the selection cannot be placed in it, it is skipped (invisible) when\n * the user modifies the selection by using arrow keys and the editor does not listen to any mutations which\n * happen inside your UI elements.\n *\n * The limitation is that you cannot convert a model element to a UI element. UI elements need to be\n * created for {@link module:engine/model/markercollection~Marker markers} or as additinal elements\n * inside normal {@link module:engine/view/containerelement~ContainerElement container elements}.\n *\n * To create a new UI element use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`} method.\n *\n * @extends module:engine/view/element~Element\n */\n\nexport default class UIElement extends Element {\n  /**\n   * Creates new instance of UIElement.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,\n   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement\n   * @protected\n   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n   * @param {String} name Node name.\n   * @param {Object|Iterable} [attributes] Collection of attributes.\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into created element.\n   */\n  constructor(document, name, attributes, children) {\n    super(document, name, attributes, children); // Override the default of the base class.\n\n    this._isAllowedInsideAttributeElement = true;\n    /**\n     * Returns `null` because filler is not needed for UIElements.\n     *\n     * @method #getFillerOffset\n     * @returns {null} Always returns null.\n     */\n\n    this.getFillerOffset = getFillerOffset;\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\tuiElement.is( 'uiElement' ); // -> true\n   *\t\tuiElement.is( 'element' ); // -> true\n   *\t\tuiElement.is( 'node' ); // -> true\n   *\t\tuiElement.is( 'view:uiElement' ); // -> true\n   *\t\tuiElement.is( 'view:element' ); // -> true\n   *\t\tuiElement.is( 'view:node' ); // -> true\n   *\n   *\t\tuiElement.is( 'model:element' ); // -> false\n   *\t\tuiElement.is( 'documentFragment' ); // -> false\n   *\n   * Assuming that the object being checked is an ui element, you can also check its\n   * {@link module:engine/view/uielement~UIElement#name name}:\n   *\n   *\t\tuiElement.is( 'element', 'span' ); // -> true if this is a span ui element\n   *\t\tuiElement.is( 'uiElement', 'span' ); // -> same as above\n   *\t\ttext.is( 'element', 'span' ); -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type Type to check.\n   * @param {String} [name] Element name.\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (!name) {\n      return type === 'uiElement' || type === 'view:uiElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n      type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';\n    } else {\n      return name === this.name && (type === 'uiElement' || type === 'view:uiElement' || type === 'element' || type === 'view:element');\n    }\n  }\n  /**\n   * Overrides {@link module:engine/view/element~Element#_insertChild} method.\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes\n   * to UIElement.\n   *\n   * @protected\n   */\n\n\n  _insertChild(index, nodes) {\n    if (nodes && (nodes instanceof Node || Array.from(nodes).length > 0)) {\n      /**\n       * Cannot add children to {@link module:engine/view/uielement~UIElement}.\n       *\n       * @error view-uielement-cannot-add\n       */\n      throw new CKEditorError('view-uielement-cannot-add', this);\n    }\n  }\n  /**\n   * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by\n   * {@link module:engine/view/domconverter~DomConverter}.\n   * Do not use inheritance to create custom rendering method, replace `render()` method instead:\n   *\n   *\t\tconst myUIElement = downcastWriter.createUIElement( 'span' );\n   *\t\tmyUIElement.render = function( domDocument, domConverter ) {\n   *\t\t\tconst domElement = this.toDomElement( domDocument );\n   *\n   *\t\t\tdomConverter.setContentOf( domElement, '<b>this is ui element</b>' );\n   *\n   *\t\t\treturn domElement;\n   *\t\t};\n   *\n   * If changes in your UI element should trigger some editor UI update you should call\n   * the {@link module:core/editor/editorui~EditorUI#update `editor.ui.update()`} method\n   * after rendering your UI element.\n   *\n   * @param {Document} domDocument\n   * @param {module:engine/view/domconverter~DomConverter} domConverter Instance of the DomConverter used to optimize the output.\n   * @returns {HTMLElement}\n   */\n\n\n  render(domDocument) {\n    // Provide basic, default output.\n    return this.toDomElement(domDocument);\n  }\n  /**\n   * Creates DOM element based on this view UIElement.\n   * Note that each time this method is called new DOM element is created.\n   *\n   * @param {Document} domDocument\n   * @returns {HTMLElement}\n   */\n\n\n  toDomElement(domDocument) {\n    const domElement = domDocument.createElement(this.name);\n\n    for (const key of this.getAttributeKeys()) {\n      domElement.setAttribute(key, this.getAttribute(key));\n    }\n\n    return domElement;\n  }\n\n}\n/**\n * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.\n *\n * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.\n * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.\n * Without this handler, it would be impossible to \"jump over\" UI element using right arrow key.\n *\n * @param {module:engine/view/view~View} view View controller to which the quirks handling will be injected.\n */\n\nexport function injectUiElementHandling(view) {\n  view.document.on('arrowKey', (evt, data) => jumpOverUiElement(evt, data, view.domConverter), {\n    priority: 'low'\n  });\n} // Returns `null` because block filler is not needed for UIElements.\n//\n// @returns {null}\n\nfunction getFillerOffset() {\n  return null;\n} // Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This\n// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection\n// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.\n\n\nfunction jumpOverUiElement(evt, data, domConverter) {\n  if (data.keyCode == keyCodes.arrowright) {\n    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n    const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed; // Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.\n\n    if (domSelectionCollapsed || data.shiftKey) {\n      const domParent = domSelection.focusNode;\n      const domOffset = domSelection.focusOffset;\n      const viewPosition = domConverter.domPositionToView(domParent, domOffset); // In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.\n\n      if (viewPosition === null) {\n        return;\n      } // Skip all following ui elements.\n\n\n      let jumpedOverAnyUiElement = false;\n      const nextViewPosition = viewPosition.getLastMatchingPosition(value => {\n        if (value.item.is('uiElement')) {\n          // Remember that there was at least one ui element.\n          jumpedOverAnyUiElement = true;\n        } // Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.\n\n\n        if (value.item.is('uiElement') || value.item.is('attributeElement')) {\n          return true;\n        } // Don't jump over text or don't get out of container element.\n\n\n        return false;\n      }); // If anything has been skipped, fix position.\n      // This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.\n\n      if (jumpedOverAnyUiElement) {\n        const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);\n\n        if (domSelectionCollapsed) {\n          // Selection was collapsed, so collapse it at further position.\n          domSelection.collapse(newDomPosition.parent, newDomPosition.offset);\n        } else {\n          // Selection was not collapse, so extend it instead of collapsing.\n          domSelection.extend(newDomPosition.parent, newDomPosition.offset);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/uielement.js"],"names":["Element","CKEditorError","Node","keyCodes","UIElement","constructor","document","name","attributes","children","_isAllowedInsideAttributeElement","getFillerOffset","is","type","_insertChild","index","nodes","Array","from","length","render","domDocument","toDomElement","domElement","createElement","key","getAttributeKeys","setAttribute","getAttribute","injectUiElementHandling","view","on","evt","data","jumpOverUiElement","domConverter","priority","keyCode","arrowright","domSelection","domTarget","ownerDocument","defaultView","getSelection","domSelectionCollapsed","rangeCount","getRangeAt","collapsed","shiftKey","domParent","focusNode","domOffset","focusOffset","viewPosition","domPositionToView","jumpedOverAnyUiElement","nextViewPosition","getLastMatchingPosition","value","item","newDomPosition","viewPositionToDom","collapse","parent","offset","extend"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/uielement\n */\n\nimport Element from './element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Node from './node';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\n/**\n * UI element class. It should be used to represent editing UI which needs to be injected into the editing view\n * If possible, you should keep your UI outside the editing view. However, if that is not possible,\n * UI elements can be used.\n *\n * How a UI element is rendered is in your control (you pass a callback to\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}).\n * The editor will ignore your UI element â€“ the selection cannot be placed in it, it is skipped (invisible) when\n * the user modifies the selection by using arrow keys and the editor does not listen to any mutations which\n * happen inside your UI elements.\n *\n * The limitation is that you cannot convert a model element to a UI element. UI elements need to be\n * created for {@link module:engine/model/markercollection~Marker markers} or as additinal elements\n * inside normal {@link module:engine/view/containerelement~ContainerElement container elements}.\n *\n * To create a new UI element use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`} method.\n *\n * @extends module:engine/view/element~Element\n */\nexport default class UIElement extends Element {\n\t/**\n\t * Creates new instance of UIElement.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,\n\t * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).\n\t *\n\t * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement\n\t * @protected\n\t * @param {module:engine/view/document~Document} document The document instance to which this element belongs.\n\t * @param {String} name Node name.\n\t * @param {Object|Iterable} [attributes] Collection of attributes.\n\t * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n\t * A list of nodes to be inserted into created element.\n\t */\n\tconstructor( document, name, attributes, children ) {\n\t\tsuper( document, name, attributes, children );\n\n\t\t// Override the default of the base class.\n\t\tthis._isAllowedInsideAttributeElement = true;\n\n\t\t/**\n\t\t * Returns `null` because filler is not needed for UIElements.\n\t\t *\n\t\t * @method #getFillerOffset\n\t\t * @returns {null} Always returns null.\n\t\t */\n\t\tthis.getFillerOffset = getFillerOffset;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tuiElement.is( 'uiElement' ); // -> true\n\t *\t\tuiElement.is( 'element' ); // -> true\n\t *\t\tuiElement.is( 'node' ); // -> true\n\t *\t\tuiElement.is( 'view:uiElement' ); // -> true\n\t *\t\tuiElement.is( 'view:element' ); // -> true\n\t *\t\tuiElement.is( 'view:node' ); // -> true\n\t *\n\t *\t\tuiElement.is( 'model:element' ); // -> false\n\t *\t\tuiElement.is( 'documentFragment' ); // -> false\n\t *\n\t * Assuming that the object being checked is an ui element, you can also check its\n\t * {@link module:engine/view/uielement~UIElement#name name}:\n\t *\n\t *\t\tuiElement.is( 'element', 'span' ); // -> true if this is a span ui element\n\t *\t\tuiElement.is( 'uiElement', 'span' ); // -> same as above\n\t *\t\ttext.is( 'element', 'span' ); -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type Type to check.\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type === 'uiElement' || type === 'view:uiElement' ||\n\t\t\t\t// From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n\t\t\t\ttype === 'element' || type === 'view:element' ||\n\t\t\t\ttype === 'node' || type === 'view:node';\n\t\t} else {\n\t\t\treturn name === this.name && (\n\t\t\t\ttype === 'uiElement' || type === 'view:uiElement' ||\n\t\t\t\ttype === 'element' || type === 'view:element'\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Overrides {@link module:engine/view/element~Element#_insertChild} method.\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes\n\t * to UIElement.\n\t *\n\t * @protected\n\t */\n\t_insertChild( index, nodes ) {\n\t\tif ( nodes && ( nodes instanceof Node || Array.from( nodes ).length > 0 ) ) {\n\t\t\t/**\n\t\t\t * Cannot add children to {@link module:engine/view/uielement~UIElement}.\n\t\t\t *\n\t\t\t * @error view-uielement-cannot-add\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-uielement-cannot-add', this );\n\t\t}\n\t}\n\n\t/**\n\t * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by\n\t * {@link module:engine/view/domconverter~DomConverter}.\n\t * Do not use inheritance to create custom rendering method, replace `render()` method instead:\n\t *\n\t *\t\tconst myUIElement = downcastWriter.createUIElement( 'span' );\n\t *\t\tmyUIElement.render = function( domDocument, domConverter ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\n\t *\t\t\tdomConverter.setContentOf( domElement, '<b>this is ui element</b>' );\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t};\n\t *\n\t * If changes in your UI element should trigger some editor UI update you should call\n\t * the {@link module:core/editor/editorui~EditorUI#update `editor.ui.update()`} method\n\t * after rendering your UI element.\n\t *\n\t * @param {Document} domDocument\n\t * @param {module:engine/view/domconverter~DomConverter} domConverter Instance of the DomConverter used to optimize the output.\n\t * @returns {HTMLElement}\n\t */\n\trender( domDocument ) {\n\t\t// Provide basic, default output.\n\t\treturn this.toDomElement( domDocument );\n\t}\n\n\t/**\n\t * Creates DOM element based on this view UIElement.\n\t * Note that each time this method is called new DOM element is created.\n\t *\n\t * @param {Document} domDocument\n\t * @returns {HTMLElement}\n\t */\n\ttoDomElement( domDocument ) {\n\t\tconst domElement = domDocument.createElement( this.name );\n\n\t\tfor ( const key of this.getAttributeKeys() ) {\n\t\t\tdomElement.setAttribute( key, this.getAttribute( key ) );\n\t\t}\n\n\t\treturn domElement;\n\t}\n}\n\n/**\n * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.\n *\n * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.\n * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.\n * Without this handler, it would be impossible to \"jump over\" UI element using right arrow key.\n *\n * @param {module:engine/view/view~View} view View controller to which the quirks handling will be injected.\n */\nexport function injectUiElementHandling( view ) {\n\tview.document.on( 'arrowKey', ( evt, data ) => jumpOverUiElement( evt, data, view.domConverter ), { priority: 'low' } );\n}\n\n// Returns `null` because block filler is not needed for UIElements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n\treturn null;\n}\n\n// Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This\n// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection\n// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.\nfunction jumpOverUiElement( evt, data, domConverter ) {\n\tif ( data.keyCode == keyCodes.arrowright ) {\n\t\tconst domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n\t\tconst domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt( 0 ).collapsed;\n\n\t\t// Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.\n\t\tif ( domSelectionCollapsed || data.shiftKey ) {\n\t\t\tconst domParent = domSelection.focusNode;\n\t\t\tconst domOffset = domSelection.focusOffset;\n\n\t\t\tconst viewPosition = domConverter.domPositionToView( domParent, domOffset );\n\n\t\t\t// In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.\n\t\t\tif ( viewPosition === null ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip all following ui elements.\n\t\t\tlet jumpedOverAnyUiElement = false;\n\n\t\t\tconst nextViewPosition = viewPosition.getLastMatchingPosition( value => {\n\t\t\t\tif ( value.item.is( 'uiElement' ) ) {\n\t\t\t\t\t// Remember that there was at least one ui element.\n\t\t\t\t\tjumpedOverAnyUiElement = true;\n\t\t\t\t}\n\n\t\t\t\t// Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.\n\t\t\t\tif ( value.item.is( 'uiElement' ) || value.item.is( 'attributeElement' ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Don't jump over text or don't get out of container element.\n\t\t\t\treturn false;\n\t\t\t} );\n\n\t\t\t// If anything has been skipped, fix position.\n\t\t\t// This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.\n\t\t\tif ( jumpedOverAnyUiElement ) {\n\t\t\t\tconst newDomPosition = domConverter.viewPositionToDom( nextViewPosition );\n\n\t\t\t\tif ( domSelectionCollapsed ) {\n\t\t\t\t\t// Selection was collapsed, so collapse it at further position.\n\t\t\t\t\tdomSelection.collapse( newDomPosition.parent, newDomPosition.offset );\n\t\t\t\t} else {\n\t\t\t\t\t// Selection was not collapse, so extend it instead of collapsing.\n\t\t\t\t\tdomSelection.extend( newDomPosition.parent, newDomPosition.offset );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}