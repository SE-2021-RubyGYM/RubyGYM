{"ast":null,"code":"function stringify(obj, options) {\n  options = options || {};\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3);\n  var addMargin = get(options, 'margins', false);\n  var maxLength = indent === '' ? Infinity : get(options, 'maxLength', 80);\n  return function _stringify(obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON();\n    }\n\n    var string = JSON.stringify(obj);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    var length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin);\n\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent;\n      var items = [];\n      var delimiters;\n\n      var comma = function (array, index) {\n        return index === array.length - 1 ? 0 : 1;\n      };\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(_stringify(obj[index], nextIndent, comma(obj, index)) || 'null');\n        }\n\n        delimiters = '[]';\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': ';\n\n          var value = _stringify(obj[key], nextIndent, keyPart.length + comma(array, index));\n\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        });\n        delimiters = '{}';\n      }\n\n      if (items.length > 0) {\n        return [delimiters[0], indent + items.join(',\\n' + nextIndent), delimiters[1]].join('\\n' + currentIndent);\n      }\n    }\n\n    return string;\n  }(obj, '', 0);\n} // Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\n\n\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g;\n\nfunction prettify(string, addMargin) {\n  var m = addMargin ? ' ' : '';\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  };\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match];\n  });\n}\n\nfunction get(options, name, defaultValue) {\n  return name in options ? options[name] : defaultValue;\n}\n\nmodule.exports = stringify;","map":{"version":3,"sources":["C:/Users/nvtung/Các project thực hiện/RubyGYM-master_test_2/client/node_modules/json-stringify-pretty-compact/index.js"],"names":["stringify","obj","options","indent","JSON","get","slice","addMargin","maxLength","Infinity","_stringify","currentIndent","reserved","toJSON","string","undefined","length","prettified","prettify","nextIndent","items","delimiters","comma","array","index","Array","isArray","push","Object","keys","forEach","key","keyPart","value","join","stringOrChar","m","tokens","replace","match","name","defaultValue","module","exports"],"mappings":"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","sourcesContent":["function stringify (obj, options) {\r\n  options = options || {}\r\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\r\n  var addMargin = get(options, 'margins', false)\r\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\r\n\r\n  return (function _stringify (obj, currentIndent, reserved) {\r\n    if (obj && typeof obj.toJSON === 'function') {\r\n      obj = obj.toJSON()\r\n    }\r\n\r\n    var string = JSON.stringify(obj)\r\n\r\n    if (string === undefined) {\r\n      return string\r\n    }\r\n\r\n    var length = maxLength - currentIndent.length - reserved\r\n\r\n    if (string.length <= length) {\r\n      var prettified = prettify(string, addMargin)\r\n      if (prettified.length <= length) {\r\n        return prettified\r\n      }\r\n    }\r\n\r\n    if (typeof obj === 'object' && obj !== null) {\r\n      var nextIndent = currentIndent + indent\r\n      var items = []\r\n      var delimiters\r\n      var comma = function (array, index) {\r\n        return (index === array.length - 1 ? 0 : 1)\r\n      }\r\n\r\n      if (Array.isArray(obj)) {\r\n        for (var index = 0; index < obj.length; index++) {\r\n          items.push(\r\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\r\n          )\r\n        }\r\n        delimiters = '[]'\r\n      } else {\r\n        Object.keys(obj).forEach(function (key, index, array) {\r\n          var keyPart = JSON.stringify(key) + ': '\r\n          var value = _stringify(obj[key], nextIndent,\r\n                                 keyPart.length + comma(array, index))\r\n          if (value !== undefined) {\r\n            items.push(keyPart + value)\r\n          }\r\n        })\r\n        delimiters = '{}'\r\n      }\r\n\r\n      if (items.length > 0) {\r\n        return [\r\n          delimiters[0],\r\n          indent + items.join(',\\n' + nextIndent),\r\n          delimiters[1]\r\n        ].join('\\n' + currentIndent)\r\n      }\r\n    }\r\n\r\n    return string\r\n  }(obj, '', 0))\r\n}\r\n\r\n// Note: This regex matches even invalid JSON strings, but since we’re\r\n// working on the output of `JSON.stringify` we know that only valid strings\r\n// are present (unless the user supplied a weird `options.indent` but in\r\n// that case we don’t care since the output would be invalid anyway).\r\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\r\n\r\nfunction prettify (string, addMargin) {\r\n  var m = addMargin ? ' ' : ''\r\n  var tokens = {\r\n    '{': '{' + m,\r\n    '[': '[' + m,\r\n    '}': m + '}',\r\n    ']': m + ']',\r\n    ',': ', ',\r\n    ':': ': '\r\n  }\r\n  return string.replace(stringOrChar, function (match, string) {\r\n    return string ? match : tokens[match]\r\n  })\r\n}\r\n\r\nfunction get (options, name, defaultValue) {\r\n  return (name in options ? options[name] : defaultValue)\r\n}\r\n\r\nmodule.exports = stringify\r\n"]},"metadata":{},"sourceType":"script"}