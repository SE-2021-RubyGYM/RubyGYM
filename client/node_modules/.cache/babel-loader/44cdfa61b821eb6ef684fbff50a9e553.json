{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport MergeOperation from './mergeoperation';\nimport SplitOperation from './splitoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport Position from '../position';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nconst transformations = new Map();\n/**\n * @module engine/model/operation/transform\n */\n\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\n\nfunction setTransformation(OperationA, OperationB, transformationFunction) {\n  let aGroup = transformations.get(OperationA);\n\n  if (!aGroup) {\n    aGroup = new Map();\n    transformations.set(OperationA, aGroup);\n  }\n\n  aGroup.set(OperationB, transformationFunction);\n}\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\n\n\nfunction getTransformation(OperationA, OperationB) {\n  const aGroup = transformations.get(OperationA);\n\n  if (aGroup && aGroup.has(OperationB)) {\n    return aGroup.get(OperationB);\n  }\n\n  return noUpdateTransformation;\n}\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\n\n\nfunction noUpdateTransformation(a) {\n  return [a];\n}\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} context Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\n\n\nexport function transform(a, b) {\n  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const transformationFunction = getTransformation(a.constructor, b.constructor);\n  /* eslint-disable no-useless-catch */\n\n  try {\n    a = a.clone();\n    return transformationFunction(a, b, context);\n  } catch (e) {\n    // @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );\n    // @if CK_DEBUG // console.warn( 'Transformed operation', a );\n    // @if CK_DEBUG // console.warn( 'Operation transformed by', b );\n    // @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );\n    // @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );\n    // @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );\n    // @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );\n    // @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );\n    throw e;\n  }\n  /* eslint-enable no-useless-catch */\n\n}\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document|null} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed\n * operations and the values are the original operations from the input (`operationsA` and `operationsB`).\n */\n\nexport function transformSets(operationsA, operationsB, options) {\n  // Create new arrays so the originally passed arguments are not changed.\n  // No need to clone operations, they are cloned as they are transformed.\n  operationsA = operationsA.slice();\n  operationsB = operationsB.slice();\n  const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);\n  contextFactory.setOriginalOperations(operationsA);\n  contextFactory.setOriginalOperations(operationsB);\n  const originalOperations = contextFactory.originalOperations; // If one of sets is empty there is simply nothing to transform, so return sets as they are.\n\n  if (operationsA.length == 0 || operationsB.length == 0) {\n    return {\n      operationsA,\n      operationsB,\n      originalOperations\n    };\n  } //\n  // Following is a description of transformation process:\n  //\n  // There are `operationsA` and `operationsB` to be transformed, both by both.\n  //\n  // So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n  //\n  // Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n  // the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n  // is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n  //\n  // However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n  // we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n  // All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n  //\n  // The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n  //\n  //          [the initial state]\n  //         [common for a1 and b1]\n  //\n  //                   *\n  //                  / \\\n  //                 /   \\\n  //               b1     a1\n  //               /       \\\n  //              /         \\\n  //             *           *\n  //            / \\         / \\\n  //           /   \\       /   \\\n  //         b2    a1'   b1'    a2\n  //         /       \\   /       \\\n  //        /         \\ /         \\\n  //       *           *           *\n  //        \\         / \\         /\n  //         \\       /   \\       /\n  //        a1''   b2'   a2'   b1''\n  //           \\   /       \\   /\n  //            \\ /         \\ /\n  //             *           *\n  //              \\         /\n  //               \\       /\n  //              a2''   b2''\n  //                 \\   /\n  //                  \\ /\n  //                   *\n  //\n  //           [the final state]\n  //\n  // The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n  // applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n  // transformed.\n  //\n  // Another thing to consider is that an operation during transformation can be broken into multiple operations.\n  // Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n  //\n  // In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n  // (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n  // by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n  // from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n  // by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n  // following `operationsA` (in our case it is just `a2`).\n  //\n  // Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n  // the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n  // be transformed by both of them.\n  //\n  //                       *\n  //                      / \\\n  //                     /   \\\n  //                    /     \\\n  //                  b1       a1\n  //                  /         \\\n  //                 /           \\\n  //                /             \\\n  //               *               *\n  //              / \\             / \\\n  //             /  a11'         /   \\\n  //            /     \\         /     \\\n  //          b2       *      b1'      a2\n  //          /       / \\     /         \\\n  //         /       /  a12' /           \\\n  //        /       /     \\ /             \\\n  //       *       b2'     *               *\n  //        \\     /       / \\             /\n  //       a11'' /     b21'' \\           /\n  //          \\ /       /     \\         /\n  //           *       *      a2'     b1''\n  //            \\     / \\       \\     /\n  //          a12'' b22''\\       \\   /\n  //              \\ /     \\       \\ /\n  //               *      a2''     *\n  //                \\       \\     /\n  //                 \\       \\  b21'''\n  //                  \\       \\ /\n  //                a2'''      *\n  //                    \\     /\n  //                     \\  b22'''\n  //                      \\ /\n  //                       *\n  //\n  // Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n  //\n  // Having all that on mind, here is an outline for the transformation process algorithm:\n  //\n  // 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n  //\n  // 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n  // All original `operationsA` are set to be transformed starting from the first operation `b`.\n  //\n  // 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n  // by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n  // with the transformation results.\n  //\n  // 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n  // original operation.\n  //\n  // 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n  // be transformed by.\n  //\n  // 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n  // unless the last operation `a` was transformed.\n  //\n  // The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n  // The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n  // to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n  // index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n  // operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n  // current `a` operation index to the next one.\n  //\n  // For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n\n\n  const nextTransformIndex = new WeakMap(); // For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n\n  for (const op of operationsA) {\n    nextTransformIndex.set(op, 0);\n  } // Additional data that is used for some postprocessing after the main transformation process is done.\n\n\n  const data = {\n    nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,\n    nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,\n    originalOperationsACount: operationsA.length,\n    originalOperationsBCount: operationsB.length\n  }; // Index of currently transformed operation `a`.\n\n  let i = 0; // While not all `operationsA` are transformed...\n\n  while (i < operationsA.length) {\n    // Get \"current\" operation `a`.\n    const opA = operationsA[i]; // For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n\n    const indexB = nextTransformIndex.get(opA); // If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n\n    if (indexB == operationsB.length) {\n      i++;\n      continue;\n    }\n\n    const opB = operationsB[indexB]; // Transform `a` by `b` and `b` by `a`.\n\n    const newOpsA = transform(opA, opB, contextFactory.getContext(opA, opB, true));\n    const newOpsB = transform(opB, opA, contextFactory.getContext(opB, opA, false)); // As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n    // Update contextual information about operations.\n\n    contextFactory.updateRelation(opA, opB);\n    contextFactory.setOriginalOperations(newOpsA, opA);\n    contextFactory.setOriginalOperations(newOpsB, opB); // For new `a` operations, update their index of the next operation `b` to transform them by.\n    //\n    // This is needed even if there was only one result (`a` was not broken) because that information is used\n    // at the beginning of this loop every time.\n\n    for (const newOpA of newOpsA) {\n      // Acknowledge, that operation `b` also might be broken into multiple operations.\n      //\n      // This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n      // spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n      // be transformed by the same operation (part of it) again.\n      nextTransformIndex.set(newOpA, indexB + newOpsB.length);\n    } // Update `operationsA` and `operationsB` with the transformed versions.\n\n\n    operationsA.splice(i, 1, ...newOpsA);\n    operationsB.splice(indexB, 1, ...newOpsB);\n  }\n\n  if (options.padWithNoOps) {\n    // If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n    const brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n    const brokenOperationsBCount = operationsB.length - data.originalOperationsBCount; // Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n    // that the base versions are equalled.\n    //\n    // Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n\n    padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);\n    padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);\n  } // Finally, update base versions of transformed operations.\n\n\n  updateBaseVersions(operationsA, data.nextBaseVersionB);\n  updateBaseVersions(operationsB, data.nextBaseVersionA);\n  return {\n    operationsA,\n    operationsB,\n    originalOperations\n  };\n} // Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\n\nclass ContextFactory {\n  // Creates `ContextFactory` instance.\n  //\n  // @param {module:engine/model/document~Document} document Document which the operations change.\n  // @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n  // better conflict resolution).\n  // @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n  // so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n  constructor(document, useRelations) {\n    let forceWeakRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // For each operation that is created during transformation process, we keep a reference to the original operation\n    // which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n    // gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n    // This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n    // gathered data through original operation reference.\n    this.originalOperations = new Map(); // `model.History` instance which information about undone operations will be taken from.\n\n    this._history = document.history; // Whether additional context should be used.\n\n    this._useRelations = useRelations;\n    this._forceWeakRemove = !!forceWeakRemove; // Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n    // to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n    // we keep relations between them.\n\n    this._relations = new Map();\n  } // Sets \"original operation\" for given operations.\n  //\n  // During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n  // or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n  // so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n  //\n  // The original operation object will be used as such an universal linking id. Throughout the transformation process\n  // all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n  //\n  // If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n  // This should be used as an initialization step.\n  //\n  // If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n  // for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n  // `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n  //\n  // @param {Array.<module:engine/model/operation/operation~Operation>} operations\n  // @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n\n\n  setOriginalOperations(operations) {\n    let takeFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;\n\n    for (const operation of operations) {\n      this.originalOperations.set(operation, originalOperation || operation);\n    }\n  } // Saves a relation between operations `opA` and `opB`.\n  //\n  // Relations are then later used to help solve conflicts when operations are transformed.\n  //\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n\n\n  updateRelation(opA, opB) {\n    // The use of relations is described in a bigger detail in transformation functions.\n    //\n    // In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n    // Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n    // position is before the other operation source position. This kind of information gives contextual information when\n    // transformation is used during undo. Similar checks are done for other pairs of operations.\n    //\n    switch (opA.constructor) {\n      case MoveOperation:\n        {\n          switch (opB.constructor) {\n            case MergeOperation:\n              {\n                if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {\n                  this._setRelation(opA, opB, 'insertAtSource');\n                } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {\n                  this._setRelation(opA, opB, 'insertBetween');\n                } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {\n                  this._setRelation(opA, opB, 'moveTargetAfter');\n                }\n\n                break;\n              }\n\n            case MoveOperation:\n              {\n                if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {\n                  this._setRelation(opA, opB, 'insertBefore');\n                } else {\n                  this._setRelation(opA, opB, 'insertAfter');\n                }\n\n                break;\n              }\n          }\n\n          break;\n        }\n\n      case SplitOperation:\n        {\n          switch (opB.constructor) {\n            case MergeOperation:\n              {\n                if (opA.splitPosition.isBefore(opB.sourcePosition)) {\n                  this._setRelation(opA, opB, 'splitBefore');\n                }\n\n                break;\n              }\n\n            case MoveOperation:\n              {\n                if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {\n                  this._setRelation(opA, opB, 'splitBefore');\n                } else {\n                  const range = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);\n\n                  if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range.containsPosition(opA.splitPosition)) {\n                    const howMany = range.end.offset - opA.splitPosition.offset;\n                    const offset = opA.splitPosition.offset - range.start.offset;\n\n                    this._setRelation(opA, opB, {\n                      howMany,\n                      offset\n                    });\n                  }\n                }\n              }\n          }\n\n          break;\n        }\n\n      case MergeOperation:\n        {\n          switch (opB.constructor) {\n            case MergeOperation:\n              {\n                if (!opA.targetPosition.isEqual(opB.sourcePosition)) {\n                  this._setRelation(opA, opB, 'mergeTargetNotMoved');\n                }\n\n                if (opA.sourcePosition.isEqual(opB.targetPosition)) {\n                  this._setRelation(opA, opB, 'mergeSourceNotMoved');\n                }\n\n                if (opA.sourcePosition.isEqual(opB.sourcePosition)) {\n                  this._setRelation(opA, opB, 'mergeSameElement');\n                }\n\n                break;\n              }\n\n            case SplitOperation:\n              {\n                if (opA.sourcePosition.isEqual(opB.splitPosition)) {\n                  this._setRelation(opA, opB, 'splitAtSource');\n                }\n              }\n          }\n\n          break;\n        }\n\n      case MarkerOperation:\n        {\n          const markerRange = opA.newRange;\n\n          if (!markerRange) {\n            return;\n          }\n\n          switch (opB.constructor) {\n            case MoveOperation:\n              {\n                const movedRange = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);\n\n                const affectedLeft = movedRange.containsPosition(markerRange.start) || movedRange.start.isEqual(markerRange.start);\n                const affectedRight = movedRange.containsPosition(markerRange.end) || movedRange.end.isEqual(markerRange.end);\n\n                if ((affectedLeft || affectedRight) && !movedRange.containsRange(markerRange)) {\n                  this._setRelation(opA, opB, {\n                    side: affectedLeft ? 'left' : 'right',\n                    path: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n                  });\n                }\n\n                break;\n              }\n\n            case MergeOperation:\n              {\n                const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);\n                const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);\n                const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);\n                const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);\n\n                if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {\n                  this._setRelation(opA, opB, {\n                    wasInLeftElement,\n                    wasStartBeforeMergedElement,\n                    wasEndBeforeMergedElement,\n                    wasInRightElement\n                  });\n                }\n\n                break;\n              }\n          }\n\n          break;\n        }\n    }\n  } // Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n  //\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n  // @returns {module:engine/model/operation/transform~TransformationContext}\n\n\n  getContext(opA, opB, aIsStrong) {\n    return {\n      aIsStrong,\n      aWasUndone: this._wasUndone(opA),\n      bWasUndone: this._wasUndone(opB),\n      abRelation: this._useRelations ? this._getRelation(opA, opB) : null,\n      baRelation: this._useRelations ? this._getRelation(opB, opA) : null,\n      forceWeakRemove: this._forceWeakRemove\n    };\n  } // Returns whether given operation `op` has already been undone.\n  //\n  // Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n  //\n  // @param {module:engine/model/operation/operation~Operation} op\n  // @returns {Boolean}\n\n\n  _wasUndone(op) {\n    // For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n    // operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n    // from which was undone. So get that original operation.\n    const originalOp = this.originalOperations.get(op); // And check with the document if the original operation was undone.\n\n    return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);\n  } // Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n  // was set earlier or `null` if there was no relation between those operations.\n  //\n  // This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n  //\n  // When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n  // undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n  // we look forward in the future and ask if in that future `opB` was undone.\n  //\n  // Relations is a backward process to `wasUndone()`.\n  //\n  // Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n  // operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n  // a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n  // between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n  // a better decision when resolving a conflict between two operations, because we know more about the context of\n  // those two operations.\n  //\n  // This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n  // back to search for a meaningful contextual information.\n  //\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n  // @returns {String|null}\n\n\n  _getRelation(opA, opB) {\n    // Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n    const origB = this.originalOperations.get(opB);\n\n    const undoneB = this._history.getUndoneOperation(origB); // If `opB` is not undoing any operation, there is no relation.\n\n\n    if (!undoneB) {\n      return null;\n    }\n\n    const origA = this.originalOperations.get(opA);\n\n    const relationsA = this._relations.get(origA); // Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n\n\n    if (relationsA) {\n      return relationsA.get(undoneB) || null;\n    }\n\n    return null;\n  } // Helper function for `ContextFactory#updateRelations`.\n  //\n  // @private\n  // @param {module:engine/model/operation/operation~Operation} opA\n  // @param {module:engine/model/operation/operation~Operation} opB\n  // @param {String} relation\n\n\n  _setRelation(opA, opB, relation) {\n    // As always, setting is for original operations, not the clones/transformed operations.\n    const origA = this.originalOperations.get(opA);\n    const origB = this.originalOperations.get(opB);\n\n    let relationsA = this._relations.get(origA);\n\n    if (!relationsA) {\n      relationsA = new Map();\n\n      this._relations.set(origA, relationsA);\n    }\n\n    relationsA.set(origB, relation);\n  }\n\n}\n/**\n * Holds additional contextual information about a transformed pair of operations (`a` and `b`). Those information\n * can be used for better conflict resolving.\n *\n * @typedef {Object} module:engine/model/operation/transform~TransformationContext\n *\n * @property {Boolean} aIsStrong Whether `a` is strong operation in this transformation, or weak.\n * @property {Boolean} aWasUndone Whether `a` operation was undone.\n * @property {Boolean} bWasUndone Whether `b` operation was undone.\n * @property {String|null} abRelation The relation between `a` operation and an operation undone by `b` operation.\n * @property {String|null} baRelation The relation between `b` operation and an operation undone by `a` operation.\n */\n\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\n\n\nfunction updateBaseVersions(operations, baseVersion) {\n  for (const operation of operations) {\n    operation.baseVersion = baseVersion++;\n  }\n}\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\n\n\nfunction padWithNoOps(operations, howMany) {\n  for (let i = 0; i < howMany; i++) {\n    operations.push(new NoOperation(0));\n  }\n} // -----------------------\n\n\nsetTransformation(AttributeOperation, AttributeOperation, (a, b, context) => {\n  // If operations in conflict, check if their ranges intersect and manage them properly.\n  //\n  // Operations can be in conflict only if:\n  //\n  // * their key is the same (they change the same attribute), and\n  // * they are in the same parent (operations for ranges [ 1 ] - [ 3 ] and [ 2, 0 ] - [ 2, 5 ] change different\n  // elements and can't be in conflict).\n  if (a.key === b.key && a.range.start.hasSameParentAs(b.range.start)) {\n    // First, we want to apply change to the part of a range that has not been changed by the other operation.\n    const operations = a.range.getDifference(b.range).map(range => {\n      return new AttributeOperation(range, a.key, a.oldValue, a.newValue, 0);\n    }); // Then we take care of the common part of ranges.\n\n    const common = a.range.getIntersection(b.range);\n\n    if (common) {\n      // If this operation is more important, we also want to apply change to the part of the\n      // original range that has already been changed by the other operation. Since that range\n      // got changed we also have to update `oldValue`.\n      if (context.aIsStrong) {\n        operations.push(new AttributeOperation(common, b.key, b.newValue, a.newValue, 0));\n      }\n    }\n\n    if (operations.length == 0) {\n      return [new NoOperation(0)];\n    }\n\n    return operations;\n  } else {\n    // If operations don't conflict, simply return an array containing just a clone of this operation.\n    return [a];\n  }\n});\nsetTransformation(AttributeOperation, InsertOperation, (a, b) => {\n  // Case 1:\n  //\n  // The attribute operation range includes the position where nodes were inserted.\n  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n  // the inserted nodes were elements and they should not receive attributes.\n  //\n  if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {\n    // If new nodes should not receive attributes, two separated ranges will be returned.\n    // Otherwise, one expanded range will be returned.\n    const range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);\n\n    const result = range.map(r => {\n      return new AttributeOperation(r, a.key, a.oldValue, a.newValue, a.baseVersion);\n    });\n\n    if (b.shouldReceiveAttributes) {\n      // `AttributeOperation#range` includes some newly inserted text.\n      // The operation should also change the attribute of that text. An example:\n      //\n      // Bold should be applied on the following range:\n      // <p>Fo[zb]ar</p>\n      //\n      // In meantime, new text is typed:\n      // <p>Fozxxbar</p>\n      //\n      // Bold should be applied also on the new text:\n      // <p>Fo[zxxb]ar</p>\n      // <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n      //\n      // There is a special case to consider here to consider.\n      //\n      // Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n      // have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n      //\n      // Attribute `highlight=\"yellow\"` should be applied on the following range:\n      // <p>Fo[zb]ar<p>\n      //\n      // In meantime, character `x` with `highlight=\"red\"` is typed:\n      // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n      //\n      // In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n      // because that would lead to an exception (`oldValue` is incorrect for `x`).\n      //\n      // We also cannot break the original range as this would mess up a scenario when there are multiple following\n      // insert operations, because then only the first inserted character is included in those ranges:\n      // <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n      //\n      // So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n      //\n      // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n      //\n      // But before that operation would be applied, we will add an additional attribute operation that will change\n      // attributes on the inserted nodes in a way which would make the original operation correct:\n      //\n      // <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n      // <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n      //\n      // Generate complementary attribute operation. Be sure to add it before the original operation.\n      const op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);\n\n      if (op) {\n        result.unshift(op);\n      }\n    } // If nodes should not receive new attribute, we are done here.\n\n\n    return result;\n  } // If insert operation is not expanding the attribute operation range, simply transform the range.\n\n\n  a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];\n  return [a];\n});\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\n\nfunction _getComplementaryAttributeOperations(insertOperation, key, newValue) {\n  const nodes = insertOperation.nodes; // At the beginning we store the attribute value from the first node.\n\n  const insertValue = nodes.getNode(0).getAttribute(key);\n\n  if (insertValue == newValue) {\n    return null;\n  }\n\n  const range = new Range(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));\n  return new AttributeOperation(range, key, insertValue, newValue, 0);\n}\n\nsetTransformation(AttributeOperation, MergeOperation, (a, b) => {\n  const ranges = []; // Case 1:\n  //\n  // Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n  // An additional attribute operation that will change the (re)moved element needs to be generated.\n  //\n\n  if (a.range.start.hasSameParentAs(b.deletionPosition)) {\n    if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {\n      ranges.push(Range._createFromPositionAndShift(b.graveyardPosition, 1));\n    }\n  }\n\n  const range = a.range._getTransformedByMergeOperation(b); // Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n\n\n  if (!range.isCollapsed) {\n    ranges.push(range);\n  } // Create `AttributeOperation`s out of the ranges.\n\n\n  return ranges.map(range => {\n    return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);\n  });\n});\nsetTransformation(AttributeOperation, MoveOperation, (a, b) => {\n  const ranges = _breakRangeByMoveOperation(a.range, b); // Create `AttributeOperation`s out of the ranges.\n\n\n  return ranges.map(range => new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion));\n}); // Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\n\nfunction _breakRangeByMoveOperation(range, moveOp) {\n  const moveRange = Range._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany); // We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n  // transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n\n\n  let common = null;\n  let difference = []; // Let's compare the ranges.\n\n  if (moveRange.containsRange(range, true)) {\n    // If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n    common = range;\n  } else if (range.start.hasSameParentAs(moveRange.start)) {\n    // If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n    // that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n    difference = range.getDifference(moveRange);\n    common = range.getIntersection(moveRange);\n  } else {\n    // In any other situation we assume that original range is different than move range, that is that move operation\n    // moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n    //\n    // Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n    // than `.getDifference` (we would get two ranges).\n    difference = [range];\n  }\n\n  const result = []; // The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n  // we do it by hand.\n\n  for (let diff of difference) {\n    // First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n    // as the range is different than the moved range.\n    diff = diff._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany); // Transform also `targetPosition`.\n\n    const targetPosition = moveOp.getMovedRangeStart(); // Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n\n    const spread = diff.start.hasSameParentAs(targetPosition); // Transform by insertion of moved nodes.\n\n    diff = diff._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);\n    result.push(...diff);\n  } // Common part can be simply transformed by the move operation. This is because move operation will not target to\n  // that common part (the operation would have to target inside its own moved range).\n\n\n  if (common) {\n    result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);\n  }\n\n  return result;\n}\n\nsetTransformation(AttributeOperation, SplitOperation, (a, b) => {\n  // Case 1:\n  //\n  // Split node is the last node in `AttributeOperation#range`.\n  // `AttributeOperation#range` needs to be expanded to include the new (split) node.\n  //\n  // Attribute `type` to be changed to `numbered` but the `listItem` is split.\n  // <listItem type=\"bulleted\">foobar</listItem>\n  //\n  // After split:\n  // <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n  //\n  // After attribute change:\n  // <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n  //\n  if (a.range.end.isEqual(b.insertionPosition)) {\n    if (!b.graveyardPosition) {\n      a.range.end.offset++;\n    }\n\n    return [a];\n  } // Case 2:\n  //\n  // Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n  // not going to make a flat range.\n  //\n  // Content with range-to-change and split position:\n  // <p>Fo[zb^a]r</p>\n  //\n  // After split:\n  // <p>Fozb</p><p>ar</p>\n  //\n  // Make two separate ranges containing all nodes to change:\n  // <p>Fo[zb]</p><p>[a]r</p>\n  //\n\n\n  if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {\n    const secondPart = a.clone();\n    secondPart.range = new Range(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));\n    a.range.end = b.splitPosition.clone();\n    a.range.end.stickiness = 'toPrevious';\n    return [a, secondPart];\n  } // The default case.\n  //\n\n\n  a.range = a.range._getTransformedBySplitOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, AttributeOperation, (a, b) => {\n  const result = [a]; // Case 1:\n  //\n  // The attribute operation range includes the position where nodes were inserted.\n  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n  // the inserted nodes were elements and they should not receive attributes.\n  //\n  // This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n  // although this case is a little less complicated. In this case we simply need to change attributes of the\n  // inserted nodes and that's it.\n  //\n\n  if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {\n    const op = _getComplementaryAttributeOperations(a, b.key, b.newValue);\n\n    if (op) {\n      result.push(op);\n    }\n  } // The default case is: do nothing.\n  // `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n  //\n\n\n  return result;\n});\nsetTransformation(InsertOperation, InsertOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n  // what will be the order of inserted nodes. However, there is no additional information to help in that\n  // decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n  //\n  // To achieve that, we will check if the operation is strong.\n  // If it is, it won't get transformed. If it is not, it will be moved.\n  //\n  if (a.position.isEqual(b.position) && context.aIsStrong) {\n    return [a];\n  } // The default case.\n  //\n\n\n  a.position = a.position._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, MoveOperation, (a, b) => {\n  // The default case.\n  //\n  a.position = a.position._getTransformedByMoveOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, SplitOperation, (a, b) => {\n  // The default case.\n  //\n  a.position = a.position._getTransformedBySplitOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, MergeOperation, (a, b) => {\n  a.position = a.position._getTransformedByMergeOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(MarkerOperation, InsertOperation, (a, b) => {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];\n  }\n\n  if (a.newRange) {\n    a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, MarkerOperation, (a, b, context) => {\n  if (a.name == b.name) {\n    if (context.aIsStrong) {\n      a.oldRange = b.newRange ? b.newRange.clone() : null;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, MergeOperation, (a, b) => {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedByMergeOperation(b);\n  }\n\n  if (a.newRange) {\n    a.newRange = a.newRange._getTransformedByMergeOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, MoveOperation, (a, b, context) => {\n  if (a.oldRange) {\n    a.oldRange = Range._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));\n  }\n\n  if (a.newRange) {\n    if (context.abRelation) {\n      const aNewRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n\n      if (context.abRelation.side == 'left' && b.targetPosition.isEqual(a.newRange.start)) {\n        a.newRange.start.path = context.abRelation.path;\n        a.newRange.end = aNewRange.end;\n        return [a];\n      } else if (context.abRelation.side == 'right' && b.targetPosition.isEqual(a.newRange.end)) {\n        a.newRange.start = aNewRange.start;\n        a.newRange.end.path = context.abRelation.path;\n        return [a];\n      }\n    }\n\n    a.newRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, SplitOperation, (a, b, context) => {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedBySplitOperation(b);\n  }\n\n  if (a.newRange) {\n    if (context.abRelation) {\n      const aNewRange = a.newRange._getTransformedBySplitOperation(b);\n\n      if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {\n        a.newRange.start = Position._createAt(b.insertionPosition);\n      } else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {\n        a.newRange.start = Position._createAt(b.moveTargetPosition);\n      }\n\n      if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {\n        a.newRange.end = Position._createAt(b.moveTargetPosition);\n      } else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {\n        a.newRange.end = Position._createAt(b.insertionPosition);\n      } else {\n        a.newRange.end = aNewRange.end;\n      }\n\n      return [a];\n    }\n\n    a.newRange = a.newRange._getTransformedBySplitOperation(b);\n  }\n\n  return [a];\n}); // -----------------------\n\nsetTransformation(MergeOperation, InsertOperation, (a, b) => {\n  if (a.sourcePosition.hasSameParentAs(b.position)) {\n    a.howMany += b.howMany;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(MergeOperation, MergeOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Same merge operations.\n  //\n  // Both operations have same source and target positions. So the element already got merged and there is\n  // theoretically nothing to do.\n  //\n  if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {\n    // There are two ways that we can provide a do-nothing operation.\n    //\n    // First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n    //\n    // Second is a merge operation that has the source operation in the merged element - in the graveyard -\n    // same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n    // which is almost the same as NoOperation.\n    //\n    // This way the merge operation can be later transformed by split operation\n    // to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n    //\n    if (!context.bWasUndone) {\n      return [new NoOperation(0)];\n    } else {\n      const path = b.graveyardPosition.path.slice();\n      path.push(0);\n      a.sourcePosition = new Position(b.graveyardPosition.root, path);\n      a.howMany = 0;\n      return [a];\n    }\n  } // Case 2:\n  //\n  // Same merge source position but different target position.\n  //\n  // This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n  // and the other person removed that paragraph and merged the same paragraph to something before:\n  //\n  // Client A:\n  // <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n  // <p>Foo</p><p>BarXyz</p>\n  //\n  // Client B:\n  // <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n  // <p>Foo</p><p>[]Xyz</p>\n  // <p>FooXyz</p>\n  //\n  // In this case we need to decide where finally \"Xyz\" will land:\n  //\n  // <p>FooXyz</p>               graveyard: <p>Bar</p>\n  // <p>Foo</p>                  graveyard: <p>BarXyz</p>\n  //\n  // Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n  // nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n  // end up in the graveyard (see above).\n  //\n  // If neither or both operations point to graveyard, then let `aIsStrong` decide.\n  //\n\n\n  if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != 'splitAtSource') {\n    const aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n    const bToGraveyard = b.targetPosition.root.rootName == '$graveyard'; // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\n    const aIsWeak = aToGraveyard && !bToGraveyard; // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\n    const bIsWeak = bToGraveyard && !aToGraveyard; // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\n    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;\n\n    if (forceMove) {\n      const sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);\n\n      const targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n\n      return [new MoveOperation(sourcePosition, a.howMany, targetPosition, 0)];\n    } else {\n      return [new NoOperation(0)];\n    }\n  } // The default case.\n  //\n\n\n  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b); // Handle positions in graveyard.\n  // If graveyard positions are same and `a` operation is strong - do not transform.\n\n  if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MergeOperation, MoveOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // The element to merge got removed.\n  //\n  // Merge operation does support merging elements which are not siblings. So it would not be a problem\n  // from technical point of view. However, if the element was removed, the intention of the user deleting it\n  // was to have it all deleted, together with its children. From user experience point of view, moving back the\n  // removed nodes might be unexpected. This means that in this scenario we will block the merging.\n  //\n  // The exception of this rule would be if the remove operation was later undone.\n  //\n  const removedRange = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n\n  if (b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n    if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {\n      return [new NoOperation(0)];\n    }\n  } // The default case.\n  //\n\n\n  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n\n  if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {\n    a.howMany -= b.howMany;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b); // `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n  // be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n  // Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n  // This means that we won't transform graveyard position if it is equal to move operation target position.\n\n  if (!a.graveyardPosition.isEqual(b.targetPosition)) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MergeOperation, SplitOperation, (a, b, context) => {\n  if (b.graveyardPosition) {\n    // If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n    // transform `a.graveyardPosition` accordingly.\n    a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1); // This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n    //\n    // So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n    // source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n    // means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n    //\n    // If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n    // `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n    // properties.\n    //\n\n    if (a.deletionPosition.isEqual(b.graveyardPosition)) {\n      a.howMany = b.howMany;\n    }\n  } // Case 1:\n  //\n  // Merge operation moves nodes to the place where split happens.\n  // This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n  // paragraph and there is a merge (delete) at the beginning of the second paragraph:\n  //\n  // <p>Foo{}</p><p>[]Bar</p>.\n  //\n  // Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n  //\n  // State after split:\n  // <p>Foo</p><p></p><p>Bar</p>\n  //\n  // Now, `Bar` should be merged to the new paragraph:\n  // <p>Foo</p><p>Bar</p>\n  //\n  // Instead of merging it to the original paragraph:\n  // <p>FooBar</p><p></p>\n  //\n  // This means that `targetPosition` needs to be transformed. This is the default case though.\n  // For example, if the split would be after `F`, `targetPosition` should also be transformed.\n  //\n  // There are three exceptions, though, when we want to keep `targetPosition` as it was.\n  //\n  // First exception is when the merge target position is inside an element (not at the end, as usual). This\n  // happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n  // targets inside the element we want to keep the original target position (and not transform it) because\n  // we have additional context telling us that we want to merge to the original element. We can check if the\n  // merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n  // is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n  //\n  // Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n  // if target position would be transformed, the merge operation would target at the source position:\n  //\n  // root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n  //\n  // SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n  // MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n  //\n  // Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n  // We would like to merge from the empty <p> to the \"Foo\" <p>:\n  //\n  // root: <p>Foo</p><p></p>\t\t\tgraveyard:\n  //\n  // MergeOperation#sourcePosition = root [ 1, 0 ]\n  //\n  // If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n  //\n  // Third exception is connected with relations. If this happens during undo and we have explicit information\n  // that target position has not been affected by the operation which is undone by this split then this split should\n  // not move the target position either.\n  //\n\n\n  if (a.targetPosition.isEqual(b.splitPosition)) {\n    const mergeInside = b.howMany != 0;\n    const mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);\n\n    if (mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved') {\n      a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  } // Case 2:\n  //\n  // Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n  // The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n  // split element) or should be move to the beginning of the new element.\n  //\n\n\n  if (a.sourcePosition.isEqual(b.splitPosition)) {\n    // Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n    // This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n    // In that case `a` operation source position should stay where it is.\n    if (context.abRelation == 'mergeSourceNotMoved') {\n      a.howMany = 0;\n      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n      return [a];\n    } // This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n    // See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n    // the special case is not applied.\n    //\n    // Now, the merge operation is transformed by the split which has undone that previous merge operation.\n    // So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n    //\n\n\n    if (context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0) {\n      a.sourcePosition = b.moveTargetPosition.clone();\n      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  } // The default case.\n  //\n\n\n  if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {\n    a.howMany = b.splitPosition.offset;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(MoveOperation, InsertOperation, (a, b) => {\n  const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  const transformed = moveRange._getTransformedByInsertOperation(b, false)[0];\n\n  a.sourcePosition = transformed.start;\n  a.howMany = transformed.end.offset - transformed.start.offset; // See `InsertOperation` x `MoveOperation` transformation for details on this case.\n  //\n  // In summary, both operations point to the same place, so the order of nodes needs to be decided.\n  // `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n  // between operations.\n  //\n\n  if (!a.targetPosition.isEqual(b.position)) {\n    a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MoveOperation, MoveOperation, (a, b, context) => {\n  //\n  // Setting and evaluating some variables that will be used in special cases and default algorithm.\n  //\n  // Create ranges from `MoveOperations` properties.\n  const rangeA = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  const rangeB = Range._createFromPositionAndShift(b.sourcePosition, b.howMany); // Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n  // this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n\n\n  let aIsStrong = context.aIsStrong; // This will be used to decide the order of nodes if both operations target at the same position.\n  // By default, use strong/weak operation mechanism.\n\n  let insertBefore = !context.aIsStrong; // If the relation is set, then use it to decide nodes order.\n\n  if (context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter') {\n    insertBefore = true;\n  } else if (context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore') {\n    insertBefore = false;\n  } // `a.targetPosition` could be affected by the `b` operation. We will transform it.\n\n\n  let newTargetPosition;\n\n  if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {\n    newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n  } else {\n    newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n  } //\n  // Special case #1 + mirror.\n  //\n  // Special case when both move operations' target positions are inside nodes that are\n  // being moved by the other move operation. So in other words, we move ranges into inside of each other.\n  // This case can't be solved reasonably (on the other hand, it should not happen often).\n\n\n  if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {\n    // Instead of transforming operation, we return a reverse of the operation that we transform by.\n    // So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n    return [b.getReversed()];\n  } //\n  // End of special case #1.\n  //\n  //\n  // Special case #2.\n  //\n  // Check if `b` operation targets inside `rangeA`.\n\n\n  const bTargetsToA = rangeA.containsPosition(b.targetPosition); // If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n  // You might say that operation `b` is captured inside operation `a`.\n\n  if (bTargetsToA && rangeA.containsRange(rangeB, true)) {\n    // There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n    // we need to transform `a` operation anyway.\n    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  } //\n  // Special case #2 mirror.\n  //\n\n\n  const aTargetsToB = rangeB.containsPosition(a.targetPosition);\n\n  if (aTargetsToB && rangeB.containsRange(rangeA, true)) {\n    // `a` operation is \"moved together\" with `b` operation.\n    // Here, just move `rangeA` \"inside\" `rangeB`.\n    rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  } //\n  // End of special case #2.\n  //\n  //\n  // Special case #3 + mirror.\n  //\n  // `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n  // but not on the same tree level. In such case ranges have common part but we have to treat it\n  // differently, because in such case those ranges are not really conflicting and should be treated like\n  // two separate ranges. Also we have to discard two difference parts.\n\n\n  const aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());\n\n  if (aCompB == 'prefix' || aCompB == 'extension') {\n    // Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n    // Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n    // like a one difference part.\n    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  } //\n  // End of special case #3.\n  //\n  //\n  // Default case - ranges are on the same level or are not connected with each other.\n  //\n  // Modifier for default case.\n  // Modifies `aIsStrong` flag in certain conditions.\n  //\n  // If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n  // to provide more expected results.\n\n\n  if (a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove) {\n    aIsStrong = true;\n  } else if (a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n    aIsStrong = false;\n  } // Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n  // This will aggregate transformed ranges.\n\n\n  const ranges = []; // Get the \"difference part\" of `a` operation source range.\n  // This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n\n  const difference = rangeA.getDifference(rangeB);\n\n  for (const range of difference) {\n    // Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n    range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);\n    range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany); // If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n\n    const shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == 'same';\n\n    const newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);\n\n    ranges.push(...newRanges);\n  } // Then, we have to manage the \"common part\" of both move ranges.\n\n\n  const common = rangeA.getIntersection(rangeB);\n\n  if (common !== null && aIsStrong) {\n    // Calculate the new position of that part of original range.\n    common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart()); // Take care of proper range order.\n    //\n    // Put `common` at appropriate place. Keep in mind that we are interested in original order.\n    // Basically there are only three cases: there is zero, one or two difference ranges.\n    //\n    // If there is zero difference ranges, just push `common` in the array.\n\n    if (ranges.length === 0) {\n      ranges.push(common);\n    } // If there is one difference range, we need to check whether common part was before it or after it.\n    else if (ranges.length == 1) {\n      if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {\n        ranges.unshift(common);\n      } else {\n        ranges.push(common);\n      }\n    } // If there are more ranges (which means two), put common part between them. This is the only scenario\n    // where there could be two difference ranges so we don't have to make any comparisons.\n    else {\n      ranges.splice(1, 0, common);\n    }\n  }\n\n  if (ranges.length === 0) {\n    // If there are no \"source ranges\", nothing should be changed.\n    // Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n    return [new NoOperation(a.baseVersion)];\n  }\n\n  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, SplitOperation, (a, b, context) => {\n  let newTargetPosition = a.targetPosition.clone(); // Do not transform if target position is same as split insertion position and this split comes from undo.\n  // This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n  // We need to make a decision how we will resolve such conflict and this is less harmful way.\n\n  if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter') {\n    newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n  } // Case 1:\n  //\n  // Last element in the moved range got split.\n  //\n  // In this case the default range transformation will not work correctly as the element created by\n  // split operation would be outside the range. The range to move needs to be fixed manually.\n  //\n\n\n  const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  if (moveRange.end.isEqual(b.insertionPosition)) {\n    // Do it only if this is a \"natural\" split, not a one that comes from undo.\n    // If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n    if (!b.graveyardPosition) {\n      a.howMany++;\n    }\n\n    a.targetPosition = newTargetPosition;\n    return [a];\n  } // Case 2:\n  //\n  // Split happened between the moved nodes. In this case two ranges to move need to be generated.\n  //\n  // Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n  // <p>F[oz|ba]r</p><p>Xyz</p>\n  //\n  // After split:\n  // <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n  //\n  // Correct ranges:\n  // <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n  //\n  // After move:\n  // <p>F</p><p>r</p><p>Xyzozba</p>\n  //\n\n\n  if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {\n    let rightRange = new Range(b.splitPosition, moveRange.end);\n    rightRange = rightRange._getTransformedBySplitOperation(b);\n    const ranges = [new Range(moveRange.start, b.splitPosition), rightRange];\n    return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n  } // Case 3:\n  //\n  // Move operation targets at the split position. We need to decide if the nodes should be inserted\n  // at the end of the split element or at the beginning of the new element.\n  //\n\n\n  if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == 'insertAtSource') {\n    newTargetPosition = b.moveTargetPosition;\n  } // Case 4:\n  //\n  // Move operation targets just after the split element. We need to decide if the nodes should be inserted\n  // between two parts of split element, or after the new element.\n  //\n  // Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n  // <p>Foo|bar</p>^<p>baz</p>\n  // <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n  //\n  // If there is no contextual information between operations (for example, they come from collaborative\n  // editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n  // However, if the split is from undo, in the past, the moved content might be targeting between the\n  // split parts, meaning that was exactly user's intention:\n  //\n  // <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n  // <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n  // <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n  //\n  // In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n  // so we need to transform accordingly. We can detect this scenario thanks to relations.\n  //\n\n\n  if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == 'insertBetween') {\n    newTargetPosition = a.targetPosition;\n  } // The default case.\n  //\n\n\n  const transformed = moveRange._getTransformedBySplitOperation(b);\n\n  const ranges = [transformed]; // Case 5:\n  //\n  // Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n  //\n\n  if (b.graveyardPosition) {\n    const movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);\n\n    if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {\n      ranges.push(Range._createFromPositionAndShift(b.insertionPosition, 1));\n    }\n  }\n\n  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, MergeOperation, (a, b, context) => {\n  const movedRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {\n    if (a.type == 'remove' && !context.forceWeakRemove) {\n      // Case 1:\n      //\n      // The element to remove got merged.\n      //\n      // Merge operation does support merging elements which are not siblings. So it would not be a problem\n      // from technical point of view. However, if the element was removed, the intention of the user\n      // deleting it was to have it all deleted. From user experience point of view, moving back the\n      // removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n      //\n      if (!context.aWasUndone) {\n        const results = [];\n        let gyMoveSource = b.graveyardPosition.clone();\n\n        let splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);\n\n        if (a.howMany > 1) {\n          results.push(new MoveOperation(a.sourcePosition, a.howMany - 1, a.targetPosition, 0));\n          gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n          splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n        }\n\n        const gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, a.targetPosition);\n\n        const gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);\n        const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n        splitNodesMoveTargetPath.push(0);\n        const splitNodesMoveTarget = new Position(gyMove.targetPosition.root, splitNodesMoveTargetPath);\n        splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);\n        const splitNodesMove = new MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);\n        results.push(gyMove);\n        results.push(splitNodesMove);\n        return results;\n      }\n    } else {\n      // Case 2:\n      //\n      // The element to move got merged and it was the only element to move.\n      // In this case just don't do anything, leave the node in the graveyard. Without special case\n      // it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n      //\n      if (a.howMany == 1) {\n        if (!context.bWasUndone) {\n          return [new NoOperation(0)];\n        } else {\n          a.sourcePosition = b.graveyardPosition.clone();\n          a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n          return [a];\n        }\n      }\n    }\n  } // The default case.\n  //\n\n\n  const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  const transformed = moveRange._getTransformedByMergeOperation(b);\n\n  a.sourcePosition = transformed.start;\n  a.howMany = transformed.end.offset - transformed.start.offset;\n  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(RenameOperation, InsertOperation, (a, b) => {\n  a.position = a.position._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, MergeOperation, (a, b) => {\n  // Case 1:\n  //\n  // Element to rename got merged, so it was moved to `b.graveyardPosition`.\n  //\n  if (a.position.isEqual(b.deletionPosition)) {\n    a.position = b.graveyardPosition.clone();\n    a.position.stickiness = 'toNext';\n    return [a];\n  }\n\n  a.position = a.position._getTransformedByMergeOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, MoveOperation, (a, b) => {\n  a.position = a.position._getTransformedByMoveOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, RenameOperation, (a, b, context) => {\n  if (a.position.isEqual(b.position)) {\n    if (context.aIsStrong) {\n      a.oldName = b.newName;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n\n  return [a];\n});\nsetTransformation(RenameOperation, SplitOperation, (a, b) => {\n  // Case 1:\n  //\n  // The element to rename has been split. In this case, the new element should be also renamed.\n  //\n  // User decides to change the paragraph to a list item:\n  // <paragraph>Foobar</paragraph>\n  //\n  // However, in meantime, split happens:\n  // <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n  //\n  // As a result, rename both elements:\n  // <listItem>Foo</listItem><listItem>bar</listItem>\n  //\n  const renamePath = a.position.path;\n  const splitPath = b.splitPosition.getParentPath();\n\n  if (compareArrays(renamePath, splitPath) == 'same' && !b.graveyardPosition) {\n    const extraRename = new RenameOperation(a.position.getShiftedBy(1), a.oldName, a.newName, 0);\n    return [a, extraRename];\n  } // The default case.\n  //\n\n\n  a.position = a.position._getTransformedBySplitOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(RootAttributeOperation, RootAttributeOperation, (a, b, context) => {\n  if (a.root === b.root && a.key === b.key) {\n    if (!context.aIsStrong || a.newValue === b.newValue) {\n      return [new NoOperation(0)];\n    } else {\n      a.oldValue = b.newValue;\n    }\n  }\n\n  return [a];\n}); // -----------------------\n\nsetTransformation(SplitOperation, InsertOperation, (a, b) => {\n  // The default case.\n  //\n  if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {\n    a.howMany += b.howMany;\n  }\n\n  a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);\n  a.insertionPosition = a.insertionPosition._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(SplitOperation, MergeOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Split element got merged. If two different elements were merged, clients will have different content.\n  //\n  // Example. Merge at `{}`, split at `[]`:\n  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n  //\n  // On merge side it will look like this:\n  // <heading>FooB[]ar</heading>\n  // <heading>FooB</heading><heading>ar</heading>\n  //\n  // On split side it will look like this:\n  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n  // <heading>FooB</heading><paragraph>ar</paragraph>\n  //\n  // Clearly, the second element is different for both clients.\n  //\n  // We could use the removed merge element from graveyard as a split element but then clients would have a different\n  // model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n  //\n  // To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n  // in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n  // used for splitting. Example below.\n  //\n  // Original state:\n  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n  //\n  // Merge side client:\n  //\n  // After merge:\n  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n  //\n  // Extra split:\n  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n  //\n  // Use the \"cloned\" element from graveyard:\n  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n  //\n  // Split side client:\n  //\n  // After split:\n  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n  //\n  // After merge:\n  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n  //\n  // This special case scenario only applies if the original split operation clones the split element.\n  // If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n  // knows exactly which element it should use. So there would be no original problem with different contents.\n  //\n  // Additionally, the special case applies only if the merge wasn't already undone.\n  //\n  if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {\n    const splitPath = b.graveyardPosition.path.slice();\n    splitPath.push(0);\n    const splitPosition = new Position(b.graveyardPosition.root, splitPath);\n    const insertionPosition = SplitOperation.getInsertionPosition(new Position(b.graveyardPosition.root, splitPath));\n    const additionalSplit = new SplitOperation(splitPosition, 0, insertionPosition, null, 0);\n    a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    a.graveyardPosition = additionalSplit.insertionPosition.clone();\n    a.graveyardPosition.stickiness = 'toNext';\n    return [additionalSplit, a];\n  } // The default case.\n  //\n\n\n  if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {\n    a.howMany--;\n  }\n\n  if (a.splitPosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n\n  a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n\n  if (a.graveyardPosition) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(SplitOperation, MoveOperation, (a, b, context) => {\n  const rangeToMove = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n\n  if (a.graveyardPosition) {\n    // Case 1:\n    //\n    // Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n    // is already moved to the correct position, we need to only move the nodes after the split position.\n    // This will be done by `MoveOperation` instead of `SplitOperation`.\n    //\n    const gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);\n\n    if (!context.bWasUndone && gyElementMoved) {\n      const sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);\n\n      const newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n\n      const newTargetPath = newParentPosition.path.slice();\n      newTargetPath.push(0);\n      const newTargetPosition = new Position(newParentPosition.root, newTargetPath);\n      const moveOp = new MoveOperation(sourcePosition, a.howMany, newTargetPosition, 0);\n      return [moveOp];\n    }\n\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n  } // Case 2:\n  //\n  // Split is at a position where nodes were moved.\n  //\n  // This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n  // \"split operation point of view\".\n  //\n\n\n  const splitAtTarget = a.splitPosition.isEqual(b.targetPosition);\n\n  if (splitAtTarget && (context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore')) {\n    a.howMany += b.howMany;\n    a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    return [a];\n  }\n\n  if (splitAtTarget && context.abRelation && context.abRelation.howMany) {\n    const {\n      howMany,\n      offset\n    } = context.abRelation;\n    a.howMany += howMany;\n    a.splitPosition = a.splitPosition.getShiftedBy(offset);\n    return [a];\n  } // Case 3:\n  //\n  // If the split position is inside the moved range, we need to shift the split position to a proper place.\n  // The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n  //\n  // Characters `bc` should be moved to the second paragraph while split position is between them:\n  // <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n  //\n  // After move, new split position is incorrect:\n  // <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n  //\n  // Correct split position:\n  // <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n  //\n  // After split:\n  // <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n  //\n\n\n  if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {\n    const howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);\n    a.howMany -= howManyRemoved;\n\n    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n      a.howMany += b.howMany;\n    }\n\n    a.splitPosition = b.sourcePosition.clone();\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    return [a];\n  } // The default case.\n  // Don't change `howMany` if move operation does not really move anything.\n  //\n\n\n  if (!b.sourcePosition.isEqual(b.targetPosition)) {\n    if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {\n      a.howMany -= b.howMany;\n    }\n\n    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n      a.howMany += b.howMany;\n    }\n  } // Change position stickiness to force a correct transformation.\n\n\n  a.splitPosition.stickiness = 'toNone';\n  a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);\n  a.splitPosition.stickiness = 'toNext';\n\n  if (a.graveyardPosition) {\n    a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);\n  } else {\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  }\n\n  return [a];\n});\nsetTransformation(SplitOperation, SplitOperation, (a, b, context) => {\n  // Case 1:\n  //\n  // Split at the same position.\n  //\n  // If there already was a split at the same position as in `a` operation, it means that the intention\n  // conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n  //\n  // However, there is a difference if these are new splits or splits created by undo. These have different\n  // intentions. Also splits moving back different elements from graveyard have different intentions. They\n  // are just different operations.\n  //\n  // So we cancel split operation only if it was really identical.\n  //\n  // Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n  // default transformation is incorrect too.\n  //\n  if (a.splitPosition.isEqual(b.splitPosition)) {\n    if (!a.graveyardPosition && !b.graveyardPosition) {\n      return [new NoOperation(0)];\n    }\n\n    if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n      return [new NoOperation(0)];\n    } // Use context to know that the `a.splitPosition` should stay where it is.\n    // This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n\n\n    if (context.abRelation == 'splitBefore') {\n      // Since split is at the same position, there are no nodes left to split.\n      a.howMany = 0; // Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n      // That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n      // It could happen if `context` is enabled in collaboration.\n\n      a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  } // Case 2:\n  //\n  // Same node is using to split different elements. This happens in undo when previously same element was merged to\n  // two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n  //\n  // In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n  // split operations. This might not always be true but in the real cases that were experienced it was. After all,\n  // if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n  // should be same for both of those splits.\n  //\n  // Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n  //\n\n\n  if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n    const aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n    const bInGraveyard = b.splitPosition.root.rootName == '$graveyard'; // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\n    const aIsWeak = aInGraveyard && !bInGraveyard; // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\n    const bIsWeak = bInGraveyard && !aInGraveyard; // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\n    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;\n\n    if (forceMove) {\n      const result = []; // First we need to move any nodes split by `b` back to where they were.\n      // Do it only if `b` actually moved something.\n\n      if (b.howMany) {\n        result.push(new MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));\n      } // Then we need to move nodes from `a` split position to their new element.\n      // Do it only if `a` actually should move something.\n\n\n      if (a.howMany) {\n        result.push(new MoveOperation(a.splitPosition, a.howMany, a.moveTargetPosition, 0));\n      }\n\n      return result;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n\n  if (a.graveyardPosition) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n  } // Case 3:\n  //\n  // Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n  // As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n  //\n\n\n  if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == 'splitBefore') {\n    a.howMany++;\n    return [a];\n  } // Case 4:\n  //\n  // This is a mirror to the case 2. above.\n  //\n\n\n  if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == 'splitBefore') {\n    const newPositionPath = b.insertionPosition.path.slice();\n    newPositionPath.push(0);\n    const newPosition = new Position(b.insertionPosition.root, newPositionPath);\n    const moveOp = new MoveOperation(a.insertionPosition, 1, newPosition, 0);\n    return [a, moveOp];\n  } // The default case.\n  //\n\n\n  if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {\n    a.howMany -= b.howMany;\n  }\n\n  a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);\n  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  return [a];\n}); // Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\n\nfunction _moveTargetIntoMovedRange(a, b) {\n  return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;\n} // Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\n\n\nfunction _makeMoveOperationsFromRanges(ranges, targetPosition) {\n  // At this moment we have some ranges and a target position, to which those ranges should be moved.\n  // Order in `ranges` array is the go-to order of after transformation.\n  //\n  // We are almost done. We have `ranges` and `targetPosition` to make operations from.\n  // Unfortunately, those operations may affect each other. Precisely, first operation after move\n  // may affect source range and target position of second and third operation. Same with second\n  // operation affecting third.\n  //\n  // We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n  const operations = []; // Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n\n  for (let i = 0; i < ranges.length; i++) {\n    // Create new operation out of a range and target position.\n    const range = ranges[i];\n    const op = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, 0);\n    operations.push(op); // Transform other ranges by the generated operation.\n\n    for (let j = i + 1; j < ranges.length; j++) {\n      // All ranges in `ranges` array should be:\n      //\n      // * non-intersecting (these are part of original operation source range), and\n      // * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n      //\n      // This means that the transformation will be \"clean\" and always return one result.\n      ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];\n    }\n\n    targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);\n  }\n\n  return operations;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js"],"names":["InsertOperation","AttributeOperation","RenameOperation","MarkerOperation","MoveOperation","RootAttributeOperation","MergeOperation","SplitOperation","NoOperation","Range","Position","compareArrays","transformations","Map","setTransformation","OperationA","OperationB","transformationFunction","aGroup","get","set","getTransformation","has","noUpdateTransformation","a","transform","b","context","constructor","clone","e","transformSets","operationsA","operationsB","options","slice","contextFactory","ContextFactory","document","useRelations","forceWeakRemove","setOriginalOperations","originalOperations","length","nextTransformIndex","WeakMap","op","data","nextBaseVersionA","baseVersion","nextBaseVersionB","originalOperationsACount","originalOperationsBCount","i","opA","indexB","opB","newOpsA","getContext","newOpsB","updateRelation","newOpA","splice","padWithNoOps","brokenOperationsACount","brokenOperationsBCount","updateBaseVersions","_history","history","_useRelations","_forceWeakRemove","_relations","operations","takeFrom","originalOperation","operation","targetPosition","isEqual","sourcePosition","movedRange","containsPosition","_setRelation","deletionPosition","isAfter","isBefore","splitPosition","range","_createFromPositionAndShift","howMany","hasSameParentAs","end","offset","start","markerRange","newRange","affectedLeft","affectedRight","containsRange","side","path","wasInLeftElement","wasStartBeforeMergedElement","wasEndBeforeMergedElement","wasInRightElement","aIsStrong","aWasUndone","_wasUndone","bWasUndone","abRelation","_getRelation","baRelation","originalOp","wasUndone","isUndoneOperation","origB","undoneB","getUndoneOperation","origA","relationsA","relation","push","key","getDifference","map","oldValue","newValue","common","getIntersection","position","_getTransformedByInsertion","shouldReceiveAttributes","result","r","_getComplementaryAttributeOperations","unshift","insertOperation","nodes","insertValue","getNode","getAttribute","getShiftedBy","ranges","graveyardPosition","_getTransformedByMergeOperation","isCollapsed","_breakRangeByMoveOperation","moveOp","moveRange","difference","diff","_getTransformedByDeletion","getMovedRangeStart","spread","_getTransformedByMove","insertionPosition","secondPart","moveTargetPosition","_getCombined","stickiness","_getTransformedBySplitOperation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","oldRange","name","_createFromRanges","aNewRange","_createAt","root","aToGraveyard","rootName","bToGraveyard","aIsWeak","bIsWeak","forceMove","removedRange","type","mergeInside","mergeSplittingElement","transformed","rangeA","rangeB","insertBefore","newTargetPosition","_moveTargetIntoMovedRange","getReversed","bTargetsToA","_makeMoveOperationsFromRanges","aTargetsToB","aCompB","getParentPath","shouldSpread","newRanges","rightRange","movesGraveyardElement","results","gyMoveSource","splitNodesMoveSource","gyMoveTarget","gyMove","splitNodesMoveTargetPath","splitNodesMoveTarget","splitNodesMove","oldName","newName","renamePath","splitPath","extraRename","getInsertionPosition","additionalSplit","rangeToMove","gyElementMoved","newParentPosition","newTargetPath","splitAtTarget","howManyRemoved","aInGraveyard","bInGraveyard","newPositionPath","newPosition","j"],"mappings":"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ACA,GAfiE,CAgBlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA,QAAME,kBAAkB,GAAG,IAAIC,OAAJ,EAA3B,CAnJkE,CAqJlE;;AACA,OAAM,MAAMC,EAAZ,IAAkBd,WAAlB,EAAgC;AAC/BY,IAAAA,kBAAkB,CAACxB,GAAnB,CAAwB0B,EAAxB,EAA4B,CAA5B;AACA,GAxJiE,CA0JlE;;;AACA,QAAMC,IAAI,GAAG;AACZC,IAAAA,gBAAgB,EAAEhB,WAAW,CAAEA,WAAW,CAACW,MAAZ,GAAqB,CAAvB,CAAX,CAAsCM,WAAtC,GAAoD,CAD1D;AAEZC,IAAAA,gBAAgB,EAAEjB,WAAW,CAAEA,WAAW,CAACU,MAAZ,GAAqB,CAAvB,CAAX,CAAsCM,WAAtC,GAAoD,CAF1D;AAGZE,IAAAA,wBAAwB,EAAEnB,WAAW,CAACW,MAH1B;AAIZS,IAAAA,wBAAwB,EAAEnB,WAAW,CAACU;AAJ1B,GAAb,CA3JkE,CAkKlE;;AACA,MAAIU,CAAC,GAAG,CAAR,CAnKkE,CAqKlE;;AAC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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport MergeOperation from './mergeoperation';\nimport SplitOperation from './splitoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport Position from '../position';\n\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\nconst transformations = new Map();\n\n/**\n * @module engine/model/operation/transform\n */\n\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\nfunction setTransformation( OperationA, OperationB, transformationFunction ) {\n\tlet aGroup = transformations.get( OperationA );\n\n\tif ( !aGroup ) {\n\t\taGroup = new Map();\n\t\ttransformations.set( OperationA, aGroup );\n\t}\n\n\taGroup.set( OperationB, transformationFunction );\n}\n\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\nfunction getTransformation( OperationA, OperationB ) {\n\tconst aGroup = transformations.get( OperationA );\n\n\tif ( aGroup && aGroup.has( OperationB ) ) {\n\t\treturn aGroup.get( OperationB );\n\t}\n\n\treturn noUpdateTransformation;\n}\n\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\nfunction noUpdateTransformation( a ) {\n\treturn [ a ];\n}\n\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} context Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\nexport function transform( a, b, context = {} ) {\n\tconst transformationFunction = getTransformation( a.constructor, b.constructor );\n\n\t/* eslint-disable no-useless-catch */\n\ttry {\n\t\ta = a.clone();\n\n\t\treturn transformationFunction( a, b, context );\n\t} catch ( e ) {\n\t\t// @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );\n\t\t// @if CK_DEBUG // console.warn( 'Transformed operation', a );\n\t\t// @if CK_DEBUG // console.warn( 'Operation transformed by', b );\n\t\t// @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );\n\t\t// @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );\n\t\t// @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );\n\n\t\tthrow e;\n\t}\n\t/* eslint-enable no-useless-catch */\n}\n\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document|null} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed\n * operations and the values are the original operations from the input (`operationsA` and `operationsB`).\n */\nexport function transformSets( operationsA, operationsB, options ) {\n\t// Create new arrays so the originally passed arguments are not changed.\n\t// No need to clone operations, they are cloned as they are transformed.\n\toperationsA = operationsA.slice();\n\toperationsB = operationsB.slice();\n\n\tconst contextFactory = new ContextFactory( options.document, options.useRelations, options.forceWeakRemove );\n\tcontextFactory.setOriginalOperations( operationsA );\n\tcontextFactory.setOriginalOperations( operationsB );\n\n\tconst originalOperations = contextFactory.originalOperations;\n\n\t// If one of sets is empty there is simply nothing to transform, so return sets as they are.\n\tif ( operationsA.length == 0 || operationsB.length == 0 ) {\n\t\treturn { operationsA, operationsB, originalOperations };\n\t}\n\t//\n\t// Following is a description of transformation process:\n\t//\n\t// There are `operationsA` and `operationsB` to be transformed, both by both.\n\t//\n\t// So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n\t//\n\t// Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n\t// the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n\t// is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n\t//\n\t// However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n\t// we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n\t// All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n\t//\n\t// The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n\t//\n\t//          [the initial state]\n\t//         [common for a1 and b1]\n\t//\n\t//                   *\n\t//                  / \\\n\t//                 /   \\\n\t//               b1     a1\n\t//               /       \\\n\t//              /         \\\n\t//             *           *\n\t//            / \\         / \\\n\t//           /   \\       /   \\\n\t//         b2    a1'   b1'    a2\n\t//         /       \\   /       \\\n\t//        /         \\ /         \\\n\t//       *           *           *\n\t//        \\         / \\         /\n\t//         \\       /   \\       /\n\t//        a1''   b2'   a2'   b1''\n\t//           \\   /       \\   /\n\t//            \\ /         \\ /\n\t//             *           *\n\t//              \\         /\n\t//               \\       /\n\t//              a2''   b2''\n\t//                 \\   /\n\t//                  \\ /\n\t//                   *\n\t//\n\t//           [the final state]\n\t//\n\t// The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n\t// applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n\t// transformed.\n\t//\n\t// Another thing to consider is that an operation during transformation can be broken into multiple operations.\n\t// Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n\t//\n\t// In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n\t// (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n\t// by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n\t// from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n\t// by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n\t// following `operationsA` (in our case it is just `a2`).\n\t//\n\t// Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n\t// the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n\t// be transformed by both of them.\n\t//\n\t//                       *\n\t//                      / \\\n\t//                     /   \\\n\t//                    /     \\\n\t//                  b1       a1\n\t//                  /         \\\n\t//                 /           \\\n\t//                /             \\\n\t//               *               *\n\t//              / \\             / \\\n\t//             /  a11'         /   \\\n\t//            /     \\         /     \\\n\t//          b2       *      b1'      a2\n\t//          /       / \\     /         \\\n\t//         /       /  a12' /           \\\n\t//        /       /     \\ /             \\\n\t//       *       b2'     *               *\n\t//        \\     /       / \\             /\n\t//       a11'' /     b21'' \\           /\n\t//          \\ /       /     \\         /\n\t//           *       *      a2'     b1''\n\t//            \\     / \\       \\     /\n\t//          a12'' b22''\\       \\   /\n\t//              \\ /     \\       \\ /\n\t//               *      a2''     *\n\t//                \\       \\     /\n\t//                 \\       \\  b21'''\n\t//                  \\       \\ /\n\t//                a2'''      *\n\t//                    \\     /\n\t//                     \\  b22'''\n\t//                      \\ /\n\t//                       *\n\t//\n\t// Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n\t//\n\t// Having all that on mind, here is an outline for the transformation process algorithm:\n\t//\n\t// 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n\t//\n\t// 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n\t// All original `operationsA` are set to be transformed starting from the first operation `b`.\n\t//\n\t// 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n\t// by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n\t// with the transformation results.\n\t//\n\t// 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n\t// original operation.\n\t//\n\t// 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n\t// be transformed by.\n\t//\n\t// 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n\t// unless the last operation `a` was transformed.\n\t//\n\t// The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n\t// The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n\t// to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n\t// index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n\t// operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n\t// current `a` operation index to the next one.\n\t//\n\n\t// For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n\tconst nextTransformIndex = new WeakMap();\n\n\t// For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n\tfor ( const op of operationsA ) {\n\t\tnextTransformIndex.set( op, 0 );\n\t}\n\n\t// Additional data that is used for some postprocessing after the main transformation process is done.\n\tconst data = {\n\t\tnextBaseVersionA: operationsA[ operationsA.length - 1 ].baseVersion + 1,\n\t\tnextBaseVersionB: operationsB[ operationsB.length - 1 ].baseVersion + 1,\n\t\toriginalOperationsACount: operationsA.length,\n\t\toriginalOperationsBCount: operationsB.length\n\t};\n\n\t// Index of currently transformed operation `a`.\n\tlet i = 0;\n\n\t// While not all `operationsA` are transformed...\n\twhile ( i < operationsA.length ) {\n\t\t// Get \"current\" operation `a`.\n\t\tconst opA = operationsA[ i ];\n\n\t\t// For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n\t\tconst indexB = nextTransformIndex.get( opA );\n\n\t\t// If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n\t\tif ( indexB == operationsB.length ) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst opB = operationsB[ indexB ];\n\n\t\t// Transform `a` by `b` and `b` by `a`.\n\t\tconst newOpsA = transform( opA, opB, contextFactory.getContext( opA, opB, true ) );\n\t\tconst newOpsB = transform( opB, opA, contextFactory.getContext( opB, opA, false ) );\n\t\t// As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n\n\t\t// Update contextual information about operations.\n\t\tcontextFactory.updateRelation( opA, opB );\n\n\t\tcontextFactory.setOriginalOperations( newOpsA, opA );\n\t\tcontextFactory.setOriginalOperations( newOpsB, opB );\n\n\t\t// For new `a` operations, update their index of the next operation `b` to transform them by.\n\t\t//\n\t\t// This is needed even if there was only one result (`a` was not broken) because that information is used\n\t\t// at the beginning of this loop every time.\n\t\tfor ( const newOpA of newOpsA ) {\n\t\t\t// Acknowledge, that operation `b` also might be broken into multiple operations.\n\t\t\t//\n\t\t\t// This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n\t\t\t// spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n\t\t\t// be transformed by the same operation (part of it) again.\n\t\t\tnextTransformIndex.set( newOpA, indexB + newOpsB.length );\n\t\t}\n\n\t\t// Update `operationsA` and `operationsB` with the transformed versions.\n\t\toperationsA.splice( i, 1, ...newOpsA );\n\t\toperationsB.splice( indexB, 1, ...newOpsB );\n\t}\n\n\tif ( options.padWithNoOps ) {\n\t\t// If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n\t\tconst brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n\t\tconst brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;\n\n\t\t// Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n\t\t// that the base versions are equalled.\n\t\t//\n\t\t// Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n\t\tpadWithNoOps( operationsA, brokenOperationsBCount - brokenOperationsACount );\n\t\tpadWithNoOps( operationsB, brokenOperationsACount - brokenOperationsBCount );\n\t}\n\n\t// Finally, update base versions of transformed operations.\n\tupdateBaseVersions( operationsA, data.nextBaseVersionB );\n\tupdateBaseVersions( operationsB, data.nextBaseVersionA );\n\n\treturn { operationsA, operationsB, originalOperations };\n}\n\n// Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\nclass ContextFactory {\n\t// Creates `ContextFactory` instance.\n\t//\n\t// @param {module:engine/model/document~Document} document Document which the operations change.\n\t// @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n\t// better conflict resolution).\n\t// @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n\t// so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n\tconstructor( document, useRelations, forceWeakRemove = false ) {\n\t\t// For each operation that is created during transformation process, we keep a reference to the original operation\n\t\t// which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n\t\t// gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n\t\t// This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n\t\t// gathered data through original operation reference.\n\t\tthis.originalOperations = new Map();\n\n\t\t// `model.History` instance which information about undone operations will be taken from.\n\t\tthis._history = document.history;\n\n\t\t// Whether additional context should be used.\n\t\tthis._useRelations = useRelations;\n\n\t\tthis._forceWeakRemove = !!forceWeakRemove;\n\n\t\t// Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n\t\t// to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n\t\t// we keep relations between them.\n\t\tthis._relations = new Map();\n\t}\n\n\t// Sets \"original operation\" for given operations.\n\t//\n\t// During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n\t// or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n\t// so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n\t//\n\t// The original operation object will be used as such an universal linking id. Throughout the transformation process\n\t// all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n\t//\n\t// If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n\t// This should be used as an initialization step.\n\t//\n\t// If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n\t// for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n\t// `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n\t//\n\t// @param {Array.<module:engine/model/operation/operation~Operation>} operations\n\t// @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n\tsetOriginalOperations( operations, takeFrom = null ) {\n\t\tconst originalOperation = takeFrom ? this.originalOperations.get( takeFrom ) : null;\n\n\t\tfor ( const operation of operations ) {\n\t\t\tthis.originalOperations.set( operation, originalOperation || operation );\n\t\t}\n\t}\n\n\t// Saves a relation between operations `opA` and `opB`.\n\t//\n\t// Relations are then later used to help solve conflicts when operations are transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\tupdateRelation( opA, opB ) {\n\t\t// The use of relations is described in a bigger detail in transformation functions.\n\t\t//\n\t\t// In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n\t\t// Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n\t\t// position is before the other operation source position. This kind of information gives contextual information when\n\t\t// transformation is used during undo. Similar checks are done for other pairs of operations.\n\t\t//\n\t\tswitch ( opA.constructor ) {\n\t\t\tcase MoveOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opB.movedRange.containsPosition( opA.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAtSource' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isEqual( opB.deletionPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBetween' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isAfter( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'moveTargetAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opA.targetPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBefore' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase SplitOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isEqual( opB.sourcePosition ) || opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst range = Range._createFromPositionAndShift( opB.sourcePosition, opB.howMany );\n\n\t\t\t\t\t\t\tif ( opA.splitPosition.hasSameParentAs( opB.sourcePosition ) && range.containsPosition( opA.splitPosition ) ) {\n\t\t\t\t\t\t\t\tconst howMany = range.end.offset - opA.splitPosition.offset;\n\t\t\t\t\t\t\t\tconst offset = opA.splitPosition.offset - range.start.offset;\n\n\t\t\t\t\t\t\t\tthis._setRelation( opA, opB, { howMany, offset } );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MergeOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( !opA.targetPosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeTargetNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSourceNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSameElement' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase SplitOperation: {\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.splitPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitAtSource' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MarkerOperation: {\n\t\t\t\tconst markerRange = opA.newRange;\n\n\t\t\t\tif ( !markerRange ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tconst movedRange = Range._createFromPositionAndShift( opB.sourcePosition, opB.howMany );\n\n\t\t\t\t\t\tconst affectedLeft = movedRange.containsPosition( markerRange.start ) ||\n\t\t\t\t\t\t\tmovedRange.start.isEqual( markerRange.start );\n\n\t\t\t\t\t\tconst affectedRight = movedRange.containsPosition( markerRange.end ) ||\n\t\t\t\t\t\t\tmovedRange.end.isEqual( markerRange.end );\n\n\t\t\t\t\t\tif ( ( affectedLeft || affectedRight ) && !movedRange.containsRange( markerRange ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\tside: affectedLeft ? 'left' : 'right',\n\t\t\t\t\t\t\t\tpath: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tconst wasInLeftElement = markerRange.start.isEqual( opB.targetPosition );\n\t\t\t\t\t\tconst wasStartBeforeMergedElement = markerRange.start.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasEndBeforeMergedElement = markerRange.end.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasInRightElement = markerRange.end.isEqual( opB.sourcePosition );\n\n\t\t\t\t\t\tif ( wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\twasInLeftElement,\n\t\t\t\t\t\t\t\twasStartBeforeMergedElement,\n\t\t\t\t\t\t\t\twasEndBeforeMergedElement,\n\t\t\t\t\t\t\t\twasInRightElement\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {module:engine/model/operation/transform~TransformationContext}\n\tgetContext( opA, opB, aIsStrong ) {\n\t\treturn {\n\t\t\taIsStrong,\n\t\t\taWasUndone: this._wasUndone( opA ),\n\t\t\tbWasUndone: this._wasUndone( opB ),\n\t\t\tabRelation: this._useRelations ? this._getRelation( opA, opB ) : null,\n\t\t\tbaRelation: this._useRelations ? this._getRelation( opB, opA ) : null,\n\t\t\tforceWeakRemove: this._forceWeakRemove\n\t\t};\n\t}\n\n\t// Returns whether given operation `op` has already been undone.\n\t//\n\t// Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} op\n\t// @returns {Boolean}\n\t_wasUndone( op ) {\n\t\t// For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n\t\t// operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n\t\t// from which was undone. So get that original operation.\n\t\tconst originalOp = this.originalOperations.get( op );\n\n\t\t// And check with the document if the original operation was undone.\n\t\treturn originalOp.wasUndone || this._history.isUndoneOperation( originalOp );\n\t}\n\n\t// Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n\t// was set earlier or `null` if there was no relation between those operations.\n\t//\n\t// This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n\t//\n\t// When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n\t// undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n\t// we look forward in the future and ask if in that future `opB` was undone.\n\t//\n\t// Relations is a backward process to `wasUndone()`.\n\t//\n\t// Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n\t// operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n\t// a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n\t// between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n\t// a better decision when resolving a conflict between two operations, because we know more about the context of\n\t// those two operations.\n\t//\n\t// This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n\t// back to search for a meaningful contextual information.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {String|null}\n\t_getRelation( opA, opB ) {\n\t\t// Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n\t\tconst origB = this.originalOperations.get( opB );\n\t\tconst undoneB = this._history.getUndoneOperation( origB );\n\n\t\t// If `opB` is not undoing any operation, there is no relation.\n\t\tif ( !undoneB ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst relationsA = this._relations.get( origA );\n\n\t\t// Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n\t\tif ( relationsA ) {\n\t\t\treturn relationsA.get( undoneB ) || null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Helper function for `ContextFactory#updateRelations`.\n\t//\n\t// @private\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @param {String} relation\n\t_setRelation( opA, opB, relation ) {\n\t\t// As always, setting is for original operations, not the clones/transformed operations.\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst origB = this.originalOperations.get( opB );\n\n\t\tlet relationsA = this._relations.get( origA );\n\n\t\tif ( !relationsA ) {\n\t\t\trelationsA = new Map();\n\t\t\tthis._relations.set( origA, relationsA );\n\t\t}\n\n\t\trelationsA.set( origB, relation );\n\t}\n}\n\n/**\n * Holds additional contextual information about a transformed pair of operations (`a` and `b`). Those information\n * can be used for better conflict resolving.\n *\n * @typedef {Object} module:engine/model/operation/transform~TransformationContext\n *\n * @property {Boolean} aIsStrong Whether `a` is strong operation in this transformation, or weak.\n * @property {Boolean} aWasUndone Whether `a` operation was undone.\n * @property {Boolean} bWasUndone Whether `b` operation was undone.\n * @property {String|null} abRelation The relation between `a` operation and an operation undone by `b` operation.\n * @property {String|null} baRelation The relation between `b` operation and an operation undone by `a` operation.\n */\n\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\nfunction updateBaseVersions( operations, baseVersion ) {\n\tfor ( const operation of operations ) {\n\t\toperation.baseVersion = baseVersion++;\n\t}\n}\n\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\nfunction padWithNoOps( operations, howMany ) {\n\tfor ( let i = 0; i < howMany; i++ ) {\n\t\toperations.push( new NoOperation( 0 ) );\n\t}\n}\n\n// -----------------------\n\nsetTransformation( AttributeOperation, AttributeOperation, ( a, b, context ) => {\n\t// If operations in conflict, check if their ranges intersect and manage them properly.\n\t//\n\t// Operations can be in conflict only if:\n\t//\n\t// * their key is the same (they change the same attribute), and\n\t// * they are in the same parent (operations for ranges [ 1 ] - [ 3 ] and [ 2, 0 ] - [ 2, 5 ] change different\n\t// elements and can't be in conflict).\n\tif ( a.key === b.key && a.range.start.hasSameParentAs( b.range.start ) ) {\n\t\t// First, we want to apply change to the part of a range that has not been changed by the other operation.\n\t\tconst operations = a.range.getDifference( b.range ).map( range => {\n\t\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, 0 );\n\t\t} );\n\n\t\t// Then we take care of the common part of ranges.\n\t\tconst common = a.range.getIntersection( b.range );\n\n\t\tif ( common ) {\n\t\t\t// If this operation is more important, we also want to apply change to the part of the\n\t\t\t// original range that has already been changed by the other operation. Since that range\n\t\t\t// got changed we also have to update `oldValue`.\n\t\t\tif ( context.aIsStrong ) {\n\t\t\t\toperations.push( new AttributeOperation( common, b.key, b.newValue, a.newValue, 0 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( operations.length == 0 ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\treturn operations;\n\t} else {\n\t\t// If operations don't conflict, simply return an array containing just a clone of this operation.\n\t\treturn [ a ];\n\t}\n} );\n\nsetTransformation( AttributeOperation, InsertOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.position ) && a.range.containsPosition( b.position ) ) {\n\t\t// If new nodes should not receive attributes, two separated ranges will be returned.\n\t\t// Otherwise, one expanded range will be returned.\n\t\tconst range = a.range._getTransformedByInsertion( b.position, b.howMany, !b.shouldReceiveAttributes );\n\t\tconst result = range.map( r => {\n\t\t\treturn new AttributeOperation( r, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t\t} );\n\n\t\tif ( b.shouldReceiveAttributes ) {\n\t\t\t// `AttributeOperation#range` includes some newly inserted text.\n\t\t\t// The operation should also change the attribute of that text. An example:\n\t\t\t//\n\t\t\t// Bold should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar</p>\n\t\t\t//\n\t\t\t// In meantime, new text is typed:\n\t\t\t// <p>Fozxxbar</p>\n\t\t\t//\n\t\t\t// Bold should be applied also on the new text:\n\t\t\t// <p>Fo[zxxb]ar</p>\n\t\t\t// <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n\t\t\t//\n\t\t\t// There is a special case to consider here to consider.\n\t\t\t//\n\t\t\t// Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n\t\t\t// have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n\t\t\t//\n\t\t\t// Attribute `highlight=\"yellow\"` should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar<p>\n\t\t\t//\n\t\t\t// In meantime, character `x` with `highlight=\"red\"` is typed:\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n\t\t\t//\n\t\t\t// In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n\t\t\t// because that would lead to an exception (`oldValue` is incorrect for `x`).\n\t\t\t//\n\t\t\t// We also cannot break the original range as this would mess up a scenario when there are multiple following\n\t\t\t// insert operations, because then only the first inserted character is included in those ranges:\n\t\t\t// <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n\t\t\t//\n\t\t\t// So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n\t\t\t//\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n\t\t\t//\n\t\t\t// But before that operation would be applied, we will add an additional attribute operation that will change\n\t\t\t// attributes on the inserted nodes in a way which would make the original operation correct:\n\t\t\t//\n\t\t\t// <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n\t\t\t// <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n\t\t\t//\n\n\t\t\t// Generate complementary attribute operation. Be sure to add it before the original operation.\n\t\t\tconst op = _getComplementaryAttributeOperations( b, a.key, a.oldValue );\n\n\t\t\tif ( op ) {\n\t\t\t\tresult.unshift( op );\n\t\t\t}\n\t\t}\n\n\t\t// If nodes should not receive new attribute, we are done here.\n\t\treturn result;\n\t}\n\n\t// If insert operation is not expanding the attribute operation range, simply transform the range.\n\ta.range = a.range._getTransformedByInsertion( b.position, b.howMany, false )[ 0 ];\n\n\treturn [ a ];\n} );\n\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\nfunction _getComplementaryAttributeOperations( insertOperation, key, newValue ) {\n\tconst nodes = insertOperation.nodes;\n\n\t// At the beginning we store the attribute value from the first node.\n\tconst insertValue = nodes.getNode( 0 ).getAttribute( key );\n\n\tif ( insertValue == newValue ) {\n\t\treturn null;\n\t}\n\n\tconst range = new Range( insertOperation.position, insertOperation.position.getShiftedBy( insertOperation.howMany ) );\n\n\treturn new AttributeOperation( range, key, insertValue, newValue, 0 );\n}\n\nsetTransformation( AttributeOperation, MergeOperation, ( a, b ) => {\n\tconst ranges = [];\n\n\t// Case 1:\n\t//\n\t// Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n\t// An additional attribute operation that will change the (re)moved element needs to be generated.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.deletionPosition ) ) {\n\t\tif ( a.range.containsPosition( b.deletionPosition ) || a.range.start.isEqual( b.deletionPosition ) ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.graveyardPosition, 1 ) );\n\t\t}\n\t}\n\n\tconst range = a.range._getTransformedByMergeOperation( b );\n\n\t// Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n\tif ( !range.isCollapsed ) {\n\t\tranges.push( range );\n\t}\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => {\n\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t} );\n} );\n\nsetTransformation( AttributeOperation, MoveOperation, ( a, b ) => {\n\tconst ranges = _breakRangeByMoveOperation( a.range, b );\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion ) );\n} );\n\n// Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\nfunction _breakRangeByMoveOperation( range, moveOp ) {\n\tconst moveRange = Range._createFromPositionAndShift( moveOp.sourcePosition, moveOp.howMany );\n\n\t// We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n\t// transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n\tlet common = null;\n\tlet difference = [];\n\n\t// Let's compare the ranges.\n\tif ( moveRange.containsRange( range, true ) ) {\n\t\t// If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n\t\tcommon = range;\n\t} else if ( range.start.hasSameParentAs( moveRange.start ) ) {\n\t\t// If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n\t\t// that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n\t\tdifference = range.getDifference( moveRange );\n\t\tcommon = range.getIntersection( moveRange );\n\t} else {\n\t\t// In any other situation we assume that original range is different than move range, that is that move operation\n\t\t// moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n\t\t//\n\t\t// Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n\t\t// than `.getDifference` (we would get two ranges).\n\t\tdifference = [ range ];\n\t}\n\n\tconst result = [];\n\n\t// The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n\t// we do it by hand.\n\tfor ( let diff of difference ) {\n\t\t// First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n\t\t// as the range is different than the moved range.\n\t\tdiff = diff._getTransformedByDeletion( moveOp.sourcePosition, moveOp.howMany );\n\n\t\t// Transform also `targetPosition`.\n\t\tconst targetPosition = moveOp.getMovedRangeStart();\n\n\t\t// Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n\t\tconst spread = diff.start.hasSameParentAs( targetPosition );\n\n\t\t// Transform by insertion of moved nodes.\n\t\tdiff = diff._getTransformedByInsertion( targetPosition, moveOp.howMany, spread );\n\n\t\tresult.push( ...diff );\n\t}\n\n\t// Common part can be simply transformed by the move operation. This is because move operation will not target to\n\t// that common part (the operation would have to target inside its own moved range).\n\tif ( common ) {\n\t\tresult.push(\n\t\t\tcommon._getTransformedByMove( moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false )[ 0 ]\n\t\t);\n\t}\n\n\treturn result;\n}\n\nsetTransformation( AttributeOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Split node is the last node in `AttributeOperation#range`.\n\t// `AttributeOperation#range` needs to be expanded to include the new (split) node.\n\t//\n\t// Attribute `type` to be changed to `numbered` but the `listItem` is split.\n\t// <listItem type=\"bulleted\">foobar</listItem>\n\t//\n\t// After split:\n\t// <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n\t//\n\t// After attribute change:\n\t// <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n\t//\n\tif ( a.range.end.isEqual( b.insertionPosition ) ) {\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.range.end.offset++;\n\t\t}\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n\t// not going to make a flat range.\n\t//\n\t// Content with range-to-change and split position:\n\t// <p>Fo[zb^a]r</p>\n\t//\n\t// After split:\n\t// <p>Fozb</p><p>ar</p>\n\t//\n\t// Make two separate ranges containing all nodes to change:\n\t// <p>Fo[zb]</p><p>[a]r</p>\n\t//\n\tif ( a.range.start.hasSameParentAs( b.splitPosition ) && a.range.containsPosition( b.splitPosition ) ) {\n\t\tconst secondPart = a.clone();\n\n\t\tsecondPart.range = new Range(\n\t\t\tb.moveTargetPosition.clone(),\n\t\t\ta.range.end._getCombined( b.splitPosition, b.moveTargetPosition )\n\t\t);\n\n\t\ta.range.end = b.splitPosition.clone();\n\t\ta.range.end.stickiness = 'toPrevious';\n\n\t\treturn [ a, secondPart ];\n\t}\n\n\t// The default case.\n\t//\n\ta.range = a.range._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, AttributeOperation, ( a, b ) => {\n\tconst result = [ a ];\n\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\t// This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n\t// although this case is a little less complicated. In this case we simply need to change attributes of the\n\t// inserted nodes and that's it.\n\t//\n\tif ( a.shouldReceiveAttributes && a.position.hasSameParentAs( b.range.start ) && b.range.containsPosition( a.position ) ) {\n\t\tconst op = _getComplementaryAttributeOperations( a, b.key, b.newValue );\n\n\t\tif ( op ) {\n\t\t\tresult.push( op );\n\t\t}\n\t}\n\n\t// The default case is: do nothing.\n\t// `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n\t//\n\treturn result;\n} );\n\nsetTransformation( InsertOperation, InsertOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n\t// what will be the order of inserted nodes. However, there is no additional information to help in that\n\t// decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n\t//\n\t// To achieve that, we will check if the operation is strong.\n\t// If it is, it won't get transformed. If it is not, it will be moved.\n\t//\n\tif ( a.position.isEqual( b.position ) && context.aIsStrong ) {\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MoveOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, SplitOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MergeOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MarkerOperation, InsertOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MarkerOperation, ( a, b, context ) => {\n\tif ( a.name == b.name ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldRange = b.newRange ? b.newRange.clone() : null;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MergeOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByMergeOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MoveOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = Range._createFromRanges( a.oldRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\n\t\t\tif ( context.abRelation.side == 'left' && b.targetPosition.isEqual( a.newRange.start ) ) {\n\t\t\t\ta.newRange.start.path = context.abRelation.path;\n\t\t\t\ta.newRange.end = aNewRange.end;\n\n\t\t\t\treturn [ a ];\n\t\t\t} else if ( context.abRelation.side == 'right' && b.targetPosition.isEqual( a.newRange.end ) ) {\n\t\t\t\ta.newRange.start = aNewRange.start;\n\t\t\t\ta.newRange.end.path = context.abRelation.path;\n\n\t\t\t\treturn [ a ];\n\t\t\t}\n\t\t}\n\n\t\ta.newRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, SplitOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedBySplitOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = a.newRange._getTransformedBySplitOperation( b );\n\n\t\t\tif ( a.newRange.start.isEqual( b.splitPosition ) && context.abRelation.wasStartBeforeMergedElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.insertionPosition );\n\t\t\t} else if ( a.newRange.start.isEqual( b.splitPosition ) && !context.abRelation.wasInLeftElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.moveTargetPosition );\n\t\t\t}\n\n\t\t\tif ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasInRightElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.moveTargetPosition );\n\t\t\t} else if ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasEndBeforeMergedElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.insertionPosition );\n\t\t\t} else {\n\t\t\t\ta.newRange.end = aNewRange.end;\n\t\t\t}\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\ta.newRange = a.newRange._getTransformedBySplitOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MergeOperation, InsertOperation, ( a, b ) => {\n\tif ( a.sourcePosition.hasSameParentAs( b.position ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByInsertOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Same merge operations.\n\t//\n\t// Both operations have same source and target positions. So the element already got merged and there is\n\t// theoretically nothing to do.\n\t//\n\tif ( a.sourcePosition.isEqual( b.sourcePosition ) && a.targetPosition.isEqual( b.targetPosition ) ) {\n\t\t// There are two ways that we can provide a do-nothing operation.\n\t\t//\n\t\t// First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n\t\t//\n\t\t// Second is a merge operation that has the source operation in the merged element - in the graveyard -\n\t\t// same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n\t\t// which is almost the same as NoOperation.\n\t\t//\n\t\t// This way the merge operation can be later transformed by split operation\n\t\t// to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n\t\t//\n\t\tif ( !context.bWasUndone ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\tconst path = b.graveyardPosition.path.slice();\n\t\t\tpath.push( 0 );\n\n\t\t\ta.sourcePosition = new Position( b.graveyardPosition.root, path );\n\t\t\ta.howMany = 0;\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same merge source position but different target position.\n\t//\n\t// This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n\t// and the other person removed that paragraph and merged the same paragraph to something before:\n\t//\n\t// Client A:\n\t// <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n\t// <p>Foo</p><p>BarXyz</p>\n\t//\n\t// Client B:\n\t// <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n\t// <p>Foo</p><p>[]Xyz</p>\n\t// <p>FooXyz</p>\n\t//\n\t// In this case we need to decide where finally \"Xyz\" will land:\n\t//\n\t// <p>FooXyz</p>               graveyard: <p>Bar</p>\n\t// <p>Foo</p>                  graveyard: <p>BarXyz</p>\n\t//\n\t// Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n\t// nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n\t// end up in the graveyard (see above).\n\t//\n\t// If neither or both operations point to graveyard, then let `aIsStrong` decide.\n\t//\n\tif (\n\t\ta.sourcePosition.isEqual( b.sourcePosition ) && !a.targetPosition.isEqual( b.targetPosition ) &&\n\t\t!context.bWasUndone && context.abRelation != 'splitAtSource'\n\t) {\n\t\tconst aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n\t\tconst bToGraveyard = b.targetPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aToGraveyard && !bToGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bToGraveyard && !aToGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst sourcePosition = b.targetPosition._getTransformedByMergeOperation( b );\n\t\t\tconst targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\treturn [ new MoveOperation( sourcePosition, a.howMany, targetPosition, 0 ) ];\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMergeOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t// Handle positions in graveyard.\n\t// If graveyard positions are same and `a` operation is strong - do not transform.\n\tif ( !a.graveyardPosition.isEqual( b.graveyardPosition ) || !context.aIsStrong ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MoveOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// The element to merge got removed.\n\t//\n\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t// from technical point of view. However, if the element was removed, the intention of the user deleting it\n\t// was to have it all deleted, together with its children. From user experience point of view, moving back the\n\t// removed nodes might be unexpected. This means that in this scenario we will block the merging.\n\t//\n\t// The exception of this rule would be if the remove operation was later undone.\n\t//\n\tconst removedRange = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\tif ( a.deletionPosition.hasSameParentAs( b.sourcePosition ) && removedRange.containsPosition( a.sourcePosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\tif ( a.sourcePosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMoveOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMoveOperation( b );\n\n\t// `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n\t// be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n\t// Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n\t// This means that we won't transform graveyard position if it is equal to move operation target position.\n\tif ( !a.graveyardPosition.isEqual( b.targetPosition ) ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, SplitOperation, ( a, b, context ) => {\n\tif ( b.graveyardPosition ) {\n\t\t// If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n\t\t// transform `a.graveyardPosition` accordingly.\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByDeletion( b.graveyardPosition, 1 );\n\n\t\t// This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n\t\t//\n\t\t// So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n\t\t// source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n\t\t// means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n\t\t//\n\t\t// If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n\t\t// `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n\t\t// properties.\n\t\t//\n\t\tif ( a.deletionPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\ta.howMany = b.howMany;\n\t\t}\n\t}\n\n\t// Case 1:\n\t//\n\t// Merge operation moves nodes to the place where split happens.\n\t// This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n\t// paragraph and there is a merge (delete) at the beginning of the second paragraph:\n\t//\n\t// <p>Foo{}</p><p>[]Bar</p>.\n\t//\n\t// Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n\t//\n\t// State after split:\n\t// <p>Foo</p><p></p><p>Bar</p>\n\t//\n\t// Now, `Bar` should be merged to the new paragraph:\n\t// <p>Foo</p><p>Bar</p>\n\t//\n\t// Instead of merging it to the original paragraph:\n\t// <p>FooBar</p><p></p>\n\t//\n\t// This means that `targetPosition` needs to be transformed. This is the default case though.\n\t// For example, if the split would be after `F`, `targetPosition` should also be transformed.\n\t//\n\t// There are three exceptions, though, when we want to keep `targetPosition` as it was.\n\t//\n\t// First exception is when the merge target position is inside an element (not at the end, as usual). This\n\t// happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n\t// targets inside the element we want to keep the original target position (and not transform it) because\n\t// we have additional context telling us that we want to merge to the original element. We can check if the\n\t// merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n\t// is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n\t//\n\t// Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n\t// if target position would be transformed, the merge operation would target at the source position:\n\t//\n\t// root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n\t//\n\t// SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n\t// MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n\t//\n\t// Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n\t// We would like to merge from the empty <p> to the \"Foo\" <p>:\n\t//\n\t// root: <p>Foo</p><p></p>\t\t\tgraveyard:\n\t//\n\t// MergeOperation#sourcePosition = root [ 1, 0 ]\n\t//\n\t// If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n\t//\n\t// Third exception is connected with relations. If this happens during undo and we have explicit information\n\t// that target position has not been affected by the operation which is undone by this split then this split should\n\t// not move the target position either.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) ) {\n\t\tconst mergeInside = b.howMany != 0;\n\t\tconst mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual( b.graveyardPosition );\n\n\t\tif ( mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved' ) {\n\t\t\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n\t// The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n\t// split element) or should be move to the beginning of the new element.\n\t//\n\tif ( a.sourcePosition.isEqual( b.splitPosition ) ) {\n\t\t// Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n\t\t// This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n\t\t// In that case `a` operation source position should stay where it is.\n\t\tif ( context.abRelation == 'mergeSourceNotMoved' ) {\n\t\t\ta.howMany = 0;\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\t// This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n\t\t// See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n\t\t// the special case is not applied.\n\t\t//\n\t\t// Now, the merge operation is transformed by the split which has undone that previous merge operation.\n\t\t// So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n\t\t//\n\t\tif ( context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0 ) {\n\t\t\ta.sourcePosition = b.moveTargetPosition.clone();\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.splitPosition ) ) {\n\t\ta.howMany = b.splitPosition.offset;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MoveOperation, InsertOperation, ( a, b ) => {\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByInsertOperation( b, false )[ 0 ];\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\n\t// See `InsertOperation` x `MoveOperation` transformation for details on this case.\n\t//\n\t// In summary, both operations point to the same place, so the order of nodes needs to be decided.\n\t// `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n\t// between operations.\n\t//\n\tif ( !a.targetPosition.isEqual( b.position ) ) {\n\t\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MoveOperation, MoveOperation, ( a, b, context ) => {\n\t//\n\t// Setting and evaluating some variables that will be used in special cases and default algorithm.\n\t//\n\t// Create ranges from `MoveOperations` properties.\n\tconst rangeA = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst rangeB = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\t// Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n\t// this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n\tlet aIsStrong = context.aIsStrong;\n\n\t// This will be used to decide the order of nodes if both operations target at the same position.\n\t// By default, use strong/weak operation mechanism.\n\tlet insertBefore = !context.aIsStrong;\n\n\t// If the relation is set, then use it to decide nodes order.\n\tif ( context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter' ) {\n\t\tinsertBefore = true;\n\t} else if ( context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore' ) {\n\t\tinsertBefore = false;\n\t}\n\n\t// `a.targetPosition` could be affected by the `b` operation. We will transform it.\n\tlet newTargetPosition;\n\n\tif ( a.targetPosition.isEqual( b.targetPosition ) && insertBefore ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByDeletion(\n\t\t\tb.sourcePosition,\n\t\t\tb.howMany\n\t\t);\n\t} else {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByMove(\n\t\t\tb.sourcePosition,\n\t\t\tb.targetPosition,\n\t\t\tb.howMany\n\t\t);\n\t}\n\n\t//\n\t// Special case #1 + mirror.\n\t//\n\t// Special case when both move operations' target positions are inside nodes that are\n\t// being moved by the other move operation. So in other words, we move ranges into inside of each other.\n\t// This case can't be solved reasonably (on the other hand, it should not happen often).\n\tif ( _moveTargetIntoMovedRange( a, b ) && _moveTargetIntoMovedRange( b, a ) ) {\n\t\t// Instead of transforming operation, we return a reverse of the operation that we transform by.\n\t\t// So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n\t\treturn [ b.getReversed() ];\n\t}\n\t//\n\t// End of special case #1.\n\t//\n\n\t//\n\t// Special case #2.\n\t//\n\t// Check if `b` operation targets inside `rangeA`.\n\tconst bTargetsToA = rangeA.containsPosition( b.targetPosition );\n\n\t// If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n\t// You might say that operation `b` is captured inside operation `a`.\n\tif ( bTargetsToA && rangeA.containsRange( rangeB, true ) ) {\n\t\t// There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n\t\t// we need to transform `a` operation anyway.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\n\t//\n\t// Special case #2 mirror.\n\t//\n\tconst aTargetsToB = rangeB.containsPosition( a.targetPosition );\n\n\tif ( aTargetsToB && rangeB.containsRange( rangeA, true ) ) {\n\t\t// `a` operation is \"moved together\" with `b` operation.\n\t\t// Here, just move `rangeA` \"inside\" `rangeB`.\n\t\trangeA.start = rangeA.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\trangeA.end = rangeA.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #2.\n\t//\n\n\t//\n\t// Special case #3 + mirror.\n\t//\n\t// `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n\t// but not on the same tree level. In such case ranges have common part but we have to treat it\n\t// differently, because in such case those ranges are not really conflicting and should be treated like\n\t// two separate ranges. Also we have to discard two difference parts.\n\tconst aCompB = compareArrays( a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath() );\n\n\tif ( aCompB == 'prefix' || aCompB == 'extension' ) {\n\t\t// Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n\t\t// Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n\t\t// like a one difference part.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #3.\n\t//\n\n\t//\n\t// Default case - ranges are on the same level or are not connected with each other.\n\t//\n\t// Modifier for default case.\n\t// Modifies `aIsStrong` flag in certain conditions.\n\t//\n\t// If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n\t// to provide more expected results.\n\tif ( a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = true;\n\t} else if ( a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = false;\n\t}\n\n\t// Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n\t// This will aggregate transformed ranges.\n\tconst ranges = [];\n\n\t// Get the \"difference part\" of `a` operation source range.\n\t// This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n\tconst difference = rangeA.getDifference( rangeB );\n\n\tfor ( const range of difference ) {\n\t\t// Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n\t\trange.start = range.start._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\trange.end = range.end._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\n\t\t// If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n\t\tconst shouldSpread = compareArrays( range.start.getParentPath(), b.getMovedRangeStart().getParentPath() ) == 'same';\n\t\tconst newRanges = range._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, shouldSpread );\n\n\t\tranges.push( ...newRanges );\n\t}\n\n\t// Then, we have to manage the \"common part\" of both move ranges.\n\tconst common = rangeA.getIntersection( rangeB );\n\n\tif ( common !== null && aIsStrong ) {\n\t\t// Calculate the new position of that part of original range.\n\t\tcommon.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\tcommon.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\t// Take care of proper range order.\n\t\t//\n\t\t// Put `common` at appropriate place. Keep in mind that we are interested in original order.\n\t\t// Basically there are only three cases: there is zero, one or two difference ranges.\n\t\t//\n\t\t// If there is zero difference ranges, just push `common` in the array.\n\t\tif ( ranges.length === 0 ) {\n\t\t\tranges.push( common );\n\t\t}\n\t\t// If there is one difference range, we need to check whether common part was before it or after it.\n\t\telse if ( ranges.length == 1 ) {\n\t\t\tif ( rangeB.start.isBefore( rangeA.start ) || rangeB.start.isEqual( rangeA.start ) ) {\n\t\t\t\tranges.unshift( common );\n\t\t\t} else {\n\t\t\t\tranges.push( common );\n\t\t\t}\n\t\t}\n\t\t// If there are more ranges (which means two), put common part between them. This is the only scenario\n\t\t// where there could be two difference ranges so we don't have to make any comparisons.\n\t\telse {\n\t\t\tranges.splice( 1, 0, common );\n\t\t}\n\t}\n\n\tif ( ranges.length === 0 ) {\n\t\t// If there are no \"source ranges\", nothing should be changed.\n\t\t// Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, SplitOperation, ( a, b, context ) => {\n\tlet newTargetPosition = a.targetPosition.clone();\n\n\t// Do not transform if target position is same as split insertion position and this split comes from undo.\n\t// This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n\t// We need to make a decision how we will resolve such conflict and this is less harmful way.\n\tif ( !a.targetPosition.isEqual( b.insertionPosition ) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter' ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 1:\n\t//\n\t// Last element in the moved range got split.\n\t//\n\t// In this case the default range transformation will not work correctly as the element created by\n\t// split operation would be outside the range. The range to move needs to be fixed manually.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( moveRange.end.isEqual( b.insertionPosition ) ) {\n\t\t// Do it only if this is a \"natural\" split, not a one that comes from undo.\n\t\t// If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.howMany++;\n\t\t}\n\n\t\ta.targetPosition = newTargetPosition;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split happened between the moved nodes. In this case two ranges to move need to be generated.\n\t//\n\t// Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n\t// <p>F[oz|ba]r</p><p>Xyz</p>\n\t//\n\t// After split:\n\t// <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n\t//\n\t// Correct ranges:\n\t// <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n\t//\n\t// After move:\n\t// <p>F</p><p>r</p><p>Xyzozba</p>\n\t//\n\tif ( moveRange.start.hasSameParentAs( b.splitPosition ) && moveRange.containsPosition( b.splitPosition ) ) {\n\t\tlet rightRange = new Range( b.splitPosition, moveRange.end );\n\t\trightRange = rightRange._getTransformedBySplitOperation( b );\n\n\t\tconst ranges = [\n\t\t\tnew Range( moveRange.start, b.splitPosition ),\n\t\t\trightRange\n\t\t];\n\n\t\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n\t}\n\n\t// Case 3:\n\t//\n\t// Move operation targets at the split position. We need to decide if the nodes should be inserted\n\t// at the end of the split element or at the beginning of the new element.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) && context.abRelation == 'insertAtSource' ) {\n\t\tnewTargetPosition = b.moveTargetPosition;\n\t}\n\n\t// Case 4:\n\t//\n\t// Move operation targets just after the split element. We need to decide if the nodes should be inserted\n\t// between two parts of split element, or after the new element.\n\t//\n\t// Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n\t// <p>Foo|bar</p>^<p>baz</p>\n\t// <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n\t//\n\t// If there is no contextual information between operations (for example, they come from collaborative\n\t// editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n\t// However, if the split is from undo, in the past, the moved content might be targeting between the\n\t// split parts, meaning that was exactly user's intention:\n\t//\n\t// <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n\t// <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n\t// <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n\t//\n\t// In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n\t// so we need to transform accordingly. We can detect this scenario thanks to relations.\n\t//\n\tif ( a.targetPosition.isEqual( b.insertionPosition ) && context.abRelation == 'insertBetween' ) {\n\t\tnewTargetPosition = a.targetPosition;\n\t}\n\n\t// The default case.\n\t//\n\tconst transformed = moveRange._getTransformedBySplitOperation( b );\n\tconst ranges = [ transformed ];\n\n\t// Case 5:\n\t//\n\t// Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n\t//\n\tif ( b.graveyardPosition ) {\n\t\tconst movesGraveyardElement = moveRange.start.isEqual( b.graveyardPosition ) || moveRange.containsPosition( b.graveyardPosition );\n\n\t\tif ( a.howMany > 1 && movesGraveyardElement && !context.aWasUndone ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.insertionPosition, 1 ) );\n\t\t}\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, MergeOperation, ( a, b, context ) => {\n\tconst movedRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( b.deletionPosition.hasSameParentAs( a.sourcePosition ) && movedRange.containsPosition( b.sourcePosition ) ) {\n\t\tif ( a.type == 'remove' && !context.forceWeakRemove ) {\n\t\t\t// Case 1:\n\t\t\t//\n\t\t\t// The element to remove got merged.\n\t\t\t//\n\t\t\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t\t\t// from technical point of view. However, if the element was removed, the intention of the user\n\t\t\t// deleting it was to have it all deleted. From user experience point of view, moving back the\n\t\t\t// removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n\t\t\t//\n\t\t\tif ( !context.aWasUndone ) {\n\t\t\t\tconst results = [];\n\n\t\t\t\tlet gyMoveSource = b.graveyardPosition.clone();\n\t\t\t\tlet splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\tif ( a.howMany > 1 ) {\n\t\t\t\t\tresults.push( new MoveOperation( a.sourcePosition, a.howMany - 1, a.targetPosition, 0 ) );\n\n\t\t\t\t\tgyMoveSource = gyMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t}\n\n\t\t\t\tconst gyMoveTarget = b.deletionPosition._getCombined( a.sourcePosition, a.targetPosition );\n\t\t\t\tconst gyMove = new MoveOperation( gyMoveSource, 1, gyMoveTarget, 0 );\n\n\t\t\t\tconst splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n\t\t\t\tsplitNodesMoveTargetPath.push( 0 );\n\n\t\t\t\tconst splitNodesMoveTarget = new Position( gyMove.targetPosition.root, splitNodesMoveTargetPath );\n\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( gyMoveSource, gyMoveTarget, 1 );\n\t\t\t\tconst splitNodesMove = new MoveOperation( splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0 );\n\n\t\t\t\tresults.push( gyMove );\n\t\t\t\tresults.push( splitNodesMove );\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t} else {\n\t\t\t// Case 2:\n\t\t\t//\n\t\t\t// The element to move got merged and it was the only element to move.\n\t\t\t// In this case just don't do anything, leave the node in the graveyard. Without special case\n\t\t\t// it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n\t\t\t//\n\t\t\tif ( a.howMany == 1 ) {\n\t\t\t\tif ( !context.bWasUndone ) {\n\t\t\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t\t\t} else {\n\t\t\t\t\ta.sourcePosition = b.graveyardPosition.clone();\n\t\t\t\t\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\t\treturn [ a ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByMergeOperation( b );\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RenameOperation, InsertOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MergeOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Element to rename got merged, so it was moved to `b.graveyardPosition`.\n\t//\n\tif ( a.position.isEqual( b.deletionPosition ) ) {\n\t\ta.position = b.graveyardPosition.clone();\n\t\ta.position.stickiness = 'toNext';\n\n\t\treturn [ a ];\n\t}\n\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MoveOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, RenameOperation, ( a, b, context ) => {\n\tif ( a.position.isEqual( b.position ) ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldName = b.newName;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The element to rename has been split. In this case, the new element should be also renamed.\n\t//\n\t// User decides to change the paragraph to a list item:\n\t// <paragraph>Foobar</paragraph>\n\t//\n\t// However, in meantime, split happens:\n\t// <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n\t//\n\t// As a result, rename both elements:\n\t// <listItem>Foo</listItem><listItem>bar</listItem>\n\t//\n\tconst renamePath = a.position.path;\n\tconst splitPath = b.splitPosition.getParentPath();\n\n\tif ( compareArrays( renamePath, splitPath ) == 'same' && !b.graveyardPosition ) {\n\t\tconst extraRename = new RenameOperation( a.position.getShiftedBy( 1 ), a.oldName, a.newName, 0 );\n\n\t\treturn [ a, extraRename ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RootAttributeOperation, RootAttributeOperation, ( a, b, context ) => {\n\tif ( a.root === b.root && a.key === b.key ) {\n\t\tif ( !context.aIsStrong || a.newValue === b.newValue ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\ta.oldValue = b.newValue;\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( SplitOperation, InsertOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.position ) && a.splitPosition.offset < b.position.offset ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByInsertOperation( b );\n\ta.insertionPosition = a.insertionPosition._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split element got merged. If two different elements were merged, clients will have different content.\n\t//\n\t// Example. Merge at `{}`, split at `[]`:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// On merge side it will look like this:\n\t// <heading>FooB[]ar</heading>\n\t// <heading>FooB</heading><heading>ar</heading>\n\t//\n\t// On split side it will look like this:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t// <heading>FooB</heading><paragraph>ar</paragraph>\n\t//\n\t// Clearly, the second element is different for both clients.\n\t//\n\t// We could use the removed merge element from graveyard as a split element but then clients would have a different\n\t// model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n\t//\n\t// To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n\t// in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n\t// used for splitting. Example below.\n\t//\n\t// Original state:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// Merge side client:\n\t//\n\t// After merge:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n\t//\n\t// Extra split:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n\t//\n\t// Use the \"cloned\" element from graveyard:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// Split side client:\n\t//\n\t// After split:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t//\n\t// After merge:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// This special case scenario only applies if the original split operation clones the split element.\n\t// If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n\t// knows exactly which element it should use. So there would be no original problem with different contents.\n\t//\n\t// Additionally, the special case applies only if the merge wasn't already undone.\n\t//\n\tif ( !a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\tconst splitPath = b.graveyardPosition.path.slice();\n\t\tsplitPath.push( 0 );\n\n\t\tconst splitPosition = new Position( b.graveyardPosition.root, splitPath );\n\t\tconst insertionPosition = SplitOperation.getInsertionPosition( new Position( b.graveyardPosition.root, splitPath ) );\n\n\t\tconst additionalSplit = new SplitOperation( splitPosition, 0, insertionPosition, null, 0 );\n\n\t\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t\ta.graveyardPosition = additionalSplit.insertionPosition.clone();\n\t\ta.graveyardPosition.stickiness = 'toNext';\n\n\t\treturn [ additionalSplit, a ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.deletionPosition ) && !a.splitPosition.isAfter( b.deletionPosition ) ) {\n\t\ta.howMany--;\n\t}\n\n\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MoveOperation, ( a, b, context ) => {\n\tconst rangeToMove = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( a.graveyardPosition ) {\n\t\t// Case 1:\n\t\t//\n\t\t// Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n\t\t// is already moved to the correct position, we need to only move the nodes after the split position.\n\t\t// This will be done by `MoveOperation` instead of `SplitOperation`.\n\t\t//\n\t\tconst gyElementMoved = rangeToMove.start.isEqual( a.graveyardPosition ) || rangeToMove.containsPosition( a.graveyardPosition );\n\n\t\tif ( !context.bWasUndone && gyElementMoved ) {\n\t\t\tconst sourcePosition = a.splitPosition._getTransformedByMoveOperation( b );\n\n\t\t\tconst newParentPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t\t\tconst newTargetPath = newParentPosition.path.slice();\n\t\t\tnewTargetPath.push( 0 );\n\n\t\t\tconst newTargetPosition = new Position( newParentPosition.root, newTargetPath );\n\t\t\tconst moveOp = new MoveOperation( sourcePosition, a.howMany, newTargetPosition, 0 );\n\n\t\t\treturn [ moveOp ];\n\t\t}\n\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\t// Case 2:\n\t//\n\t// Split is at a position where nodes were moved.\n\t//\n\t// This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n\t// \"split operation point of view\".\n\t//\n\tconst splitAtTarget = a.splitPosition.isEqual( b.targetPosition );\n\n\tif ( splitAtTarget && ( context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore' ) ) {\n\t\ta.howMany += b.howMany;\n\t\ta.splitPosition = a.splitPosition._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\tif ( splitAtTarget && context.abRelation && context.abRelation.howMany ) {\n\t\tconst { howMany, offset } = context.abRelation;\n\n\t\ta.howMany += howMany;\n\t\ta.splitPosition = a.splitPosition.getShiftedBy( offset );\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 3:\n\t//\n\t// If the split position is inside the moved range, we need to shift the split position to a proper place.\n\t// The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n\t//\n\t// Characters `bc` should be moved to the second paragraph while split position is between them:\n\t// <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n\t//\n\t// After move, new split position is incorrect:\n\t// <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n\t//\n\t// Correct split position:\n\t// <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\t// After split:\n\t// <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && rangeToMove.containsPosition( a.splitPosition ) ) {\n\t\tconst howManyRemoved = b.howMany - ( a.splitPosition.offset - b.sourcePosition.offset );\n\t\ta.howMany -= howManyRemoved;\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\n\t\ta.splitPosition = b.sourcePosition.clone();\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t// Don't change `howMany` if move operation does not really move anything.\n\t//\n\tif ( !b.sourcePosition.isEqual( b.targetPosition ) ) {\n\t\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && a.splitPosition.offset <= b.sourcePosition.offset ) {\n\t\t\ta.howMany -= b.howMany;\n\t\t}\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\t}\n\n\t// Change position stickiness to force a correct transformation.\n\ta.splitPosition.stickiness = 'toNone';\n\ta.splitPosition = a.splitPosition._getTransformedByMoveOperation( b );\n\ta.splitPosition.stickiness = 'toNext';\n\n\tif ( a.graveyardPosition ) {\n\t\ta.insertionPosition = a.insertionPosition._getTransformedByMoveOperation( b );\n\t} else {\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, SplitOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split at the same position.\n\t//\n\t// If there already was a split at the same position as in `a` operation, it means that the intention\n\t// conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n\t//\n\t// However, there is a difference if these are new splits or splits created by undo. These have different\n\t// intentions. Also splits moving back different elements from graveyard have different intentions. They\n\t// are just different operations.\n\t//\n\t// So we cancel split operation only if it was really identical.\n\t//\n\t// Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n\t// default transformation is incorrect too.\n\t//\n\tif ( a.splitPosition.isEqual( b.splitPosition ) ) {\n\t\tif ( !a.graveyardPosition && !b.graveyardPosition ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\t// Use context to know that the `a.splitPosition` should stay where it is.\n\t\t// This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n\t\tif ( context.abRelation == 'splitBefore' ) {\n\t\t\t// Since split is at the same position, there are no nodes left to split.\n\t\t\ta.howMany = 0;\n\n\t\t\t// Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n\t\t\t// That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n\t\t\t// It could happen if `context` is enabled in collaboration.\n\t\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same node is using to split different elements. This happens in undo when previously same element was merged to\n\t// two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n\t//\n\t// In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n\t// split operations. This might not always be true but in the real cases that were experienced it was. After all,\n\t// if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n\t// should be same for both of those splits.\n\t//\n\t// Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n\t//\n\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\tconst aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n\t\tconst bInGraveyard = b.splitPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aInGraveyard && !bInGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bInGraveyard && !aInGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst result = [];\n\n\t\t\t// First we need to move any nodes split by `b` back to where they were.\n\t\t\t// Do it only if `b` actually moved something.\n\t\t\tif ( b.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( b.moveTargetPosition, b.howMany, b.splitPosition, 0 ) );\n\t\t\t}\n\n\t\t\t// Then we need to move nodes from `a` split position to their new element.\n\t\t\t// Do it only if `a` actually should move something.\n\t\t\tif ( a.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( a.splitPosition, a.howMany, a.moveTargetPosition, 0 ) );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 3:\n\t//\n\t// Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n\t// As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n\t//\n\tif ( a.splitPosition.isEqual( b.insertionPosition ) && context.abRelation == 'splitBefore' ) {\n\t\ta.howMany++;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 4:\n\t//\n\t// This is a mirror to the case 2. above.\n\t//\n\tif ( b.splitPosition.isEqual( a.insertionPosition ) && context.baRelation == 'splitBefore' ) {\n\t\tconst newPositionPath = b.insertionPosition.path.slice();\n\t\tnewPositionPath.push( 0 );\n\n\t\tconst newPosition = new Position( b.insertionPosition.root, newPositionPath );\n\t\tconst moveOp = new MoveOperation( a.insertionPosition, 1, newPosition, 0 );\n\n\t\treturn [ a, moveOp ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.splitPosition ) && a.splitPosition.offset < b.splitPosition.offset ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedBySplitOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\treturn [ a ];\n} );\n\n// Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\nfunction _moveTargetIntoMovedRange( a, b ) {\n\treturn a.targetPosition._getTransformedByDeletion( b.sourcePosition, b.howMany ) === null;\n}\n\n// Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\nfunction _makeMoveOperationsFromRanges( ranges, targetPosition ) {\n\t// At this moment we have some ranges and a target position, to which those ranges should be moved.\n\t// Order in `ranges` array is the go-to order of after transformation.\n\t//\n\t// We are almost done. We have `ranges` and `targetPosition` to make operations from.\n\t// Unfortunately, those operations may affect each other. Precisely, first operation after move\n\t// may affect source range and target position of second and third operation. Same with second\n\t// operation affecting third.\n\t//\n\t// We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n\tconst operations = [];\n\n\t// Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t// Create new operation out of a range and target position.\n\t\tconst range = ranges[ i ];\n\t\tconst op = new MoveOperation(\n\t\t\trange.start,\n\t\t\trange.end.offset - range.start.offset,\n\t\t\ttargetPosition,\n\t\t\t0\n\t\t);\n\n\t\toperations.push( op );\n\n\t\t// Transform other ranges by the generated operation.\n\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t// All ranges in `ranges` array should be:\n\t\t\t//\n\t\t\t// * non-intersecting (these are part of original operation source range), and\n\t\t\t// * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n\t\t\t//\n\t\t\t// This means that the transformation will be \"clean\" and always return one result.\n\t\t\tranges[ j ] = ranges[ j ]._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany )[ 0 ];\n\t\t}\n\n\t\ttargetPosition = targetPosition._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany );\n\t}\n\n\treturn operations;\n}\n"]},"metadata":{},"sourceType":"module"}