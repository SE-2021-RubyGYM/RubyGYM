{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/splitoperation\n */\nimport Operation from './operation';\nimport MergeOperation from './mergeoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _insert, _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to split {@link module:engine/model/element~Element an element} at given\n * {@link module:engine/model/operation/splitoperation~SplitOperation#splitPosition split position} into two elements,\n * both containing a part of the element's original content.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\n\nexport default class SplitOperation extends Operation {\n  /**\n   * Creates a split operation.\n   *\n   * @param {module:engine/model/position~Position} splitPosition Position at which an element should be split.\n   * @param {Number} howMany Total offset size of elements that are in the split element after `position`.\n   * @param {module:engine/model/position~Position} insertionPosition Position at which the clone of split element\n   * (or element from graveyard) will be inserted.\n   * @param {module:engine/model/position~Position|null} graveyardPosition Position in the graveyard root before the element which\n   * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {\n    super(baseVersion);\n    /**\n     * Position at which an element should be split.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#splitPosition\n     */\n\n    this.splitPosition = splitPosition.clone(); // Keep position sticking to the next node. This way any new content added at the place where the element is split\n    // will be left in the original element.\n\n    this.splitPosition.stickiness = 'toNext';\n    /**\n     * Total offset size of elements that are in the split element after `position`.\n     *\n     * @member {Number} module:engine/model/operation/splitoperation~SplitOperation#howMany\n     */\n\n    this.howMany = howMany;\n    /**\n     * Position at which the clone of split element (or element from graveyard) will be inserted.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#insertionPosition\n     */\n\n    this.insertionPosition = insertionPosition;\n    /**\n     * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.\n     * If it is not set, a copy of the the `position` parent will be used.\n     *\n     * The default behavior is to clone the split element. Element from graveyard is used during undo.\n     *\n     * @member {module:engine/model/position~Position|null} #graveyardPosition\n     */\n\n    this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;\n\n    if (this.graveyardPosition) {\n      this.graveyardPosition.stickiness = 'toNext';\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  get type() {\n    return 'split';\n  }\n  /**\n   * Position inside the new clone of a split element.\n   *\n   * This is a position where nodes that are after the split position will be moved to.\n   *\n   * @readonly\n   * @type {module:engine/model/position~Position}\n   */\n\n\n  get moveTargetPosition() {\n    const path = this.insertionPosition.path.slice();\n    path.push(0);\n    return new Position(this.insertionPosition.root, path);\n  }\n  /**\n   * Artificial range that contains all the nodes from the split element that will be moved to the new element.\n   * The range starts at {@link ~#splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n   *\n   * @readonly\n   * @type {module:engine/model/range~Range}\n   */\n\n\n  get movedRange() {\n    const end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);\n    return new Range(this.splitPosition, end);\n  }\n  /**\n   * Creates and returns an operation that has the same parameters as this operation.\n   *\n   * @returns {module:engine/model/operation/splitoperation~SplitOperation} Clone of this operation.\n   */\n\n\n  clone() {\n    return new this.constructor(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);\n  }\n  /**\n   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n   *\n   * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n   */\n\n\n  getReversed() {\n    const graveyard = this.splitPosition.root.document.graveyard;\n    const graveyardPosition = new Position(graveyard, [0]);\n    return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _validate() {\n    const element = this.splitPosition.parent;\n    const offset = this.splitPosition.offset; // Validate whether split operation has correct parameters.\n\n    if (!element || element.maxOffset < offset) {\n      /**\n       * Split position is invalid.\n       *\n       * @error split-operation-position-invalid\n       */\n      throw new CKEditorError('split-operation-position-invalid', this);\n    } else if (!element.parent) {\n      /**\n       * Cannot split root element.\n       *\n       * @error split-operation-split-in-root\n       */\n      throw new CKEditorError('split-operation-split-in-root', this);\n    } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {\n      /**\n       * Split operation specifies wrong number of nodes to move.\n       *\n       * @error split-operation-how-many-invalid\n       */\n      throw new CKEditorError('split-operation-how-many-invalid', this);\n    } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {\n      /**\n       * Graveyard position invalid.\n       *\n       * @error split-operation-graveyard-position-invalid\n       */\n      throw new CKEditorError('split-operation-graveyard-position-invalid', this);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _execute() {\n    const splitElement = this.splitPosition.parent;\n\n    if (this.graveyardPosition) {\n      _move(Range._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);\n    } else {\n      const newElement = splitElement._clone();\n\n      _insert(this.insertionPosition, newElement);\n    }\n\n    const sourceRange = new Range(Position._createAt(splitElement, this.splitPosition.offset), Position._createAt(splitElement, splitElement.maxOffset));\n\n    _move(sourceRange, this.moveTargetPosition);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  toJSON() {\n    const json = super.toJSON();\n    json.splitPosition = this.splitPosition.toJSON();\n    json.insertionPosition = this.insertionPosition.toJSON();\n\n    if (this.graveyardPosition) {\n      json.graveyardPosition = this.graveyardPosition.toJSON();\n    }\n\n    return json;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get className() {\n    return 'SplitOperation';\n  }\n  /**\n   * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion\n   * position is after the split element.\n   *\n   * @param {module:engine/model/position~Position} splitPosition\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  static getInsertionPosition(splitPosition) {\n    const path = splitPosition.path.slice(0, -1);\n    path[path.length - 1]++;\n    return new Position(splitPosition.root, path, 'toPrevious');\n  }\n  /**\n   * Creates `SplitOperation` object from deserilized object, i.e. from parsed JSON string.\n   *\n   * @param {Object} json Deserialized JSON object.\n   * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n   * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n   */\n\n\n  static fromJSON(json, document) {\n    const splitPosition = Position.fromJSON(json.splitPosition, document);\n    const insertionPosition = Position.fromJSON(json.insertionPosition, document);\n    const graveyardPosition = json.graveyardPosition ? Position.fromJSON(json.graveyardPosition, document) : null;\n    return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn `SplitOperation( ${ this.baseVersion } ): ${ this.splitPosition } ` +\n  // @if CK_DEBUG_ENGINE //\t\t`( ${ this.howMany } ) -> ${ this.insertionPosition }` +\n  // @if CK_DEBUG_ENGINE //\t\t`${ this.graveyardPosition ? ' with ' + this.graveyardPosition : '' }`;\n  // @if CK_DEBUG_ENGINE // }\n\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/splitoperation.js"],"names":["Operation","MergeOperation","Position","Range","_insert","_move","CKEditorError","SplitOperation","constructor","splitPosition","howMany","insertionPosition","graveyardPosition","baseVersion","clone","stickiness","type","moveTargetPosition","path","slice","push","root","movedRange","end","getShiftedBy","Number","POSITIVE_INFINITY","getReversed","graveyard","document","_validate","element","parent","offset","maxOffset","nodeAfter","_execute","splitElement","_createFromPositionAndShift","newElement","_clone","sourceRange","_createAt","toJSON","json","className","getInsertionPosition","length","fromJSON"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/splitoperation\n */\n\nimport Operation from './operation';\nimport MergeOperation from './mergeoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _insert, _move } from './utils';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Operation to split {@link module:engine/model/element~Element an element} at given\n * {@link module:engine/model/operation/splitoperation~SplitOperation#splitPosition split position} into two elements,\n * both containing a part of the element's original content.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class SplitOperation extends Operation {\n\t/**\n\t * Creates a split operation.\n\t *\n\t * @param {module:engine/model/position~Position} splitPosition Position at which an element should be split.\n\t * @param {Number} howMany Total offset size of elements that are in the split element after `position`.\n\t * @param {module:engine/model/position~Position} insertionPosition Position at which the clone of split element\n\t * (or element from graveyard) will be inserted.\n\t * @param {module:engine/model/position~Position|null} graveyardPosition Position in the graveyard root before the element which\n\t * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Position at which an element should be split.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#splitPosition\n\t\t */\n\t\tthis.splitPosition = splitPosition.clone();\n\t\t// Keep position sticking to the next node. This way any new content added at the place where the element is split\n\t\t// will be left in the original element.\n\t\tthis.splitPosition.stickiness = 'toNext';\n\n\t\t/**\n\t\t * Total offset size of elements that are in the split element after `position`.\n\t\t *\n\t\t * @member {Number} module:engine/model/operation/splitoperation~SplitOperation#howMany\n\t\t */\n\t\tthis.howMany = howMany;\n\n\t\t/**\n\t\t * Position at which the clone of split element (or element from graveyard) will be inserted.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#insertionPosition\n\t\t */\n\t\tthis.insertionPosition = insertionPosition;\n\n\t\t/**\n\t\t * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.\n\t\t * If it is not set, a copy of the the `position` parent will be used.\n\t\t *\n\t\t * The default behavior is to clone the split element. Element from graveyard is used during undo.\n\t\t *\n\t\t * @member {module:engine/model/position~Position|null} #graveyardPosition\n\t\t */\n\t\tthis.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;\n\n\t\tif ( this.graveyardPosition ) {\n\t\t\tthis.graveyardPosition.stickiness = 'toNext';\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'split';\n\t}\n\n\t/**\n\t * Position inside the new clone of a split element.\n\t *\n\t * This is a position where nodes that are after the split position will be moved to.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/position~Position}\n\t */\n\tget moveTargetPosition() {\n\t\tconst path = this.insertionPosition.path.slice();\n\t\tpath.push( 0 );\n\n\t\treturn new Position( this.insertionPosition.root, path );\n\t}\n\n\t/**\n\t * Artificial range that contains all the nodes from the split element that will be moved to the new element.\n\t * The range starts at {@link ~#splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/range~Range}\n\t */\n\tget movedRange() {\n\t\tconst end = this.splitPosition.getShiftedBy( Number.POSITIVE_INFINITY );\n\n\t\treturn new Range( this.splitPosition, end );\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/splitoperation~SplitOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n\t */\n\tgetReversed() {\n\t\tconst graveyard = this.splitPosition.root.document.graveyard;\n\t\tconst graveyardPosition = new Position( graveyard, [ 0 ] );\n\n\t\treturn new MergeOperation( this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tconst element = this.splitPosition.parent;\n\t\tconst offset = this.splitPosition.offset;\n\n\t\t// Validate whether split operation has correct parameters.\n\t\tif ( !element || element.maxOffset < offset ) {\n\t\t\t/**\n\t\t\t * Split position is invalid.\n\t\t\t *\n\t\t\t * @error split-operation-position-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'split-operation-position-invalid', this );\n\t\t} else if ( !element.parent ) {\n\t\t\t/**\n\t\t\t * Cannot split root element.\n\t\t\t *\n\t\t\t * @error split-operation-split-in-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'split-operation-split-in-root', this );\n\t\t} else if ( this.howMany != element.maxOffset - this.splitPosition.offset ) {\n\t\t\t/**\n\t\t\t * Split operation specifies wrong number of nodes to move.\n\t\t\t *\n\t\t\t * @error split-operation-how-many-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'split-operation-how-many-invalid', this );\n\t\t} else if ( this.graveyardPosition && !this.graveyardPosition.nodeAfter ) {\n\t\t\t/**\n\t\t\t * Graveyard position invalid.\n\t\t\t *\n\t\t\t * @error split-operation-graveyard-position-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'split-operation-graveyard-position-invalid', this );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\tconst splitElement = this.splitPosition.parent;\n\n\t\tif ( this.graveyardPosition ) {\n\t\t\t_move( Range._createFromPositionAndShift( this.graveyardPosition, 1 ), this.insertionPosition );\n\t\t} else {\n\t\t\tconst newElement = splitElement._clone();\n\n\t\t\t_insert( this.insertionPosition, newElement );\n\t\t}\n\n\t\tconst sourceRange = new Range(\n\t\t\tPosition._createAt( splitElement, this.splitPosition.offset ),\n\t\t\tPosition._createAt( splitElement, splitElement.maxOffset )\n\t\t);\n\n\t\t_move( sourceRange, this.moveTargetPosition );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tjson.splitPosition = this.splitPosition.toJSON();\n\t\tjson.insertionPosition = this.insertionPosition.toJSON();\n\n\t\tif ( this.graveyardPosition ) {\n\t\t\tjson.graveyardPosition = this.graveyardPosition.toJSON();\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'SplitOperation';\n\t}\n\n\t/**\n\t * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion\n\t * position is after the split element.\n\t *\n\t * @param {module:engine/model/position~Position} splitPosition\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tstatic getInsertionPosition( splitPosition ) {\n\t\tconst path = splitPosition.path.slice( 0, -1 );\n\t\tpath[ path.length - 1 ]++;\n\n\t\treturn new Position( splitPosition.root, path, 'toPrevious' );\n\t}\n\n\t/**\n\t * Creates `SplitOperation` object from deserilized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\tconst splitPosition = Position.fromJSON( json.splitPosition, document );\n\t\tconst insertionPosition = Position.fromJSON( json.insertionPosition, document );\n\t\tconst graveyardPosition = json.graveyardPosition ? Position.fromJSON( json.graveyardPosition, document ) : null;\n\n\t\treturn new this( splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `SplitOperation( ${ this.baseVersion } ): ${ this.splitPosition } ` +\n\t// @if CK_DEBUG_ENGINE //\t\t`( ${ this.howMany } ) -> ${ this.insertionPosition }` +\n\t// @if CK_DEBUG_ENGINE //\t\t`${ this.graveyardPosition ? ' with ' + this.graveyardPosition : '' }`;\n\t// @if CK_DEBUG_ENGINE // }\n}\n"]},"metadata":{},"sourceType":"module"}