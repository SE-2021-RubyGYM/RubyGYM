{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror'; // To check if component is loaded more than once.\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\n\nexport default class Position {\n  /**\n   * Creates a position.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   */\n  constructor(root, path) {\n    let stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';\n\n    if (!root.is('element') && !root.is('documentFragment')) {\n      /**\n       * Position root is invalid.\n       *\n       * Positions can only be anchored in elements or document fragments.\n       *\n       * @error model-position-root-invalid\n       */\n      throw new CKEditorError('model-position-root-invalid', root);\n    }\n\n    if (!(path instanceof Array) || path.length === 0) {\n      /**\n       * Position path must be an array with at least one item.\n       *\n       * @error model-position-path-incorrect-format\n       * @param path\n       */\n      throw new CKEditorError('model-position-path-incorrect-format', root, {\n        path\n      });\n    } // Normalize the root and path when element (not root) is passed.\n\n\n    if (root.is('rootElement')) {\n      path = path.slice();\n    } else {\n      path = [...root.getPath(), ...path];\n      root = root.root;\n    }\n    /**\n     * Root of the position path.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     * module:engine/model/position~Position#root\n     */\n\n\n    this.root = root;\n    /**\n     * Position of the node in the tree. **Path contains offsets, not indexes.**\n     *\n     * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n     * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n     * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n     * down to the position offset in it's parent.\n     *\n     *\t\t ROOT\n     *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n     *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n     *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n     *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n     *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n     *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n     *\n     * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n     * greater than `1` you can place position offset between their start and end:\n     *\n     *\t\t ROOT\n     *\t\t  |- P\n     *\t\t  |- UL\n     *\t\t     |- LI\n     *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n     *\t\t     |- LI\n     *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n     *\n     * @readonly\n     * @member {Array.<Number>} module:engine/model/position~Position#path\n     */\n\n    this.path = path;\n    /**\n     * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n     *\n     * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n     */\n\n    this.stickiness = stickiness;\n  }\n  /**\n   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n   * to the last item in position {@link module:engine/model/position~Position#path path}.\n   *\n   * @type {Number}\n   */\n\n\n  get offset() {\n    return this.path[this.path.length - 1];\n  }\n\n  set offset(newOffset) {\n    this.path[this.path.length - 1] = newOffset;\n  }\n  /**\n   * Parent element of this position.\n   *\n   * Keep in mind that `parent` value is calculated when the property is accessed.\n   * If {@link module:engine/model/position~Position#path position path}\n   * leads to a non-existing element, `parent` property will throw error.\n   *\n   * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n   *\n   * @readonly\n   * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  get parent() {\n    let parent = this.root;\n\n    for (let i = 0; i < this.path.length - 1; i++) {\n      parent = parent.getChild(parent.offsetToIndex(this.path[i]));\n\n      if (!parent) {\n        /**\n         * The position's path is incorrect. This means that a position does not point to\n         * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n         *\n         * **Note**: Unlike DOM and view positions, in the model, the\n         * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n         * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element\n         * where this position points.\n         *\n         * Read more about model positions and offsets in\n         * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n         *\n         * @error model-position-path-incorrect\n         * @param {module:engine/model/position~Position} position The incorrect position.\n         */\n        throw new CKEditorError('model-position-path-incorrect', this, {\n          position: this\n        });\n      }\n    }\n\n    if (parent.is('$text')) {\n      throw new CKEditorError('model-position-path-incorrect', this, {\n        position: this\n      });\n    }\n\n    return parent;\n  }\n  /**\n   * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n   * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n   * in text node, position index is equal to the index of that text node.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get index() {\n    return this.parent.offsetToIndex(this.offset);\n  }\n  /**\n   * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n   * position is not in a text node.\n   *\n   * @readonly\n   * @type {module:engine/model/text~Text|null}\n   */\n\n\n  get textNode() {\n    return getTextNodeAtPosition(this, this.parent);\n  }\n  /**\n   * Node directly after this position or `null` if this position is in text node.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|null}\n   */\n\n\n  get nodeAfter() {\n    // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n    const parent = this.parent;\n    return getNodeAfterPosition(this, parent, getTextNodeAtPosition(this, parent));\n  }\n  /**\n   * Node directly before this position or `null` if this position is in text node.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|null}\n   */\n\n\n  get nodeBefore() {\n    // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n    const parent = this.parent;\n    return getNodeBeforePosition(this, parent, getTextNodeAtPosition(this, parent));\n  }\n  /**\n   * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isAtStart() {\n    return this.offset === 0;\n  }\n  /**\n   * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isAtEnd() {\n    return this.offset == this.parent.maxOffset;\n  }\n  /**\n   * Checks whether this position is before or after given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {module:engine/model/position~PositionRelation}\n   */\n\n\n  compareWith(otherPosition) {\n    if (this.root != otherPosition.root) {\n      return 'different';\n    }\n\n    const result = compareArrays(this.path, otherPosition.path);\n\n    switch (result) {\n      case 'same':\n        return 'same';\n\n      case 'prefix':\n        return 'before';\n\n      case 'extension':\n        return 'after';\n\n      default:\n        return this.path[result] < otherPosition.path[result] ? 'before' : 'after';\n    }\n  }\n  /**\n   * Gets the farthest position which matches the callback using\n   * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n   *\n   * For example:\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n   * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n   * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n   *\n   * \t\tgetLastMatchingPosition( value => false );\n   * \t\t// Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   *\n   * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n   */\n\n\n  getLastMatchingPosition(skip) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.startPosition = this;\n    const treeWalker = new TreeWalker(options);\n    treeWalker.skip(skip);\n    return treeWalker.position;\n  }\n  /**\n   * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n   * but without the last item.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @returns {Array.<Number>} Path to the parent.\n   */\n\n\n  getParentPath() {\n    return this.path.slice(0, -1);\n  }\n  /**\n   * Returns ancestors array of this position, that is this position's parent and its ancestors.\n   *\n   * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n   */\n\n\n  getAncestors() {\n    const parent = this.parent;\n\n    if (parent.is('documentFragment')) {\n      return [parent];\n    } else {\n      return parent.getAncestors({\n        includeSelf: true\n      });\n    }\n  }\n  /**\n   * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.\n   *\n   * @param {String} parentName The name of the parent element to find.\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  findAncestor(parentName) {\n    const parent = this.parent;\n\n    if (parent.is('element')) {\n      return parent.findAncestor(parentName, {\n        includeSelf: true\n      });\n    }\n\n    return null;\n  }\n  /**\n   * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n   * of these two paths must be identical.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} position The second position.\n   * @returns {Array.<Number>} The common path.\n   */\n\n\n  getCommonPath(position) {\n    if (this.root != position.root) {\n      return [];\n    } // We find on which tree-level start and end have the lowest common ancestor\n\n\n    const cmp = compareArrays(this.path, position.path); // If comparison returned string it means that arrays are same.\n\n    const diffAt = typeof cmp == 'string' ? Math.min(this.path.length, position.path.length) : cmp;\n    return this.path.slice(0, diffAt);\n  }\n  /**\n   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n   * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n   *\n   * @param {module:engine/model/position~Position} position The second position.\n   * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n\n\n  getCommonAncestor(position) {\n    const ancestorsA = this.getAncestors();\n    const ancestorsB = position.getAncestors();\n    let i = 0;\n\n    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n      i++;\n    }\n\n    return i === 0 ? null : ancestorsA[i - 1];\n  }\n  /**\n   * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n   * is shifted by `shift` value (can be a negative value).\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {Number} shift Offset shift. Can be a negative value.\n   * @returns {module:engine/model/position~Position} Shifted position.\n   */\n\n\n  getShiftedBy(shift) {\n    const shifted = this.clone();\n    const offset = shifted.offset + shift;\n    shifted.offset = offset < 0 ? 0 : offset;\n    return shifted;\n  }\n  /**\n   * Checks whether this position is after given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @see module:engine/model/position~Position#isBefore\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if this position is after given position.\n   */\n\n\n  isAfter(otherPosition) {\n    return this.compareWith(otherPosition) == 'after';\n  }\n  /**\n   * Checks whether this position is before given position.\n   *\n   * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n   * be `true` if positions are in different roots and you might not expect this. You should probably use\n   * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n   * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n   *\n   *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n   *\t\t\t// do A.\n   *\t\t} else {\n   *\t\t\t// do B.\n   *\t\t}\n   *\n   * or, if you have only one if-branch:\n   *\n   *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n   *\t\t\t// do B.\n   *\t\t}\n   *\n   * rather than:\n   *\n   *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n   *\t\t\t// do B.\n   *\t\t} else {\n   *\t\t\t// do A.\n   *\t\t}\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if this position is before given position.\n   */\n\n\n  isBefore(otherPosition) {\n    return this.compareWith(otherPosition) == 'before';\n  }\n  /**\n   * Checks whether this position is equal to given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions are same.\n   */\n\n\n  isEqual(otherPosition) {\n    return this.compareWith(otherPosition) == 'same';\n  }\n  /**\n   * Checks whether this position is touching given position. Positions touch when there are no text nodes\n   * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n   * they are very similar or even indistinguishable.\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions touch.\n   */\n\n\n  isTouching(otherPosition) {\n    let left = null;\n    let right = null;\n    const compare = this.compareWith(otherPosition);\n\n    switch (compare) {\n      case 'same':\n        return true;\n\n      case 'before':\n        left = Position._createAt(this);\n        right = Position._createAt(otherPosition);\n        break;\n\n      case 'after':\n        left = Position._createAt(otherPosition);\n        right = Position._createAt(this);\n        break;\n\n      default:\n        return false;\n    } // Cached for optimization purposes.\n\n\n    let leftParent = left.parent;\n\n    while (left.path.length + right.path.length) {\n      if (left.isEqual(right)) {\n        return true;\n      }\n\n      if (left.path.length > right.path.length) {\n        if (left.offset !== leftParent.maxOffset) {\n          return false;\n        }\n\n        left.path = left.path.slice(0, -1);\n        leftParent = leftParent.parent;\n        left.offset++;\n      } else {\n        if (right.offset !== 0) {\n          return false;\n        }\n\n        right.path = right.path.slice(0, -1);\n      }\n    }\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\tposition.is( 'position' ); // -> true\n   *\t\tposition.is( 'model:position' ); // -> true\n   *\n   *\t\tposition.is( 'view:position' ); // -> false\n   *\t\tposition.is( 'documentSelection' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'position' || type === 'model:position';\n  }\n  /**\n   * Checks if two positions are in the same parent.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} position Position to compare with.\n   * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n   */\n\n\n  hasSameParentAs(position) {\n    if (this.root !== position.root) {\n      return false;\n    }\n\n    const thisParentPath = this.getParentPath();\n    const posParentPath = position.getParentPath();\n    return compareArrays(thisParentPath, posParentPath) == 'same';\n  }\n  /**\n   * Returns a copy of this position that is transformed by given `operation`.\n   *\n   * The new position's parameters are updated accordingly to the effect of the `operation`.\n   *\n   * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n   * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n\n\n  getTransformedByOperation(operation) {\n    let result;\n\n    switch (operation.type) {\n      case 'insert':\n        result = this._getTransformedByInsertOperation(operation);\n        break;\n\n      case 'move':\n      case 'remove':\n      case 'reinsert':\n        result = this._getTransformedByMoveOperation(operation);\n        break;\n\n      case 'split':\n        result = this._getTransformedBySplitOperation(operation);\n        break;\n\n      case 'merge':\n        result = this._getTransformedByMergeOperation(operation);\n        break;\n\n      default:\n        result = Position._createAt(this);\n        break;\n    }\n\n    return result;\n  }\n  /**\n   * Returns a copy of this position transformed by an insert operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedByInsertOperation(operation) {\n    return this._getTransformedByInsertion(operation.position, operation.howMany);\n  }\n  /**\n   * Returns a copy of this position transformed by a move operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedByMoveOperation(operation) {\n    return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);\n  }\n  /**\n   * Returns a copy of this position transformed by a split operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedBySplitOperation(operation) {\n    const movedRange = operation.movedRange;\n    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == 'toNext';\n\n    if (isContained) {\n      return this._getCombined(operation.splitPosition, operation.moveTargetPosition);\n    } else {\n      if (operation.graveyardPosition) {\n        return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);\n      } else {\n        return this._getTransformedByInsertion(operation.insertionPosition, 1);\n      }\n    }\n  }\n  /**\n   * Returns a copy of this position transformed by merge operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedByMergeOperation(operation) {\n    const movedRange = operation.movedRange;\n    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);\n    let pos;\n\n    if (isContained) {\n      pos = this._getCombined(operation.sourcePosition, operation.targetPosition);\n\n      if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n        // Above happens during OT when the merged element is moved before the merged-to element.\n        pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);\n      }\n    } else if (this.isEqual(operation.deletionPosition)) {\n      pos = Position._createAt(operation.deletionPosition);\n    } else {\n      pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);\n    }\n\n    return pos;\n  }\n  /**\n   * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n   * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n   * @param {Number} howMany How many nodes are removed.\n   * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n   */\n\n\n  _getTransformedByDeletion(deletePosition, howMany) {\n    const transformed = Position._createAt(this); // This position can't be affected if deletion was in a different root.\n\n\n    if (this.root != deletePosition.root) {\n      return transformed;\n    }\n\n    if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'same') {\n      // If nodes are removed from the node that is pointed by this position...\n      if (deletePosition.offset < this.offset) {\n        // And are removed from before an offset of that position...\n        if (deletePosition.offset + howMany > this.offset) {\n          // Position is in removed range, it's no longer in the tree.\n          return null;\n        } else {\n          // Decrement the offset accordingly.\n          transformed.offset -= howMany;\n        }\n      }\n    } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'prefix') {\n      // If nodes are removed from a node that is on a path to this position...\n      const i = deletePosition.path.length - 1;\n\n      if (deletePosition.offset <= this.path[i]) {\n        // And are removed from before next node of that path...\n        if (deletePosition.offset + howMany > this.path[i]) {\n          // If the next node of that path is removed return null\n          // because the node containing this position got removed.\n          return null;\n        } else {\n          // Otherwise, decrement index on that path.\n          transformed.path[i] -= howMany;\n        }\n      }\n    }\n\n    return transformed;\n  }\n  /**\n   * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n   * @param {Number} howMany How many nodes are inserted.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n\n\n  _getTransformedByInsertion(insertPosition, howMany) {\n    const transformed = Position._createAt(this); // This position can't be affected if insertion was in a different root.\n\n\n    if (this.root != insertPosition.root) {\n      return transformed;\n    }\n\n    if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'same') {\n      // If nodes are inserted in the node that is pointed by this position...\n      if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != 'toPrevious') {\n        // And are inserted before an offset of that position...\n        // \"Push\" this positions offset.\n        transformed.offset += howMany;\n      }\n    } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'prefix') {\n      // If nodes are inserted in a node that is on a path to this position...\n      const i = insertPosition.path.length - 1;\n\n      if (insertPosition.offset <= this.path[i]) {\n        // And are inserted before next node of that path...\n        // \"Push\" the index on that path.\n        transformed.path[i] += howMany;\n      }\n    }\n\n    return transformed;\n  }\n  /**\n   * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n   * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n   * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n\n\n  _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n    // Update target position, as it could be affected by nodes removal.\n    targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n\n    if (sourcePosition.isEqual(targetPosition)) {\n      // If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n      return Position._createAt(this);\n    } // Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\n\n    const transformed = this._getTransformedByDeletion(sourcePosition, howMany);\n\n    const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == 'toNext' || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == 'toPrevious';\n\n    if (isMoved) {\n      // This position is inside moved range (or sticks to it).\n      // In this case, we calculate a combination of this position, move source position and target position.\n      return this._getCombined(sourcePosition, targetPosition);\n    } else {\n      // This position is not inside a removed range.\n      //\n      // In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n      return transformed._getTransformedByInsertion(targetPosition, howMany);\n    }\n  }\n  /**\n   * Returns a new position that is a combination of this position and given positions.\n   *\n   * The combined position is a copy of this position transformed by moving a range starting at `source` position\n   * to the `target` position. It is expected that this position is inside the moved range.\n   *\n   * Example:\n   *\n   *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n   *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n   *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n   *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n   *\n   * Explanation:\n   *\n   * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n   * was inside moved nodes and now should point to the new place. The moved nodes will be after\n   * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n   * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n   * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n   * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} source Beginning of the moved range.\n   * @param {module:engine/model/position~Position} target Position where the range is moved.\n   * @returns {module:engine/model/position~Position} Combined position.\n   */\n\n\n  _getCombined(source, target) {\n    const i = source.path.length - 1; // The first part of a path to combined position is a path to the place where nodes were moved.\n\n    const combined = Position._createAt(target);\n\n    combined.stickiness = this.stickiness; // Then we have to update the rest of the path.\n    // Fix the offset because this position might be after `from` position and we have to reflect that.\n\n    combined.offset = combined.offset + this.path[i] - source.offset; // Then, add the rest of the path.\n    // If this position is at the same level as `from` position nothing will get added.\n\n    combined.path = [...combined.path, ...this.path.slice(i + 1)];\n    return combined;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  toJSON() {\n    return {\n      root: this.root.toJSON(),\n      path: Array.from(this.path),\n      stickiness: this.stickiness\n    };\n  }\n  /**\n   * Returns a new position that is equal to current position.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  clone() {\n    return new this.constructor(this.root, this.path, this.stickiness);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/model/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n   *\n   * This method is a shortcut to other factory methods such as:\n   *\n   * * {@link module:engine/model/position~Position._createBefore},\n   * * {@link module:engine/model/position~Position._createAfter}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @protected\n   */\n\n\n  static _createAt(itemOrPosition, offset) {\n    let stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';\n\n    if (itemOrPosition instanceof Position) {\n      return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);\n    } else {\n      const node = itemOrPosition;\n\n      if (offset == 'end') {\n        offset = node.maxOffset;\n      } else if (offset == 'before') {\n        return this._createBefore(node, stickiness);\n      } else if (offset == 'after') {\n        return this._createAfter(node, stickiness);\n      } else if (offset !== 0 && !offset) {\n        /**\n         * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n         * requires the offset to be specified when the first parameter is a model item.\n         *\n         * @error model-createpositionat-offset-required\n         */\n        throw new CKEditorError('model-createpositionat-offset-required', [this, itemOrPosition]);\n      }\n\n      if (!node.is('element') && !node.is('documentFragment')) {\n        /**\n         * Position parent have to be a model element or model document fragment.\n         *\n         * @error model-position-parent-incorrect\n         */\n        throw new CKEditorError('model-position-parent-incorrect', [this, itemOrPosition]);\n      }\n\n      const path = node.getPath();\n      path.push(offset);\n      return new this(node.root, path, stickiness);\n    }\n  }\n  /**\n   * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * @returns {module:engine/model/position~Position}\n   * @protected\n   */\n\n\n  static _createAfter(item, stickiness) {\n    if (!item.parent) {\n      /**\n       * You can not make a position after a root element.\n       *\n       * @error model-position-after-root\n       * @param {module:engine/model/item~Item} root\n       */\n      throw new CKEditorError('model-position-after-root', [this, item], {\n        root: item\n      });\n    }\n\n    return this._createAt(item.parent, item.endOffset, stickiness);\n  }\n  /**\n   * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n   *\n   * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * @returns {module:engine/model/position~Position}\n   * @protected\n   */\n\n\n  static _createBefore(item, stickiness) {\n    if (!item.parent) {\n      /**\n       * You can not make a position before a root element.\n       *\n       * @error model-position-before-root\n       * @param {module:engine/model/item~Item} root\n       */\n      throw new CKEditorError('model-position-before-root', item, {\n        root: item\n      });\n    }\n\n    return this._createAt(item.parent, item.startOffset, stickiness);\n  }\n  /**\n   * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n   *\n   * @param {Object} json Plain object to be converted to `Position`.\n   * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n   * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n   */\n\n\n  static fromJSON(json, doc) {\n    if (json.root === '$graveyard') {\n      const pos = new Position(doc.graveyard, json.path);\n      pos.stickiness = json.stickiness;\n      return pos;\n    }\n\n    if (!doc.getRoot(json.root)) {\n      /**\n       * Cannot create position for document. Root with specified name does not exist.\n       *\n       * @error model-position-fromjson-no-root\n       * @param {String} rootName\n       */\n      throw new CKEditorError('model-position-fromjson-no-root', doc, {\n        rootName: json.root\n      });\n    }\n\n    return new Position(doc.getRoot(json.root), json.path, json.stickiness);\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.path.join( ', ' ) } ]`;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // log() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n  // @if CK_DEBUG_ENGINE // }\n\n\n}\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n\n/**\n * Returns a text node at the given position.\n *\n * This is a helper function optimized to reuse the position parent instance for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#textNode `Position#textNode`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`}\n * check if your algorithm does not access it multiple times (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getNodeAfterPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @returns {module:engine/model/text~Text|null}\n */\n\nexport function getTextNodeAtPosition(position, positionParent) {\n  const node = positionParent.getChild(positionParent.offsetToIndex(position.offset));\n\n  if (node && node.is('$text') && node.startOffset < position.offset) {\n    return node;\n  }\n\n  return null;\n}\n/**\n * Returns the node after the given position.\n *\n * This is a helper function optimized to reuse the position parent instance and the calculation of the text node at the\n * specific position for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#nodeAfter `Position#nodeAfter`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`} and/or\n * {@link module:engine/model/position~Position#textNode `Position#textNode`}\n * check if your algorithm does not access those properties multiple times\n * (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579 and https://github.com/ckeditor/ckeditor5/issues/6582.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\n\nexport function getNodeAfterPosition(position, positionParent, textNode) {\n  if (textNode !== null) {\n    return null;\n  }\n\n  return positionParent.getChild(positionParent.offsetToIndex(position.offset));\n}\n/**\n * Returns the node before the given position.\n *\n * Refer to {@link module:engine/model/position~getNodeBeforePosition} for documentation on when to use this util method.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeAfterPosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\n\nexport function getNodeBeforePosition(position, positionParent, textNode) {\n  if (textNode !== null) {\n    return null;\n  }\n\n  return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js"],"names":["TreeWalker","compareArrays","CKEditorError","Position","constructor","root","path","stickiness","is","Array","length","slice","getPath","offset","newOffset","parent","i","getChild","offsetToIndex","position","index","textNode","getTextNodeAtPosition","nodeAfter","getNodeAfterPosition","nodeBefore","getNodeBeforePosition","isAtStart","isAtEnd","maxOffset","compareWith","otherPosition","result","getLastMatchingPosition","skip","options","startPosition","treeWalker","getParentPath","getAncestors","includeSelf","findAncestor","parentName","getCommonPath","cmp","diffAt","Math","min","getCommonAncestor","ancestorsA","ancestorsB","getShiftedBy","shift","shifted","clone","isAfter","isBefore","isEqual","isTouching","left","right","compare","_createAt","leftParent","type","hasSameParentAs","thisParentPath","posParentPath","getTransformedByOperation","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","_getTransformedByInsertion","howMany","_getTransformedByMove","sourcePosition","targetPosition","movedRange","isContained","containsPosition","start","_getCombined","splitPosition","moveTargetPosition","graveyardPosition","insertionPosition","pos","_getTransformedByDeletion","deletionPosition","deletePosition","transformed","insertPosition","isMoved","source","target","combined","toJSON","from","itemOrPosition","node","_createBefore","_createAfter","push","item","endOffset","startOffset","fromJSON","json","doc","graveyard","getRoot","rootName","positionParent"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\n\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t */\n\tconstructor( root, path, stickiness = 'toNone' ) {\n\t\tif ( !root.is( 'element' ) && !root.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * Position root is invalid.\n\t\t\t *\n\t\t\t * Positions can only be anchored in elements or document fragments.\n\t\t\t *\n\t\t\t * @error model-position-root-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-root-invalid',\n\t\t\t\troot\n\t\t\t);\n\t\t}\n\n\t\tif ( !( path instanceof Array ) || path.length === 0 ) {\n\t\t\t/**\n\t\t\t * Position path must be an array with at least one item.\n\t\t\t *\n\t\t\t * @error model-position-path-incorrect-format\n\t\t\t * @param path\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-path-incorrect-format',\n\t\t\t\troot,\n\t\t\t\t{ path }\n\t\t\t);\n\t\t}\n\n\t\t// Normalize the root and path when element (not root) is passed.\n\t\tif ( root.is( 'rootElement' ) ) {\n\t\t\tpath = path.slice();\n\t\t} else {\n\t\t\tpath = [ ...root.getPath(), ...path ];\n\t\t\troot = root.root;\n\t\t}\n\n\t\t/**\n\t\t * Root of the position path.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/position~Position#root\n\t\t */\n\t\tthis.root = root;\n\n\t\t/**\n\t\t * Position of the node in the tree. **Path contains offsets, not indexes.**\n\t\t *\n\t\t * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n\t\t * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n\t\t * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n\t\t * down to the position offset in it's parent.\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n\t\t *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n\t\t *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n\t\t *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n\t\t *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n\t\t *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n\t\t *\n\t\t * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n\t\t * greater than `1` you can place position offset between their start and end:\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P\n\t\t *\t\t  |- UL\n\t\t *\t\t     |- LI\n\t\t *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n\t\t *\t\t     |- LI\n\t\t *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<Number>} module:engine/model/position~Position#path\n\t\t */\n\t\tthis.path = path;\n\n\t\t/**\n\t\t * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n\t\t *\n\t\t * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n\t\t */\n\t\tthis.stickiness = stickiness;\n\t}\n\n\t/**\n\t * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n\t * to the last item in position {@link module:engine/model/position~Position#path path}.\n\t *\n\t * @type {Number}\n\t */\n\tget offset() {\n\t\treturn this.path[ this.path.length - 1 ];\n\t}\n\n\tset offset( newOffset ) {\n\t\tthis.path[ this.path.length - 1 ] = newOffset;\n\t}\n\n\t/**\n\t * Parent element of this position.\n\t *\n\t * Keep in mind that `parent` value is calculated when the property is accessed.\n\t * If {@link module:engine/model/position~Position#path position path}\n\t * leads to a non-existing element, `parent` property will throw error.\n\t *\n\t * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget parent() {\n\t\tlet parent = this.root;\n\n\t\tfor ( let i = 0; i < this.path.length - 1; i++ ) {\n\t\t\tparent = parent.getChild( parent.offsetToIndex( this.path[ i ] ) );\n\n\t\t\tif ( !parent ) {\n\t\t\t\t/**\n\t\t\t\t * The position's path is incorrect. This means that a position does not point to\n\t\t\t\t * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n\t\t\t\t *\n\t\t\t\t * **Note**: Unlike DOM and view positions, in the model, the\n\t\t\t\t * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n\t\t\t\t * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element\n\t\t\t\t * where this position points.\n\t\t\t\t *\n\t\t\t\t * Read more about model positions and offsets in\n\t\t\t\t * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n\t\t\t\t *\n\t\t\t\t * @error model-position-path-incorrect\n\t\t\t\t * @param {module:engine/model/position~Position} position The incorrect position.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-position-path-incorrect', this, { position: this } );\n\t\t\t}\n\t\t}\n\n\t\tif ( parent.is( '$text' ) ) {\n\t\t\tthrow new CKEditorError( 'model-position-path-incorrect', this, { position: this } );\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n\t * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n\t * in text node, position index is equal to the index of that text node.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget index() {\n\t\treturn this.parent.offsetToIndex( this.offset );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n\t * position is not in a text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/text~Text|null}\n\t */\n\tget textNode() {\n\t\treturn getTextNodeAtPosition( this, this.parent );\n\t}\n\n\t/**\n\t * Node directly after this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\t// Cache the parent and reuse for performance reasons. See #6579 and #6582.\n\t\tconst parent = this.parent;\n\n\t\treturn getNodeAfterPosition( this, parent, getTextNodeAtPosition( this, parent ) );\n\t}\n\n\t/**\n\t * Node directly before this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeBefore() {\n\t\t// Cache the parent and reuse for performance reasons. See #6579 and #6582.\n\t\tconst parent = this.parent;\n\n\t\treturn getNodeBeforePosition( this, parent, getTextNodeAtPosition( this, parent ) );\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\treturn this.offset == this.parent.maxOffset;\n\t}\n\n\t/**\n\t * Checks whether this position is before or after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/model/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root != otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tconst result = compareArrays( this.path, otherPosition.path );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'same':\n\t\t\t\treturn 'same';\n\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn this.path[ result ] < otherPosition.path[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n\t * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n\t * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => false );\n\t * \t\t// Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n\t * but without the last item.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @returns {Array.<Number>} Path to the parent.\n\t */\n\tgetParentPath() {\n\t\treturn this.path.slice( 0, -1 );\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and its ancestors.\n\t *\n\t * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tconst parent = this.parent;\n\n\t\tif ( parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ parent ];\n\t\t} else {\n\t\t\treturn parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.\n\t *\n\t * @param {String} parentName The name of the parent element to find.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tfindAncestor( parentName ) {\n\t\tconst parent = this.parent;\n\n\t\tif ( parent.is( 'element' ) ) {\n\t\t\treturn parent.findAncestor( parentName, { includeSelf: true } );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n\t * of these two paths must be identical.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {Array.<Number>} The common path.\n\t */\n\tgetCommonPath( position ) {\n\t\tif ( this.root != position.root ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We find on which tree-level start and end have the lowest common ancestor\n\t\tconst cmp = compareArrays( this.path, position.path );\n\t\t// If comparison returned string it means that arrays are same.\n\t\tconst diffAt = ( typeof cmp == 'string' ) ? Math.min( this.path.length, position.path.length ) : cmp;\n\n\t\treturn this.path.slice( 0, diffAt );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n\t * is shifted by `shift` value (can be a negative value).\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {Number} shift Offset shift. Can be a negative value.\n\t * @returns {module:engine/model/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = this.clone();\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Checks whether this position is after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @see module:engine/model/position~Position#isBefore\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before given position.\n\t *\n\t * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n\t * be `true` if positions are in different roots and you might not expect this. You should probably use\n\t * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n\t * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n\t *\n\t *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do A.\n\t *\t\t} else {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * or, if you have only one if-branch:\n\t *\n\t *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * rather than:\n\t *\n\t *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t} else {\n\t *\t\t\t// do A.\n\t *\t\t}\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is equal to given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'same';\n\t}\n\n\t/**\n\t * Checks whether this position is touching given position. Positions touch when there are no text nodes\n\t * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n\t * they are very similar or even indistinguishable.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions touch.\n\t */\n\tisTouching( otherPosition ) {\n\t\tlet left = null;\n\t\tlet right = null;\n\t\tconst compare = this.compareWith( otherPosition );\n\n\t\tswitch ( compare ) {\n\t\t\tcase 'same':\n\t\t\t\treturn true;\n\n\t\t\tcase 'before':\n\t\t\t\tleft = Position._createAt( this );\n\t\t\t\tright = Position._createAt( otherPosition );\n\t\t\t\tbreak;\n\n\t\t\tcase 'after':\n\t\t\t\tleft = Position._createAt( otherPosition );\n\t\t\t\tright = Position._createAt( this );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// Cached for optimization purposes.\n\t\tlet leftParent = left.parent;\n\n\t\twhile ( left.path.length + right.path.length ) {\n\t\t\tif ( left.isEqual( right ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( left.path.length > right.path.length ) {\n\t\t\t\tif ( left.offset !== leftParent.maxOffset ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tleft.path = left.path.slice( 0, -1 );\n\t\t\t\tleftParent = leftParent.parent;\n\t\t\t\tleft.offset++;\n\t\t\t} else {\n\t\t\t\tif ( right.offset !== 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tright.path = right.path.slice( 0, -1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tposition.is( 'position' ); // -> true\n\t *\t\tposition.is( 'model:position' ); // -> true\n\t *\n\t *\t\tposition.is( 'view:position' ); // -> false\n\t *\t\tposition.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'position' || type === 'model:position';\n\t}\n\n\t/**\n\t * Checks if two positions are in the same parent.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position Position to compare with.\n\t * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n\t */\n\thasSameParentAs( position ) {\n\t\tif ( this.root !== position.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisParentPath = this.getParentPath();\n\t\tconst posParentPath = position.getParentPath();\n\n\t\treturn compareArrays( thisParentPath, posParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Returns a copy of this position that is transformed by given `operation`.\n\t *\n\t * The new position's parameters are updated accordingly to the effect of the `operation`.\n\t *\n\t * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n\t * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tlet result;\n\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\tresult = this._getTransformedByInsertOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\tresult = this._getTransformedByMoveOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'split':\n\t\t\t\tresult = this._getTransformedBySplitOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tresult = this._getTransformedByMergeOperation( operation );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = Position._createAt( this );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by an insert operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByInsertOperation( operation ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a move operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMoveOperation( operation ) {\n\t\treturn this._getTransformedByMove( operation.sourcePosition, operation.targetPosition, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a split operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\n\t\tconst isContained = movedRange.containsPosition( this ) ||\n\t\t\t( movedRange.start.isEqual( this ) && this.stickiness == 'toNext' );\n\n\t\tif ( isContained ) {\n\t\t\treturn this._getCombined( operation.splitPosition, operation.moveTargetPosition );\n\t\t} else {\n\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\treturn this._getTransformedByMove( operation.graveyardPosition, operation.insertionPosition, 1 );\n\t\t\t} else {\n\t\t\t\treturn this._getTransformedByInsertion( operation.insertionPosition, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by merge operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\t\tconst isContained = movedRange.containsPosition( this ) || movedRange.start.isEqual( this );\n\n\t\tlet pos;\n\n\t\tif ( isContained ) {\n\t\t\tpos = this._getCombined( operation.sourcePosition, operation.targetPosition );\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Above happens during OT when the merged element is moved before the merged-to element.\n\t\t\t\tpos = pos._getTransformedByDeletion( operation.deletionPosition, 1 );\n\t\t\t}\n\t\t} else if ( this.isEqual( operation.deletionPosition ) ) {\n\t\t\tpos = Position._createAt( operation.deletionPosition );\n\t\t} else {\n\t\t\tpos = this._getTransformedByMove( operation.deletionPosition, operation.graveyardPosition, 1 );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n\t * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if deletion was in a different root.\n\t\tif ( this.root != deletePosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are removed from the node that is pointed by this position...\n\t\t\tif ( deletePosition.offset < this.offset ) {\n\t\t\t\t// And are removed from before an offset of that position...\n\t\t\t\tif ( deletePosition.offset + howMany > this.offset ) {\n\t\t\t\t\t// Position is in removed range, it's no longer in the tree.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the offset accordingly.\n\t\t\t\t\ttransformed.offset -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are removed from a node that is on a path to this position...\n\t\t\tconst i = deletePosition.path.length - 1;\n\n\t\t\tif ( deletePosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are removed from before next node of that path...\n\t\t\t\tif ( deletePosition.offset + howMany > this.path[ i ] ) {\n\t\t\t\t\t// If the next node of that path is removed return null\n\t\t\t\t\t// because the node containing this position got removed.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, decrement index on that path.\n\t\t\t\t\ttransformed.path[ i ] -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if insertion was in a different root.\n\t\tif ( this.root != insertPosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are inserted in the node that is pointed by this position...\n\t\t\tif ( insertPosition.offset < this.offset || ( insertPosition.offset == this.offset && this.stickiness != 'toPrevious' ) ) {\n\t\t\t\t// And are inserted before an offset of that position...\n\t\t\t\t// \"Push\" this positions offset.\n\t\t\t\ttransformed.offset += howMany;\n\t\t\t}\n\t\t} else if ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are inserted in a node that is on a path to this position...\n\t\t\tconst i = insertPosition.path.length - 1;\n\n\t\t\tif ( insertPosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are inserted before next node of that path...\n\t\t\t\t// \"Push\" the index on that path.\n\t\t\t\ttransformed.path[ i ] += howMany;\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n\t * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n\t * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany ) {\n\t\t// Update target position, as it could be affected by nodes removal.\n\t\ttargetPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( sourcePosition.isEqual( targetPosition ) ) {\n\t\t\t// If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n\t\t\treturn Position._createAt( this );\n\t\t}\n\n\t\t// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\t\tconst transformed = this._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tconst isMoved = transformed === null ||\n\t\t\t( sourcePosition.isEqual( this ) && this.stickiness == 'toNext' ) ||\n\t\t\t( sourcePosition.getShiftedBy( howMany ).isEqual( this ) && this.stickiness == 'toPrevious' );\n\n\t\tif ( isMoved ) {\n\t\t\t// This position is inside moved range (or sticks to it).\n\t\t\t// In this case, we calculate a combination of this position, move source position and target position.\n\t\t\treturn this._getCombined( sourcePosition, targetPosition );\n\t\t} else {\n\t\t\t// This position is not inside a removed range.\n\t\t\t//\n\t\t\t// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n\t\t\treturn transformed._getTransformedByInsertion( targetPosition, howMany );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new position that is a combination of this position and given positions.\n\t *\n\t * The combined position is a copy of this position transformed by moving a range starting at `source` position\n\t * to the `target` position. It is expected that this position is inside the moved range.\n\t *\n\t * Example:\n\t *\n\t *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n\t *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n\t *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n\t *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n\t *\n\t * Explanation:\n\t *\n\t * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n\t * was inside moved nodes and now should point to the new place. The moved nodes will be after\n\t * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n\t * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n\t * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n\t * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} source Beginning of the moved range.\n\t * @param {module:engine/model/position~Position} target Position where the range is moved.\n\t * @returns {module:engine/model/position~Position} Combined position.\n\t */\n\t_getCombined( source, target ) {\n\t\tconst i = source.path.length - 1;\n\n\t\t// The first part of a path to combined position is a path to the place where nodes were moved.\n\t\tconst combined = Position._createAt( target );\n\t\tcombined.stickiness = this.stickiness;\n\n\t\t// Then we have to update the rest of the path.\n\n\t\t// Fix the offset because this position might be after `from` position and we have to reflect that.\n\t\tcombined.offset = combined.offset + this.path[ i ] - source.offset;\n\n\t\t// Then, add the rest of the path.\n\t\t// If this position is at the same level as `from` position nothing will get added.\n\t\tcombined.path = [ ...combined.path, ...this.path.slice( i + 1 ) ];\n\n\t\treturn combined;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\troot: this.root.toJSON(),\n\t\t\tpath: Array.from( this.path ),\n\t\t\tstickiness: this.stickiness\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new position that is equal to current position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.root, this.path, this.stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/position~Position._createBefore},\n\t * * {@link module:engine/model/position~Position._createAfter}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @protected\n\t */\n\tstatic _createAt( itemOrPosition, offset, stickiness = 'toNone' ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn new Position( itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.maxOffset;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this._createBefore( node, stickiness );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this._createAfter( node, stickiness );\n\t\t\t} else if ( offset !== 0 && !offset ) {\n\t\t\t\t/**\n\t\t\t\t * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n\t\t\t\t * requires the offset to be specified when the first parameter is a model item.\n\t\t\t\t *\n\t\t\t\t * @error model-createpositionat-offset-required\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-createpositionat-offset-required', [ this, itemOrPosition ] );\n\t\t\t}\n\n\t\t\tif ( !node.is( 'element' ) && !node.is( 'documentFragment' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Position parent have to be a model element or model document fragment.\n\t\t\t\t *\n\t\t\t\t * @error model-position-parent-incorrect\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-position-parent-incorrect',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst path = node.getPath();\n\n\t\t\tpath.push( offset );\n\n\t\t\treturn new this( node.root, path, stickiness );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createAfter( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root element.\n\t\t\t *\n\t\t\t * @error model-position-after-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-after-root',\n\t\t\t\t[ this, item ],\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.endOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createBefore( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position before a root element.\n\t\t\t *\n\t\t\t * @error model-position-before-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-before-root',\n\t\t\t\titem,\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.startOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Position`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n\t * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\tif ( json.root === '$graveyard' ) {\n\t\t\tconst pos = new Position( doc.graveyard, json.path );\n\t\t\tpos.stickiness = json.stickiness;\n\n\t\t\treturn pos;\n\t\t}\n\n\t\tif ( !doc.getRoot( json.root ) ) {\n\t\t\t/**\n\t\t\t * Cannot create position for document. Root with specified name does not exist.\n\t\t\t *\n\t\t\t * @error model-position-fromjson-no-root\n\t\t\t * @param {String} rootName\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-fromjson-no-root',\n\t\t\t\tdoc,\n\t\t\t\t{ rootName: json.root }\n\t\t\t);\n\t\t}\n\n\t\treturn new Position( doc.getRoot( json.root ), json.path, json.stickiness );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n\n/**\n * Returns a text node at the given position.\n *\n * This is a helper function optimized to reuse the position parent instance for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#textNode `Position#textNode`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`}\n * check if your algorithm does not access it multiple times (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getNodeAfterPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @returns {module:engine/model/text~Text|null}\n */\nexport function getTextNodeAtPosition( position, positionParent ) {\n\tconst node = positionParent.getChild( positionParent.offsetToIndex( position.offset ) );\n\n\tif ( node && node.is( '$text' ) && node.startOffset < position.offset ) {\n\t\treturn node;\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns the node after the given position.\n *\n * This is a helper function optimized to reuse the position parent instance and the calculation of the text node at the\n * specific position for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#nodeAfter `Position#nodeAfter`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`} and/or\n * {@link module:engine/model/position~Position#textNode `Position#textNode`}\n * check if your algorithm does not access those properties multiple times\n * (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579 and https://github.com/ckeditor/ckeditor5/issues/6582.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeAfterPosition( position, positionParent, textNode ) {\n\tif ( textNode !== null ) {\n\t\treturn null;\n\t}\n\n\treturn positionParent.getChild( positionParent.offsetToIndex( position.offset ) );\n}\n\n/**\n * Returns the node before the given position.\n *\n * Refer to {@link module:engine/model/position~getNodeBeforePosition} for documentation on when to use this util method.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeAfterPosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeBeforePosition( position, positionParent, textNode ) {\n\tif ( textNode !== null ) {\n\t\treturn null;\n\t}\n\n\treturn positionParent.getChild( positionParent.offsetToIndex( position.offset ) - 1 );\n}\n"]},"metadata":{},"sourceType":"module"}