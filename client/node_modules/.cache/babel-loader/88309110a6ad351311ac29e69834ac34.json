{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/treewalker\n */\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Element from './element';\nimport { default as Position, getTextNodeAtPosition, getNodeAfterPosition, getNodeBeforePosition } from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\n\nexport default class TreeWalker {\n  /**\n   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n   *\n   * @constructor\n   * @param {Object} [options={}] Object with configuration.\n   * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n   * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n   * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n   * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n   * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n   * {@link module:engine/model/textproxy~TextProxy} (`false`).\n   * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n   * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n   * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n   * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n   * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n   * twice: for `'elementStart'` and `'elementEnd'`.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.boundaries && !options.startPosition) {\n      /**\n       * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n       *\n       * @error model-tree-walker-no-start-position\n       */\n      throw new CKEditorError('model-tree-walker-no-start-position', null);\n    }\n\n    const direction = options.direction || 'forward';\n\n    if (direction != 'forward' && direction != 'backward') {\n      /**\n       * Only `backward` and `forward` direction allowed.\n       *\n       * @error model-tree-walker-unknown-direction\n       */\n      throw new CKEditorError('model-tree-walker-unknown-direction', options, {\n        direction\n      });\n    }\n    /**\n     * Walking direction. Defaults `'forward'`.\n     *\n     * @readonly\n     * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n     */\n\n\n    this.direction = direction;\n    /**\n     * Iterator boundaries.\n     *\n     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n     * on the start of boundary, then `{ done: true }` is returned.\n     *\n     * If boundaries are not defined they are set before first and after last child of the root node.\n     *\n     * @readonly\n     * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries\n     */\n\n    this.boundaries = options.boundaries || null;\n    /**\n     * Iterator position. This is always static position, even if the initial position was a\n     * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n     * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n     * is `'backward'` position starts from the end.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n     */\n\n    if (options.startPosition) {\n      this.position = options.startPosition.clone();\n    } else {\n      this.position = Position._createAt(this.boundaries[this.direction == 'backward' ? 'end' : 'start']);\n    } // Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.\n\n\n    this.position.stickiness = 'toNone';\n    /**\n     * Flag indicating whether all consecutive characters with the same attributes should be\n     * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n     */\n\n    this.singleCharacters = !!options.singleCharacters;\n    /**\n     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n     * iterated node will not be returned along with `elementEnd` tag.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n     */\n\n    this.shallow = !!options.shallow;\n    /**\n     * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n     * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n     * be returned once, while if the option is `false` they might be returned twice:\n     * for `'elementStart'` and `'elementEnd'`.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n     */\n\n    this.ignoreElementEnd = !!options.ignoreElementEnd;\n    /**\n     * Start boundary cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n     */\n\n    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n    /**\n     * End boundary cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n     */\n\n    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n    /**\n     * Parent of the most recently visited node. Cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     * module:engine/model/treewalker~TreeWalker#_visitedParent\n     */\n\n    this._visitedParent = this.position.parent;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n   *\n   * For example:\n   *\n   * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n   * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n   * \t\twalker.skip( () => false ); // Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   */\n\n\n  skip(skip) {\n    let done, value, prevPosition, prevVisitedParent;\n\n    do {\n      prevPosition = this.position;\n      prevVisitedParent = this._visitedParent;\n      ({\n        done,\n        value\n      } = this.next());\n    } while (!done && skip(value));\n\n    if (!done) {\n      this.position = prevPosition;\n      this._visitedParent = prevVisitedParent;\n    }\n  }\n  /**\n   * Gets the next tree walker's value.\n   *\n   * @returns {module:engine/model/treewalker~TreeWalkerValue} Next tree walker's value.\n   */\n\n\n  next() {\n    if (this.direction == 'forward') {\n      return this._next();\n    } else {\n      return this._previous();\n    }\n  }\n  /**\n   * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done True if iterator is done.\n   * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n   */\n\n\n  _next() {\n    const previousPosition = this.position;\n    const position = this.position.clone();\n    const parent = this._visitedParent; // We are at the end of the root.\n\n    if (parent.parent === null && position.offset === parent.maxOffset) {\n      return {\n        done: true\n      };\n    } // We reached the walker boundary.\n\n\n    if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n      return {\n        done: true\n      };\n    } // Get node just after the current position.\n    // Use a highly optimized version instead of checking the text node first and then getting the node after. See #6582.\n\n\n    const positionParent = position.parent;\n    const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);\n    const node = textNodeAtPosition ? textNodeAtPosition : getNodeAfterPosition(position, positionParent, textNodeAtPosition);\n\n    if (node instanceof Element) {\n      if (!this.shallow) {\n        // Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n        position.path.push(0);\n        this._visitedParent = node;\n      } else {\n        position.offset++;\n      }\n\n      this.position = position;\n      return formatReturnValue('elementStart', node, previousPosition, position, 1);\n    } else if (node instanceof Text) {\n      let charactersCount;\n\n      if (this.singleCharacters) {\n        charactersCount = 1;\n      } else {\n        let offset = node.endOffset;\n\n        if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {\n          offset = this.boundaries.end.offset;\n        }\n\n        charactersCount = offset - position.offset;\n      }\n\n      const offsetInTextNode = position.offset - node.startOffset;\n      const item = new TextProxy(node, offsetInTextNode, charactersCount);\n      position.offset += charactersCount;\n      this.position = position;\n      return formatReturnValue('text', item, previousPosition, position, charactersCount);\n    } else {\n      // `node` is not set, we reached the end of current `parent`.\n      position.path.pop();\n      position.offset++;\n      this.position = position;\n      this._visitedParent = parent.parent;\n\n      if (this.ignoreElementEnd) {\n        return this._next();\n      } else {\n        return formatReturnValue('elementEnd', parent, previousPosition, position);\n      }\n    }\n  }\n  /**\n   * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n   *\n   * @private\n   * @returns {Object}\n   * @returns {Boolean} return.done True if iterator is done.\n   * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n   */\n\n\n  _previous() {\n    const previousPosition = this.position;\n    const position = this.position.clone();\n    const parent = this._visitedParent; // We are at the beginning of the root.\n\n    if (parent.parent === null && position.offset === 0) {\n      return {\n        done: true\n      };\n    } // We reached the walker boundary.\n\n\n    if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n      return {\n        done: true\n      };\n    } // Get node just before the current position.\n    // Use a highly optimized version instead of checking the text node first and then getting the node before. See #6582.\n\n\n    const positionParent = position.parent;\n    const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);\n    const node = textNodeAtPosition ? textNodeAtPosition : getNodeBeforePosition(position, positionParent, textNodeAtPosition);\n\n    if (node instanceof Element) {\n      position.offset--;\n\n      if (!this.shallow) {\n        position.path.push(node.maxOffset);\n        this.position = position;\n        this._visitedParent = node;\n\n        if (this.ignoreElementEnd) {\n          return this._previous();\n        } else {\n          return formatReturnValue('elementEnd', node, previousPosition, position);\n        }\n      } else {\n        this.position = position;\n        return formatReturnValue('elementStart', node, previousPosition, position, 1);\n      }\n    } else if (node instanceof Text) {\n      let charactersCount;\n\n      if (this.singleCharacters) {\n        charactersCount = 1;\n      } else {\n        let offset = node.startOffset;\n\n        if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {\n          offset = this.boundaries.start.offset;\n        }\n\n        charactersCount = position.offset - offset;\n      }\n\n      const offsetInTextNode = position.offset - node.startOffset;\n      const item = new TextProxy(node, offsetInTextNode - charactersCount, charactersCount);\n      position.offset -= charactersCount;\n      this.position = position;\n      return formatReturnValue('text', item, previousPosition, position, charactersCount);\n    } else {\n      // `node` is not set, we reached the beginning of current `parent`.\n      position.path.pop();\n      this.position = position;\n      this._visitedParent = parent.parent;\n      return formatReturnValue('elementStart', parent, previousPosition, position, 1);\n    }\n  }\n\n}\n\nfunction formatReturnValue(type, item, previousPosition, nextPosition, length) {\n  return {\n    done: false,\n    value: {\n      type,\n      item,\n      previousPosition,\n      nextPosition,\n      length\n    }\n  };\n}\n/**\n * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,\n * or `'text'` if walker traversed over text.\n *\n * @typedef {'elementStart'|'elementEnd'|'text'} module:engine/model/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.\n *\n * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue\n * @property {module:engine/model/treewalker~TreeWalkerValueType} type\n * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.\n * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * @property {Number} [length] Length of the item. For `'elementStart'` it is 1. For `'text'` it is\n * the length of the text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/model/treewalker~TreeWalkerDirection\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js"],"names":["Text","TextProxy","Element","default","Position","getTextNodeAtPosition","getNodeAfterPosition","getNodeBeforePosition","CKEditorError","TreeWalker","constructor","options","boundaries","startPosition","direction","position","clone","_createAt","stickiness","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","start","parent","_boundaryEndParent","end","_visitedParent","Symbol","iterator","skip","done","value","prevPosition","prevVisitedParent","next","_next","_previous","previousPosition","offset","maxOffset","positionParent","textNodeAtPosition","node","path","push","formatReturnValue","charactersCount","endOffset","offsetInTextNode","startOffset","item","pop","type","nextPosition","length"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/treewalker\n */\n\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Element from './element';\nimport {\n\tdefault as Position,\n\tgetTextNodeAtPosition,\n\tgetNodeAfterPosition,\n\tgetNodeBeforePosition\n} from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n\t/**\n\t * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n\t *\n\t * @constructor\n\t * @param {Object} [options={}] Object with configuration.\n\t * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n\t * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n\t * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n\t * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n\t * {@link module:engine/model/textproxy~TextProxy} (`false`).\n\t * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n\t * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n\t * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n\t * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n\t * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n\t * twice: for `'elementStart'` and `'elementEnd'`.\n\t */\n\tconstructor( options = {} ) {\n\t\tif ( !options.boundaries && !options.startPosition ) {\n\t\t\t/**\n\t\t\t * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n\t\t\t *\n\t\t\t * @error model-tree-walker-no-start-position\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-tree-walker-no-start-position',\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tconst direction = options.direction || 'forward';\n\n\t\tif ( direction != 'forward' && direction != 'backward' ) {\n\t\t\t/**\n\t\t\t * Only `backward` and `forward` direction allowed.\n\t\t\t *\n\t\t\t * @error model-tree-walker-unknown-direction\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-tree-walker-unknown-direction', options, { direction } );\n\t\t}\n\n\t\t/**\n\t\t * Walking direction. Defaults `'forward'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Iterator boundaries.\n\t\t *\n\t\t * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n\t\t * on the start of boundary, then `{ done: true }` is returned.\n\t\t *\n\t\t * If boundaries are not defined they are set before first and after last child of the root node.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries\n\t\t */\n\t\tthis.boundaries = options.boundaries || null;\n\n\t\t/**\n\t\t * Iterator position. This is always static position, even if the initial position was a\n\t\t * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n\t\t * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n\t\t * is `'backward'` position starts from the end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n\t\t */\n\t\tif ( options.startPosition ) {\n\t\t\tthis.position = options.startPosition.clone();\n\t\t} else {\n\t\t\tthis.position = Position._createAt( this.boundaries[ this.direction == 'backward' ? 'end' : 'start' ] );\n\t\t}\n\n\t\t// Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.\n\t\tthis.position.stickiness = 'toNone';\n\n\t\t/**\n\t\t * Flag indicating whether all consecutive characters with the same attributes should be\n\t\t * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n\t\t */\n\t\tthis.singleCharacters = !!options.singleCharacters;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n\t\t * iterated node will not be returned along with `elementEnd` tag.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n\t\t */\n\t\tthis.shallow = !!options.shallow;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n\t\t * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n\t\t * be returned once, while if the option is `false` they might be returned twice:\n\t\t * for `'elementStart'` and `'elementEnd'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n\t\t */\n\t\tthis.ignoreElementEnd = !!options.ignoreElementEnd;\n\n\t\t/**\n\t\t * Start boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n\t\t */\n\t\tthis._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n\n\t\t/**\n\t\t * End boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n\t\t */\n\t\tthis._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n\n\t\t/**\n\t\t * Parent of the most recently visited node. Cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/treewalker~TreeWalker#_visitedParent\n\t\t */\n\t\tthis._visitedParent = this.position.parent;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n\t *\n\t * For example:\n\t *\n\t * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n\t * \t\twalker.skip( () => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t */\n\tskip( skip ) {\n\t\tlet done, value, prevPosition, prevVisitedParent;\n\n\t\tdo {\n\t\t\tprevPosition = this.position;\n\t\t\tprevVisitedParent = this._visitedParent;\n\n\t\t\t( { done, value } = this.next() );\n\t\t} while ( !done && skip( value ) );\n\n\t\tif ( !done ) {\n\t\t\tthis.position = prevPosition;\n\t\t\tthis._visitedParent = prevVisitedParent;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the next tree walker's value.\n\t *\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} Next tree walker's value.\n\t */\n\tnext() {\n\t\tif ( this.direction == 'forward' ) {\n\t\t\treturn this._next();\n\t\t} else {\n\t\t\treturn this._previous();\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_next() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = this.position.clone();\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the end of the root.\n\t\tif ( parent.parent === null && position.offset === parent.maxOffset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just after the current position.\n\t\t// Use a highly optimized version instead of checking the text node first and then getting the node after. See #6582.\n\t\tconst positionParent = position.parent;\n\t\tconst textNodeAtPosition = getTextNodeAtPosition( position, positionParent );\n\t\tconst node = textNodeAtPosition ? textNodeAtPosition : getNodeAfterPosition( position, positionParent, textNodeAtPosition );\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\t// Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n\t\t\t\tposition.path.push( 0 );\n\t\t\t\tthis._visitedParent = node;\n\t\t\t} else {\n\t\t\t\tposition.offset++;\n\t\t\t}\n\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.endOffset;\n\n\t\t\t\tif ( this._boundaryEndParent == parent && this.boundaries.end.offset < offset ) {\n\t\t\t\t\toffset = this.boundaries.end.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = offset - position.offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode, charactersCount );\n\n\t\t\tposition.offset += charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the end of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tposition.offset++;\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\treturn formatReturnValue( 'elementEnd', parent, previousPosition, position );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_previous() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = this.position.clone();\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the beginning of the root.\n\t\tif ( parent.parent === null && position.offset === 0 ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just before the current position.\n\t\t// Use a highly optimized version instead of checking the text node first and then getting the node before. See #6582.\n\t\tconst positionParent = position.parent;\n\t\tconst textNodeAtPosition = getTextNodeAtPosition( position, positionParent );\n\t\tconst node = textNodeAtPosition ? textNodeAtPosition : getNodeBeforePosition( position, positionParent, textNodeAtPosition );\n\n\t\tif ( node instanceof Element ) {\n\t\t\tposition.offset--;\n\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition.path.push( node.maxOffset );\n\t\t\t\tthis.position = position;\n\t\t\t\tthis._visitedParent = node;\n\n\t\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\t\treturn this._previous();\n\t\t\t\t} else {\n\t\t\t\t\treturn formatReturnValue( 'elementEnd', node, previousPosition, position );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t\t}\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.startOffset;\n\n\t\t\t\tif ( this._boundaryStartParent == parent && this.boundaries.start.offset > offset ) {\n\t\t\t\t\toffset = this.boundaries.start.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = position.offset - offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode - charactersCount, charactersCount );\n\n\t\t\tposition.offset -= charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the beginning of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\treturn formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );\n\t\t}\n\t}\n}\n\nfunction formatReturnValue( type, item, previousPosition, nextPosition, length ) {\n\treturn {\n\t\tdone: false,\n\t\tvalue: {\n\t\t\ttype,\n\t\t\titem,\n\t\t\tpreviousPosition,\n\t\t\tnextPosition,\n\t\t\tlength\n\t\t}\n\t};\n}\n\n/**\n * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,\n * or `'text'` if walker traversed over text.\n *\n * @typedef {'elementStart'|'elementEnd'|'text'} module:engine/model/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.\n *\n * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue\n * @property {module:engine/model/treewalker~TreeWalkerValueType} type\n * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.\n * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * @property {Number} [length] Length of the item. For `'elementStart'` it is 1. For `'text'` it is\n * the length of the text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/model/treewalker~TreeWalkerDirection\n */\n"]},"metadata":{},"sourceType":"module"}