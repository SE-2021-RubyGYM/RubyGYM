{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/imageuploadediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport { Notification } from 'ckeditor5/src/ui';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { FileRepository } from 'ckeditor5/src/upload';\nimport { env } from 'ckeditor5/src/utils';\nimport ImageUtils from '../imageutils';\nimport UploadImageCommand from './uploadimagecommand';\nimport { fetchLocalImage, isLocalImage } from '../../src/imageupload/utils';\nimport { createImageTypeRegExp } from './utils';\n/**\n * The editing part of the image upload feature. It registers the `'uploadImage'` command\n * and the `imageUpload` command as an aliased name.\n *\n * When an image is uploaded, it fires the {@link ~ImageUploadEditing#event:uploadComplete `uploadComplete`} event\n * that allows adding custom attributes to the {@link module:engine/model/element~Element image element}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class ImageUploadEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [FileRepository, Notification, ClipboardPipeline, ImageUtils];\n  }\n\n  static get pluginName() {\n    return 'ImageUploadEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  constructor(editor) {\n    super(editor);\n    editor.config.define('image', {\n      upload: {\n        types: ['jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff']\n      }\n    });\n    /**\n     * An internal mapping of {@link module:upload/filerepository~FileLoader#id file loader UIDs} and\n     * model elements during the upload.\n     *\n     * Model element of the uploaded image can change, for instance, when {@link module:image/image/imagetypecommand~ImageTypeCommand}\n     * is executed as a result of adding caption or changing image style. As a result, the upload logic must keep track of the model\n     * element (reference) and resolve the upload for the correct model element (instead of the one that landed in the `$graveyard`\n     * after image type changed).\n     *\n     * @private\n     * @readonly\n     * @member {Map.<String,module:engine/model/element~Element>}\n     */\n\n    this._uploadImageElements = new Map();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const doc = editor.model.document;\n    const conversion = editor.conversion;\n    const fileRepository = editor.plugins.get(FileRepository);\n    const imageUtils = editor.plugins.get('ImageUtils');\n    const imageTypes = createImageTypeRegExp(editor.config.get('image.upload.types'));\n    const uploadImageCommand = new UploadImageCommand(editor); // Register `uploadImage` command and add `imageUpload` command as an alias for backward compatibility.\n\n    editor.commands.add('uploadImage', uploadImageCommand);\n    editor.commands.add('imageUpload', uploadImageCommand); // Register upcast converter for uploadId.\n\n    conversion.for('upcast').attributeToAttribute({\n      view: {\n        name: 'img',\n        key: 'uploadId'\n      },\n      model: 'uploadId'\n    }); // Handle pasted images.\n    // For every image file, a new file loader is created and a placeholder image is\n    // inserted into the content. Then, those images are uploaded once they appear in the model\n    // (see Document#change listener below).\n\n    this.listenTo(editor.editing.view.document, 'clipboardInput', (evt, data) => {\n      // Skip if non empty HTML data is included.\n      // https://github.com/ckeditor/ckeditor5-upload/issues/68\n      if (isHtmlIncluded(data.dataTransfer)) {\n        return;\n      }\n\n      const images = Array.from(data.dataTransfer.files).filter(file => {\n        // See https://github.com/ckeditor/ckeditor5-image/pull/254.\n        if (!file) {\n          return false;\n        }\n\n        return imageTypes.test(file.type);\n      });\n\n      if (!images.length) {\n        return;\n      }\n\n      evt.stop();\n      editor.model.change(writer => {\n        // Set selection to paste target.\n        if (data.targetRanges) {\n          writer.setSelection(data.targetRanges.map(viewRange => editor.editing.mapper.toModelRange(viewRange)));\n        } // Upload images after the selection has changed in order to ensure the command's state is refreshed.\n\n\n        editor.model.enqueueChange('default', () => {\n          editor.execute('uploadImage', {\n            file: images\n          });\n        });\n      });\n    }); // Handle HTML pasted with images with base64 or blob sources.\n    // For every image file, a new file loader is created and a placeholder image is\n    // inserted into the content. Then, those images are uploaded once they appear in the model\n    // (see Document#change listener below).\n\n    this.listenTo(editor.plugins.get('ClipboardPipeline'), 'inputTransformation', (evt, data) => {\n      const fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).filter(value => isLocalImage(imageUtils, value.item) && !value.item.getAttribute('uploadProcessed')).map(value => {\n        return {\n          promise: fetchLocalImage(value.item),\n          imageElement: value.item\n        };\n      });\n\n      if (!fetchableImages.length) {\n        return;\n      }\n\n      const writer = new UpcastWriter(editor.editing.view.document);\n\n      for (const fetchableImage of fetchableImages) {\n        // Set attribute marking that the image was processed already.\n        writer.setAttribute('uploadProcessed', true, fetchableImage.imageElement);\n        const loader = fileRepository.createLoader(fetchableImage.promise);\n\n        if (loader) {\n          writer.setAttribute('src', '', fetchableImage.imageElement);\n          writer.setAttribute('uploadId', loader.id, fetchableImage.imageElement);\n        }\n      }\n    }); // Prevents from the browser redirecting to the dropped image.\n\n    editor.editing.view.document.on('dragover', (evt, data) => {\n      data.preventDefault();\n    }); // Upload placeholder images that appeared in the model.\n\n    doc.on('change', () => {\n      // Note: Reversing changes to start with insertions and only then handle removals. If it was the other way around,\n      // loaders for **all** images that land in the $graveyard would abort while in fact only those that were **not** replaced\n      // by other images should be aborted.\n      const changes = doc.differ.getChanges({\n        includeChangesInGraveyard: true\n      }).reverse();\n      const insertedImagesIds = new Set();\n\n      for (const entry of changes) {\n        if (entry.type == 'insert' && entry.name != '$text') {\n          const item = entry.position.nodeAfter;\n          const isInsertedInGraveyard = entry.position.root.rootName == '$graveyard';\n\n          for (const imageElement of getImagesFromChangeItem(editor, item)) {\n            // Check if the image element still has upload id.\n            const uploadId = imageElement.getAttribute('uploadId');\n\n            if (!uploadId) {\n              continue;\n            } // Check if the image is loaded on this client.\n\n\n            const loader = fileRepository.loaders.get(uploadId);\n\n            if (!loader) {\n              continue;\n            }\n\n            if (isInsertedInGraveyard) {\n              // If the image was inserted to the graveyard for good (**not** replaced by another image),\n              // only then abort the loading process.\n              if (!insertedImagesIds.has(uploadId)) {\n                loader.abort();\n              }\n            } else {\n              // Remember the upload id of the inserted image. If it acted as a replacement for another\n              // image (which landed in the $graveyard), the related loader will not be aborted because\n              // this is still the same image upload.\n              insertedImagesIds.add(uploadId); // Keep the mapping between the upload ID and the image model element so the upload\n              // can later resolve in the context of the correct model element. The model element could\n              // change for the same upload if one image was replaced by another (e.g. image type was changed),\n              // so this may also replace an existing mapping.\n\n              this._uploadImageElements.set(uploadId, imageElement);\n\n              if (loader.status == 'idle') {\n                // If the image was inserted into content and has not been loaded yet, start loading it.\n                this._readAndUpload(loader);\n              }\n            }\n          }\n        }\n      }\n    }); // Set the default handler for feeding the image element with `src` and `srcset` attributes.\n\n    this.on('uploadComplete', (evt, _ref) => {\n      let {\n        imageElement,\n        data\n      } = _ref;\n      const urls = data.urls ? data.urls : data;\n      this.editor.model.change(writer => {\n        writer.setAttribute('src', urls.default, imageElement);\n\n        this._parseAndSetSrcsetAttributeOnImage(urls, imageElement, writer);\n      });\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  afterInit() {\n    const schema = this.editor.model.schema; // Setup schema to allow uploadId and uploadStatus for images.\n    // Wait for ImageBlockEditing or ImageInlineEditing to register their elements first,\n    // that's why doing this in afterInit() instead of init().\n\n    if (this.editor.plugins.has('ImageBlockEditing')) {\n      schema.extend('imageBlock', {\n        allowAttributes: ['uploadId', 'uploadStatus']\n      });\n    }\n\n    if (this.editor.plugins.has('ImageInlineEditing')) {\n      schema.extend('imageInline', {\n        allowAttributes: ['uploadId', 'uploadStatus']\n      });\n    }\n  }\n  /**\n   * Reads and uploads an image.\n   *\n   * The image is read from the disk and as a Base64-encoded string it is set temporarily to\n   * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target\n   * image's URL (the URL to the uploaded image on the server).\n   *\n   * @protected\n   * @param {module:upload/filerepository~FileLoader} loader\n   * @returns {Promise}\n   */\n\n\n  _readAndUpload(loader) {\n    const editor = this.editor;\n    const model = editor.model;\n    const t = editor.locale.t;\n    const fileRepository = editor.plugins.get(FileRepository);\n    const notification = editor.plugins.get(Notification);\n    const imageUtils = editor.plugins.get('ImageUtils');\n    const imageUploadElements = this._uploadImageElements;\n    model.enqueueChange('transparent', writer => {\n      writer.setAttribute('uploadStatus', 'reading', imageUploadElements.get(loader.id));\n    });\n    return loader.read().then(() => {\n      const promise = loader.upload();\n      const imageElement = imageUploadElements.get(loader.id); // Force re–paint in Safari. Without it, the image will display with a wrong size.\n      // https://github.com/ckeditor/ckeditor5/issues/1975\n\n      /* istanbul ignore next */\n\n      if (env.isSafari) {\n        const viewFigure = editor.editing.mapper.toViewElement(imageElement);\n        const viewImg = imageUtils.findViewImgElement(viewFigure);\n        editor.editing.view.once('render', () => {\n          // Early returns just to be safe. There might be some code ran\n          // in between the outer scope and this callback.\n          if (!viewImg.parent) {\n            return;\n          }\n\n          const domFigure = editor.editing.view.domConverter.mapViewToDom(viewImg.parent);\n\n          if (!domFigure) {\n            return;\n          }\n\n          const originalDisplay = domFigure.style.display;\n          domFigure.style.display = 'none'; // Make sure this line will never be removed during minification for having \"no effect\".\n\n          domFigure._ckHack = domFigure.offsetHeight;\n          domFigure.style.display = originalDisplay;\n        });\n      }\n\n      model.enqueueChange('transparent', writer => {\n        writer.setAttribute('uploadStatus', 'uploading', imageElement);\n      });\n      return promise;\n    }).then(data => {\n      model.enqueueChange('transparent', writer => {\n        const imageElement = imageUploadElements.get(loader.id);\n        writer.setAttribute('uploadStatus', 'complete', imageElement);\n        /**\n         * An event fired when an image is uploaded. You can hook into this event to provide\n         * custom attributes to the {@link module:engine/model/element~Element image element} based on the data from\n         * the server.\n         *\n         * \t\tconst imageUploadEditing = editor.plugins.get( 'ImageUploadEditing' );\n         *\n         * \t\timageUploadEditing.on( 'uploadComplete', ( evt, { data, imageElement } ) => {\n         * \t\t\teditor.model.change( writer => {\n         * \t\t\t\twriter.setAttribute( 'someAttribute', 'foo', imageElement );\n         * \t\t\t} );\n         * \t\t} );\n         *\n         * You can also stop the default handler that sets the `src` and `srcset` attributes\n         * if you want to provide custom values for these attributes.\n         *\n         * \t\timageUploadEditing.on( 'uploadComplete', ( evt, { data, imageElement } ) => {\n         * \t\t\tevt.stop();\n         * \t\t} );\n         *\n         * **Note**: This event is fired by the {@link module:image/imageupload/imageuploadediting~ImageUploadEditing} plugin.\n         *\n         * @event uploadComplete\n         * @param {Object} data The `uploadComplete` event data.\n         * @param {Object} data.data The data coming from the upload adapter.\n         * @param {module:engine/model/element~Element} data.imageElement The\n         * model {@link module:engine/model/element~Element image element} that can be customized.\n         */\n\n        this.fire('uploadComplete', {\n          data,\n          imageElement\n        });\n      });\n      clean();\n    }).catch(error => {\n      // If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,\n      // it might be generic error and it would be real pain to find what is going on.\n      if (loader.status !== 'error' && loader.status !== 'aborted') {\n        throw error;\n      } // Might be 'aborted'.\n\n\n      if (loader.status == 'error' && error) {\n        notification.showWarning(error, {\n          title: t('Upload failed'),\n          namespace: 'upload'\n        });\n      } // Permanently remove image from insertion batch.\n\n\n      model.enqueueChange('transparent', writer => {\n        writer.remove(imageUploadElements.get(loader.id));\n      });\n      clean();\n    });\n\n    function clean() {\n      model.enqueueChange('transparent', writer => {\n        const imageElement = imageUploadElements.get(loader.id);\n        writer.removeAttribute('uploadId', imageElement);\n        writer.removeAttribute('uploadStatus', imageElement);\n        imageUploadElements.delete(loader.id);\n      });\n      fileRepository.destroyLoader(loader);\n    }\n  }\n  /**\n   * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.\n   *\n   * @protected\n   * @param {Object} data Data object from which `srcset` will be created.\n   * @param {module:engine/model/element~Element} image The image element on which the `srcset` attribute will be set.\n   * @param {module:engine/model/writer~Writer} writer\n   */\n\n\n  _parseAndSetSrcsetAttributeOnImage(data, image, writer) {\n    // Srcset attribute for responsive images support.\n    let maxWidth = 0;\n    const srcsetAttribute = Object.keys(data) // Filter out keys that are not integers.\n    .filter(key => {\n      const width = parseInt(key, 10);\n\n      if (!isNaN(width)) {\n        maxWidth = Math.max(maxWidth, width);\n        return true;\n      }\n    }) // Convert each key to srcset entry.\n    .map(key => `${data[key]} ${key}w`) // Join all entries.\n    .join(', ');\n\n    if (srcsetAttribute != '') {\n      writer.setAttribute('srcset', {\n        data: srcsetAttribute,\n        width: maxWidth\n      }, image);\n    }\n  }\n\n} // Returns `true` if non-empty `text/html` is included in the data transfer.\n//\n// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer\n// @returns {Boolean}\n\nexport function isHtmlIncluded(dataTransfer) {\n  return Array.from(dataTransfer.types).includes('text/html') && dataTransfer.getData('text/html') !== '';\n}\n\nfunction getImagesFromChangeItem(editor, item) {\n  const imageUtils = editor.plugins.get('ImageUtils');\n  return Array.from(editor.model.createRangeOn(item)).filter(value => imageUtils.isImage(value.item)).map(value => value.item);\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadediting.js"],"names":["Plugin","UpcastWriter","Notification","ClipboardPipeline","FileRepository","env","ImageUtils","UploadImageCommand","fetchLocalImage","isLocalImage","createImageTypeRegExp","ImageUploadEditing","requires","pluginName","constructor","editor","config","define","upload","types","_uploadImageElements","Map","init","doc","model","document","conversion","fileRepository","plugins","get","imageUtils","imageTypes","uploadImageCommand","commands","add","for","attributeToAttribute","view","name","key","listenTo","editing","evt","data","isHtmlIncluded","dataTransfer","images","Array","from","files","filter","file","test","type","length","stop","change","writer","targetRanges","setSelection","map","viewRange","mapper","toModelRange","enqueueChange","execute","fetchableImages","createRangeIn","content","value","item","getAttribute","promise","imageElement","fetchableImage","setAttribute","loader","createLoader","id","on","preventDefault","changes","differ","getChanges","includeChangesInGraveyard","reverse","insertedImagesIds","Set","entry","position","nodeAfter","isInsertedInGraveyard","root","rootName","getImagesFromChangeItem","uploadId","loaders","has","abort","set","status","_readAndUpload","urls","default","_parseAndSetSrcsetAttributeOnImage","priority","afterInit","schema","extend","allowAttributes","t","locale","notification","imageUploadElements","read","then","isSafari","viewFigure","toViewElement","viewImg","findViewImgElement","once","parent","domFigure","domConverter","mapViewToDom","originalDisplay","style","display","_ckHack","offsetHeight","fire","clean","catch","error","showWarning","title","namespace","remove","removeAttribute","delete","destroyLoader","image","maxWidth","srcsetAttribute","Object","keys","width","parseInt","isNaN","Math","max","join","includes","getData","createRangeOn","isImage"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/imageuploadediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\n\nimport { UpcastWriter } from 'ckeditor5/src/engine';\n\nimport { Notification } from 'ckeditor5/src/ui';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { FileRepository } from 'ckeditor5/src/upload';\nimport { env } from 'ckeditor5/src/utils';\n\nimport ImageUtils from '../imageutils';\nimport UploadImageCommand from './uploadimagecommand';\nimport { fetchLocalImage, isLocalImage } from '../../src/imageupload/utils';\nimport { createImageTypeRegExp } from './utils';\n\n/**\n * The editing part of the image upload feature. It registers the `'uploadImage'` command\n * and the `imageUpload` command as an aliased name.\n *\n * When an image is uploaded, it fires the {@link ~ImageUploadEditing#event:uploadComplete `uploadComplete`} event\n * that allows adding custom attributes to the {@link module:engine/model/element~Element image element}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUploadEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ FileRepository, Notification, ClipboardPipeline, ImageUtils ];\n\t}\n\n\tstatic get pluginName() {\n\t\treturn 'ImageUploadEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\teditor.config.define( 'image', {\n\t\t\tupload: {\n\t\t\t\ttypes: [ 'jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff' ]\n\t\t\t}\n\t\t} );\n\n\t\t/**\n\t\t * An internal mapping of {@link module:upload/filerepository~FileLoader#id file loader UIDs} and\n\t\t * model elements during the upload.\n\t\t *\n\t\t * Model element of the uploaded image can change, for instance, when {@link module:image/image/imagetypecommand~ImageTypeCommand}\n\t\t * is executed as a result of adding caption or changing image style. As a result, the upload logic must keep track of the model\n\t\t * element (reference) and resolve the upload for the correct model element (instead of the one that landed in the `$graveyard`\n\t\t * after image type changed).\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @member {Map.<String,module:engine/model/element~Element>}\n\t\t */\n\t\tthis._uploadImageElements = new Map();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst doc = editor.model.document;\n\t\tconst conversion = editor.conversion;\n\t\tconst fileRepository = editor.plugins.get( FileRepository );\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t\tconst imageTypes = createImageTypeRegExp( editor.config.get( 'image.upload.types' ) );\n\t\tconst uploadImageCommand = new UploadImageCommand( editor );\n\n\t\t// Register `uploadImage` command and add `imageUpload` command as an alias for backward compatibility.\n\t\teditor.commands.add( 'uploadImage', uploadImageCommand );\n\t\teditor.commands.add( 'imageUpload', uploadImageCommand );\n\n\t\t// Register upcast converter for uploadId.\n\t\tconversion.for( 'upcast' )\n\t\t\t.attributeToAttribute( {\n\t\t\t\tview: {\n\t\t\t\t\tname: 'img',\n\t\t\t\t\tkey: 'uploadId'\n\t\t\t\t},\n\t\t\t\tmodel: 'uploadId'\n\t\t\t} );\n\n\t\t// Handle pasted images.\n\t\t// For every image file, a new file loader is created and a placeholder image is\n\t\t// inserted into the content. Then, those images are uploaded once they appear in the model\n\t\t// (see Document#change listener below).\n\t\tthis.listenTo( editor.editing.view.document, 'clipboardInput', ( evt, data ) => {\n\t\t\t// Skip if non empty HTML data is included.\n\t\t\t// https://github.com/ckeditor/ckeditor5-upload/issues/68\n\t\t\tif ( isHtmlIncluded( data.dataTransfer ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst images = Array.from( data.dataTransfer.files ).filter( file => {\n\t\t\t\t// See https://github.com/ckeditor/ckeditor5-image/pull/254.\n\t\t\t\tif ( !file ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn imageTypes.test( file.type );\n\t\t\t} );\n\n\t\t\tif ( !images.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevt.stop();\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\t// Set selection to paste target.\n\t\t\t\tif ( data.targetRanges ) {\n\t\t\t\t\twriter.setSelection( data.targetRanges.map( viewRange => editor.editing.mapper.toModelRange( viewRange ) ) );\n\t\t\t\t}\n\n\t\t\t\t// Upload images after the selection has changed in order to ensure the command's state is refreshed.\n\t\t\t\teditor.model.enqueueChange( 'default', () => {\n\t\t\t\t\teditor.execute( 'uploadImage', { file: images } );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\n\t\t// Handle HTML pasted with images with base64 or blob sources.\n\t\t// For every image file, a new file loader is created and a placeholder image is\n\t\t// inserted into the content. Then, those images are uploaded once they appear in the model\n\t\t// (see Document#change listener below).\n\t\tthis.listenTo( editor.plugins.get( 'ClipboardPipeline' ), 'inputTransformation', ( evt, data ) => {\n\t\t\tconst fetchableImages = Array.from( editor.editing.view.createRangeIn( data.content ) )\n\t\t\t\t.filter( value => isLocalImage( imageUtils, value.item ) && !value.item.getAttribute( 'uploadProcessed' ) )\n\t\t\t\t.map( value => { return { promise: fetchLocalImage( value.item ), imageElement: value.item }; } );\n\n\t\t\tif ( !fetchableImages.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst writer = new UpcastWriter( editor.editing.view.document );\n\n\t\t\tfor ( const fetchableImage of fetchableImages ) {\n\t\t\t\t// Set attribute marking that the image was processed already.\n\t\t\t\twriter.setAttribute( 'uploadProcessed', true, fetchableImage.imageElement );\n\n\t\t\t\tconst loader = fileRepository.createLoader( fetchableImage.promise );\n\n\t\t\t\tif ( loader ) {\n\t\t\t\t\twriter.setAttribute( 'src', '', fetchableImage.imageElement );\n\t\t\t\t\twriter.setAttribute( 'uploadId', loader.id, fetchableImage.imageElement );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Prevents from the browser redirecting to the dropped image.\n\t\teditor.editing.view.document.on( 'dragover', ( evt, data ) => {\n\t\t\tdata.preventDefault();\n\t\t} );\n\n\t\t// Upload placeholder images that appeared in the model.\n\t\tdoc.on( 'change', () => {\n\t\t\t// Note: Reversing changes to start with insertions and only then handle removals. If it was the other way around,\n\t\t\t// loaders for **all** images that land in the $graveyard would abort while in fact only those that were **not** replaced\n\t\t\t// by other images should be aborted.\n\t\t\tconst changes = doc.differ.getChanges( { includeChangesInGraveyard: true } ).reverse();\n\t\t\tconst insertedImagesIds = new Set();\n\n\t\t\tfor ( const entry of changes ) {\n\t\t\t\tif ( entry.type == 'insert' && entry.name != '$text' ) {\n\t\t\t\t\tconst item = entry.position.nodeAfter;\n\t\t\t\t\tconst isInsertedInGraveyard = entry.position.root.rootName == '$graveyard';\n\n\t\t\t\t\tfor ( const imageElement of getImagesFromChangeItem( editor, item ) ) {\n\t\t\t\t\t\t// Check if the image element still has upload id.\n\t\t\t\t\t\tconst uploadId = imageElement.getAttribute( 'uploadId' );\n\n\t\t\t\t\t\tif ( !uploadId ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check if the image is loaded on this client.\n\t\t\t\t\t\tconst loader = fileRepository.loaders.get( uploadId );\n\n\t\t\t\t\t\tif ( !loader ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isInsertedInGraveyard ) {\n\t\t\t\t\t\t\t// If the image was inserted to the graveyard for good (**not** replaced by another image),\n\t\t\t\t\t\t\t// only then abort the loading process.\n\t\t\t\t\t\t\tif ( !insertedImagesIds.has( uploadId ) ) {\n\t\t\t\t\t\t\t\tloader.abort();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remember the upload id of the inserted image. If it acted as a replacement for another\n\t\t\t\t\t\t\t// image (which landed in the $graveyard), the related loader will not be aborted because\n\t\t\t\t\t\t\t// this is still the same image upload.\n\t\t\t\t\t\t\tinsertedImagesIds.add( uploadId );\n\n\t\t\t\t\t\t\t// Keep the mapping between the upload ID and the image model element so the upload\n\t\t\t\t\t\t\t// can later resolve in the context of the correct model element. The model element could\n\t\t\t\t\t\t\t// change for the same upload if one image was replaced by another (e.g. image type was changed),\n\t\t\t\t\t\t\t// so this may also replace an existing mapping.\n\t\t\t\t\t\t\tthis._uploadImageElements.set( uploadId, imageElement );\n\n\t\t\t\t\t\t\tif ( loader.status == 'idle' ) {\n\t\t\t\t\t\t\t\t// If the image was inserted into content and has not been loaded yet, start loading it.\n\t\t\t\t\t\t\t\tthis._readAndUpload( loader );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Set the default handler for feeding the image element with `src` and `srcset` attributes.\n\t\tthis.on( 'uploadComplete', ( evt, { imageElement, data } ) => {\n\t\t\tconst urls = data.urls ? data.urls : data;\n\n\t\t\tthis.editor.model.change( writer => {\n\t\t\t\twriter.setAttribute( 'src', urls.default, imageElement );\n\t\t\t\tthis._parseAndSetSrcsetAttributeOnImage( urls, imageElement, writer );\n\t\t\t} );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tafterInit() {\n\t\tconst schema = this.editor.model.schema;\n\n\t\t// Setup schema to allow uploadId and uploadStatus for images.\n\t\t// Wait for ImageBlockEditing or ImageInlineEditing to register their elements first,\n\t\t// that's why doing this in afterInit() instead of init().\n\t\tif ( this.editor.plugins.has( 'ImageBlockEditing' ) ) {\n\t\t\tschema.extend( 'imageBlock', {\n\t\t\t\tallowAttributes: [ 'uploadId', 'uploadStatus' ]\n\t\t\t} );\n\t\t}\n\n\t\tif ( this.editor.plugins.has( 'ImageInlineEditing' ) ) {\n\t\t\tschema.extend( 'imageInline', {\n\t\t\t\tallowAttributes: [ 'uploadId', 'uploadStatus' ]\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Reads and uploads an image.\n\t *\n\t * The image is read from the disk and as a Base64-encoded string it is set temporarily to\n\t * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target\n\t * image's URL (the URL to the uploaded image on the server).\n\t *\n\t * @protected\n\t * @param {module:upload/filerepository~FileLoader} loader\n\t * @returns {Promise}\n\t */\n\t_readAndUpload( loader ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst t = editor.locale.t;\n\t\tconst fileRepository = editor.plugins.get( FileRepository );\n\t\tconst notification = editor.plugins.get( Notification );\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t\tconst imageUploadElements = this._uploadImageElements;\n\n\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\twriter.setAttribute( 'uploadStatus', 'reading', imageUploadElements.get( loader.id ) );\n\t\t} );\n\n\t\treturn loader.read()\n\t\t\t.then( () => {\n\t\t\t\tconst promise = loader.upload();\n\t\t\t\tconst imageElement = imageUploadElements.get( loader.id );\n\n\t\t\t\t// Force re–paint in Safari. Without it, the image will display with a wrong size.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5/issues/1975\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif ( env.isSafari ) {\n\t\t\t\t\tconst viewFigure = editor.editing.mapper.toViewElement( imageElement );\n\t\t\t\t\tconst viewImg = imageUtils.findViewImgElement( viewFigure );\n\n\t\t\t\t\teditor.editing.view.once( 'render', () => {\n\t\t\t\t\t\t// Early returns just to be safe. There might be some code ran\n\t\t\t\t\t\t// in between the outer scope and this callback.\n\t\t\t\t\t\tif ( !viewImg.parent ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst domFigure = editor.editing.view.domConverter.mapViewToDom( viewImg.parent );\n\n\t\t\t\t\t\tif ( !domFigure ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst originalDisplay = domFigure.style.display;\n\n\t\t\t\t\t\tdomFigure.style.display = 'none';\n\n\t\t\t\t\t\t// Make sure this line will never be removed during minification for having \"no effect\".\n\t\t\t\t\t\tdomFigure._ckHack = domFigure.offsetHeight;\n\n\t\t\t\t\t\tdomFigure.style.display = originalDisplay;\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\t\twriter.setAttribute( 'uploadStatus', 'uploading', imageElement );\n\t\t\t\t} );\n\n\t\t\t\treturn promise;\n\t\t\t} )\n\t\t\t.then( data => {\n\t\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\t\tconst imageElement = imageUploadElements.get( loader.id );\n\n\t\t\t\t\twriter.setAttribute( 'uploadStatus', 'complete', imageElement );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * An event fired when an image is uploaded. You can hook into this event to provide\n\t\t\t\t\t * custom attributes to the {@link module:engine/model/element~Element image element} based on the data from\n\t\t\t\t\t * the server.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\tconst imageUploadEditing = editor.plugins.get( 'ImageUploadEditing' );\n\t\t\t\t\t *\n\t\t\t\t\t * \t\timageUploadEditing.on( 'uploadComplete', ( evt, { data, imageElement } ) => {\n\t\t\t\t\t * \t\t\teditor.model.change( writer => {\n\t\t\t\t\t * \t\t\t\twriter.setAttribute( 'someAttribute', 'foo', imageElement );\n\t\t\t\t\t * \t\t\t} );\n\t\t\t\t\t * \t\t} );\n\t\t\t\t\t *\n\t\t\t\t\t * You can also stop the default handler that sets the `src` and `srcset` attributes\n\t\t\t\t\t * if you want to provide custom values for these attributes.\n\t\t\t\t\t *\n\t\t\t\t\t * \t\timageUploadEditing.on( 'uploadComplete', ( evt, { data, imageElement } ) => {\n\t\t\t\t\t * \t\t\tevt.stop();\n\t\t\t\t\t * \t\t} );\n\t\t\t\t\t *\n\t\t\t\t\t * **Note**: This event is fired by the {@link module:image/imageupload/imageuploadediting~ImageUploadEditing} plugin.\n\t\t\t\t\t *\n\t\t\t\t\t * @event uploadComplete\n\t\t\t\t\t * @param {Object} data The `uploadComplete` event data.\n\t\t\t\t\t * @param {Object} data.data The data coming from the upload adapter.\n\t\t\t\t\t * @param {module:engine/model/element~Element} data.imageElement The\n\t\t\t\t\t * model {@link module:engine/model/element~Element image element} that can be customized.\n\t\t\t\t\t */\n\t\t\t\t\tthis.fire( 'uploadComplete', { data, imageElement } );\n\t\t\t\t} );\n\n\t\t\t\tclean();\n\t\t\t} )\n\t\t\t.catch( error => {\n\t\t\t\t// If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,\n\t\t\t\t// it might be generic error and it would be real pain to find what is going on.\n\t\t\t\tif ( loader.status !== 'error' && loader.status !== 'aborted' ) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Might be 'aborted'.\n\t\t\t\tif ( loader.status == 'error' && error ) {\n\t\t\t\t\tnotification.showWarning( error, {\n\t\t\t\t\t\ttitle: t( 'Upload failed' ),\n\t\t\t\t\t\tnamespace: 'upload'\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\t// Permanently remove image from insertion batch.\n\t\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\t\twriter.remove( imageUploadElements.get( loader.id ) );\n\t\t\t\t} );\n\n\t\t\t\tclean();\n\t\t\t} );\n\n\t\tfunction clean() {\n\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\tconst imageElement = imageUploadElements.get( loader.id );\n\n\t\t\t\twriter.removeAttribute( 'uploadId', imageElement );\n\t\t\t\twriter.removeAttribute( 'uploadStatus', imageElement );\n\n\t\t\t\timageUploadElements.delete( loader.id );\n\t\t\t} );\n\n\t\t\tfileRepository.destroyLoader( loader );\n\t\t}\n\t}\n\n\t/**\n\t * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.\n\t *\n\t * @protected\n\t * @param {Object} data Data object from which `srcset` will be created.\n\t * @param {module:engine/model/element~Element} image The image element on which the `srcset` attribute will be set.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\t_parseAndSetSrcsetAttributeOnImage( data, image, writer ) {\n\t\t// Srcset attribute for responsive images support.\n\t\tlet maxWidth = 0;\n\n\t\tconst srcsetAttribute = Object.keys( data )\n\t\t\t// Filter out keys that are not integers.\n\t\t\t.filter( key => {\n\t\t\t\tconst width = parseInt( key, 10 );\n\n\t\t\t\tif ( !isNaN( width ) ) {\n\t\t\t\t\tmaxWidth = Math.max( maxWidth, width );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// Convert each key to srcset entry.\n\t\t\t.map( key => `${ data[ key ] } ${ key }w` )\n\n\t\t\t// Join all entries.\n\t\t\t.join( ', ' );\n\n\t\tif ( srcsetAttribute != '' ) {\n\t\t\twriter.setAttribute( 'srcset', {\n\t\t\t\tdata: srcsetAttribute,\n\t\t\t\twidth: maxWidth\n\t\t\t}, image );\n\t\t}\n\t}\n}\n\n// Returns `true` if non-empty `text/html` is included in the data transfer.\n//\n// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer\n// @returns {Boolean}\nexport function isHtmlIncluded( dataTransfer ) {\n\treturn Array.from( dataTransfer.types ).includes( 'text/html' ) && dataTransfer.getData( 'text/html' ) !== '';\n}\n\nfunction getImagesFromChangeItem( editor, item ) {\n\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\treturn Array.from( editor.model.createRangeOn( item ) )\n\t\t.filter( value => imageUtils.isImage( value.item ) )\n\t\t.map( value => value.item );\n}\n"]},"metadata":{},"sourceType":"module"}