{"ast":null,"code":"/* eslint-disable max-len */\nimport { isNullOrUndefined, getDefaultDateObject, getValue, cldrData } from '@syncfusion/ej2-base';\nimport { MS_PER_DAY, addDays, resetTime, capitalizeFirstWord } from '../schedule/base/util';\nimport { Islamic, Gregorian } from '../common/calendar-util';\nimport { Timezone } from '../schedule/timezone/timezone';\n/**\r\n * Date Generator from Recurrence Rule\r\n */\n\n/**\r\n * Generate Summary from Recurrence Rule\r\n *\r\n * @param {string} rule Accepts the Recurrence rule\r\n * @param {L10n} localeObject Accepts the locale object\r\n * @param {string} locale Accepts the locale name\r\n * @param {CalendarType} calendarType Accepts the calendar type\r\n * @returns {string} Returns the summary string from given recurrence rule\r\n */\n\nexport function generateSummary(rule, localeObject, locale, calendarType) {\n  if (calendarType === void 0) {\n    calendarType = 'Gregorian';\n  }\n\n  var ruleObject = extractObjectFromRule(rule);\n  var summary = localeObject.getConstant(EVERY) + ' ';\n  var cldrObj;\n  var cldrObj1;\n  var calendarMode = calendarType.toLowerCase();\n\n  if (locale === 'en' || locale === 'en-US') {\n    var nameSpace1 = 'months.stand-alone.abbreviated';\n    var nameSpace = 'days.stand-alone.abbreviated';\n    cldrObj1 = getValue(nameSpace1, getDefaultDateObject(calendarMode));\n    cldrObj = getValue(nameSpace, getDefaultDateObject(calendarMode));\n  } else {\n    var nameSpace1 = 'main.' + locale + '.dates.calendars.' + calendarMode + '.months.stand-alone.abbreviated';\n    var nameSpace = 'main.' + locale + '.dates.calendars.' + calendarMode + '.days.stand-alone.abbreviated';\n    cldrObj1 = getValue(nameSpace1, cldrData);\n    cldrObj = getValue(nameSpace, cldrData);\n  }\n\n  if (ruleObject.interval > 1) {\n    summary += ruleObject.interval + ' ';\n  }\n\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      summary += localeObject.getConstant(DAYS);\n      break;\n\n    case 'WEEKLY':\n      summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';\n      ruleObject.day.forEach(function (day, index) {\n        summary += capitalizeFirstWord(getValue(DAYINDEXOBJECT[day], cldrObj), 'single');\n        summary += ruleObject.day.length - 1 === index ? '' : ', ';\n      });\n      break;\n\n    case 'MONTHLY':\n      summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n\n    case 'YEARLY':\n      summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += capitalizeFirstWord(getValue(ruleObject.month[0].toString(), cldrObj1), 'single') + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n  }\n\n  if (ruleObject.count) {\n    summary += ', ' + ruleObject.count + ' ' + localeObject.getConstant(TIMES);\n  } else if (ruleObject.until) {\n    var tempDate = ruleObject.until;\n    summary += ', ' + localeObject.getConstant(UNTIL) + ' ' + tempDate.getDate() + ' ' + capitalizeFirstWord(getValue((tempDate.getMonth() + 1).toString(), cldrObj1), 'single') + ' ' + tempDate.getFullYear();\n  }\n\n  return summary;\n}\n/**\r\n * Generates Month summary\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {string[]} cldrObj Accepts the collections of month name from calendar\r\n * @param {L10n} localeObj Accepts the locale object\r\n * @returns {string} Returns the month summary string from given recurrence rule object\r\n * @private\r\n */\n\nfunction getMonthSummary(ruleObject, cldrObj, localeObj) {\n  var summary = '';\n\n  if (ruleObject.monthDay.length) {\n    summary += ruleObject.monthDay[0];\n  } else if (ruleObject.day) {\n    var pos = ruleObject.setPosition - 1;\n    summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : WEEKPOS.length - 1]) + ' ' + capitalizeFirstWord(getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj), 'single');\n  }\n\n  return summary;\n}\n/**\r\n * Generates the date collections from the given recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the rule start date\r\n * @param {string} rule Accepts the recurrence rule\r\n * @param {string} excludeDate Accepts the exception dates in string format\r\n * @param {number} startDayOfWeek Accepts the start day index of week\r\n * @param {number} maximumCount Accepts the maximum number count to generate date collections\r\n * @param {Date} viewDate Accepts the current date instead of start date\r\n * @param {CalendarType} calendarMode Accepts the calendar type\r\n * @param {string} oldTimezone Accepts the timezone name\r\n * @param {string} newTimezone Accepts the timezone name\r\n * @returns {number[]} Returns the collection of dates\r\n */\n\n\nexport function generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount, viewDate, calendarMode, oldTimezone, newTimezone) {\n  if (maximumCount === void 0) {\n    maximumCount = MAXOCCURRENCE;\n  }\n\n  if (viewDate === void 0) {\n    viewDate = null;\n  }\n\n  if (calendarMode === void 0) {\n    calendarMode = 'Gregorian';\n  }\n\n  if (oldTimezone === void 0) {\n    oldTimezone = null;\n  }\n\n  if (newTimezone === void 0) {\n    newTimezone = null;\n  }\n\n  var ruleObject = extractObjectFromRule(rule);\n  var cacheDate;\n  calendarUtil = getCalendarUtil(calendarMode);\n  var data = [];\n  var modifiedDate = new Date(startDate.getTime());\n  tempExcludeDate = [];\n  var tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');\n  var tz = new Timezone();\n  tempDate.forEach(function (content) {\n    var parsedDate = getDateFromRecurrenceDateString(content);\n\n    if (oldTimezone && newTimezone) {\n      parsedDate = tz.convert(new Date(parsedDate.getTime()), oldTimezone, newTimezone);\n    }\n\n    tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));\n  });\n  ruleObject.recExceptionCount = !isNullOrUndefined(ruleObject.count) ? tempExcludeDate.length : 0;\n\n  if (viewDate && viewDate > startDate && !ruleObject.count) {\n    tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));\n  } else {\n    tempViewDate = null;\n  }\n\n  if (!ruleObject.until && tempViewDate) {\n    cacheDate = new Date(tempViewDate.getTime());\n    cacheDate.setDate(tempViewDate.getDate() + maximumCount * ruleObject.interval);\n    ruleObject.until = cacheDate;\n  }\n\n  if (ruleObject.until && startDate > ruleObject.until) {\n    return data;\n  }\n\n  maxOccurrence = maximumCount;\n  setFirstDayOfWeek(DAYINDEX[startDayOfWeek]);\n\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      dailyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'WEEKLY':\n      weeklyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'MONTHLY':\n      monthlyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n\n    case 'YEARLY':\n      yearlyType(modifiedDate, ruleObject.until, data, ruleObject);\n  }\n\n  return data;\n}\n/**\r\n * Generate date object from given date string\r\n *\r\n * @param {string} recDateString Accepts the exception date as string\r\n * @returns {Date} Returns the date from exception date string\r\n */\n\nexport function getDateFromRecurrenceDateString(recDateString) {\n  return new Date(recDateString.substr(0, 4) + '-' + recDateString.substr(4, 2) + '-' + recDateString.substr(6, 5) + ':' + recDateString.substr(11, 2) + ':' + recDateString.substr(13));\n}\n/**\r\n * Internal method to handle exclude date\r\n *\r\n * @param {number[]} data Accepts the exception date collections\r\n * @param {number} date Accepts the new exclude date\r\n * @returns {void}\r\n * @private\r\n */\n\nfunction excludeDateHandler(data, date) {\n  var zeroIndex = new Date(date).setHours(0, 0, 0, 0);\n\n  if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {\n    data.push(date);\n  }\n}\n/**\r\n * Internal method for get date count\r\n *\r\n * @param {Date} startDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} Returns the number of date count\r\n * @private\r\n */\n\n\nfunction getDateCount(startDate, ruleObject) {\n  var count = maxOccurrence;\n\n  if (ruleObject.count) {\n    count = ruleObject.count;\n  } else if (ruleObject.until) {\n    if (ruleObject.freq === 'DAILY' || ruleObject.freq === 'WEEKLY') {\n      count = Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1;\n    } else if (ruleObject.freq === 'MONTHLY' || ruleObject.freq === 'YEARLY') {\n      count = Math.floor((ruleObject.until.getMonth() + 12 * ruleObject.until.getFullYear() - (startDate.getMonth() + 12 * startDate.getFullYear())) / ruleObject.interval) + (ruleObject.day.length > 1 ? Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1 : 1);\n\n      if (ruleObject.freq === 'YEARLY') {\n        count = ruleObject.month.length > 1 ? count * ruleObject.month.length : count;\n      }\n    }\n  }\n\n  return count;\n}\n/**\r\n *  Internal method for daily type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction dailyType(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n  var interval = ruleObject.interval;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var expectedDays = ruleObject.day;\n\n  while (compareDates(tempDate, endDate)) {\n    state = true;\n    state = validateRules(tempDate, ruleObject);\n\n    if (state && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1 || expectedDays.length === 0)) {\n      excludeDateHandler(data, tempDate.getTime());\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n    }\n\n    tempDate.setDate(tempDate.getDate() + interval);\n  }\n}\n/**\r\n * Internal method for weekly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction weeklyType(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n\n  if (!ruleObject.day.length) {\n    ruleObject.day.push(DAYINDEX[startDate.getDay()]);\n  }\n\n  var interval = ruleObject.interval;\n  var expectedDays = ruleObject.day;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var weekState = true;\n  var wkstIndex;\n  var weekCollection = [];\n\n  if (expectedDays.length > 1) {\n    if (isNullOrUndefined(ruleObject.wkst) || ruleObject.wkst === '') {\n      ruleObject.wkst = dayIndex[0];\n    }\n\n    wkstIndex = DAYINDEX.indexOf(ruleObject.wkst);\n\n    while (compareDates(tempDate, endDate)) {\n      var startDateDiff = DAYINDEX.indexOf(DAYINDEX[tempDate.getDay()]) - wkstIndex;\n      startDateDiff = startDateDiff === -1 ? 6 : startDateDiff;\n      var weekstartDate = addDays(tempDate, -startDateDiff);\n      var weekendDate = addDays(weekstartDate, 6);\n      var compareTempDate = new Date(tempDate.getTime());\n      weekendDate = resetTime(weekendDate);\n      compareTempDate = resetTime(compareTempDate);\n\n      while (weekendDate >= compareTempDate) {\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          weekCollection.push([tempDate.getTime()]);\n        }\n\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          break;\n        }\n\n        tempDate.setDate(tempDate.getDate() + 1);\n        compareTempDate = new Date(tempDate.getTime());\n        compareTempDate = resetTime(compareTempDate);\n      }\n\n      tempDate.setDate(tempDate.getDate() - 1);\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n\n      tempDate.setDate(tempDate.getDate() + 1 + (interval - 1) * 7);\n      insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n      weekCollection = [];\n    }\n  } else {\n    tempDate = getStartDateForWeek(startDate, ruleObject.day);\n\n    while (compareDates(tempDate, endDate)) {\n      weekState = validateRules(tempDate, ruleObject);\n\n      if (weekState && expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        excludeDateHandler(data, tempDate.getTime());\n      }\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n\n      tempDate.setDate(tempDate.getDate() + interval * 7);\n    }\n\n    insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n    weekCollection = [];\n  }\n}\n/**\r\n *  Internal method for monthly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction monthlyType(startDate, endDate, data, ruleObject) {\n  // Set monthday value if BYDAY, BYMONTH and Month day property is not set based on start date\n  if (!ruleObject.month.length && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n\n    if (ruleObject.freq === 'YEARLY') {\n      ruleObject.month.push(startDate.getMonth() + 1);\n    }\n  } else if (ruleObject.month.length > 0 && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n  }\n\n  var ruleType = validateMonthlyRuleType(ruleObject);\n\n  switch (ruleType) {\n    case 'day':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n\n        case 'YEARLY':\n          monthlyDayTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n\n      break;\n\n    case 'both':\n    case 'date':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n\n        case 'YEARLY':\n          monthlyDateTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n\n      break;\n  }\n}\n/**\r\n * Internal method for yearly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction yearlyType(startDate, endDate, data, ruleObject) {\n  var typeValue = checkYearlyType(ruleObject);\n\n  switch (typeValue) {\n    case 'MONTH':\n      monthlyType(startDate, endDate, data, ruleObject);\n      break;\n\n    case 'WEEKNO':\n      processWeekNo(startDate, endDate, data, ruleObject);\n      break;\n\n    case 'YEARDAY':\n      processYearDay(startDate, endDate, data, ruleObject);\n      break;\n  }\n}\n/**\r\n * Internal method for process week no\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction processWeekNo(startDate, endDate, data, ruleObject) {\n  var stDate = calendarUtil.getYearLastDate(startDate, 0);\n  var tempDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var startDay;\n  var firstWeekSpan;\n  var weekNos = ruleObject.weekNo;\n  var weekNo;\n  var maxDate;\n  var minDate;\n  var weekCollection = [];\n  var expectedDays = ruleObject.day;\n\n  while (compareDates(stDate, endDate)) {\n    startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);\n    firstWeekSpan = 6 - startDay + 1;\n\n    for (var index = 0; index < weekNos.length; index++) {\n      weekNo = weekNos[index];\n      weekNo = weekNo > 0 ? weekNo : 53 + weekNo + 1;\n      maxDate = weekNo === 1 ? firstWeekSpan : firstWeekSpan + (weekNo - 1) * 7;\n      minDate = weekNo === 1 ? firstWeekSpan - 7 : firstWeekSpan + (weekNo - 2) * 7;\n\n      while (minDate < maxDate) {\n        tempDate = new Date(stDate.getTime() + MS_PER_DAY * minDate);\n\n        if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n          } else {\n            weekCollection.push([tempDate.getTime()]);\n          }\n        }\n\n        minDate++;\n      }\n    }\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(weekCollection, state, startDate, endDate, data, ruleObject);\n    }\n\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    weekCollection = [];\n  }\n}\n/**\r\n * Internal method for process year day\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction processYearDay(startDate, endDate, data, ruleObject) {\n  var stDate = calendarUtil.getYearLastDate(startDate, 0);\n  var tempDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var dateCollection = [];\n  var date;\n  var expectedDays = ruleObject.day;\n\n  while (compareDates(stDate, endDate)) {\n    for (var index = 0; index < ruleObject.yearDay.length; index++) {\n      date = ruleObject.yearDay[index];\n      tempDate = new Date(stDate.getTime());\n\n      if ((date === calendarUtil.getLeapYearDaysCount() || date === -calendarUtil.getLeapYearDaysCount()) && !calendarUtil.isLeapYear(calendarUtil.getFullYear(tempDate), 1)) {\n        tempDate.setDate(tempDate.getDate() + 1);\n        continue;\n      }\n\n      tempDate.setDate(tempDate.getDate() + (date < 0 ? calendarUtil.getYearDaysCount(tempDate, 1) + 1 + date : date));\n\n      if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        if (ruleObject.setPosition == null) {\n          insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n        } else {\n          dateCollection.push([tempDate.getTime()]);\n        }\n      }\n    }\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject);\n    }\n\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    dateCollection = [];\n  }\n}\n/**\r\n * Internal method to check yearly type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {YearRuleType} Returns the Yearly rule type object\r\n * @private\r\n */\n\n\nfunction checkYearlyType(ruleObject) {\n  if (ruleObject.yearDay.length) {\n    return 'YEARDAY';\n  } else if (ruleObject.weekNo.length) {\n    return 'WEEKNO';\n  }\n\n  return 'MONTH';\n}\n/**\r\n * Internal method to initialize recurrence rule variables\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {RuleData} Return the rule data object\r\n * @private\r\n */\n\n\nfunction initializeRecRuleVariables(startDate, ruleObject) {\n  var ruleData = {\n    monthCollection: [],\n    index: 0,\n    tempDate: new Date(startDate.getTime()),\n    mainDate: new Date(startDate.getTime()),\n    expectedCount: getDateCount(startDate, ruleObject),\n    monthInit: 0,\n    dateCollection: []\n  };\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(ruleData.tempDate, ruleObject.month[0], ruleData.tempDate.getDate());\n  }\n\n  return ruleData;\n}\n/**\r\n * Internal method for process monthly date type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {\n  if (ruleObject.month.length) {\n    monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n\n  var ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  var currentMonthDate;\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n\n  while (compareDates(ruleData.tempDate, endDate)) {\n    currentMonthDate = new Date(ruleData.tempDate.getTime());\n\n    while (calendarUtil.isSameYear(currentMonthDate, ruleData.tempDate) && ruleData.expectedCount && data.length + ruleObject.recExceptionCount <= ruleData.expectedCount) {\n      if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(ruleData.tempDate, ruleObject.month)) {\n        processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, false);\n        ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n      } else {\n        calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n        ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n        break;\n      }\n    }\n\n    ruleData.tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\n    insertDataCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n\n    if (calendarUtil.isLastMonth(ruleData.tempDate)) {\n      calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n      ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    }\n\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n\n    ruleData.tempDate.setFullYear(ruleData.tempDate.getFullYear() + ruleObject.interval - 1);\n    ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n}\n/**\r\n * Internal method for process monthly date type with month frequency from recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  var ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n\n  if ((ruleObject.freq === 'MONTHLY' && ruleObject.interval === 12 || ruleObject.freq === 'YEARLY') && calendarUtil.getMonthDaysCount(startDate) < ruleObject.monthDay[0]) {\n    return;\n  }\n\n  while (compareDates(ruleData.tempDate, endDate)) {\n    ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n    processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, true, startDate, data);\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n    }\n\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n}\n/**\r\n * To process date collection for Monthly & Yearly based on BYMONTH Day property\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {RuleData} recRuleVariables Accepts the rule data\r\n * @param {Date} endDate Accepts the end date\r\n * @param {boolean} isByMonth Accepts the boolean to validate either month or not\r\n * @param {Date} startDate Accepts the start date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction processDateCollectionForByMonthDay(ruleObject, recRuleVariables, endDate, isByMonth, startDate, data) {\n  for (var index = 0; index < ruleObject.monthDay.length; index++) {\n    recRuleVariables.date = ruleObject.monthDay[index];\n    recRuleVariables.tempDate = calendarUtil.getMonthStartDate(recRuleVariables.tempDate);\n    var maxDate = calendarUtil.getMonthDaysCount(recRuleVariables.tempDate);\n    recRuleVariables.date = recRuleVariables.date > 0 ? recRuleVariables.date : maxDate + recRuleVariables.date + 1;\n\n    if (validateProperDate(recRuleVariables.tempDate, recRuleVariables.date, recRuleVariables.mainDate) && recRuleVariables.date > 0) {\n      calendarUtil.setDate(recRuleVariables.tempDate, recRuleVariables.date);\n\n      if (endDate && recRuleVariables.tempDate > endDate) {\n        return;\n      }\n\n      if (ruleObject.day.length === 0 || ruleObject.day.indexOf(DAYINDEX[recRuleVariables.tempDate.getDay()]) > -1) {\n        if (isByMonth && isNullOrUndefined(ruleObject.setPosition) && recRuleVariables.expectedCount && data.length + ruleObject.recExceptionCount < recRuleVariables.expectedCount) {\n          insertDateCollection(recRuleVariables.state, startDate, endDate, data, ruleObject, recRuleVariables.tempDate.getTime());\n        } else {\n          recRuleVariables.dateCollection.push([recRuleVariables.tempDate.getTime()]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * Internal method to set next valid date\r\n *\r\n * @param {Date} tempDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} monthInit Accepts the initial month\r\n * @param {Date} beginDate Accepts the initial date\r\n * @param {number} interval Accepts the interval duration\r\n * @returns {number} Returnx the next valid date\r\n * @private\r\n */\n\n\nfunction setNextValidDate(tempDate, ruleObject, monthInit, beginDate, interval) {\n  if (beginDate === void 0) {\n    beginDate = null;\n  }\n\n  var monthData = beginDate ? beginDate.getMonth() : 0;\n  var startDate = calendarUtil.getMonthStartDate(tempDate);\n  interval = isNullOrUndefined(interval) ? ruleObject.interval : interval;\n  tempDate.setFullYear(startDate.getFullYear());\n  tempDate.setMonth(startDate.getMonth());\n  tempDate.setDate(startDate.getDate());\n\n  if (ruleObject.month.length) {\n    monthInit++;\n    monthInit = monthInit % ruleObject.month.length;\n    calendarUtil.setMonth(tempDate, ruleObject.month[monthInit], 1);\n\n    if (monthInit === 0) {\n      calendarUtil.addYears(tempDate, interval, ruleObject.month[0]);\n    }\n  } else {\n    if (beginDate && beginDate.getFullYear() < tempDate.getFullYear()) {\n      monthData = tempDate.getMonth() - 1;\n    }\n\n    calendarUtil.setValidDate(tempDate, interval, 1, monthData, beginDate);\n  }\n\n  return monthInit;\n}\n/**\r\n * To get month collection when BYDAY property having more than one value in list.\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction getMonthCollection(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var tempDate = new Date(startDate.getTime());\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  var monthCollection = [];\n  var dateCollection = [];\n  var dates = [];\n  var index;\n  var state;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var monthInit = 0;\n  var beginDate;\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    var currentMonthDate = new Date(tempDate.getTime());\n    var isHavingNumber = expectedDays.map(function (item) {\n      return HASNUMBER.test(item);\n    });\n\n    if (isHavingNumber.indexOf(true) > -1) {\n      for (var j = 0; j <= expectedDays.length - 1; j++) {\n        var expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\n        var position = parseInt(expectedDaysArray[0], 10);\n        tempDate = new Date(tempDate.getTime());\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, expectedDays);\n        currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && calendarUtil.isSameMonth(currentMonthDate, tempDate)) {\n          if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentMonthDate.getDay()]) {\n            monthCollection.push([currentMonthDate.getTime()]);\n          }\n\n          currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n        }\n\n        currentMonthDate.setDate(currentMonthDate.getDate() - 1);\n\n        if (expectedDaysArray[0].indexOf('-') > -1) {\n          index = monthCollection.length - -1 * position;\n        } else {\n          index = position - 1;\n        }\n\n        index = isNaN(index) ? 0 : index;\n\n        if (monthCollection.length > 0) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n          } else {\n            dateCollection = [filterDateCollectionByIndex(monthCollection, index, dates)];\n          }\n        }\n\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n\n        monthCollection = [];\n      }\n\n      if (!isNullOrUndefined(ruleObject.setPosition)) {\n        insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n        dates = [];\n      }\n\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    } else {\n      var weekCollection = [];\n      var dayCycleData = processWeekDays(expectedDays);\n      currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n      var initialDate = new Date(tempDate.getTime());\n      beginDate = new Date(tempDate.getTime());\n\n      while (calendarUtil.isSameMonth(initialDate, tempDate)) {\n        weekCollection.push(tempDate.getTime());\n\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          monthCollection.push(weekCollection);\n          weekCollection = [];\n        }\n\n        tempDate.setDate(tempDate.getDate() + dayCycleData[DAYINDEX[tempDate.getDay()]]);\n      }\n\n      index = ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n\n      if (isNullOrUndefined(ruleObject.setPosition)) {\n        index = 0;\n        var datas = [];\n\n        for (var week = 0; week < monthCollection.length; week++) {\n          for (var row = 0; row < monthCollection[week].length; row++) {\n            datas.push(monthCollection[week][row]);\n          }\n        }\n\n        monthCollection = [datas];\n      }\n\n      if (monthCollection.length > 0) {\n        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n      }\n\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        return;\n      }\n\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    }\n  }\n}\n/**\r\n * To process monday day type for FREQ=MONTHLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day; // When BYDAY property having more than 1 value.\n\n  if (expectedDays.length > 1) {\n    getMonthCollection(startDate, endDate, data, ruleObject);\n    return;\n  }\n\n  var tempDate = new Date(startDate.getTime());\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var monthCollection = [];\n  var beginDate;\n  var monthInit = 0;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    beginDate = new Date(tempDate.getTime());\n    var currentMonthDate = new Date(tempDate.getTime());\n\n    while (calendarUtil.isSameMonth(tempDate, currentMonthDate)) {\n      monthCollection.push([currentMonthDate.getTime()]);\n      currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n    } // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n\n\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n    monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n}\n/**\r\n * To process monday day type for FREQ=YEARLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var isHavingNumber = expectedDays.map(function (item) {\n    return HASNUMBER.test(item);\n  }); // If BYDAY property having more than 1 value in list\n\n  if (expectedDays.length > 1 && isHavingNumber.indexOf(true) > -1) {\n    processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject);\n    return;\n  } else if (ruleObject.month.length && expectedDays.length === 1 && isHavingNumber.indexOf(true) > -1) {\n    monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n\n  var tempDate = new Date(startDate.getTime());\n  var currentMonthDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var interval = ruleObject.interval;\n  var monthCollection = [];\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n  } // Set the date as start date of the yeear if yearly freq having ByDay property alone\n\n\n  if (isNullOrUndefined(ruleObject.setPosition) && ruleObject.month.length === 0 && ruleObject.weekNo.length === 0) {\n    tempDate.setFullYear(startDate.getFullYear(), 0, 1);\n  }\n\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n\n    while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n      currentMonthDate = new Date(tempDate.getTime());\n\n      while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n        if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(tempDate, ruleObject.month)) {\n          if (expectedDays.length > 1) {\n            if (calendarUtil.compareMonth(currentMonthDate, tempDate)) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n\n            if (expectedDays.indexOf(DAYINDEX[currentMonthDate.getDay()]) > -1) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n\n            currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n          } else {\n            // If BYDAY property having 1 value in list\n            if (currentMonthDate.getFullYear() > tempDate.getFullYear()) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n\n            var newstr = getDayString(expectedDays[0]);\n\n            if (DAYINDEX[currentMonthDate.getDay()] === newstr && new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 0) > new Date(startDate.getFullYear())) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n\n            currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n          }\n        } else {\n          calendarUtil.setValidDate(tempDate, 1, 1);\n          tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          break;\n        }\n      }\n    }\n\n    tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate()); // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    }\n\n    tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n}\n/**\r\n * To process the recurrence rule when BYDAY property having values with integer\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var tempDate = new Date(startDate.getTime());\n  var interval = ruleObject.interval;\n  var monthCollection = [];\n  var dateCollection = [];\n  var index;\n  var state;\n  var monthInit = 0;\n  var currentMonthDate;\n  var currentDate;\n  var beginDate;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  var datas = [];\n\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n\n    for (var i = 0; i <= ruleObject.month.length; i++) {\n      for (var j = 0; j <= expectedDays.length - 1; j++) {\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n        monthCollection = [];\n\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n          while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n            currentMonthDate = new Date(tempDate.getTime());\n\n            if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && ruleObject.month[i] === calendarUtil.getMonth(currentMonthDate)) {\n              var expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\n              var position = parseInt(expectedDaysArray[0], 10);\n              currentDate = new Date(tempDate.getTime());\n\n              while (calendarUtil.isSameYear(currentDate, tempDate) && calendarUtil.isSameMonth(currentDate, tempDate)) {\n                if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentDate.getDay()]) {\n                  monthCollection.push([currentDate.getTime()]);\n                }\n\n                currentDate.setDate(currentDate.getDate() + 1);\n              }\n\n              currentDate.setDate(currentDate.getDate() - 1);\n\n              if (expectedDaysArray[0].indexOf('-') > -1) {\n                index = monthCollection.length - -1 * position;\n              } else {\n                index = position - 1;\n              }\n\n              index = isNaN(index) ? 0 : index;\n            }\n\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate, 1);\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          }\n        }\n\n        tempDate = j === 0 && currentDate ? new Date(currentDate.getTime()) : new Date(currentMonthDate.getTime());\n\n        if (monthCollection.length > 0) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n          } else {\n            dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n          }\n        }\n\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n      }\n    }\n\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n      datas = [];\n    }\n\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n    } else {\n      tempDate.setFullYear(tempDate.getFullYear() + interval);\n    }\n\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n\n    if (ruleObject.month.length) {\n      calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n    }\n  }\n}\n/**\r\n * To get recurrence collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month collection dates\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {RuleData} Returns the rule data object\r\n * @private\r\n */\n\n\nfunction getRecurrenceCollection(monthCollection, expectedDays) {\n  var index;\n  var recurrenceCollectionObject = {\n    monthCollection: [],\n    index: 0\n  };\n\n  if (expectedDays.length === 1) {\n    // To split numeric value from BYDAY property value\n    var expectedDaysArrays = expectedDays[0].match(SPLITNUMBERANDSTRING);\n    var arrPosition = void 0;\n\n    if (expectedDaysArrays.length > 1) {\n      arrPosition = parseInt(expectedDaysArrays[0], 10);\n      index = arrPosition < 1 ? monthCollection.length + arrPosition : arrPosition - 1;\n    } else {\n      index = 0;\n      monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n    }\n  } else {\n    index = 0;\n    monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n  }\n\n  recurrenceCollectionObject.monthCollection = monthCollection;\n  recurrenceCollectionObject.index = index;\n  return recurrenceCollectionObject;\n}\n/**\r\n * Internal method to process the data collections\r\n *\r\n * @param {number[]} dateCollection Accepts the date collections\r\n * @param {boolean} state Accepts the state\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of numbers\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction insertDataCollection(dateCollection, state, startDate, endDate, data, ruleObject) {\n  var index = ruleObject.setPosition < 1 ? dateCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n\n  if (isNullOrUndefined(ruleObject.setPosition)) {\n    index = 0;\n    dateCollection = getDateCollectionforBySetPosNull(dateCollection);\n  }\n\n  if (dateCollection.length > 0) {\n    insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject, index);\n  }\n}\n/**\r\n * To process month collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @returns {number[]} Returns the month date collections\r\n * @private\r\n */\n\n\nfunction getDateCollectionforBySetPosNull(monthCollection) {\n  var datas = [];\n\n  for (var week = 0; week < monthCollection.length; week++) {\n    for (var row = 0; row < monthCollection[week].length; row++) {\n      datas.push(new Date(monthCollection[week][row]).getTime());\n    }\n  }\n\n  monthCollection = datas.length > 0 ? [datas] : [];\n  return monthCollection;\n}\n/**\r\n * To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the date collections\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var state;\n  var datas = [];\n  var dateCollection = [];\n  var recurrenceCollections = getRecurrenceCollection(monthCollection, expectedDays);\n  monthCollection = recurrenceCollections.monthCollection;\n  var index = recurrenceCollections.index;\n\n  if (ruleObject.setPosition != null) {\n    dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n    insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n  } else {\n    if (monthCollection.length > 0) {\n      insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n    }\n  }\n\n  datas = [];\n}\n/**\r\n * To filter date collection when BYDAY property having values with number\r\n *\r\n * @param {number[]} monthCollection Accepts the date collections\r\n * @param {number} index Accepts the index of date collections\r\n * @param {number[]} datas Accepts the collection of dates\r\n * @returns {number[]} Returns the collection of dates\r\n * @private\r\n */\n\n\nfunction filterDateCollectionByIndex(monthCollection, index, datas) {\n  for (var week = 0; week < monthCollection[index].length; week++) {\n    datas.push(monthCollection[index][week]);\n  }\n\n  return datas;\n}\n/**\r\n * To insert processed date collection in final array element\r\n *\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} dayData Accepts the date index\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction insertDateCollection(state, startDate, endDate, data, ruleObject, dayData) {\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var chDate = new Date(dayData);\n  state = validateRules(chDate, ruleObject);\n\n  if (chDate >= startDate && compareDates(chDate, endDate) && state && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    excludeDateHandler(data, dayData);\n  }\n}\n/**\r\n * Return the last week number of given month and year.\r\n *\r\n * @param {number} year Accepts the Year in number format\r\n * @param {number} startDayOfWeek Accepts the start date\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {number} week Accepts the week in number format\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} returns week number\r\n * @private\r\n */\n\n\nfunction weekCount(year, startDayOfWeek, monthCollection, week, ruleObject) {\n  var firstDayOfWeek = startDayOfWeek || 0;\n  var firstOfMonth = new Date(year, ruleObject.month[0] - 1, 1);\n  var lastOfMonth = new Date(year, ruleObject.month[0] - 1, 0);\n  var numberOfDaysInMonth = lastOfMonth.getDate();\n  var firstWeekDay = (firstOfMonth.getDay() - firstDayOfWeek + 7) % 7;\n  var used = firstWeekDay + numberOfDaysInMonth;\n  var count = Math.ceil(used / 7) - 1;\n  var dayData = monthCollection[week][count];\n  var chDate = new Date(dayData);\n  var state = validateRules(chDate, ruleObject);\n  return state ? count : count - 1;\n}\n/**\r\n * To process date collection based on Byset position after process the collection based on BYDAY property value index: EX:BYDAY=1SUm-1SU\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction insertDateCollectionBasedonBySetPos(monthCollection, state, startDate, endDate, data, ruleObject) {\n  if (monthCollection.length > 0) {\n    for (var week = 0; week < monthCollection.length; week++) {\n      monthCollection[week].sort();\n      var expectedDays = ruleObject.day;\n      var isHavingNumber = expectedDays.map(function (item) {\n        return HASNUMBER.test(item);\n      });\n      var weekIndex = ruleObject.freq === 'YEARLY' && ruleObject.validRules.indexOf('BYMONTH') > -1 && !(isHavingNumber.indexOf(true) > -1) ? weekCount(new Date(monthCollection[0][0]).getFullYear(), 0, monthCollection, week, ruleObject) : monthCollection[week].length + ruleObject.setPosition;\n      var index = ruleObject.setPosition < 1 ? weekIndex : ruleObject.setPosition - 1;\n      var dayData = monthCollection[week][index];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n}\n/**\r\n * To insert datas into existing collection which is processed from previous loop.\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} index Accepts the index value\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) {\n  if (monthCollection.length > 0) {\n    index = !isNullOrUndefined(index) ? index : ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n    monthCollection[index].sort();\n\n    for (var week = 0; week < monthCollection[index].length; week++) {\n      var dayData = monthCollection[index][week];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n}\n/**\r\n * Internal method to compare dates\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @returns {boolean} Returns the result of checking start and end dates\r\n * @private\r\n */\n\n\nfunction compareDates(startDate, endDate) {\n  return endDate ? startDate <= endDate : true;\n}\n/**\r\n * Internal method to get day string\r\n *\r\n * @param {string} expectedDays Accepts the exception date string\r\n * @returns {string} Returns the valid string\r\n * @private\r\n */\n\n\nfunction getDayString(expectedDays) {\n  // To get BYDAY value without numeric value\n  var newstr = expectedDays.replace(REMOVENUMBERINSTRING, '');\n  return newstr;\n}\n/**\r\n * Internal method to check day index\r\n *\r\n * @param {number} day Accepts the day index\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {boolean} Returns the index date\r\n * @private\r\n */\n\n\nfunction checkDayIndex(day, expectedDays) {\n  var sortedExpectedDays = [];\n  expectedDays.forEach(function (element) {\n    var expectedDaysNumberSplit = element.match(SPLITNUMBERANDSTRING);\n\n    if (expectedDaysNumberSplit.length === 2) {\n      sortedExpectedDays.push(expectedDaysNumberSplit[1]);\n    } else {\n      sortedExpectedDays.push(expectedDaysNumberSplit[0]);\n    }\n  });\n  return sortedExpectedDays.indexOf(DAYINDEX[day]) === -1;\n}\n/**\r\n * Internal method to get start date of week\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {Date} Return the week start date\r\n * @private\r\n */\n\n\nfunction getStartDateForWeek(startDate, expectedDays) {\n  var tempDate = new Date(startDate.getTime());\n  var newstr;\n\n  if (expectedDays.length > 0) {\n    var expectedDaysArr = [];\n\n    for (var i = 0; i <= expectedDays.length - 1; i++) {\n      newstr = getDayString(expectedDays[i]);\n      expectedDaysArr.push(newstr);\n    }\n\n    if (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {\n      do {\n        tempDate.setDate(tempDate.getDate() + 1);\n      } while (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1);\n    }\n  }\n\n  return tempDate;\n}\n/**\r\n * Method to generate recurrence rule object from given rule\r\n *\r\n * @param {string} rules Accepts the recurrence rule\r\n * @returns {RecRule} Returns the recurrence rule object\r\n */\n\n\nexport function extractObjectFromRule(rules) {\n  var ruleObject = {\n    freq: null,\n    interval: 1,\n    count: null,\n    until: null,\n    day: [],\n    wkst: null,\n    month: [],\n    weekNo: [],\n    monthDay: [],\n    yearDay: [],\n    setPosition: null,\n    validRules: []\n  };\n  var rulesList = rules.split(';');\n  var splitData = [];\n  var temp;\n  rulesList.forEach(function (data) {\n    splitData = data.split('=');\n\n    switch (splitData[0]) {\n      case 'UNTIL':\n        temp = splitData[1];\n        ruleObject.until = getDateFromRecurrenceDateString(temp);\n        break;\n\n      case 'BYDAY':\n        ruleObject.day = splitData[1].split(',');\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYMONTHDAY':\n        ruleObject.monthDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYMONTH':\n        ruleObject.month = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYYEARDAY':\n        ruleObject.yearDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'BYWEEKNO':\n        ruleObject.weekNo = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n\n      case 'INTERVAL':\n        ruleObject.interval = parseInt(splitData[1], 10);\n        break;\n\n      case 'COUNT':\n        ruleObject.count = parseInt(splitData[1], 10);\n        break;\n\n      case 'BYSETPOS':\n        ruleObject.setPosition = parseInt(splitData[1], 10) > 4 ? -1 : parseInt(splitData[1], 10);\n        break;\n\n      case 'FREQ':\n        ruleObject.freq = splitData[1];\n        break;\n\n      case 'WKST':\n        ruleObject.wkst = splitData[1];\n        break;\n    }\n  });\n\n  if (ruleObject.freq === 'MONTHLY' && ruleObject.monthDay.length === 0) {\n    var index = ruleObject.validRules.indexOf('BYDAY');\n    ruleObject.validRules.splice(index, 1);\n  }\n\n  return ruleObject;\n}\n/**\r\n * Internal method to validate proper date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number} data Accepts the data value\r\n * @param {Date} startDate Accepts the start date\r\n * @returns {boolean} Returns the result of date validate\r\n * @private\r\n */\n\nfunction validateProperDate(tempDate, data, startDate) {\n  var maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  return data <= maxDate && tempDate >= startDate;\n}\n/**\r\n * Internal method to process week days\r\n *\r\n * @param {string[]} expectedDays Accepts the expection dates\r\n * @returns {Object} Returns the weekdays object\r\n * @private\r\n */\n\n\nfunction processWeekDays(expectedDays) {\n  var dayCycle = {};\n  expectedDays.forEach(function (element, index) {\n    if (index === expectedDays.length - 1) {\n      var startIndex = dayIndex.indexOf(element);\n      var temp = startIndex;\n\n      while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {\n        temp++;\n      }\n\n      dayCycle[element] = temp - startIndex;\n    } else {\n      dayCycle[element] = dayIndex.indexOf(expectedDays[index + 1]) - dayIndex.indexOf(element);\n    }\n  });\n  return dayCycle;\n}\n/**\r\n * Internal method to check date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedDate Accepts the exception dates\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\n\n\nfunction checkDate(tempDate, expectedDate) {\n  var temp = expectedDate.slice(0);\n  var data;\n  var maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  data = temp.shift();\n\n  while (data) {\n    if (data < 0) {\n      data = data + maxDate + 1;\n    }\n\n    if (data === tempDate.getDate()) {\n      return false;\n    }\n\n    data = temp.shift();\n  }\n\n  return true;\n}\n/**\r\n * Internal method to check the year value\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedyearDay Accepts the exception dates in year\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\n\n\nfunction checkYear(tempDate, expectedyearDay) {\n  var temp = expectedyearDay.slice(0);\n  var data;\n  var yearDay = getYearDay(tempDate);\n  data = temp.shift();\n\n  while (data) {\n    if (data < 0) {\n      data = data + calendarUtil.getYearDaysCount(tempDate, 0) + 1;\n    }\n\n    if (data === yearDay) {\n      return false;\n    }\n\n    data = temp.shift();\n  }\n\n  return true;\n}\n/**\r\n * Internal method to get the year day\r\n *\r\n * @param {Date} currentDate Accepts the date value\r\n * @returns {number} Returns the boolean value\r\n * @private\r\n */\n\n\nfunction getYearDay(currentDate) {\n  if (!startDateCollection[calendarUtil.getFullYear(currentDate)]) {\n    startDateCollection[calendarUtil.getFullYear(currentDate)] = calendarUtil.getYearLastDate(currentDate, 0);\n  }\n\n  var tempDate = startDateCollection[calendarUtil.getFullYear(currentDate)];\n  var diff = currentDate.getTime() - tempDate.getTime();\n  return Math.ceil(diff / MS_PER_DAY);\n}\n/**\r\n * Internal method to validate monthly rule type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {MonthlyType} Returns the monthly type object\r\n * @private\r\n */\n\n\nfunction validateMonthlyRuleType(ruleObject) {\n  if (ruleObject.monthDay.length && !ruleObject.day.length) {\n    return 'date';\n  } else if (!ruleObject.monthDay.length && ruleObject.day.length) {\n    return 'day';\n  }\n\n  return 'both';\n}\n/**\r\n * Internal method to re-order the week days based on first day of week\r\n *\r\n * @param {string[]} days Accepts the week days value\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction rotate(days) {\n  var data = days.shift();\n  days.push(data);\n}\n/**\r\n * Internal method to set first day of week\r\n *\r\n * @param {string} day Accepts the first day string\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction setFirstDayOfWeek(day) {\n  while (dayIndex[0] !== day) {\n    rotate(dayIndex);\n  }\n}\n/**\r\n * Internal method to validate recurrence rule\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\n\n\nfunction validateRules(tempDate, ruleObject) {\n  var state = true;\n  var expectedDays = ruleObject.day;\n  var expectedMonth = ruleObject.month;\n  var expectedDate = calendarUtil.getExpectedDays(tempDate, ruleObject.monthDay);\n  var expectedyearDay = ruleObject.yearDay;\n  ruleObject.validRules.forEach(function (rule) {\n    switch (rule) {\n      case 'BYDAY':\n        if (checkDayIndex(tempDate.getDay(), expectedDays)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYMONTH':\n        if (calendarUtil.checkMonth(tempDate, expectedMonth)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYMONTHDAY':\n        if (checkDate(tempDate, expectedDate)) {\n          state = false;\n        }\n\n        break;\n\n      case 'BYYEARDAY':\n        if (checkYear(tempDate, expectedyearDay)) {\n          state = false;\n        }\n\n        break;\n    }\n  });\n  return state;\n}\n/**\r\n * Internal method to get calendar util\r\n *\r\n * @param {CalendarType} calendarMode Accepts the calendar type object\r\n * @returns {CalendarUtil} Returns the calendar util object\r\n * @private\r\n */\n\n\nexport function getCalendarUtil(calendarMode) {\n  if (calendarMode === 'Islamic') {\n    return new Islamic();\n  }\n\n  return new Gregorian();\n}\nvar startDateCollection = {};\nvar tempExcludeDate;\nvar dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar maxOccurrence;\nvar tempViewDate;\nvar calendarUtil;\nvar DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar MAXOCCURRENCE = 43;\nvar WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];\nvar TIMES = 'summaryTimes';\nvar ON = 'summaryOn';\nvar EVERY = 'every';\nvar UNTIL = 'summaryUntil';\nvar DAYS = 'summaryDay';\nvar WEEKS = 'summaryWeek';\nvar MONTHS = 'summaryMonth';\nvar YEARS = 'summaryYear';\nvar DAYINDEXOBJECT = {\n  SU: 'sun',\n  MO: 'mon',\n  TU: 'tue',\n  WE: 'wed',\n  TH: 'thu',\n  FR: 'fri',\n  SA: 'sat'\n}; // To check string has number\n\nvar HASNUMBER = /\\d/; // To find the numbers in string\n\nvar REMOVENUMBERINSTRING = /[^A-Z]+/; // To split number and string\n\nvar SPLITNUMBERANDSTRING = /[a-z]+|[^a-z]+/gi;\n/**\r\n * Method to generate string from date\r\n *\r\n * @param {Date} date Accepts the date value\r\n * @returns {string} Returns the string value\r\n */\n\nexport function getRecurrenceStringFromDate(date) {\n  return [date.getUTCFullYear(), roundDateValues(date.getUTCMonth() + 1), roundDateValues(date.getUTCDate()), 'T', roundDateValues(date.getUTCHours()), roundDateValues(date.getUTCMinutes()), roundDateValues(date.getUTCSeconds()), 'Z'].join('');\n}\n/**\r\n * Internal method to round the date values\r\n *\r\n * @param {string | number} date Accepts the date value in either string or number format\r\n * @returns {string} Returns the date value in string format\r\n * @private\r\n */\n\nfunction roundDateValues(date) {\n  return ('0' + date).slice(-2);\n}","map":{"version":3,"sources":["D:/HUST/20211/Introduction to Software Engineering/Project/Sprint 2/RubyGYM/client/node_modules/@syncfusion/ej2-schedule/src/recurrence-editor/date-generator.js"],"names":["isNullOrUndefined","getDefaultDateObject","getValue","cldrData","MS_PER_DAY","addDays","resetTime","capitalizeFirstWord","Islamic","Gregorian","Timezone","generateSummary","rule","localeObject","locale","calendarType","ruleObject","extractObjectFromRule","summary","getConstant","EVERY","cldrObj","cldrObj1","calendarMode","toLowerCase","nameSpace1","nameSpace","interval","freq","DAYS","WEEKS","ON","day","forEach","index","DAYINDEXOBJECT","length","MONTHS","getMonthSummary","YEARS","month","toString","count","TIMES","until","tempDate","UNTIL","getDate","getMonth","getFullYear","localeObj","monthDay","pos","setPosition","WEEKPOS","generate","startDate","excludeDate","startDayOfWeek","maximumCount","viewDate","oldTimezone","newTimezone","MAXOCCURRENCE","cacheDate","calendarUtil","getCalendarUtil","data","modifiedDate","Date","getTime","tempExcludeDate","split","tz","content","parsedDate","getDateFromRecurrenceDateString","convert","push","setHours","recExceptionCount","tempViewDate","setDate","maxOccurrence","setFirstDayOfWeek","DAYINDEX","dailyType","weeklyType","monthlyType","yearlyType","recDateString","substr","excludeDateHandler","date","zeroIndex","indexOf","getDateCount","Math","floor","endDate","expectedCount","state","expectedDays","compareDates","validateRules","getDay","weekState","wkstIndex","weekCollection","wkst","dayIndex","startDateDiff","weekstartDate","weekendDate","compareTempDate","insertDataCollection","getStartDateForWeek","ruleType","validateMonthlyRuleType","monthlyDayTypeProcessforMonthFreq","monthlyDayTypeProcess","monthlyDateTypeProcessforMonthFreq","monthlyDateTypeProcess","typeValue","checkYearlyType","processWeekNo","processYearDay","stDate","getYearLastDate","startDay","firstWeekSpan","weekNos","weekNo","maxDate","minDate","insertDateCollection","insertDatasIntoExistingCollection","dateCollection","yearDay","getLeapYearDaysCount","isLeapYear","getYearDaysCount","initializeRecRuleVariables","ruleData","monthCollection","mainDate","monthInit","setMonth","currentMonthDate","getMonthStartDate","isSameYear","checkMonth","processDateCollectionForByMonthDay","beginDate","setNextValidDate","setValidDate","setFullYear","isLastMonth","getMonthDaysCount","recRuleVariables","isByMonth","validateProperDate","monthData","addYears","getMonthCollection","dates","isHavingNumber","map","item","HASNUMBER","test","j","expectedDaysArray","match","SPLITNUMBERANDSTRING","position","parseInt","isSameMonth","isNaN","filterDateCollectionByIndex","insertDateCollectionBasedonBySetPos","dayCycleData","processWeekDays","initialDate","datas","week","row","insertDateCollectionBasedonIndex","processDateCollectionforByDayWithInteger","compareMonth","newstr","getDayString","currentDate","i","getRecurrenceCollection","recurrenceCollectionObject","expectedDaysArrays","arrPosition","getDateCollectionforBySetPosNull","recurrenceCollections","dayData","chDate","weekCount","year","firstDayOfWeek","firstOfMonth","lastOfMonth","numberOfDaysInMonth","firstWeekDay","used","ceil","sort","weekIndex","validRules","replace","REMOVENUMBERINSTRING","checkDayIndex","sortedExpectedDays","element","expectedDaysNumberSplit","expectedDaysArr","rules","rulesList","splitData","temp","Number","splice","dayCycle","startIndex","checkDate","expectedDate","slice","shift","checkYear","expectedyearDay","getYearDay","startDateCollection","diff","rotate","days","expectedMonth","getExpectedDays","SU","MO","TU","WE","TH","FR","SA","getRecurrenceStringFromDate","getUTCFullYear","roundDateValues","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","join"],"mappings":"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","sourcesContent":["/* eslint-disable max-len */\r\nimport { isNullOrUndefined, getDefaultDateObject, getValue, cldrData } from '@syncfusion/ej2-base';\r\nimport { MS_PER_DAY, addDays, resetTime, capitalizeFirstWord } from '../schedule/base/util';\r\nimport { Islamic, Gregorian } from '../common/calendar-util';\r\nimport { Timezone } from '../schedule/timezone/timezone';\r\n/**\r\n * Date Generator from Recurrence Rule\r\n */\r\n/**\r\n * Generate Summary from Recurrence Rule\r\n *\r\n * @param {string} rule Accepts the Recurrence rule\r\n * @param {L10n} localeObject Accepts the locale object\r\n * @param {string} locale Accepts the locale name\r\n * @param {CalendarType} calendarType Accepts the calendar type\r\n * @returns {string} Returns the summary string from given recurrence rule\r\n */\r\nexport function generateSummary(rule, localeObject, locale, calendarType) {\r\n    if (calendarType === void 0) { calendarType = 'Gregorian'; }\r\n    var ruleObject = extractObjectFromRule(rule);\r\n    var summary = localeObject.getConstant(EVERY) + ' ';\r\n    var cldrObj;\r\n    var cldrObj1;\r\n    var calendarMode = calendarType.toLowerCase();\r\n    if (locale === 'en' || locale === 'en-US') {\r\n        var nameSpace1 = 'months.stand-alone.abbreviated';\r\n        var nameSpace = 'days.stand-alone.abbreviated';\r\n        cldrObj1 = (getValue(nameSpace1, getDefaultDateObject(calendarMode)));\r\n        cldrObj = (getValue(nameSpace, getDefaultDateObject(calendarMode)));\r\n    }\r\n    else {\r\n        var nameSpace1 = 'main.' + locale + '.dates.calendars.' + calendarMode + '.months.stand-alone.abbreviated';\r\n        var nameSpace = 'main.' + locale + '.dates.calendars.' + calendarMode + '.days.stand-alone.abbreviated';\r\n        cldrObj1 =\r\n            (getValue(nameSpace1, cldrData));\r\n        cldrObj =\r\n            (getValue(nameSpace, cldrData));\r\n    }\r\n    if (ruleObject.interval > 1) {\r\n        summary += ruleObject.interval + ' ';\r\n    }\r\n    switch (ruleObject.freq) {\r\n        case 'DAILY':\r\n            summary += localeObject.getConstant(DAYS);\r\n            break;\r\n        case 'WEEKLY':\r\n            summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';\r\n            ruleObject.day.forEach(function (day, index) {\r\n                summary += capitalizeFirstWord(getValue(DAYINDEXOBJECT[day], cldrObj), 'single');\r\n                summary += (((ruleObject.day.length - 1) === index) ? '' : ', ');\r\n            });\r\n            break;\r\n        case 'MONTHLY':\r\n            summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';\r\n            summary += getMonthSummary(ruleObject, cldrObj, localeObject);\r\n            break;\r\n        case 'YEARLY':\r\n            summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';\r\n            summary += capitalizeFirstWord(getValue((ruleObject.month[0]).toString(), cldrObj1), 'single') + ' ';\r\n            summary += getMonthSummary(ruleObject, cldrObj, localeObject);\r\n            break;\r\n    }\r\n    if (ruleObject.count) {\r\n        summary += ', ' + (ruleObject.count) + ' ' + localeObject.getConstant(TIMES);\r\n    }\r\n    else if (ruleObject.until) {\r\n        var tempDate = ruleObject.until;\r\n        summary += ', ' + localeObject.getConstant(UNTIL)\r\n            + ' ' + tempDate.getDate()\r\n            + ' ' + capitalizeFirstWord(getValue((tempDate.getMonth() + 1).toString(), cldrObj1), 'single')\r\n            + ' ' + tempDate.getFullYear();\r\n    }\r\n    return summary;\r\n}\r\n/**\r\n * Generates Month summary\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {string[]} cldrObj Accepts the collections of month name from calendar\r\n * @param {L10n} localeObj Accepts the locale object\r\n * @returns {string} Returns the month summary string from given recurrence rule object\r\n * @private\r\n */\r\nfunction getMonthSummary(ruleObject, cldrObj, localeObj) {\r\n    var summary = '';\r\n    if (ruleObject.monthDay.length) {\r\n        summary += ruleObject.monthDay[0];\r\n    }\r\n    else if (ruleObject.day) {\r\n        var pos = ruleObject.setPosition - 1;\r\n        summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : (WEEKPOS.length - 1)])\r\n            + ' ' + capitalizeFirstWord(getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj), 'single');\r\n    }\r\n    return summary;\r\n}\r\n/**\r\n * Generates the date collections from the given recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the rule start date\r\n * @param {string} rule Accepts the recurrence rule\r\n * @param {string} excludeDate Accepts the exception dates in string format\r\n * @param {number} startDayOfWeek Accepts the start day index of week\r\n * @param {number} maximumCount Accepts the maximum number count to generate date collections\r\n * @param {Date} viewDate Accepts the current date instead of start date\r\n * @param {CalendarType} calendarMode Accepts the calendar type\r\n * @param {string} oldTimezone Accepts the timezone name\r\n * @param {string} newTimezone Accepts the timezone name\r\n * @returns {number[]} Returns the collection of dates\r\n */\r\nexport function generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount, viewDate, calendarMode, oldTimezone, newTimezone) {\r\n    if (maximumCount === void 0) { maximumCount = MAXOCCURRENCE; }\r\n    if (viewDate === void 0) { viewDate = null; }\r\n    if (calendarMode === void 0) { calendarMode = 'Gregorian'; }\r\n    if (oldTimezone === void 0) { oldTimezone = null; }\r\n    if (newTimezone === void 0) { newTimezone = null; }\r\n    var ruleObject = extractObjectFromRule(rule);\r\n    var cacheDate;\r\n    calendarUtil = getCalendarUtil(calendarMode);\r\n    var data = [];\r\n    var modifiedDate = new Date(startDate.getTime());\r\n    tempExcludeDate = [];\r\n    var tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');\r\n    var tz = new Timezone();\r\n    tempDate.forEach(function (content) {\r\n        var parsedDate = getDateFromRecurrenceDateString(content);\r\n        if (oldTimezone && newTimezone) {\r\n            parsedDate = tz.convert(new Date(parsedDate.getTime()), oldTimezone, newTimezone);\r\n        }\r\n        tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));\r\n    });\r\n    ruleObject.recExceptionCount = !isNullOrUndefined(ruleObject.count) ? tempExcludeDate.length : 0;\r\n    if (viewDate && viewDate > startDate && !ruleObject.count) {\r\n        tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));\r\n    }\r\n    else {\r\n        tempViewDate = null;\r\n    }\r\n    if (!ruleObject.until && tempViewDate) {\r\n        cacheDate = new Date(tempViewDate.getTime());\r\n        cacheDate.setDate(tempViewDate.getDate() + maximumCount * (ruleObject.interval));\r\n        ruleObject.until = cacheDate;\r\n    }\r\n    if (ruleObject.until && startDate > ruleObject.until) {\r\n        return data;\r\n    }\r\n    maxOccurrence = maximumCount;\r\n    setFirstDayOfWeek(DAYINDEX[startDayOfWeek]);\r\n    switch (ruleObject.freq) {\r\n        case 'DAILY':\r\n            dailyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n            break;\r\n        case 'WEEKLY':\r\n            weeklyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n            break;\r\n        case 'MONTHLY':\r\n            monthlyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n            break;\r\n        case 'YEARLY':\r\n            yearlyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n    }\r\n    return data;\r\n}\r\n/**\r\n * Generate date object from given date string\r\n *\r\n * @param {string} recDateString Accepts the exception date as string\r\n * @returns {Date} Returns the date from exception date string\r\n */\r\nexport function getDateFromRecurrenceDateString(recDateString) {\r\n    return new Date(recDateString.substr(0, 4) +\r\n        '-' + recDateString.substr(4, 2) +\r\n        '-' + recDateString.substr(6, 5) +\r\n        ':' + recDateString.substr(11, 2) +\r\n        ':' + recDateString.substr(13));\r\n}\r\n/**\r\n * Internal method to handle exclude date\r\n *\r\n * @param {number[]} data Accepts the exception date collections\r\n * @param {number} date Accepts the new exclude date\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction excludeDateHandler(data, date) {\r\n    var zeroIndex = new Date(date).setHours(0, 0, 0, 0);\r\n    if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {\r\n        data.push(date);\r\n    }\r\n}\r\n/**\r\n * Internal method for get date count\r\n *\r\n * @param {Date} startDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} Returns the number of date count\r\n * @private\r\n */\r\nfunction getDateCount(startDate, ruleObject) {\r\n    var count = maxOccurrence;\r\n    if (ruleObject.count) {\r\n        count = ruleObject.count;\r\n    }\r\n    else if (ruleObject.until) {\r\n        if (ruleObject.freq === 'DAILY' || ruleObject.freq === 'WEEKLY') {\r\n            count = Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1;\r\n        }\r\n        else if (ruleObject.freq === 'MONTHLY' || ruleObject.freq === 'YEARLY') {\r\n            count = Math.floor(((ruleObject.until.getMonth() + 12 * ruleObject.until.getFullYear()) -\r\n                (startDate.getMonth() + 12 * startDate.getFullYear())) / ruleObject.interval) +\r\n                (ruleObject.day.length > 1 ? (Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1) : 1);\r\n            if (ruleObject.freq === 'YEARLY') {\r\n                count = ruleObject.month.length > 1 ? (count * ruleObject.month.length) : count;\r\n            }\r\n        }\r\n    }\r\n    return count;\r\n}\r\n/**\r\n *  Internal method for daily type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction dailyType(startDate, endDate, data, ruleObject) {\r\n    var tempDate = new Date(startDate.getTime());\r\n    var interval = ruleObject.interval;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var state;\r\n    var expectedDays = ruleObject.day;\r\n    while (compareDates(tempDate, endDate)) {\r\n        state = true;\r\n        state = validateRules(tempDate, ruleObject);\r\n        if (state && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1 || expectedDays.length === 0)) {\r\n            excludeDateHandler(data, tempDate.getTime());\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                break;\r\n            }\r\n        }\r\n        tempDate.setDate(tempDate.getDate() + interval);\r\n    }\r\n}\r\n/**\r\n * Internal method for weekly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction weeklyType(startDate, endDate, data, ruleObject) {\r\n    var tempDate = new Date(startDate.getTime());\r\n    if (!ruleObject.day.length) {\r\n        ruleObject.day.push(DAYINDEX[startDate.getDay()]);\r\n    }\r\n    var interval = ruleObject.interval;\r\n    var expectedDays = ruleObject.day;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var weekState = true;\r\n    var wkstIndex;\r\n    var weekCollection = [];\r\n    if (expectedDays.length > 1) {\r\n        if (isNullOrUndefined(ruleObject.wkst) || ruleObject.wkst === '') {\r\n            ruleObject.wkst = dayIndex[0];\r\n        }\r\n        wkstIndex = DAYINDEX.indexOf(ruleObject.wkst);\r\n        while (compareDates(tempDate, endDate)) {\r\n            var startDateDiff = DAYINDEX.indexOf(DAYINDEX[tempDate.getDay()]) - wkstIndex;\r\n            startDateDiff = startDateDiff === -1 ? 6 : startDateDiff;\r\n            var weekstartDate = addDays(tempDate, -startDateDiff);\r\n            var weekendDate = addDays(weekstartDate, 6);\r\n            var compareTempDate = new Date(tempDate.getTime());\r\n            weekendDate = resetTime(weekendDate);\r\n            compareTempDate = resetTime(compareTempDate);\r\n            while (weekendDate >= compareTempDate) {\r\n                if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                    weekCollection.push([tempDate.getTime()]);\r\n                }\r\n                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                    break;\r\n                }\r\n                tempDate.setDate(tempDate.getDate() + 1);\r\n                compareTempDate = new Date(tempDate.getTime());\r\n                compareTempDate = resetTime(compareTempDate);\r\n            }\r\n            tempDate.setDate(tempDate.getDate() - 1);\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                break;\r\n            }\r\n            tempDate.setDate((tempDate.getDate()) + 1 + ((interval - 1) * 7));\r\n            insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\r\n            weekCollection = [];\r\n        }\r\n    }\r\n    else {\r\n        tempDate = getStartDateForWeek(startDate, ruleObject.day);\r\n        while (compareDates(tempDate, endDate)) {\r\n            weekState = validateRules(tempDate, ruleObject);\r\n            if (weekState && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1)) {\r\n                excludeDateHandler(data, tempDate.getTime());\r\n            }\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                break;\r\n            }\r\n            tempDate.setDate(tempDate.getDate() + (interval * 7));\r\n        }\r\n        insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\r\n        weekCollection = [];\r\n    }\r\n}\r\n/**\r\n *  Internal method for monthly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyType(startDate, endDate, data, ruleObject) {\r\n    // Set monthday value if BYDAY, BYMONTH and Month day property is not set based on start date\r\n    if (!ruleObject.month.length && !ruleObject.day.length && !ruleObject.monthDay.length) {\r\n        ruleObject.monthDay.push(startDate.getDate());\r\n        if (ruleObject.freq === 'YEARLY') {\r\n            ruleObject.month.push(startDate.getMonth() + 1);\r\n        }\r\n    }\r\n    else if (ruleObject.month.length > 0 && !ruleObject.day.length && !ruleObject.monthDay.length) {\r\n        ruleObject.monthDay.push(startDate.getDate());\r\n    }\r\n    var ruleType = validateMonthlyRuleType(ruleObject);\r\n    switch (ruleType) {\r\n        case 'day':\r\n            switch (ruleObject.freq) {\r\n                case 'MONTHLY':\r\n                    monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n                    break;\r\n                case 'YEARLY':\r\n                    monthlyDayTypeProcess(startDate, endDate, data, ruleObject);\r\n                    break;\r\n            }\r\n            break;\r\n        case 'both':\r\n        case 'date':\r\n            switch (ruleObject.freq) {\r\n                case 'MONTHLY':\r\n                    monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n                    break;\r\n                case 'YEARLY':\r\n                    monthlyDateTypeProcess(startDate, endDate, data, ruleObject);\r\n                    break;\r\n            }\r\n            break;\r\n    }\r\n}\r\n/**\r\n * Internal method for yearly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction yearlyType(startDate, endDate, data, ruleObject) {\r\n    var typeValue = checkYearlyType(ruleObject);\r\n    switch (typeValue) {\r\n        case 'MONTH':\r\n            monthlyType(startDate, endDate, data, ruleObject);\r\n            break;\r\n        case 'WEEKNO':\r\n            processWeekNo(startDate, endDate, data, ruleObject);\r\n            break;\r\n        case 'YEARDAY':\r\n            processYearDay(startDate, endDate, data, ruleObject);\r\n            break;\r\n    }\r\n}\r\n/**\r\n * Internal method for process week no\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processWeekNo(startDate, endDate, data, ruleObject) {\r\n    var stDate = calendarUtil.getYearLastDate(startDate, 0);\r\n    var tempDate;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var state;\r\n    var startDay;\r\n    var firstWeekSpan;\r\n    var weekNos = ruleObject.weekNo;\r\n    var weekNo;\r\n    var maxDate;\r\n    var minDate;\r\n    var weekCollection = [];\r\n    var expectedDays = ruleObject.day;\r\n    while (compareDates(stDate, endDate)) {\r\n        startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);\r\n        firstWeekSpan = (6 - startDay) + 1;\r\n        for (var index = 0; index < weekNos.length; index++) {\r\n            weekNo = weekNos[index];\r\n            weekNo = (weekNo > 0) ? weekNo : 53 + weekNo + 1;\r\n            maxDate = (weekNo === 1) ? firstWeekSpan : firstWeekSpan + ((weekNo - 1) * 7);\r\n            minDate = (weekNo === 1) ? firstWeekSpan - 7 : firstWeekSpan + ((weekNo - 2) * 7);\r\n            while (minDate < maxDate) {\r\n                tempDate = new Date(stDate.getTime() + (MS_PER_DAY * minDate));\r\n                if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                        insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\r\n                    }\r\n                    else {\r\n                        weekCollection.push([tempDate.getTime()]);\r\n                    }\r\n                }\r\n                minDate++;\r\n            }\r\n        }\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDatasIntoExistingCollection(weekCollection, state, startDate, endDate, data, ruleObject);\r\n        }\r\n        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n            return;\r\n        }\r\n        stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\r\n        weekCollection = [];\r\n    }\r\n}\r\n/**\r\n * Internal method for process year day\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processYearDay(startDate, endDate, data, ruleObject) {\r\n    var stDate = calendarUtil.getYearLastDate(startDate, 0);\r\n    var tempDate;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var state;\r\n    var dateCollection = [];\r\n    var date;\r\n    var expectedDays = ruleObject.day;\r\n    while (compareDates(stDate, endDate)) {\r\n        for (var index = 0; index < ruleObject.yearDay.length; index++) {\r\n            date = ruleObject.yearDay[index];\r\n            tempDate = new Date(stDate.getTime());\r\n            if ((date === calendarUtil.getLeapYearDaysCount() || date === -calendarUtil.getLeapYearDaysCount()) &&\r\n                (!calendarUtil.isLeapYear(calendarUtil.getFullYear(tempDate), 1))) {\r\n                tempDate.setDate(tempDate.getDate() + 1);\r\n                continue;\r\n            }\r\n            tempDate.setDate(tempDate.getDate() + ((date < 0) ?\r\n                calendarUtil.getYearDaysCount(tempDate, 1) + 1 + date : date));\r\n            if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                if (ruleObject.setPosition == null) {\r\n                    insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\r\n                }\r\n                else {\r\n                    dateCollection.push([tempDate.getTime()]);\r\n                }\r\n            }\r\n        }\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject);\r\n        }\r\n        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n            return;\r\n        }\r\n        stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\r\n        dateCollection = [];\r\n    }\r\n}\r\n/**\r\n * Internal method to check yearly type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {YearRuleType} Returns the Yearly rule type object\r\n * @private\r\n */\r\nfunction checkYearlyType(ruleObject) {\r\n    if (ruleObject.yearDay.length) {\r\n        return 'YEARDAY';\r\n    }\r\n    else if (ruleObject.weekNo.length) {\r\n        return 'WEEKNO';\r\n    }\r\n    return 'MONTH';\r\n}\r\n/**\r\n * Internal method to initialize recurrence rule variables\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {RuleData} Return the rule data object\r\n * @private\r\n */\r\nfunction initializeRecRuleVariables(startDate, ruleObject) {\r\n    var ruleData = {\r\n        monthCollection: [],\r\n        index: 0,\r\n        tempDate: new Date(startDate.getTime()),\r\n        mainDate: new Date(startDate.getTime()),\r\n        expectedCount: getDateCount(startDate, ruleObject),\r\n        monthInit: 0,\r\n        dateCollection: []\r\n    };\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(ruleData.tempDate, ruleObject.month[0], ruleData.tempDate.getDate());\r\n    }\r\n    return ruleData;\r\n}\r\n/**\r\n * Internal method for process monthly date type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {\r\n    if (ruleObject.month.length) {\r\n        monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    var ruleData = initializeRecRuleVariables(startDate, ruleObject);\r\n    var currentMonthDate;\r\n    ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\r\n    while (compareDates(ruleData.tempDate, endDate)) {\r\n        currentMonthDate = new Date(ruleData.tempDate.getTime());\r\n        while (calendarUtil.isSameYear(currentMonthDate, ruleData.tempDate) &&\r\n            (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) <= ruleData.expectedCount)) {\r\n            if (ruleObject.month.length === 0 || (ruleObject.month.length > 0\r\n                && !calendarUtil.checkMonth(ruleData.tempDate, ruleObject.month))) {\r\n                processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, false);\r\n                ruleData.beginDate = new Date(ruleData.tempDate.getTime());\r\n                ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\r\n            }\r\n            else {\r\n                calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\r\n                ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\r\n                break;\r\n            }\r\n        }\r\n        ruleData.tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\r\n        insertDataCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\r\n        if (calendarUtil.isLastMonth(ruleData.tempDate)) {\r\n            calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\r\n            ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\r\n        }\r\n        if (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) >= ruleData.expectedCount) {\r\n            return;\r\n        }\r\n        ruleData.tempDate.setFullYear(ruleData.tempDate.getFullYear() + ruleObject.interval - 1);\r\n        ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\r\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\r\n        ruleData.dateCollection = [];\r\n    }\r\n}\r\n/**\r\n * Internal method for process monthly date type with month frequency from recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\r\n    var ruleData = initializeRecRuleVariables(startDate, ruleObject);\r\n    ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\r\n    if (((ruleObject.freq === 'MONTHLY' && ruleObject.interval === 12) || (ruleObject.freq === 'YEARLY')) &&\r\n        calendarUtil.getMonthDaysCount(startDate) < ruleObject.monthDay[0]) {\r\n        return;\r\n    }\r\n    while (compareDates(ruleData.tempDate, endDate)) {\r\n        ruleData.beginDate = new Date(ruleData.tempDate.getTime());\r\n        processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, true, startDate, data);\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDatasIntoExistingCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\r\n        }\r\n        if (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) >= ruleData.expectedCount) {\r\n            return;\r\n        }\r\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\r\n        ruleData.dateCollection = [];\r\n    }\r\n}\r\n/**\r\n * To process date collection for Monthly & Yearly based on BYMONTH Day property\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {RuleData} recRuleVariables Accepts the rule data\r\n * @param {Date} endDate Accepts the end date\r\n * @param {boolean} isByMonth Accepts the boolean to validate either month or not\r\n * @param {Date} startDate Accepts the start date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processDateCollectionForByMonthDay(ruleObject, recRuleVariables, endDate, isByMonth, startDate, data) {\r\n    for (var index = 0; index < ruleObject.monthDay.length; index++) {\r\n        recRuleVariables.date = ruleObject.monthDay[index];\r\n        recRuleVariables.tempDate = calendarUtil.getMonthStartDate(recRuleVariables.tempDate);\r\n        var maxDate = calendarUtil.getMonthDaysCount(recRuleVariables.tempDate);\r\n        recRuleVariables.date = recRuleVariables.date > 0 ? recRuleVariables.date : (maxDate + recRuleVariables.date + 1);\r\n        if (validateProperDate(recRuleVariables.tempDate, recRuleVariables.date, recRuleVariables.mainDate)\r\n            && (recRuleVariables.date > 0)) {\r\n            calendarUtil.setDate(recRuleVariables.tempDate, recRuleVariables.date);\r\n            if (endDate && recRuleVariables.tempDate > endDate) {\r\n                return;\r\n            }\r\n            if (ruleObject.day.length === 0 || ruleObject.day.indexOf(DAYINDEX[recRuleVariables.tempDate.getDay()]) > -1) {\r\n                if (isByMonth && isNullOrUndefined(ruleObject.setPosition) && (recRuleVariables.expectedCount\r\n                    && (data.length + ruleObject.recExceptionCount) < recRuleVariables.expectedCount)) {\r\n                    insertDateCollection(recRuleVariables.state, startDate, endDate, data, ruleObject, recRuleVariables.tempDate.getTime());\r\n                }\r\n                else {\r\n                    recRuleVariables.dateCollection.push([recRuleVariables.tempDate.getTime()]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Internal method to set next valid date\r\n *\r\n * @param {Date} tempDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} monthInit Accepts the initial month\r\n * @param {Date} beginDate Accepts the initial date\r\n * @param {number} interval Accepts the interval duration\r\n * @returns {number} Returnx the next valid date\r\n * @private\r\n */\r\nfunction setNextValidDate(tempDate, ruleObject, monthInit, beginDate, interval) {\r\n    if (beginDate === void 0) { beginDate = null; }\r\n    var monthData = beginDate ? beginDate.getMonth() : 0;\r\n    var startDate = calendarUtil.getMonthStartDate(tempDate);\r\n    interval = isNullOrUndefined(interval) ? ruleObject.interval : interval;\r\n    tempDate.setFullYear(startDate.getFullYear());\r\n    tempDate.setMonth(startDate.getMonth());\r\n    tempDate.setDate(startDate.getDate());\r\n    if (ruleObject.month.length) {\r\n        monthInit++;\r\n        monthInit = monthInit % ruleObject.month.length;\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[monthInit], 1);\r\n        if (monthInit === 0) {\r\n            calendarUtil.addYears(tempDate, interval, ruleObject.month[0]);\r\n        }\r\n    }\r\n    else {\r\n        if (beginDate && (beginDate.getFullYear() < tempDate.getFullYear())) {\r\n            monthData = tempDate.getMonth() - 1;\r\n        }\r\n        calendarUtil.setValidDate(tempDate, interval, 1, monthData, beginDate);\r\n    }\r\n    return monthInit;\r\n}\r\n/**\r\n * To get month collection when BYDAY property having more than one value in list.\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction getMonthCollection(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var tempDate = new Date(startDate.getTime());\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    var monthCollection = [];\r\n    var dateCollection = [];\r\n    var dates = [];\r\n    var index;\r\n    var state;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var monthInit = 0;\r\n    var beginDate;\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\r\n    }\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate)\r\n        && (expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount)) {\r\n        var currentMonthDate = new Date(tempDate.getTime());\r\n        var isHavingNumber = expectedDays.map(function (item) { return HASNUMBER.test(item); });\r\n        if (isHavingNumber.indexOf(true) > -1) {\r\n            for (var j = 0; j <= expectedDays.length - 1; j++) {\r\n                var expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\r\n                var position = parseInt(expectedDaysArray[0], 10);\r\n                tempDate = new Date(tempDate.getTime());\r\n                tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n                tempDate = getStartDateForWeek(tempDate, expectedDays);\r\n                currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\r\n                while (calendarUtil.isSameYear(currentMonthDate, tempDate) && calendarUtil.isSameMonth(currentMonthDate, tempDate)) {\r\n                    if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentMonthDate.getDay()]) {\r\n                        monthCollection.push([currentMonthDate.getTime()]);\r\n                    }\r\n                    currentMonthDate.setDate(currentMonthDate.getDate() + (1));\r\n                }\r\n                currentMonthDate.setDate(currentMonthDate.getDate() - (1));\r\n                if (expectedDaysArray[0].indexOf('-') > -1) {\r\n                    index = monthCollection.length - (-1 * position);\r\n                }\r\n                else {\r\n                    index = position - 1;\r\n                }\r\n                index = isNaN(index) ? 0 : index;\r\n                if (monthCollection.length > 0) {\r\n                    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n                    }\r\n                    else {\r\n                        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, dates))];\r\n                    }\r\n                }\r\n                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                    return;\r\n                }\r\n                monthCollection = [];\r\n            }\r\n            if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n                insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\r\n                dates = [];\r\n            }\r\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\r\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n            monthCollection = [];\r\n        }\r\n        else {\r\n            var weekCollection = [];\r\n            var dayCycleData = processWeekDays(expectedDays);\r\n            currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\r\n            var initialDate = new Date(tempDate.getTime());\r\n            beginDate = new Date(tempDate.getTime());\r\n            while (calendarUtil.isSameMonth(initialDate, tempDate)) {\r\n                weekCollection.push(tempDate.getTime());\r\n                if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                    monthCollection.push(weekCollection);\r\n                    weekCollection = [];\r\n                }\r\n                tempDate.setDate(tempDate.getDate()\r\n                    + dayCycleData[DAYINDEX[tempDate.getDay()]]);\r\n            }\r\n            index = ((ruleObject.setPosition < 1) ? (monthCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);\r\n            if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                index = 0;\r\n                var datas = [];\r\n                for (var week = 0; week < monthCollection.length; week++) {\r\n                    for (var row = 0; row < monthCollection[week].length; row++) {\r\n                        datas.push(monthCollection[week][row]);\r\n                    }\r\n                }\r\n                monthCollection = [datas];\r\n            }\r\n            if (monthCollection.length > 0) {\r\n                insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n            }\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                return;\r\n            }\r\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\r\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n            monthCollection = [];\r\n        }\r\n    }\r\n}\r\n/**\r\n * To process monday day type for FREQ=MONTHLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    // When BYDAY property having more than 1 value.\r\n    if (expectedDays.length > 1) {\r\n        getMonthCollection(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    var tempDate = new Date(startDate.getTime());\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var monthCollection = [];\r\n    var beginDate;\r\n    var monthInit = 0;\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\r\n    }\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate) && (expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount)) {\r\n        beginDate = new Date(tempDate.getTime());\r\n        var currentMonthDate = new Date(tempDate.getTime());\r\n        while (calendarUtil.isSameMonth(tempDate, currentMonthDate)) {\r\n            monthCollection.push([currentMonthDate.getTime()]);\r\n            currentMonthDate.setDate(currentMonthDate.getDate() + (7));\r\n        }\r\n        // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n        insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\r\n        monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\r\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        monthCollection = [];\r\n    }\r\n}\r\n/**\r\n * To process monday day type for FREQ=YEARLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var isHavingNumber = expectedDays.map(function (item) { return HASNUMBER.test(item); });\r\n    // If BYDAY property having more than 1 value in list\r\n    if (expectedDays.length > 1 && isHavingNumber.indexOf(true) > -1) {\r\n        processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    else if (ruleObject.month.length && expectedDays.length === 1 && isHavingNumber.indexOf(true) > -1) {\r\n        monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    var tempDate = new Date(startDate.getTime());\r\n    var currentMonthDate;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var interval = ruleObject.interval;\r\n    var monthCollection = [];\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\r\n    }\r\n    // Set the date as start date of the yeear if yearly freq having ByDay property alone\r\n    if (isNullOrUndefined(ruleObject.setPosition) && ruleObject.month.length === 0 && ruleObject.weekNo.length === 0) {\r\n        tempDate.setFullYear(startDate.getFullYear(), 0, 1);\r\n    }\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate)) {\r\n        currentMonthDate = new Date(tempDate.getTime());\r\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) &&\r\n            (expectedCount && (data.length + ruleObject.recExceptionCount) <= expectedCount)) {\r\n            currentMonthDate = new Date(tempDate.getTime());\r\n            while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\r\n                if (ruleObject.month.length === 0 || (ruleObject.month.length > 0\r\n                    && !calendarUtil.checkMonth(tempDate, ruleObject.month))) {\r\n                    if (expectedDays.length > 1) {\r\n                        if (calendarUtil.compareMonth(currentMonthDate, tempDate)) {\r\n                            calendarUtil.setValidDate(tempDate, 1, 1);\r\n                            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                            break;\r\n                        }\r\n                        if (expectedDays.indexOf(DAYINDEX[currentMonthDate.getDay()]) > -1) {\r\n                            monthCollection.push([currentMonthDate.getTime()]);\r\n                        }\r\n                        currentMonthDate.setDate(currentMonthDate.getDate() + (1));\r\n                    }\r\n                    else {\r\n                        // If BYDAY property having 1 value in list\r\n                        if (currentMonthDate.getFullYear() > tempDate.getFullYear()) {\r\n                            calendarUtil.setValidDate(tempDate, 1, 1);\r\n                            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                            break;\r\n                        }\r\n                        var newstr = getDayString(expectedDays[0]);\r\n                        if (DAYINDEX[currentMonthDate.getDay()] === newstr\r\n                            && new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 0)\r\n                                > new Date(startDate.getFullYear())) {\r\n                            monthCollection.push([currentMonthDate.getTime()]);\r\n                        }\r\n                        currentMonthDate.setDate(currentMonthDate.getDate() + (7));\r\n                    }\r\n                }\r\n                else {\r\n                    calendarUtil.setValidDate(tempDate, 1, 1);\r\n                    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\r\n        // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n        insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\r\n        if (calendarUtil.isLastMonth(tempDate)) {\r\n            calendarUtil.setValidDate(tempDate, 1, 1);\r\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        }\r\n        tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\r\n        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n            return;\r\n        }\r\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        monthCollection = [];\r\n    }\r\n}\r\n/**\r\n * To process the recurrence rule when BYDAY property having values with integer\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var tempDate = new Date(startDate.getTime());\r\n    var interval = ruleObject.interval;\r\n    var monthCollection = [];\r\n    var dateCollection = [];\r\n    var index;\r\n    var state;\r\n    var monthInit = 0;\r\n    var currentMonthDate;\r\n    var currentDate;\r\n    var beginDate;\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    var datas = [];\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\r\n    }\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate)) {\r\n        currentMonthDate = new Date(tempDate.getTime());\r\n        for (var i = 0; i <= ruleObject.month.length; i++) {\r\n            for (var j = 0; j <= expectedDays.length - 1; j++) {\r\n                tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n                tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                monthCollection = [];\r\n                while (calendarUtil.isSameYear(currentMonthDate, tempDate) &&\r\n                    (expectedCount && (data.length + ruleObject.recExceptionCount) <= expectedCount)) {\r\n                    while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\r\n                        currentMonthDate = new Date(tempDate.getTime());\r\n                        if (ruleObject.month.length === 0 ||\r\n                            (ruleObject.month.length > 0 && ruleObject.month[i] === calendarUtil.getMonth(currentMonthDate))) {\r\n                            var expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\r\n                            var position = parseInt(expectedDaysArray[0], 10);\r\n                            currentDate = new Date(tempDate.getTime());\r\n                            while (calendarUtil.isSameYear(currentDate, tempDate)\r\n                                && calendarUtil.isSameMonth(currentDate, tempDate)) {\r\n                                if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentDate.getDay()]) {\r\n                                    monthCollection.push([currentDate.getTime()]);\r\n                                }\r\n                                currentDate.setDate(currentDate.getDate() + (1));\r\n                            }\r\n                            currentDate.setDate(currentDate.getDate() - (1));\r\n                            if (expectedDaysArray[0].indexOf('-') > -1) {\r\n                                index = monthCollection.length - (-1 * position);\r\n                            }\r\n                            else {\r\n                                index = position - 1;\r\n                            }\r\n                            index = isNaN(index) ? 0 : index;\r\n                        }\r\n                        monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate, 1);\r\n                        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                    }\r\n                }\r\n                tempDate = j === 0 && currentDate ? new Date(currentDate.getTime()) : new Date(currentMonthDate.getTime());\r\n                if (monthCollection.length > 0) {\r\n                    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n                    }\r\n                    else {\r\n                        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, datas))];\r\n                    }\r\n                }\r\n                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\r\n            datas = [];\r\n        }\r\n        if (calendarUtil.isLastMonth(tempDate)) {\r\n            calendarUtil.setValidDate(tempDate, 1, 1);\r\n            tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\r\n        }\r\n        else {\r\n            tempDate.setFullYear(tempDate.getFullYear() + interval);\r\n        }\r\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        if (ruleObject.month.length) {\r\n            calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\r\n        }\r\n    }\r\n}\r\n/**\r\n * To get recurrence collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month collection dates\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {RuleData} Returns the rule data object\r\n * @private\r\n */\r\nfunction getRecurrenceCollection(monthCollection, expectedDays) {\r\n    var index;\r\n    var recurrenceCollectionObject = { monthCollection: [], index: 0 };\r\n    if (expectedDays.length === 1) {\r\n        // To split numeric value from BYDAY property value\r\n        var expectedDaysArrays = expectedDays[0].match(SPLITNUMBERANDSTRING);\r\n        var arrPosition = void 0;\r\n        if (expectedDaysArrays.length > 1) {\r\n            arrPosition = parseInt(expectedDaysArrays[0], 10);\r\n            index = ((arrPosition < 1) ? (monthCollection.length + arrPosition) : arrPosition - 1);\r\n        }\r\n        else {\r\n            index = 0;\r\n            monthCollection = getDateCollectionforBySetPosNull(monthCollection);\r\n        }\r\n    }\r\n    else {\r\n        index = 0;\r\n        monthCollection = getDateCollectionforBySetPosNull(monthCollection);\r\n    }\r\n    recurrenceCollectionObject.monthCollection = monthCollection;\r\n    recurrenceCollectionObject.index = index;\r\n    return recurrenceCollectionObject;\r\n}\r\n/**\r\n * Internal method to process the data collections\r\n *\r\n * @param {number[]} dateCollection Accepts the date collections\r\n * @param {boolean} state Accepts the state\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of numbers\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDataCollection(dateCollection, state, startDate, endDate, data, ruleObject) {\r\n    var index = ((ruleObject.setPosition < 1) ?\r\n        (dateCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);\r\n    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n        index = 0;\r\n        dateCollection = getDateCollectionforBySetPosNull(dateCollection);\r\n    }\r\n    if (dateCollection.length > 0) {\r\n        insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject, index);\r\n    }\r\n}\r\n/**\r\n * To process month collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @returns {number[]} Returns the month date collections\r\n * @private\r\n */\r\nfunction getDateCollectionforBySetPosNull(monthCollection) {\r\n    var datas = [];\r\n    for (var week = 0; week < monthCollection.length; week++) {\r\n        for (var row = 0; row < monthCollection[week].length; row++) {\r\n            datas.push(new Date(monthCollection[week][row]).getTime());\r\n        }\r\n    }\r\n    monthCollection = datas.length > 0 ? [datas] : [];\r\n    return monthCollection;\r\n}\r\n/**\r\n * To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the date collections\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var state;\r\n    var datas = [];\r\n    var dateCollection = [];\r\n    var recurrenceCollections = getRecurrenceCollection(monthCollection, expectedDays);\r\n    monthCollection = recurrenceCollections.monthCollection;\r\n    var index = recurrenceCollections.index;\r\n    if (ruleObject.setPosition != null) {\r\n        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, datas))];\r\n        insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\r\n    }\r\n    else {\r\n        if (monthCollection.length > 0) {\r\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n        }\r\n    }\r\n    datas = [];\r\n}\r\n/**\r\n * To filter date collection when BYDAY property having values with number\r\n *\r\n * @param {number[]} monthCollection Accepts the date collections\r\n * @param {number} index Accepts the index of date collections\r\n * @param {number[]} datas Accepts the collection of dates\r\n * @returns {number[]} Returns the collection of dates\r\n * @private\r\n */\r\nfunction filterDateCollectionByIndex(monthCollection, index, datas) {\r\n    for (var week = 0; week < monthCollection[index].length; week++) {\r\n        datas.push(monthCollection[index][week]);\r\n    }\r\n    return datas;\r\n}\r\n/**\r\n * To insert processed date collection in final array element\r\n *\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} dayData Accepts the date index\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDateCollection(state, startDate, endDate, data, ruleObject, dayData) {\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var chDate = new Date(dayData);\r\n    state = validateRules(chDate, ruleObject);\r\n    if ((chDate >= startDate) && compareDates(chDate, endDate) && state\r\n        && expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount) {\r\n        excludeDateHandler(data, dayData);\r\n    }\r\n}\r\n/**\r\n * Return the last week number of given month and year.\r\n *\r\n * @param {number} year Accepts the Year in number format\r\n * @param {number} startDayOfWeek Accepts the start date\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {number} week Accepts the week in number format\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} returns week number\r\n * @private\r\n */\r\nfunction weekCount(year, startDayOfWeek, monthCollection, week, ruleObject) {\r\n    var firstDayOfWeek = startDayOfWeek || 0;\r\n    var firstOfMonth = new Date(year, ruleObject.month[0] - 1, 1);\r\n    var lastOfMonth = new Date(year, ruleObject.month[0] - 1, 0);\r\n    var numberOfDaysInMonth = lastOfMonth.getDate();\r\n    var firstWeekDay = (firstOfMonth.getDay() - firstDayOfWeek + 7) % 7;\r\n    var used = firstWeekDay + numberOfDaysInMonth;\r\n    var count = Math.ceil(used / 7) - 1;\r\n    var dayData = monthCollection[week][count];\r\n    var chDate = new Date(dayData);\r\n    var state = validateRules(chDate, ruleObject);\r\n    return (state) ? count : count - 1;\r\n}\r\n/**\r\n * To process date collection based on Byset position after process the collection based on BYDAY property value index: EX:BYDAY=1SUm-1SU\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDateCollectionBasedonBySetPos(monthCollection, state, startDate, endDate, data, ruleObject) {\r\n    if (monthCollection.length > 0) {\r\n        for (var week = 0; week < monthCollection.length; week++) {\r\n            monthCollection[week].sort();\r\n            var expectedDays = ruleObject.day;\r\n            var isHavingNumber = expectedDays.map(function (item) { return HASNUMBER.test(item); });\r\n            var weekIndex = (ruleObject.freq === 'YEARLY' && (ruleObject.validRules.indexOf('BYMONTH') > -1) &&\r\n                !(isHavingNumber.indexOf(true) > -1)) ?\r\n                weekCount(new Date(monthCollection[0][0]).getFullYear(), 0, monthCollection, week, ruleObject)\r\n                : (monthCollection[week].length + ruleObject.setPosition);\r\n            var index = ((ruleObject.setPosition < 1) ? weekIndex : ruleObject.setPosition - 1);\r\n            var dayData = monthCollection[week][index];\r\n            insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\r\n        }\r\n    }\r\n}\r\n/**\r\n * To insert datas into existing collection which is processed from previous loop.\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} index Accepts the index value\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) {\r\n    if (monthCollection.length > 0) {\r\n        index = !isNullOrUndefined(index) ? index :\r\n            ((ruleObject.setPosition < 1)\r\n                ? (monthCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);\r\n        monthCollection[index].sort();\r\n        for (var week = 0; week < monthCollection[index].length; week++) {\r\n            var dayData = monthCollection[index][week];\r\n            insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Internal method to compare dates\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @returns {boolean} Returns the result of checking start and end dates\r\n * @private\r\n */\r\nfunction compareDates(startDate, endDate) {\r\n    return endDate ? (startDate <= endDate) : true;\r\n}\r\n/**\r\n * Internal method to get day string\r\n *\r\n * @param {string} expectedDays Accepts the exception date string\r\n * @returns {string} Returns the valid string\r\n * @private\r\n */\r\nfunction getDayString(expectedDays) {\r\n    // To get BYDAY value without numeric value\r\n    var newstr = expectedDays.replace(REMOVENUMBERINSTRING, '');\r\n    return newstr;\r\n}\r\n/**\r\n * Internal method to check day index\r\n *\r\n * @param {number} day Accepts the day index\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {boolean} Returns the index date\r\n * @private\r\n */\r\nfunction checkDayIndex(day, expectedDays) {\r\n    var sortedExpectedDays = [];\r\n    expectedDays.forEach(function (element) {\r\n        var expectedDaysNumberSplit = element.match(SPLITNUMBERANDSTRING);\r\n        if (expectedDaysNumberSplit.length === 2) {\r\n            sortedExpectedDays.push(expectedDaysNumberSplit[1]);\r\n        }\r\n        else {\r\n            sortedExpectedDays.push(expectedDaysNumberSplit[0]);\r\n        }\r\n    });\r\n    return (sortedExpectedDays.indexOf(DAYINDEX[day]) === -1);\r\n}\r\n/**\r\n * Internal method to get start date of week\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {Date} Return the week start date\r\n * @private\r\n */\r\nfunction getStartDateForWeek(startDate, expectedDays) {\r\n    var tempDate = new Date(startDate.getTime());\r\n    var newstr;\r\n    if (expectedDays.length > 0) {\r\n        var expectedDaysArr = [];\r\n        for (var i = 0; i <= expectedDays.length - 1; i++) {\r\n            newstr = getDayString(expectedDays[i]);\r\n            expectedDaysArr.push(newstr);\r\n        }\r\n        if (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {\r\n            do {\r\n                tempDate.setDate(tempDate.getDate() + 1);\r\n            } while (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1);\r\n        }\r\n    }\r\n    return tempDate;\r\n}\r\n/**\r\n * Method to generate recurrence rule object from given rule\r\n *\r\n * @param {string} rules Accepts the recurrence rule\r\n * @returns {RecRule} Returns the recurrence rule object\r\n */\r\nexport function extractObjectFromRule(rules) {\r\n    var ruleObject = {\r\n        freq: null,\r\n        interval: 1,\r\n        count: null,\r\n        until: null,\r\n        day: [],\r\n        wkst: null,\r\n        month: [],\r\n        weekNo: [],\r\n        monthDay: [],\r\n        yearDay: [],\r\n        setPosition: null,\r\n        validRules: []\r\n    };\r\n    var rulesList = rules.split(';');\r\n    var splitData = [];\r\n    var temp;\r\n    rulesList.forEach(function (data) {\r\n        splitData = data.split('=');\r\n        switch (splitData[0]) {\r\n            case 'UNTIL':\r\n                temp = splitData[1];\r\n                ruleObject.until = getDateFromRecurrenceDateString(temp);\r\n                break;\r\n            case 'BYDAY':\r\n                ruleObject.day = splitData[1].split(',');\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYMONTHDAY':\r\n                ruleObject.monthDay = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYMONTH':\r\n                ruleObject.month = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYYEARDAY':\r\n                ruleObject.yearDay = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYWEEKNO':\r\n                ruleObject.weekNo = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'INTERVAL':\r\n                ruleObject.interval = parseInt(splitData[1], 10);\r\n                break;\r\n            case 'COUNT':\r\n                ruleObject.count = parseInt(splitData[1], 10);\r\n                break;\r\n            case 'BYSETPOS':\r\n                ruleObject.setPosition = parseInt(splitData[1], 10) > 4 ? -1 : parseInt(splitData[1], 10);\r\n                break;\r\n            case 'FREQ':\r\n                ruleObject.freq = splitData[1];\r\n                break;\r\n            case 'WKST':\r\n                ruleObject.wkst = splitData[1];\r\n                break;\r\n        }\r\n    });\r\n    if ((ruleObject.freq === 'MONTHLY') && (ruleObject.monthDay.length === 0)) {\r\n        var index = ruleObject.validRules.indexOf('BYDAY');\r\n        ruleObject.validRules.splice(index, 1);\r\n    }\r\n    return ruleObject;\r\n}\r\n/**\r\n * Internal method to validate proper date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number} data Accepts the data value\r\n * @param {Date} startDate Accepts the start date\r\n * @returns {boolean} Returns the result of date validate\r\n * @private\r\n */\r\nfunction validateProperDate(tempDate, data, startDate) {\r\n    var maxDate = calendarUtil.getMonthDaysCount(tempDate);\r\n    return (data <= maxDate) && (tempDate >= startDate);\r\n}\r\n/**\r\n * Internal method to process week days\r\n *\r\n * @param {string[]} expectedDays Accepts the expection dates\r\n * @returns {Object} Returns the weekdays object\r\n * @private\r\n */\r\nfunction processWeekDays(expectedDays) {\r\n    var dayCycle = {};\r\n    expectedDays.forEach(function (element, index) {\r\n        if (index === expectedDays.length - 1) {\r\n            var startIndex = dayIndex.indexOf(element);\r\n            var temp = startIndex;\r\n            while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {\r\n                temp++;\r\n            }\r\n            dayCycle[element] = temp - startIndex;\r\n        }\r\n        else {\r\n            dayCycle[element] = dayIndex.indexOf(expectedDays[(index + 1)]) - dayIndex.indexOf(element);\r\n        }\r\n    });\r\n    return dayCycle;\r\n}\r\n/**\r\n * Internal method to check date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedDate Accepts the exception dates\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\r\nfunction checkDate(tempDate, expectedDate) {\r\n    var temp = expectedDate.slice(0);\r\n    var data;\r\n    var maxDate = calendarUtil.getMonthDaysCount(tempDate);\r\n    data = temp.shift();\r\n    while (data) {\r\n        if (data < 0) {\r\n            data = data + maxDate + 1;\r\n        }\r\n        if (data === tempDate.getDate()) {\r\n            return false;\r\n        }\r\n        data = temp.shift();\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Internal method to check the year value\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedyearDay Accepts the exception dates in year\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\r\nfunction checkYear(tempDate, expectedyearDay) {\r\n    var temp = expectedyearDay.slice(0);\r\n    var data;\r\n    var yearDay = getYearDay(tempDate);\r\n    data = temp.shift();\r\n    while (data) {\r\n        if (data < 0) {\r\n            data = data + calendarUtil.getYearDaysCount(tempDate, 0) + 1;\r\n        }\r\n        if (data === yearDay) {\r\n            return false;\r\n        }\r\n        data = temp.shift();\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Internal method to get the year day\r\n *\r\n * @param {Date} currentDate Accepts the date value\r\n * @returns {number} Returns the boolean value\r\n * @private\r\n */\r\nfunction getYearDay(currentDate) {\r\n    if (!startDateCollection[calendarUtil.getFullYear(currentDate)]) {\r\n        startDateCollection[calendarUtil.getFullYear(currentDate)] = calendarUtil.getYearLastDate(currentDate, 0);\r\n    }\r\n    var tempDate = startDateCollection[calendarUtil.getFullYear(currentDate)];\r\n    var diff = currentDate.getTime() - tempDate.getTime();\r\n    return Math.ceil(diff / MS_PER_DAY);\r\n}\r\n/**\r\n * Internal method to validate monthly rule type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {MonthlyType} Returns the monthly type object\r\n * @private\r\n */\r\nfunction validateMonthlyRuleType(ruleObject) {\r\n    if (ruleObject.monthDay.length && !ruleObject.day.length) {\r\n        return 'date';\r\n    }\r\n    else if (!ruleObject.monthDay.length && ruleObject.day.length) {\r\n        return 'day';\r\n    }\r\n    return 'both';\r\n}\r\n/**\r\n * Internal method to re-order the week days based on first day of week\r\n *\r\n * @param {string[]} days Accepts the week days value\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction rotate(days) {\r\n    var data = days.shift();\r\n    days.push(data);\r\n}\r\n/**\r\n * Internal method to set first day of week\r\n *\r\n * @param {string} day Accepts the first day string\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction setFirstDayOfWeek(day) {\r\n    while (dayIndex[0] !== day) {\r\n        rotate(dayIndex);\r\n    }\r\n}\r\n/**\r\n * Internal method to validate recurrence rule\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\r\nfunction validateRules(tempDate, ruleObject) {\r\n    var state = true;\r\n    var expectedDays = ruleObject.day;\r\n    var expectedMonth = ruleObject.month;\r\n    var expectedDate = calendarUtil.getExpectedDays(tempDate, ruleObject.monthDay);\r\n    var expectedyearDay = ruleObject.yearDay;\r\n    ruleObject.validRules.forEach(function (rule) {\r\n        switch (rule) {\r\n            case 'BYDAY':\r\n                if (checkDayIndex(tempDate.getDay(), expectedDays)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n            case 'BYMONTH':\r\n                if (calendarUtil.checkMonth(tempDate, expectedMonth)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n            case 'BYMONTHDAY':\r\n                if (checkDate(tempDate, expectedDate)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n            case 'BYYEARDAY':\r\n                if (checkYear(tempDate, expectedyearDay)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n        }\r\n    });\r\n    return state;\r\n}\r\n/**\r\n * Internal method to get calendar util\r\n *\r\n * @param {CalendarType} calendarMode Accepts the calendar type object\r\n * @returns {CalendarUtil} Returns the calendar util object\r\n * @private\r\n */\r\nexport function getCalendarUtil(calendarMode) {\r\n    if (calendarMode === 'Islamic') {\r\n        return new Islamic();\r\n    }\r\n    return new Gregorian();\r\n}\r\nvar startDateCollection = {};\r\nvar tempExcludeDate;\r\nvar dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\r\nvar maxOccurrence;\r\nvar tempViewDate;\r\nvar calendarUtil;\r\nvar DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\r\nvar MAXOCCURRENCE = 43;\r\nvar WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];\r\nvar TIMES = 'summaryTimes';\r\nvar ON = 'summaryOn';\r\nvar EVERY = 'every';\r\nvar UNTIL = 'summaryUntil';\r\nvar DAYS = 'summaryDay';\r\nvar WEEKS = 'summaryWeek';\r\nvar MONTHS = 'summaryMonth';\r\nvar YEARS = 'summaryYear';\r\nvar DAYINDEXOBJECT = {\r\n    SU: 'sun',\r\n    MO: 'mon',\r\n    TU: 'tue',\r\n    WE: 'wed',\r\n    TH: 'thu',\r\n    FR: 'fri',\r\n    SA: 'sat'\r\n};\r\n// To check string has number\r\nvar HASNUMBER = /\\d/;\r\n// To find the numbers in string\r\nvar REMOVENUMBERINSTRING = /[^A-Z]+/;\r\n// To split number and string\r\nvar SPLITNUMBERANDSTRING = /[a-z]+|[^a-z]+/gi;\r\n/**\r\n * Method to generate string from date\r\n *\r\n * @param {Date} date Accepts the date value\r\n * @returns {string} Returns the string value\r\n */\r\nexport function getRecurrenceStringFromDate(date) {\r\n    return [date.getUTCFullYear(),\r\n        roundDateValues(date.getUTCMonth() + 1),\r\n        roundDateValues(date.getUTCDate()),\r\n        'T',\r\n        roundDateValues(date.getUTCHours()),\r\n        roundDateValues(date.getUTCMinutes()),\r\n        roundDateValues(date.getUTCSeconds()),\r\n        'Z'].join('');\r\n}\r\n/**\r\n * Internal method to round the date values\r\n *\r\n * @param {string | number} date Accepts the date value in either string or number format\r\n * @returns {string} Returns the date value in string format\r\n * @private\r\n */\r\nfunction roundDateValues(date) {\r\n    return ('0' + date).slice(-2);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}