{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/mutationobserver\n */\n\n/* globals window */\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { startsWithFiller, getDataWithoutFiller } from '../filler';\nimport { isEqualWith } from 'lodash-es';\n/**\n * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view\n * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.\n * Because all mutated nodes are marked as \"to be rendered\" and the\n * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the\n * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor\n * will block all changes which are not handled.\n *\n * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and\n * mutations on elements which do not have corresponding view elements. Also\n * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\n\nexport default class MutationObserver extends Observer {\n  constructor(view) {\n    super(view);\n    /**\n     * Native mutation observer config.\n     *\n     * @private\n     * @member {Object}\n     */\n\n    this._config = {\n      childList: true,\n      characterData: true,\n      characterDataOldValue: true,\n      subtree: true\n    };\n    /**\n     * Reference to the {@link module:engine/view/view~View#domConverter}.\n     *\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n\n    this.domConverter = view.domConverter;\n    /**\n     * Reference to the {@link module:engine/view/view~View#_renderer}.\n     *\n     * @member {module:engine/view/renderer~Renderer}\n     */\n\n    this.renderer = view._renderer;\n    /**\n     * Observed DOM elements.\n     *\n     * @private\n     * @member {Array.<HTMLElement>}\n     */\n\n    this._domElements = [];\n    /**\n     * Native mutation observer.\n     *\n     * @private\n     * @member {MutationObserver}\n     */\n\n    this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));\n  }\n  /**\n   * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.\n   * At the same time empties the queue so mutations will not be fired twice.\n   */\n\n\n  flush() {\n    this._onMutations(this._mutationObserver.takeRecords());\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  observe(domElement) {\n    this._domElements.push(domElement);\n\n    if (this.isEnabled) {\n      this._mutationObserver.observe(domElement, this._config);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  enable() {\n    super.enable();\n\n    for (const domElement of this._domElements) {\n      this._mutationObserver.observe(domElement, this._config);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  disable() {\n    super.disable();\n\n    this._mutationObserver.disconnect();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    super.destroy();\n\n    this._mutationObserver.disconnect();\n  }\n  /**\n   * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.\n   *\n   * @private\n   * @param {Array.<Object>} domMutations Array of native mutations.\n   */\n\n\n  _onMutations(domMutations) {\n    // As a result of this.flush() we can have an empty collection.\n    if (domMutations.length === 0) {\n      return;\n    }\n\n    const domConverter = this.domConverter; // Use map and set for deduplication.\n\n    const mutatedTexts = new Map();\n    const mutatedElements = new Set(); // Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the\n    // element with changed structure anyway.\n\n    for (const mutation of domMutations) {\n      if (mutation.type === 'childList') {\n        const element = domConverter.mapDomToView(mutation.target); // Do not collect mutations from UIElements and RawElements.\n\n        if (element && (element.is('uiElement') || element.is('rawElement'))) {\n          continue;\n        }\n\n        if (element && !this._isBogusBrMutation(mutation)) {\n          mutatedElements.add(element);\n        }\n      }\n    } // Handle `characterData` mutations later, when we have the full list of nodes which changed structure.\n\n\n    for (const mutation of domMutations) {\n      const element = domConverter.mapDomToView(mutation.target); // Do not collect mutations from UIElements and RawElements.\n\n      if (element && (element.is('uiElement') || element.is('rawElement'))) {\n        continue;\n      }\n\n      if (mutation.type === 'characterData') {\n        const text = domConverter.findCorrespondingViewText(mutation.target);\n\n        if (text && !mutatedElements.has(text.parent)) {\n          // Use text as a key, for deduplication. If there will be another mutation on the same text element\n          // we will have only one in the map.\n          mutatedTexts.set(text, {\n            type: 'text',\n            oldText: text.data,\n            newText: getDataWithoutFiller(mutation.target),\n            node: text\n          });\n        } // When we added first letter to the text node which had only inline filler, for the DOM it is mutation\n        // on text, but for the view, where filler text node did not existed, new text node was created, so we\n        // need to fire 'children' mutation instead of 'text'.\n        else if (!text && startsWithFiller(mutation.target)) {\n          mutatedElements.add(domConverter.mapDomToView(mutation.target.parentNode));\n        }\n      }\n    } // Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the\n    // same node multiple times in case of duplication.\n    // List of mutations we will fire.\n\n\n    const viewMutations = [];\n\n    for (const mutatedText of mutatedTexts.values()) {\n      this.renderer.markToSync('text', mutatedText.node);\n      viewMutations.push(mutatedText);\n    }\n\n    for (const viewElement of mutatedElements) {\n      const domElement = domConverter.mapViewToDom(viewElement);\n      const viewChildren = Array.from(viewElement.getChildren());\n      const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {\n        withChildren: false\n      })); // It may happen that as a result of many changes (sth was inserted and then removed),\n      // both elements haven't really changed. #1031\n\n      if (!isEqualWith(viewChildren, newViewChildren, sameNodes)) {\n        this.renderer.markToSync('children', viewElement);\n        viewMutations.push({\n          type: 'children',\n          oldChildren: viewChildren,\n          newChildren: newViewChildren,\n          node: viewElement\n        });\n      }\n    } // Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.\n    // There should not be simultaneous mutation in multiple documents, so it's fine.\n\n\n    const domSelection = domMutations[0].target.ownerDocument.getSelection();\n    let viewSelection = null;\n\n    if (domSelection && domSelection.anchorNode) {\n      // If `domSelection` is inside a dom node that is already bound to a view node from view tree, get\n      // corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may\n      // be used by features handling mutations.\n      // Only one range is supported.\n      const viewSelectionAnchor = domConverter.domPositionToView(domSelection.anchorNode, domSelection.anchorOffset);\n      const viewSelectionFocus = domConverter.domPositionToView(domSelection.focusNode, domSelection.focusOffset); // Anchor and focus has to be properly mapped to view.\n\n      if (viewSelectionAnchor && viewSelectionFocus) {\n        viewSelection = new ViewSelection(viewSelectionAnchor);\n        viewSelection.setFocus(viewSelectionFocus);\n      }\n    } // In case only non-relevant mutations were recorded it skips the event and force render (#5600).\n\n\n    if (viewMutations.length) {\n      this.document.fire('mutations', viewMutations, viewSelection); // If nothing changes on `mutations` event, at this point we have \"dirty DOM\" (changed) and de-synched\n      // view (which has not been changed). In order to \"reset DOM\" we render the view again.\n\n      this.view.forceRender();\n    }\n\n    function sameNodes(child1, child2) {\n      // First level of comparison (array of children vs array of children) â€“ use the Lodash's default behavior.\n      if (Array.isArray(child1)) {\n        return;\n      } // Elements.\n\n\n      if (child1 === child2) {\n        return true;\n      } // Texts.\n      else if (child1.is('$text') && child2.is('$text')) {\n        return child1.data === child2.data;\n      } // Not matching types.\n\n\n      return false;\n    }\n  }\n  /**\n   * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.\n   * Such mutations are generated while pressing space or performing native spellchecker correction\n   * on the end of the block element in Firefox browser.\n   *\n   * @private\n   * @param {Object} mutation Native mutation object.\n   * @returns {Boolean}\n   */\n\n\n  _isBogusBrMutation(mutation) {\n    let addedNode = null; // Check if mutation added only one node on the end of its parent.\n\n    if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {\n      addedNode = this.domConverter.domToView(mutation.addedNodes[0], {\n        withChildren: false\n      });\n    }\n\n    return addedNode && addedNode.is('element', 'br');\n  }\n\n}\n/**\n * Fired when mutation occurred. If tree view is not changed on this event, DOM will be reverted to the state before\n * mutation, so all changes which should be applied, should be handled on this event.\n *\n * Introduced by {@link module:engine/view/observer/mutationobserver~MutationObserver}.\n *\n * Note that because {@link module:engine/view/observer/mutationobserver~MutationObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @event module:engine/view/document~Document#event:mutations\n * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|module:engine/view/observer/mutationobserver~MutatedChildren>}\n * viewMutations Array of mutations.\n * For mutated texts it will be {@link module:engine/view/observer/mutationobserver~MutatedText} and for mutated elements it will be\n * {@link module:engine/view/observer/mutationobserver~MutatedChildren}. You can recognize the type based on the `type` property.\n * @param {module:engine/view/selection~Selection|null} viewSelection View selection that is a result of converting DOM selection to view.\n * Keep in\n * mind that the DOM selection is already \"updated\", meaning that it already acknowledges changes done in mutation.\n */\n\n/**\n * Mutation item for text.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedText\n *\n * @property {String} type For text mutations it is always 'text'.\n * @property {module:engine/view/text~Text} node Mutated text node.\n * @property {String} oldText Old text.\n * @property {String} newText New text.\n */\n\n/**\n * Mutation item for child nodes.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedText\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @property {String} type For child nodes mutations it is always 'children'.\n * @property {module:engine/view/element~Element} node Parent of the mutated children.\n * @property {Array.<module:engine/view/node~Node>} oldChildren Old child nodes.\n * @property {Array.<module:engine/view/node~Node>} newChildren New child nodes.\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mutationobserver.js"],"names":["Observer","ViewSelection","startsWithFiller","getDataWithoutFiller","isEqualWith","MutationObserver","constructor","view","_config","childList","characterData","characterDataOldValue","subtree","domConverter","renderer","_renderer","_domElements","_mutationObserver","window","_onMutations","bind","flush","takeRecords","observe","domElement","push","isEnabled","enable","disable","disconnect","destroy","domMutations","length","mutatedTexts","Map","mutatedElements","Set","mutation","type","element","mapDomToView","target","is","_isBogusBrMutation","add","text","findCorrespondingViewText","has","parent","set","oldText","data","newText","node","parentNode","viewMutations","mutatedText","values","markToSync","viewElement","mapViewToDom","viewChildren","Array","from","getChildren","newViewChildren","domChildrenToView","withChildren","sameNodes","oldChildren","newChildren","domSelection","ownerDocument","getSelection","viewSelection","anchorNode","viewSelectionAnchor","domPositionToView","anchorOffset","viewSelectionFocus","focusNode","focusOffset","setFocus","document","fire","forceRender","child1","child2","isArray","addedNode","nextSibling","removedNodes","addedNodes","domToView"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/mutationobserver\n */\n\n/* globals window */\n\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { startsWithFiller, getDataWithoutFiller } from '../filler';\nimport { isEqualWith } from 'lodash-es';\n\n/**\n * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view\n * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.\n * Because all mutated nodes are marked as \"to be rendered\" and the\n * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the\n * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor\n * will block all changes which are not handled.\n *\n * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and\n * mutations on elements which do not have corresponding view elements. Also\n * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class MutationObserver extends Observer {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * Native mutation observer config.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._config = {\n\t\t\tchildList: true,\n\t\t\tcharacterData: true,\n\t\t\tcharacterDataOldValue: true,\n\t\t\tsubtree: true\n\t\t};\n\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/view~View#domConverter}.\n\t\t *\n\t\t * @member {module:engine/view/domconverter~DomConverter}\n\t\t */\n\t\tthis.domConverter = view.domConverter;\n\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/view~View#_renderer}.\n\t\t *\n\t\t * @member {module:engine/view/renderer~Renderer}\n\t\t */\n\t\tthis.renderer = view._renderer;\n\n\t\t/**\n\t\t * Observed DOM elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Array.<HTMLElement>}\n\t\t */\n\t\tthis._domElements = [];\n\n\t\t/**\n\t\t * Native mutation observer.\n\t\t *\n\t\t * @private\n\t\t * @member {MutationObserver}\n\t\t */\n\t\tthis._mutationObserver = new window.MutationObserver( this._onMutations.bind( this ) );\n\t}\n\n\t/**\n\t * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.\n\t * At the same time empties the queue so mutations will not be fired twice.\n\t */\n\tflush() {\n\t\tthis._onMutations( this._mutationObserver.takeRecords() );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve( domElement ) {\n\t\tthis._domElements.push( domElement );\n\n\t\tif ( this.isEnabled ) {\n\t\t\tthis._mutationObserver.observe( domElement, this._config );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tenable() {\n\t\tsuper.enable();\n\n\t\tfor ( const domElement of this._domElements ) {\n\t\t\tthis._mutationObserver.observe( domElement, this._config );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisable() {\n\t\tsuper.disable();\n\n\t\tthis._mutationObserver.disconnect();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._mutationObserver.disconnect();\n\t}\n\n\t/**\n\t * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.\n\t *\n\t * @private\n\t * @param {Array.<Object>} domMutations Array of native mutations.\n\t */\n\t_onMutations( domMutations ) {\n\t\t// As a result of this.flush() we can have an empty collection.\n\t\tif ( domMutations.length === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst domConverter = this.domConverter;\n\n\t\t// Use map and set for deduplication.\n\t\tconst mutatedTexts = new Map();\n\t\tconst mutatedElements = new Set();\n\n\t\t// Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the\n\t\t// element with changed structure anyway.\n\t\tfor ( const mutation of domMutations ) {\n\t\t\tif ( mutation.type === 'childList' ) {\n\t\t\t\tconst element = domConverter.mapDomToView( mutation.target );\n\n\t\t\t\t// Do not collect mutations from UIElements and RawElements.\n\t\t\t\tif ( element && ( element.is( 'uiElement' ) || element.is( 'rawElement' ) ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( element && !this._isBogusBrMutation( mutation ) ) {\n\t\t\t\t\tmutatedElements.add( element );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle `characterData` mutations later, when we have the full list of nodes which changed structure.\n\t\tfor ( const mutation of domMutations ) {\n\t\t\tconst element = domConverter.mapDomToView( mutation.target );\n\n\t\t\t// Do not collect mutations from UIElements and RawElements.\n\t\t\tif ( element && ( element.is( 'uiElement' ) || element.is( 'rawElement' ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( mutation.type === 'characterData' ) {\n\t\t\t\tconst text = domConverter.findCorrespondingViewText( mutation.target );\n\n\t\t\t\tif ( text && !mutatedElements.has( text.parent ) ) {\n\t\t\t\t\t// Use text as a key, for deduplication. If there will be another mutation on the same text element\n\t\t\t\t\t// we will have only one in the map.\n\t\t\t\t\tmutatedTexts.set( text, {\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\toldText: text.data,\n\t\t\t\t\t\tnewText: getDataWithoutFiller( mutation.target ),\n\t\t\t\t\t\tnode: text\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// When we added first letter to the text node which had only inline filler, for the DOM it is mutation\n\t\t\t\t// on text, but for the view, where filler text node did not existed, new text node was created, so we\n\t\t\t\t// need to fire 'children' mutation instead of 'text'.\n\t\t\t\telse if ( !text && startsWithFiller( mutation.target ) ) {\n\t\t\t\t\tmutatedElements.add( domConverter.mapDomToView( mutation.target.parentNode ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the\n\t\t// same node multiple times in case of duplication.\n\n\t\t// List of mutations we will fire.\n\t\tconst viewMutations = [];\n\n\t\tfor ( const mutatedText of mutatedTexts.values() ) {\n\t\t\tthis.renderer.markToSync( 'text', mutatedText.node );\n\t\t\tviewMutations.push( mutatedText );\n\t\t}\n\n\t\tfor ( const viewElement of mutatedElements ) {\n\t\t\tconst domElement = domConverter.mapViewToDom( viewElement );\n\t\t\tconst viewChildren = Array.from( viewElement.getChildren() );\n\t\t\tconst newViewChildren = Array.from( domConverter.domChildrenToView( domElement, { withChildren: false } ) );\n\n\t\t\t// It may happen that as a result of many changes (sth was inserted and then removed),\n\t\t\t// both elements haven't really changed. #1031\n\t\t\tif ( !isEqualWith( viewChildren, newViewChildren, sameNodes ) ) {\n\t\t\t\tthis.renderer.markToSync( 'children', viewElement );\n\n\t\t\t\tviewMutations.push( {\n\t\t\t\t\ttype: 'children',\n\t\t\t\t\toldChildren: viewChildren,\n\t\t\t\t\tnewChildren: newViewChildren,\n\t\t\t\t\tnode: viewElement\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\t// Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.\n\t\t// There should not be simultaneous mutation in multiple documents, so it's fine.\n\t\tconst domSelection = domMutations[ 0 ].target.ownerDocument.getSelection();\n\n\t\tlet viewSelection = null;\n\n\t\tif ( domSelection && domSelection.anchorNode ) {\n\t\t\t// If `domSelection` is inside a dom node that is already bound to a view node from view tree, get\n\t\t\t// corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may\n\t\t\t// be used by features handling mutations.\n\t\t\t// Only one range is supported.\n\n\t\t\tconst viewSelectionAnchor = domConverter.domPositionToView( domSelection.anchorNode, domSelection.anchorOffset );\n\t\t\tconst viewSelectionFocus = domConverter.domPositionToView( domSelection.focusNode, domSelection.focusOffset );\n\n\t\t\t// Anchor and focus has to be properly mapped to view.\n\t\t\tif ( viewSelectionAnchor && viewSelectionFocus ) {\n\t\t\t\tviewSelection = new ViewSelection( viewSelectionAnchor );\n\t\t\t\tviewSelection.setFocus( viewSelectionFocus );\n\t\t\t}\n\t\t}\n\n\t\t// In case only non-relevant mutations were recorded it skips the event and force render (#5600).\n\t\tif ( viewMutations.length ) {\n\t\t\tthis.document.fire( 'mutations', viewMutations, viewSelection );\n\n\t\t\t// If nothing changes on `mutations` event, at this point we have \"dirty DOM\" (changed) and de-synched\n\t\t\t// view (which has not been changed). In order to \"reset DOM\" we render the view again.\n\t\t\tthis.view.forceRender();\n\t\t}\n\n\t\tfunction sameNodes( child1, child2 ) {\n\t\t\t// First level of comparison (array of children vs array of children) â€“ use the Lodash's default behavior.\n\t\t\tif ( Array.isArray( child1 ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Elements.\n\t\t\tif ( child1 === child2 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Texts.\n\t\t\telse if ( child1.is( '$text' ) && child2.is( '$text' ) ) {\n\t\t\t\treturn child1.data === child2.data;\n\t\t\t}\n\n\t\t\t// Not matching types.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.\n\t * Such mutations are generated while pressing space or performing native spellchecker correction\n\t * on the end of the block element in Firefox browser.\n\t *\n\t * @private\n\t * @param {Object} mutation Native mutation object.\n\t * @returns {Boolean}\n\t */\n\t_isBogusBrMutation( mutation ) {\n\t\tlet addedNode = null;\n\n\t\t// Check if mutation added only one node on the end of its parent.\n\t\tif ( mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1 ) {\n\t\t\taddedNode = this.domConverter.domToView( mutation.addedNodes[ 0 ], {\n\t\t\t\twithChildren: false\n\t\t\t} );\n\t\t}\n\n\t\treturn addedNode && addedNode.is( 'element', 'br' );\n\t}\n}\n\n/**\n * Fired when mutation occurred. If tree view is not changed on this event, DOM will be reverted to the state before\n * mutation, so all changes which should be applied, should be handled on this event.\n *\n * Introduced by {@link module:engine/view/observer/mutationobserver~MutationObserver}.\n *\n * Note that because {@link module:engine/view/observer/mutationobserver~MutationObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @event module:engine/view/document~Document#event:mutations\n * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|module:engine/view/observer/mutationobserver~MutatedChildren>}\n * viewMutations Array of mutations.\n * For mutated texts it will be {@link module:engine/view/observer/mutationobserver~MutatedText} and for mutated elements it will be\n * {@link module:engine/view/observer/mutationobserver~MutatedChildren}. You can recognize the type based on the `type` property.\n * @param {module:engine/view/selection~Selection|null} viewSelection View selection that is a result of converting DOM selection to view.\n * Keep in\n * mind that the DOM selection is already \"updated\", meaning that it already acknowledges changes done in mutation.\n */\n\n/**\n * Mutation item for text.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedText\n *\n * @property {String} type For text mutations it is always 'text'.\n * @property {module:engine/view/text~Text} node Mutated text node.\n * @property {String} oldText Old text.\n * @property {String} newText New text.\n */\n\n/**\n * Mutation item for child nodes.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedText\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @property {String} type For child nodes mutations it is always 'children'.\n * @property {module:engine/view/element~Element} node Parent of the mutated children.\n * @property {Array.<module:engine/view/node~Node>} oldChildren Old child nodes.\n * @property {Array.<module:engine/view/node~Node>} newChildren New child nodes.\n */\n"]},"metadata":{},"sourceType":"module"}