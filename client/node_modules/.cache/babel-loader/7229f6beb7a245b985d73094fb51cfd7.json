{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/node\n */\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays'; // To check if component is loaded more than once.\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Model node. Most basic structure of model tree.\n *\n * This is an abstract class that is a base for other classes representing different nodes in model.\n *\n * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.\n * However, it is **very important** that nodes already attached to model tree should be only changed through\n * {@link module:engine/model/writer~Writer Writer API}.\n *\n * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or\n * {@link module:engine/model/node~Node#_setAttribute _setAttribute}\n * do not generate {@link module:engine/model/operation/operation~Operation operations}\n * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.\n *\n * The flow of working on `Node` (and classes that inherits from it) is as such:\n * 1. You can create a `Node` instance, modify it using it's API.\n * 2. Add `Node` to the model using `Batch` API.\n * 3. Change `Node` that was already added to the model using `Batch` API.\n *\n * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception\n * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.\n *\n * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because\n * the information about `Node` is still kept in model document.\n *\n * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and\n * follows same rules.\n */\n\nexport default class Node {\n  /**\n   * Creates a model node.\n   *\n   * This is an abstract class, so this constructor should not be used directly.\n   *\n   * @abstract\n   * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n   */\n  constructor(attrs) {\n    /**\n     * Parent of this node. It could be {@link module:engine/model/element~Element}\n     * or {@link module:engine/model/documentfragment~DocumentFragment}.\n     * Equals to `null` if the node has no parent.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n    this.parent = null;\n    /**\n     * Attributes set on this node.\n     *\n     * @private\n     * @member {Map} module:engine/model/node~Node#_attrs\n     */\n\n    this._attrs = toMap(attrs);\n  }\n  /**\n   * Index of this node in it's parent or `null` if the node has no parent.\n   *\n   * Accessing this property throws an error if this node's parent element does not contain it.\n   * This means that model tree got broken.\n   *\n   * @readonly\n   * @type {Number|null}\n   */\n\n\n  get index() {\n    let pos;\n\n    if (!this.parent) {\n      return null;\n    }\n\n    if ((pos = this.parent.getChildIndex(this)) === null) {\n      throw new CKEditorError('model-node-not-found-in-parent', this);\n    }\n\n    return pos;\n  }\n  /**\n   * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}\n   * of all it's previous siblings. Equals to `null` if node has no parent.\n   *\n   * Accessing this property throws an error if this node's parent element does not contain it.\n   * This means that model tree got broken.\n   *\n   * @readonly\n   * @type {Number|null}\n   */\n\n\n  get startOffset() {\n    let pos;\n\n    if (!this.parent) {\n      return null;\n    }\n\n    if ((pos = this.parent.getChildStartOffset(this)) === null) {\n      throw new CKEditorError('model-node-not-found-in-parent', this);\n    }\n\n    return pos;\n  }\n  /**\n   * Offset size of this node. Represents how much \"offset space\" is occupied by the node in it's parent.\n   * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position\n   * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more\n   * than one entity, i.e. {@link module:engine/model/text~Text text node}.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get offsetSize() {\n    return 1;\n  }\n  /**\n   * Offset at which this node ends in it's parent. It is equal to the sum of this node's\n   * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.\n   * Equals to `null` if the node has no parent.\n   *\n   * @readonly\n   * @type {Number|null}\n   */\n\n\n  get endOffset() {\n    if (!this.parent) {\n      return null;\n    }\n\n    return this.startOffset + this.offsetSize;\n  }\n  /**\n   * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|null}\n   */\n\n\n  get nextSibling() {\n    const index = this.index;\n    return index !== null && this.parent.getChild(index + 1) || null;\n  }\n  /**\n   * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|null}\n   */\n\n\n  get previousSibling() {\n    const index = this.index;\n    return index !== null && this.parent.getChild(index - 1) || null;\n  }\n  /**\n   * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part\n   * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  get root() {\n    let root = this; // eslint-disable-line consistent-this\n\n    while (root.parent) {\n      root = root.parent;\n    }\n\n    return root;\n  }\n  /**\n   * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).\n   *\n   * @returns {Boolean}\n   */\n\n\n  isAttached() {\n    return this.root.is('rootElement');\n  }\n  /**\n   * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,\n   * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to\n   * create {@link module:engine/model/position~Position Position} instance.\n   *\n   *\t\tconst abc = new Text( 'abc' );\n   *\t\tconst foo = new Text( 'foo' );\n   *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n   *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n   *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n   *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n   *\t\th1.getPath(); // Returns [ 0 ].\n   *\t\tdiv.getPath(); // Returns [].\n   *\n   * @returns {Array.<Number>} The path.\n   */\n\n\n  getPath() {\n    const path = [];\n    let node = this; // eslint-disable-line consistent-this\n\n    while (node.parent) {\n      path.unshift(node.startOffset);\n      node = node.parent;\n    }\n\n    return path;\n  }\n  /**\n   * Returns ancestors array of this node.\n   *\n   * @param {Object} options Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n   * otherwise root element will be the first item in the array.\n   * @returns {Array} Array with ancestors.\n   */\n\n\n  getAncestors() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      includeSelf: false,\n      parentFirst: false\n    };\n    const ancestors = [];\n    let parent = options.includeSelf ? this : this.parent;\n\n    while (parent) {\n      ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n      parent = parent.parent;\n    }\n\n    return ancestors;\n  }\n  /**\n   * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n   * which is a common ancestor of both nodes.\n   *\n   * @param {module:engine/model/node~Node} node The second node.\n   * @param {Object} options Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n   * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n   * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n\n\n  getCommonAncestor(node) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const ancestorsA = this.getAncestors(options);\n    const ancestorsB = node.getAncestors(options);\n    let i = 0;\n\n    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n      i++;\n    }\n\n    return i === 0 ? null : ancestorsA[i - 1];\n  }\n  /**\n   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n   *\n   * @param {module:engine/model/node~Node} node Node to compare with.\n   * @returns {Boolean}\n   */\n\n\n  isBefore(node) {\n    // Given node is not before this node if they are same.\n    if (this == node) {\n      return false;\n    } // Return `false` if it is impossible to compare nodes.\n\n\n    if (this.root !== node.root) {\n      return false;\n    }\n\n    const thisPath = this.getPath();\n    const nodePath = node.getPath();\n    const result = compareArrays(thisPath, nodePath);\n\n    switch (result) {\n      case 'prefix':\n        return true;\n\n      case 'extension':\n        return false;\n\n      default:\n        return thisPath[result] < nodePath[result];\n    }\n  }\n  /**\n   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n   *\n   * @param {module:engine/model/node~Node} node Node to compare with.\n   * @returns {Boolean}\n   */\n\n\n  isAfter(node) {\n    // Given node is not before this node if they are same.\n    if (this == node) {\n      return false;\n    } // Return `false` if it is impossible to compare nodes.\n\n\n    if (this.root !== node.root) {\n      return false;\n    } // In other cases, just check if the `node` is before, and return the opposite.\n\n\n    return !this.isBefore(node);\n  }\n  /**\n   * Checks if the node has an attribute with given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.\n   */\n\n\n  hasAttribute(key) {\n    return this._attrs.has(key);\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on node.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n\n\n  getAttribute(key) {\n    return this._attrs.get(key);\n  }\n  /**\n   * Returns iterator that iterates over this node's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  getAttributes() {\n    return this._attrs.entries();\n  }\n  /**\n   * Returns iterator that iterates over this node's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  getAttributeKeys() {\n    return this._attrs.keys();\n  }\n  /**\n   * Converts `Node` to plain object and returns it.\n   *\n   * @returns {Object} `Node` converted to plain object.\n   */\n\n\n  toJSON() {\n    const json = {}; // Serializes attributes to the object.\n    // attributes = { a: 'foo', b: 1, c: true }.\n\n    if (this._attrs.size) {\n      json.attributes = Array.from(this._attrs).reduce((result, attr) => {\n        result[attr[0]] = attr[1];\n        return result;\n      }, {});\n    }\n\n    return json;\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   * This method is useful when processing model objects that are of unknown type. For example, a function\n   * may return a {@link module:engine/model/documentfragment~DocumentFragment} or a {@link module:engine/model/node~Node}\n   * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n   *\n   *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n   *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n   *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n   *\n   * Since this method is also available on a range of view objects, you can prefix the type of the object with\n   * `model:` or `view:` to check, for example, if this is the model's or view's element:\n   *\n   *\t\tmodelElement.is( 'model:element' ); // -> true\n   *\t\tmodelElement.is( 'view:element' ); // -> false\n   *\n   * By using this method it is also possible to check a name of an element:\n   *\n   *\t\timageElement.is( 'element', 'imageBlock' ); // -> true\n   *\t\timageElement.is( 'element', 'imageBlock' ); // -> same as above\n   *\t\timageElement.is( 'model:element', 'imageBlock' ); // -> same as above, but more precise\n   *\n   * The list of model objects which implement the `is()` method:\n   *\n   * * {@link module:engine/model/node~Node#is `Node#is()`}\n   * * {@link module:engine/model/text~Text#is `Text#is()`}\n   * * {@link module:engine/model/element~Element#is `Element#is()`}\n   * * {@link module:engine/model/rootelement~RootElement#is `RootElement#is()`}\n   * * {@link module:engine/model/position~Position#is `Position#is()`}\n   * * {@link module:engine/model/liveposition~LivePosition#is `LivePosition#is()`}\n   * * {@link module:engine/model/range~Range#is `Range#is()`}\n   * * {@link module:engine/model/liverange~LiveRange#is `LiveRange#is()`}\n   * * {@link module:engine/model/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n   * * {@link module:engine/model/selection~Selection#is `Selection#is()`}\n   * * {@link module:engine/model/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n   * * {@link module:engine/model/markercollection~Marker#is `Marker#is()`}\n   * * {@link module:engine/model/textproxy~TextProxy#is `TextProxy#is()`}\n   *\n   * @method #is\n   * @param {String} type Type to check.\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'node' || type === 'model:node';\n  }\n  /**\n   * Creates a copy of this node, that is a node with exactly same attributes, and returns it.\n   *\n   * @protected\n   * @returns {module:engine/model/node~Node} Node with same attributes as this node.\n   */\n\n\n  _clone() {\n    return new Node(this._attrs);\n  }\n  /**\n   * Removes this node from it's parent.\n   *\n   * @see module:engine/model/writer~Writer#remove\n   * @protected\n   */\n\n\n  _remove() {\n    this.parent._removeChildren(this.index);\n  }\n  /**\n   * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.\n   *\n   * @see module:engine/model/writer~Writer#setAttribute\n   * @protected\n   * @param {String} key Key of attribute to set.\n   * @param {*} value Attribute value.\n   */\n\n\n  _setAttribute(key, value) {\n    this._attrs.set(key, value);\n  }\n  /**\n   * Removes all attributes from the node and sets given attributes.\n   *\n   * @see module:engine/model/writer~Writer#setAttributes\n   * @protected\n   * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.\n   */\n\n\n  _setAttributesTo(attrs) {\n    this._attrs = toMap(attrs);\n  }\n  /**\n   * Removes an attribute with given key from the node.\n   *\n   * @see module:engine/model/writer~Writer#removeAttribute\n   * @protected\n   * @param {String} key Key of attribute to remove.\n   * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.\n   */\n\n\n  _removeAttribute(key) {\n    return this._attrs.delete(key);\n  }\n  /**\n   * Removes all attributes from the node.\n   *\n   * @see module:engine/model/writer~Writer#clearAttributes\n   * @protected\n   */\n\n\n  _clearAttributes() {\n    this._attrs.clear();\n  }\n\n}\n/**\n * The node's parent does not contain this node.\n *\n * @error model-node-not-found-in-parent\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js"],"names":["toMap","CKEditorError","compareArrays","Node","constructor","attrs","parent","_attrs","index","pos","getChildIndex","startOffset","getChildStartOffset","offsetSize","endOffset","nextSibling","getChild","previousSibling","root","isAttached","is","getPath","path","node","unshift","getAncestors","options","includeSelf","parentFirst","ancestors","getCommonAncestor","ancestorsA","ancestorsB","i","isBefore","thisPath","nodePath","result","isAfter","hasAttribute","key","has","getAttribute","get","getAttributes","entries","getAttributeKeys","keys","toJSON","json","size","attributes","Array","from","reduce","attr","type","_clone","_remove","_removeChildren","_setAttribute","value","set","_setAttributesTo","_removeAttribute","delete","_clearAttributes","clear"],"mappings":"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AsBA,IAAI,CAAE,CAAF,CAA1B;AAEA,eAAOlB,MAAP;AACA,OAJiB,EAIf,EAJe,CAAlB;AAKA;;AAED,WAAOY,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC7B,EAAAA,EAAE,CAAEoC,IAAF,EAAS;AACV,WAAOA,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,YAAnC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,MAAM,GAAG;AACR,WAAO,IAAItD,IAAJ,CAAU,KAAKI,MAAf,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCmD,EAAAA,OAAO,GAAG;AACT,SAAKpD,MAAL,CAAYqD,eAAZ,CAA6B,KAAKnD,KAAlC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCoD,EAAAA,aAAa,CAAEpB,GAAF,EAAOqB,KAAP,EAAe;AAC3B,SAAKtD,MAAL,CAAYuD,GAAZ,CAAiBtB,GAAjB,EAAsBqB,KAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,gBAAgB,CAAE1D,KAAF,EAAU;AACzB,SAAKE,MAAL,GAAcP,KAAK,CAAEK,KAAF,CAAnB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC2D,EAAAA,gBAAgB,CAAExB,GAAF,EAAQ;AACvB,WAAO,KAAKjC,MAAL,CAAY0D,MAAZ,CAAoBzB,GAApB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC0B,EAAAA,gBAAgB,GAAG;AAClB,SAAK3D,MAAL,CAAY4D,KAAZ;AACA;;AAxcwB;AA2c1B;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/node\n */\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Model node. Most basic structure of model tree.\n *\n * This is an abstract class that is a base for other classes representing different nodes in model.\n *\n * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.\n * However, it is **very important** that nodes already attached to model tree should be only changed through\n * {@link module:engine/model/writer~Writer Writer API}.\n *\n * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or\n * {@link module:engine/model/node~Node#_setAttribute _setAttribute}\n * do not generate {@link module:engine/model/operation/operation~Operation operations}\n * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.\n *\n * The flow of working on `Node` (and classes that inherits from it) is as such:\n * 1. You can create a `Node` instance, modify it using it's API.\n * 2. Add `Node` to the model using `Batch` API.\n * 3. Change `Node` that was already added to the model using `Batch` API.\n *\n * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception\n * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.\n *\n * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because\n * the information about `Node` is still kept in model document.\n *\n * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and\n * follows same rules.\n */\nexport default class Node {\n\t/**\n\t * Creates a model node.\n\t *\n\t * This is an abstract class, so this constructor should not be used directly.\n\t *\n\t * @abstract\n\t * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\tconstructor( attrs ) {\n\t\t/**\n\t\t * Parent of this node. It could be {@link module:engine/model/element~Element}\n\t\t * or {@link module:engine/model/documentfragment~DocumentFragment}.\n\t\t * Equals to `null` if the node has no parent.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t\t */\n\t\tthis.parent = null;\n\n\t\t/**\n\t\t * Attributes set on this node.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/node~Node#_attrs\n\t\t */\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Index of this node in it's parent or `null` if the node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget index() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildIndex( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}\n\t * of all it's previous siblings. Equals to `null` if node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget startOffset() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildStartOffset( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset size of this node. Represents how much \"offset space\" is occupied by the node in it's parent.\n\t * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position\n\t * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more\n\t * than one entity, i.e. {@link module:engine/model/text~Text text node}.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget offsetSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Offset at which this node ends in it's parent. It is equal to the sum of this node's\n\t * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.\n\t * Equals to `null` if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget endOffset() {\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.startOffset + this.offsetSize;\n\t}\n\n\t/**\n\t * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nextSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index + 1 ) ) || null;\n\t}\n\n\t/**\n\t * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget previousSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index - 1 ) ) || null;\n\t}\n\n\t/**\n\t * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part\n\t * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\tlet root = this; // eslint-disable-line consistent-this\n\n\t\twhile ( root.parent ) {\n\t\t\troot = root.parent;\n\t\t}\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).\n\t *\n\t * @returns {Boolean}\n\t */\n\tisAttached() {\n\t\treturn this.root.is( 'rootElement' );\n\t}\n\n\t/**\n\t * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,\n\t * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to\n\t * create {@link module:engine/model/position~Position Position} instance.\n\t *\n\t *\t\tconst abc = new Text( 'abc' );\n\t *\t\tconst foo = new Text( 'foo' );\n\t *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n\t *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n\t *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n\t *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n\t *\t\th1.getPath(); // Returns [ 0 ].\n\t *\t\tdiv.getPath(); // Returns [].\n\t *\n\t * @returns {Array.<Number>} The path.\n\t */\n\tgetPath() {\n\t\tconst path = [];\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\twhile ( node.parent ) {\n\t\t\tpath.unshift( node.startOffset );\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this node.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both nodes.\n\t *\n\t * @param {module:engine/model/node~Node} node The second node.\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n\t * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( node, options = {} ) {\n\t\tconst ancestorsA = this.getAncestors( options );\n\t\tconst ancestorsB = node.getAncestors( options );\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisBefore( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisPath = this.getPath();\n\t\tconst nodePath = node.getPath();\n\n\t\tconst result = compareArrays( thisPath, nodePath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn true;\n\n\t\t\tcase 'extension':\n\t\t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < nodePath[ result ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisAfter( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In other cases, just check if the `node` is before, and return the opposite.\n\t\treturn !this.isBefore( node );\n\t}\n\n\t/**\n\t * Checks if the node has an attribute with given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on node.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Converts `Node` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = {};\n\n\t\t// Serializes attributes to the object.\n\t\t// attributes = { a: 'foo', b: 1, c: true }.\n\t\tif ( this._attrs.size ) {\n\t\t\tjson.attributes = Array.from( this._attrs ).reduce( ( result, attr ) => {\n\t\t\t\tresult[ attr[ 0 ] ] = attr[ 1 ];\n\n\t\t\t\treturn result;\n\t\t\t}, {} );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t * This method is useful when processing model objects that are of unknown type. For example, a function\n\t * may return a {@link module:engine/model/documentfragment~DocumentFragment} or a {@link module:engine/model/node~Node}\n\t * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n\t *\n\t *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n\t *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n\t *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n\t *\n\t * Since this method is also available on a range of view objects, you can prefix the type of the object with\n\t * `model:` or `view:` to check, for example, if this is the model's or view's element:\n\t *\n\t *\t\tmodelElement.is( 'model:element' ); // -> true\n\t *\t\tmodelElement.is( 'view:element' ); // -> false\n\t *\n\t * By using this method it is also possible to check a name of an element:\n\t *\n\t *\t\timageElement.is( 'element', 'imageBlock' ); // -> true\n\t *\t\timageElement.is( 'element', 'imageBlock' ); // -> same as above\n\t *\t\timageElement.is( 'model:element', 'imageBlock' ); // -> same as above, but more precise\n\t *\n\t * The list of model objects which implement the `is()` method:\n\t *\n\t * * {@link module:engine/model/node~Node#is `Node#is()`}\n\t * * {@link module:engine/model/text~Text#is `Text#is()`}\n\t * * {@link module:engine/model/element~Element#is `Element#is()`}\n\t * * {@link module:engine/model/rootelement~RootElement#is `RootElement#is()`}\n\t * * {@link module:engine/model/position~Position#is `Position#is()`}\n\t * * {@link module:engine/model/liveposition~LivePosition#is `LivePosition#is()`}\n\t * * {@link module:engine/model/range~Range#is `Range#is()`}\n\t * * {@link module:engine/model/liverange~LiveRange#is `LiveRange#is()`}\n\t * * {@link module:engine/model/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n\t * * {@link module:engine/model/selection~Selection#is `Selection#is()`}\n\t * * {@link module:engine/model/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n\t * * {@link module:engine/model/markercollection~Marker#is `Marker#is()`}\n\t * * {@link module:engine/model/textproxy~TextProxy#is `TextProxy#is()`}\n\t *\n\t * @method #is\n\t * @param {String} type Type to check.\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'node' || type === 'model:node';\n\t}\n\n\t/**\n\t * Creates a copy of this node, that is a node with exactly same attributes, and returns it.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/node~Node} Node with same attributes as this node.\n\t */\n\t_clone() {\n\t\treturn new Node( this._attrs );\n\t}\n\n\t/**\n\t * Removes this node from it's parent.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t */\n\t_remove() {\n\t\tthis.parent._removeChildren( this.index );\n\t}\n\n\t/**\n\t * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._attrs.set( key, value );\n\t}\n\n\t/**\n\t * Removes all attributes from the node and sets given attributes.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttributes\n\t * @protected\n\t * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\t_setAttributesTo( attrs ) {\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#removeAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to remove.\n\t * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.\n\t */\n\t_removeAttribute( key ) {\n\t\treturn this._attrs.delete( key );\n\t}\n\n\t/**\n\t * Removes all attributes from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#clearAttributes\n\t * @protected\n\t */\n\t_clearAttributes() {\n\t\tthis._attrs.clear();\n\t}\n}\n\n/**\n * The node's parent does not contain this node.\n *\n * @error model-node-not-found-in-parent\n */\n"]},"metadata":{},"sourceType":"module"}