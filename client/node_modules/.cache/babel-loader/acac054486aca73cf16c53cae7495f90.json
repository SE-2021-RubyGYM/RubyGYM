{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/element\n */\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable'; // @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );\n\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends module:engine/model/node~Node\n */\n\nexport default class Element extends Node {\n  /**\n   * Creates a model element.\n   *\n   * **Note:** Constructor of this class shouldn't be used directly in the code.\n   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n   *\n   * @protected\n   * @param {String} name Element's name.\n   * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n   * One or more nodes to be inserted as children of created element.\n   */\n  constructor(name, attrs, children) {\n    super(attrs);\n    /**\n     * Element name.\n     *\n     * @readonly\n     * @member {String} module:engine/model/element~Element#name\n     */\n\n    this.name = name;\n    /**\n     * List of children nodes.\n     *\n     * @private\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n     */\n\n    this._children = new NodeList();\n\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Number of this element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get maxOffset() {\n    return this._children.maxOffset;\n  }\n  /**\n   * Is `true` if there are no nodes inside this element, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isEmpty() {\n    return this.childCount === 0;\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\telement.is( 'element' ); // -> true\n   *\t\telement.is( 'node' ); // -> true\n   *\t\telement.is( 'model:element' ); // -> true\n   *\t\telement.is( 'model:node' ); // -> true\n   *\n   *\t\telement.is( 'view:element' ); // -> false\n   *\t\telement.is( 'documentSelection' ); // -> false\n   *\n   * Assuming that the object being checked is an element, you can also check its\n   * {@link module:engine/model/element~Element#name name}:\n   *\n   *\t\telement.is( 'element', 'imageBlock' ); // -> true if this is an <imageBlock> element\n   *\t\telement.is( 'element', 'imageBlock' ); // -> same as above\n   *\t\ttext.is( 'element', 'imageBlock' ); -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type Type to check.\n   * @param {String} [name] Element name.\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (!name) {\n      return type === 'element' || type === 'model:element' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n      type === 'node' || type === 'model:node';\n    }\n\n    return name === this.name && (type === 'element' || type === 'model:element');\n  }\n  /**\n   * Gets the child at the given index.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/model/node~Node} Child node.\n   */\n\n\n  getChild(index) {\n    return this._children.getNode(index);\n  }\n  /**\n   * Returns an iterator that iterates over all of this element's children.\n   *\n   * @returns {Iterable.<module:engine/model/node~Node>}\n   */\n\n\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number} Child node's index in this element.\n   */\n\n\n  getChildIndex(node) {\n    return this._children.getNodeIndex(node);\n  }\n  /**\n   * Returns the starting offset of given child. Starting offset is equal to the sum of\n   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n   * given node is not a child of this element.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number} Child node's starting offset.\n   */\n\n\n  getChildStartOffset(node) {\n    return this._children.getNodeStartOffset(node);\n  }\n  /**\n   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n   * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n   *\n   *\t\tconst textNode = new Text( 'foo' );\n   *\t\tconst pElement = new Element( 'p' );\n   *\t\tconst divElement = new Element( [ textNode, pElement ] );\n   *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n   *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n   *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n   *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n   *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n   *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n   *\n   * @param {Number} offset Offset to look for.\n   * @returns {Number}\n   */\n\n\n  offsetToIndex(offset) {\n    return this._children.offsetToIndex(offset);\n  }\n  /**\n   * Returns a descendant node by its path relative to this element.\n   *\n   *\t\t// <this>a<b>c</b></this>\n   *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n   *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n   *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n   *\n   * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n   * @returns {module:engine/model/node~Node}\n   */\n\n\n  getNodeByPath(relativePath) {\n    let node = this; // eslint-disable-line consistent-this\n\n    for (const index of relativePath) {\n      node = node.getChild(node.offsetToIndex(index));\n    }\n\n    return node;\n  }\n  /**\n   * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.\n   *\n   * @param {String} parentName The name of the parent element to find.\n   * @param {Object} [options] Options object.\n   * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included while searching.\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  findAncestor(parentName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      includeSelf: false\n    };\n    let parent = options.includeSelf ? this : this.parent;\n\n    while (parent) {\n      if (parent.name === parentName) {\n        return parent;\n      }\n\n      parent = parent.parent;\n    }\n\n    return null;\n  }\n  /**\n   * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n   *\n   * @returns {Object} `Element` instance converted to plain object.\n   */\n\n\n  toJSON() {\n    const json = super.toJSON();\n    json.name = this.name;\n\n    if (this._children.length > 0) {\n      json.children = [];\n\n      for (const node of this._children) {\n        json.children.push(node.toJSON());\n      }\n    }\n\n    return json;\n  }\n  /**\n   * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n   *\n   * @protected\n   * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n   * element will be cloned without any child.\n   */\n\n\n  _clone() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const children = deep ? Array.from(this._children).map(node => node._clone(true)) : null;\n    return new Element(this.name, this.getAttributes(), children);\n  }\n  /**\n   * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n   *\n   * @see module:engine/model/writer~Writer#append\n   * @protected\n   * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.\n   */\n\n\n  _appendChild(nodes) {\n    this._insertChild(this.childCount, nodes);\n  }\n  /**\n   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n   * to this element.\n   *\n   * @see module:engine/model/writer~Writer#insert\n   * @protected\n   * @param {Number} index Index at which nodes should be inserted.\n   * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n   */\n\n\n  _insertChild(index, items) {\n    const nodes = normalize(items);\n\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n\n      node.parent = this;\n    }\n\n    this._children._insertNodes(index, nodes);\n  }\n  /**\n   * Removes one or more nodes starting at the given index and sets\n   * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n   *\n   * @see module:engine/model/writer~Writer#remove\n   * @protected\n   * @param {Number} index Index of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n   */\n\n\n  _removeChildren(index) {\n    let howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    const nodes = this._children._removeNodes(index, howMany);\n\n    for (const node of nodes) {\n      node.parent = null;\n    }\n\n    return nodes;\n  }\n  /**\n   * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n   * Converts `Element` children to proper nodes.\n   *\n   * @param {Object} json Plain object to be converted to `Element`.\n   * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n   */\n\n\n  static fromJSON(json) {\n    let children = null;\n\n    if (json.children) {\n      children = [];\n\n      for (const child of json.children) {\n        if (child.name) {\n          // If child has name property, it is an Element.\n          children.push(Element.fromJSON(child));\n        } else {\n          // Otherwise, it is a Text node.\n          children.push(Text.fromJSON(child));\n        }\n      }\n    }\n\n    return new Element(json.name, json.attributes, children);\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn `<${ this.rootName || this.name }>`;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // log() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelElement: ' + this );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logExtended() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( `ModelElement: ${ this }, ${ this.childCount } children,\n  // @if CK_DEBUG_ENGINE //\t\tattrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logAll() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( '--------------------' );\n  // @if CK_DEBUG_ENGINE //\n  // @if CK_DEBUG_ENGINE // \tthis.logExtended();\n  // @if CK_DEBUG_ENGINE //\tconsole.log( 'List of children:' );\n  // @if CK_DEBUG_ENGINE //\n  // @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n  // @if CK_DEBUG_ENGINE // \t\tchild.log();\n  // @if CK_DEBUG_ENGINE // \t}\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // printTree( level = 0) {\n  // @if CK_DEBUG_ENGINE // \tlet string = '';\n  // @if CK_DEBUG_ENGINE // \tstring += '\\t'.repeat( level );\n  // @if CK_DEBUG_ENGINE // \tstring += `<${ this.rootName || this.name }${ convertMapToTags( this.getAttributes() ) }>`;\n  // @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n  // @if CK_DEBUG_ENGINE // \t\tstring += '\\n';\n  // @if CK_DEBUG_ENGINE // \t\tif ( child.is( '$text' ) ) {\n  // @if CK_DEBUG_ENGINE // \t\t\tconst textAttrs = convertMapToTags( child._attrs );\n  // @if CK_DEBUG_ENGINE // \t\t\tstring += '\\t'.repeat( level + 1 );\n  // @if CK_DEBUG_ENGINE // \t\t\tif ( textAttrs !== '' ) {\n  // @if CK_DEBUG_ENGINE // \t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n  // @if CK_DEBUG_ENGINE // \t\t\t} else {\n  // @if CK_DEBUG_ENGINE // \t\t\t\tstring += child.data;\n  // @if CK_DEBUG_ENGINE // \t\t\t}\n  // @if CK_DEBUG_ENGINE // \t\t} else {\n  // @if CK_DEBUG_ENGINE // \t\t\tstring += child.printTree( level + 1 );\n  // @if CK_DEBUG_ENGINE // \t\t}\n  // @if CK_DEBUG_ENGINE // \t}\n  // @if CK_DEBUG_ENGINE // \tif ( this.childCount ) {\n  // @if CK_DEBUG_ENGINE // \t\tstring += '\\n' + '\\t'.repeat( level );\n  // @if CK_DEBUG_ENGINE // \t}\n  // @if CK_DEBUG_ENGINE // \tstring += `</${ this.rootName || this.name }>`;\n  // @if CK_DEBUG_ENGINE // \treturn string;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logTree() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n  // @if CK_DEBUG_ENGINE // }\n\n\n} // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\n\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(node.data, node.getAttributes());\n    }\n\n    return node;\n  });\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/element.js"],"names":["Node","NodeList","Text","TextProxy","isIterable","Element","constructor","name","attrs","children","_children","_insertChild","childCount","length","maxOffset","isEmpty","is","type","getChild","index","getNode","getChildren","Symbol","iterator","getChildIndex","node","getNodeIndex","getChildStartOffset","getNodeStartOffset","offsetToIndex","offset","getNodeByPath","relativePath","findAncestor","parentName","options","includeSelf","parent","toJSON","json","push","_clone","deep","Array","from","map","getAttributes","_appendChild","nodes","items","normalize","_remove","_insertNodes","_removeChildren","howMany","_removeNodes","fromJSON","child","attributes","data"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/element\n */\n\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n// @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );\n\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends module:engine/model/node~Node\n */\nexport default class Element extends Node {\n\t/**\n\t * Creates a model element.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n\t *\n\t * @protected\n\t * @param {String} name Element's name.\n\t * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * One or more nodes to be inserted as children of created element.\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper( attrs );\n\n\t\t/**\n\t\t * Element name.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} module:engine/model/element~Element#name\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * List of children nodes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Number of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this element, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\telement.is( 'element' ); // -> true\n\t *\t\telement.is( 'node' ); // -> true\n\t *\t\telement.is( 'model:element' ); // -> true\n\t *\t\telement.is( 'model:node' ); // -> true\n\t *\n\t *\t\telement.is( 'view:element' ); // -> false\n\t *\t\telement.is( 'documentSelection' ); // -> false\n\t *\n\t * Assuming that the object being checked is an element, you can also check its\n\t * {@link module:engine/model/element~Element#name name}:\n\t *\n\t *\t\telement.is( 'element', 'imageBlock' ); // -> true if this is an <imageBlock> element\n\t *\t\telement.is( 'element', 'imageBlock' ); // -> same as above\n\t *\t\ttext.is( 'element', 'imageBlock' ); -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type Type to check.\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type === 'element' || type === 'model:element' ||\n\t\t\t\t// From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n\t\t\t\ttype === 'node' || type === 'model:node';\n\t\t}\n\n\t\treturn name === this.name && ( type === 'element' || type === 'model:element' );\n\t}\n\n\t/**\n\t * Gets the child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this element's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's index in this element.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst divElement = new Element( [ textNode, pElement ] );\n\t *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number}\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.\n\t *\n\t * @param {String} parentName The name of the parent element to find.\n\t * @param {Object} [options] Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included while searching.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tfindAncestor( parentName, options = { includeSelf: false } ) {\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( parent.name === parentName ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n\t *\n\t * @returns {Object} `Element` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tjson.name = this.name;\n\n\t\tif ( this._children.length > 0 ) {\n\t\t\tjson.children = [];\n\n\t\t\tfor ( const node of this._children ) {\n\t\t\t\tjson.children.push( node.toJSON() );\n\t\t\t}\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n\t * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n\t *\n\t * @protected\n\t * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any child.\n\t */\n\t_clone( deep = false ) {\n\t\tconst children = deep ? Array.from( this._children ).map( node => node._clone( true ) ) : null;\n\n\t\treturn new Element( this.name, this.getAttributes(), children );\n\t}\n\n\t/**\n\t * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n\t *\n\t * @see module:engine/model/writer~Writer#append\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.\n\t */\n\t_appendChild( nodes ) {\n\t\tthis._insertChild( this.childCount, nodes );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this element.\n\t *\n\t * @see module:engine/model/writer~Writer#insert\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index and sets\n\t * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `Element` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `Element`.\n\t * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tlet children = null;\n\n\t\tif ( json.children ) {\n\t\t\tchildren = [];\n\n\t\t\tfor ( const child of json.children ) {\n\t\t\t\tif ( child.name ) {\n\t\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Element( json.name, json.attributes, children );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `<${ this.rootName || this.name }>`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelElement: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logExtended() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( `ModelElement: ${ this }, ${ this.childCount } children,\n\t// @if CK_DEBUG_ENGINE //\t\tattrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logAll() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( '--------------------' );\n\t// @if CK_DEBUG_ENGINE //\n\t// @if CK_DEBUG_ENGINE // \tthis.logExtended();\n\t// @if CK_DEBUG_ENGINE //\tconsole.log( 'List of children:' );\n\t// @if CK_DEBUG_ENGINE //\n\t// @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE // \t\tchild.log();\n\t// @if CK_DEBUG_ENGINE // \t}\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // printTree( level = 0) {\n\t// @if CK_DEBUG_ENGINE // \tlet string = '';\n\n\t// @if CK_DEBUG_ENGINE // \tstring += '\\t'.repeat( level );\n\t// @if CK_DEBUG_ENGINE // \tstring += `<${ this.rootName || this.name }${ convertMapToTags( this.getAttributes() ) }>`;\n\n\t// @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE // \t\tstring += '\\n';\n\n\t// @if CK_DEBUG_ENGINE // \t\tif ( child.is( '$text' ) ) {\n\t// @if CK_DEBUG_ENGINE // \t\t\tconst textAttrs = convertMapToTags( child._attrs );\n\n\t// @if CK_DEBUG_ENGINE // \t\t\tstring += '\\t'.repeat( level + 1 );\n\n\t// @if CK_DEBUG_ENGINE // \t\t\tif ( textAttrs !== '' ) {\n\t// @if CK_DEBUG_ENGINE // \t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n\t// @if CK_DEBUG_ENGINE // \t\t\t} else {\n\t// @if CK_DEBUG_ENGINE // \t\t\t\tstring += child.data;\n\t// @if CK_DEBUG_ENGINE // \t\t\t}\n\t// @if CK_DEBUG_ENGINE // \t\t} else {\n\t// @if CK_DEBUG_ENGINE // \t\t\tstring += child.printTree( level + 1 );\n\t// @if CK_DEBUG_ENGINE // \t\t}\n\t// @if CK_DEBUG_ENGINE // \t}\n\n\t// @if CK_DEBUG_ENGINE // \tif ( this.childCount ) {\n\t// @if CK_DEBUG_ENGINE // \t\tstring += '\\n' + '\\t'.repeat( level );\n\t// @if CK_DEBUG_ENGINE // \t}\n\n\t// @if CK_DEBUG_ENGINE // \tstring += `</${ this.rootName || this.name }>`;\n\n\t// @if CK_DEBUG_ENGINE // \treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]},"metadata":{},"sourceType":"module"}