{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, DOMParser, Text */\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewUIElement from './uielement';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport Matcher from './matcher';\nimport { BR_FILLER, INLINE_FILLER_LENGTH, NBSP_FILLER, MARKED_NBSP_FILLER, getDataWithoutFiller, isInlineFiller, startsWithFiller } from './filler';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nconst BR_FILLER_REF = BR_FILLER(document); // eslint-disable-line new-cap\n\nconst NBSP_FILLER_REF = NBSP_FILLER(document); // eslint-disable-line new-cap\n\nconst MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(document); // eslint-disable-line new-cap\n\n/**\n * `DomConverter` is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements bindings} between these nodes.\n *\n * An instance of the DOM converter is available under\n * {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * The DOM converter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep the\n * state of a tree nor keeps the synchronization between the tree view and the DOM tree (use {@link module:engine/view/document~Document}).\n *\n * The DOM converter keeps DOM elements to view element bindings, so when the converter gets destroyed, the bindings are lost.\n * Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\n\nexport default class DomConverter {\n  /**\n   * Creates a DOM converter.\n   *\n   * @param {module:engine/view/document~Document} document The view document instance.\n   * @param {Object} options An object with configuration options.\n   * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode] The type of the block filler to use.\n   * Default value depends on the options.renderingMode:\n   *  'nbsp' when options.renderingMode == 'data',\n   *  'br' when options.renderingMode == 'editing'.\n   * @param {'data'|'editing'} [options.renderingMode='editing'] Whether to leave the View-to-DOM conversion result unchanged\n   * or improve editing experience by filtering out interactive data.\n   */\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.\n     *\n     * @member {'data'|'editing'} module:engine/view/domconverter~DomConverter#renderingMode\n     */\n\n    this.renderingMode = options.renderingMode || 'editing';\n    /**\n     * Main switch for new rendering approach in the editing view.\n     *\n     * @protected\n     * @member {Boolean}\n     */\n\n    this.experimentalRenderingMode = false;\n    /**\n     * The mode of a block filler used by the DOM converter.\n     *\n     * @member {'br'|'nbsp'|'markedNbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n     */\n\n    this.blockFillerMode = options.blockFillerMode || (this.renderingMode === 'editing' ? 'br' : 'nbsp');\n    /**\n     * Elements which are considered pre-formatted elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n     */\n\n    this.preElements = ['pre'];\n    /**\n     * Elements which are considered block elements (and hence should be filled with a\n     * {@link #isBlockFiller block filler}).\n     *\n     * Whether an element is considered a block element also affects handling of trailing whitespaces.\n     *\n     * You can extend this array if you introduce support for block elements which are not yet recognized here.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n     */\n\n    this.blockElements = ['address', 'article', 'aside', 'blockquote', 'caption', 'center', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'legend', 'li', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'];\n    /**\n     * A list of elements that exist inline (in text) but their inner structure cannot be edited because\n     * of the way they are rendered by the browser. They are mostly HTML form elements but there are other\n     * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.\n     *\n     * Whether an element is considered an inline object has an impact on white space rendering (trimming)\n     * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.\n     *\n     * You can extend this array if you introduce support for inline object elements which are not yet recognized here.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#inlineObjectElements\n     */\n\n    this.inlineObjectElements = ['object', 'iframe', 'input', 'button', 'textarea', 'select', 'option', 'video', 'embed', 'audio', 'img', 'canvas'];\n    /**\n     * The DOM-to-view mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n     */\n\n    this._domToViewMapping = new WeakMap();\n    /**\n     * The view-to-DOM mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n     */\n\n    this._viewToDomMapping = new WeakMap();\n    /**\n     * Holds the mapping between fake selection containers and corresponding view selections.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n     */\n\n    this._fakeSelectionMapping = new WeakMap();\n    /**\n     * Matcher for view elements whose content should be treated as raw data\n     * and not processed during the conversion from DOM nodes to view elements.\n     *\n     * @private\n     * @type {module:engine/view/matcher~Matcher}\n     */\n\n    this._rawContentElementMatcher = new Matcher();\n    /**\n     * A set of encountered raw content DOM nodes. It is used for preventing left trimming of the following text node.\n     *\n     * @private\n     * @type {WeakSet.<Node>}\n     */\n\n    this._encounteredRawContentDomNodes = new WeakSet();\n  }\n  /**\n   * Binds a given DOM element that represents fake selection to a **position** of a\n   * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n   * Document selection copy is stored and can be retrieved by the\n   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n   *\n   * @param {HTMLElement} domElement\n   * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n   */\n\n\n  bindFakeSelection(domElement, viewDocumentSelection) {\n    this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));\n  }\n  /**\n   * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given\n   * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.\n   *\n   * @param {HTMLElement} domElement\n   * @returns {module:engine/view/selection~Selection|undefined}\n   */\n\n\n  fakeSelectionToView(domElement) {\n    return this._fakeSelectionMapping.get(domElement);\n  }\n  /**\n   * Binds DOM and view elements, so it will be possible to get corresponding elements using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {HTMLElement} domElement The DOM element to bind.\n   * @param {module:engine/view/element~Element} viewElement The view element to bind.\n   */\n\n\n  bindElements(domElement, viewElement) {\n    this._domToViewMapping.set(domElement, viewElement);\n\n    this._viewToDomMapping.set(viewElement, domElement);\n  }\n  /**\n   * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of\n   * the DOM element will be unbound too.\n   *\n   * @param {HTMLElement} domElement The DOM element to unbind.\n   */\n\n\n  unbindDomElement(domElement) {\n    const viewElement = this._domToViewMapping.get(domElement);\n\n    if (viewElement) {\n      this._domToViewMapping.delete(domElement);\n\n      this._viewToDomMapping.delete(viewElement);\n\n      for (const child of domElement.childNodes) {\n        this.unbindDomElement(child);\n      }\n    }\n  }\n  /**\n   * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {DocumentFragment} domFragment The DOM document fragment to bind.\n   * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment The view document fragment to bind.\n   */\n\n\n  bindDocumentFragments(domFragment, viewFragment) {\n    this._domToViewMapping.set(domFragment, viewFragment);\n\n    this._viewToDomMapping.set(viewFragment, domFragment);\n  }\n  /**\n   * Decides whether given pair of attribute key and value should be passed further down the pipeline.\n   *\n   * @param {String} attributeKey\n   * @param {String} attributeValue\n   * @returns {Boolean}\n   */\n\n\n  shouldRenderAttribute(attributeKey, attributeValue) {\n    if (!this.experimentalRenderingMode || this.renderingMode === 'data') {\n      return true;\n    }\n\n    return !(attributeKey.toLowerCase().startsWith('on') || attributeValue.match(/(\\b)(on\\S+)(\\s*)=|javascript:|(<\\s*)(\\/*)script/i) || attributeValue.match(/data:(?!image\\/(png|jpeg|gif|webp))/i));\n  }\n  /**\n   * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.\n   *\n   * @param {Element} domElement DOM element that should have `html` set as its content.\n   * @param {String} html Textual representation of the HTML that will be set on `domElement`.\n   */\n\n\n  setContentOf(domElement, html) {\n    // For data pipeline we pass the HTML as-is.\n    if (!this.experimentalRenderingMode || this.renderingMode === 'data') {\n      domElement.innerHTML = html;\n      return;\n    }\n\n    const document = new DOMParser().parseFromString(html, 'text/html');\n    const fragment = document.createDocumentFragment();\n    const bodyChildNodes = document.body.childNodes;\n\n    while (bodyChildNodes.length > 0) {\n      fragment.appendChild(bodyChildNodes[0]);\n    }\n\n    const treeWalker = document.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);\n    const nodes = [];\n    let currentNode; // eslint-disable-next-line no-cond-assign\n\n    while (currentNode = treeWalker.nextNode()) {\n      nodes.push(currentNode);\n    }\n\n    for (const currentNode of nodes) {\n      // Go through nodes to remove those that are prohibited in editing pipeline.\n      for (const attributeName of currentNode.getAttributeNames()) {\n        const attributeValue = currentNode.getAttribute(attributeName);\n\n        if (!this.shouldRenderAttribute(attributeName, attributeValue)) {\n          currentNode.removeAttribute(attributeName);\n        }\n      }\n\n      const elementName = currentNode.tagName.toLowerCase(); // There are certain nodes, that should be renamed to <span> in editing pipeline.\n\n      if (this._shouldRenameElement(elementName)) {\n        currentNode.replaceWith(this._createReplacementDomElement(elementName, currentNode));\n      }\n    } // Empty the target element.\n\n\n    while (domElement.firstChild) {\n      domElement.firstChild.remove();\n    }\n\n    domElement.append(fragment);\n  }\n  /**\n   * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments the method will return corresponding items.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View node or document fragment to transform.\n   * @param {Document} domDocument Document which will be used to create DOM nodes.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n   */\n\n\n  viewToDom(viewNode, domDocument) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (viewNode.is('$text')) {\n      const textData = this._processDataFromViewText(viewNode);\n\n      return domDocument.createTextNode(textData);\n    } else {\n      if (this.mapViewToDom(viewNode)) {\n        return this.mapViewToDom(viewNode);\n      }\n\n      let domElement;\n\n      if (viewNode.is('documentFragment')) {\n        // Create DOM document fragment.\n        domElement = domDocument.createDocumentFragment();\n\n        if (options.bind) {\n          this.bindDocumentFragments(domElement, viewNode);\n        }\n      } else if (viewNode.is('uiElement')) {\n        if (viewNode.name === '$comment') {\n          domElement = domDocument.createComment(viewNode.getCustomProperty('$rawContent'));\n        } else {\n          // UIElement has its own render() method (see #799).\n          domElement = viewNode.render(domDocument, this);\n        }\n\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        }\n\n        return domElement;\n      } else {\n        // Create DOM element.\n        if (this._shouldRenameElement(viewNode.name)) {\n          domElement = this._createReplacementDomElement(viewNode.name);\n        } else if (viewNode.hasAttribute('xmlns')) {\n          domElement = domDocument.createElementNS(viewNode.getAttribute('xmlns'), viewNode.name);\n        } else {\n          domElement = domDocument.createElement(viewNode.name);\n        } // RawElement take care of their children in RawElement#render() method which can be customized\n        // (see https://github.com/ckeditor/ckeditor5/issues/4469).\n\n\n        if (viewNode.is('rawElement')) {\n          viewNode.render(domElement, this);\n        }\n\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        } // Copy element's attributes.\n\n\n        for (const key of viewNode.getAttributeKeys()) {\n          const value = viewNode.getAttribute(key);\n\n          if (!this.shouldRenderAttribute(key, value)) {\n            continue;\n          }\n\n          domElement.setAttribute(key, value);\n        }\n      }\n\n      if (options.withChildren !== false) {\n        for (const child of this.viewChildrenToDom(viewNode, domDocument, options)) {\n          domElement.appendChild(child);\n        }\n      }\n\n      return domElement;\n    }\n  }\n  /**\n   * Converts children of the view element to DOM using the\n   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n   * @param {Document} domDocument Document which will be used to create DOM nodes.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n   * @returns {Iterable.<Node>} DOM nodes.\n   */\n\n\n  *viewChildrenToDom(viewElement, domDocument) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n    let offset = 0;\n\n    for (const childView of viewElement.getChildren()) {\n      if (fillerPositionOffset === offset) {\n        yield this._getBlockFiller(domDocument);\n      }\n\n      yield this.viewToDom(childView, domDocument, options);\n      offset++;\n    }\n\n    if (fillerPositionOffset === offset) {\n      yield this._getBlockFiller(domDocument);\n    }\n  }\n  /**\n   * Converts view {@link module:engine/view/range~Range} to DOM range.\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   *\n   * @param {module:engine/view/range~Range} viewRange View range.\n   * @returns {Range} DOM range.\n   */\n\n\n  viewRangeToDom(viewRange) {\n    const domStart = this.viewPositionToDom(viewRange.start);\n    const domEnd = this.viewPositionToDom(viewRange.end);\n    const domRange = document.createRange();\n    domRange.setStart(domStart.parent, domStart.offset);\n    domRange.setEnd(domEnd.parent, domEnd.offset);\n    return domRange;\n  }\n  /**\n   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n   *\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   * If the converted position is directly before inline filler it is moved inside the filler.\n   *\n   * @param {module:engine/view/position~Position} viewPosition View position.\n   * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n   * @returns {Node} position.parent DOM position parent.\n   * @returns {Number} position.offset DOM position offset.\n   */\n\n\n  viewPositionToDom(viewPosition) {\n    const viewParent = viewPosition.parent;\n\n    if (viewParent.is('$text')) {\n      const domParent = this.findCorrespondingDomText(viewParent);\n\n      if (!domParent) {\n        // Position is in a view text node that has not been rendered to DOM yet.\n        return null;\n      }\n\n      let offset = viewPosition.offset;\n\n      if (startsWithFiller(domParent)) {\n        offset += INLINE_FILLER_LENGTH;\n      }\n\n      return {\n        parent: domParent,\n        offset\n      };\n    } else {\n      // viewParent is instance of ViewElement.\n      let domParent, domBefore, domAfter;\n\n      if (viewPosition.offset === 0) {\n        domParent = this.mapViewToDom(viewParent);\n\n        if (!domParent) {\n          // Position is in a view element that has not been rendered to DOM yet.\n          return null;\n        }\n\n        domAfter = domParent.childNodes[0];\n      } else {\n        const nodeBefore = viewPosition.nodeBefore;\n        domBefore = nodeBefore.is('$text') ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(viewPosition.nodeBefore);\n\n        if (!domBefore) {\n          // Position is after a view element that has not been rendered to DOM yet.\n          return null;\n        }\n\n        domParent = domBefore.parentNode;\n        domAfter = domBefore.nextSibling;\n      } // If there is an inline filler at position return position inside the filler. We should never return\n      // the position before the inline filler.\n\n\n      if (isText(domAfter) && startsWithFiller(domAfter)) {\n        return {\n          parent: domAfter,\n          offset: INLINE_FILLER_LENGTH\n        };\n      }\n\n      const offset = domBefore ? indexOf(domBefore) + 1 : 0;\n      return {\n        parent: domParent,\n        offset\n      };\n    }\n  }\n  /**\n   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments function will return corresponding items. For\n   * {@link module:engine/view/filler fillers} `null` will be returned.\n   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converted to lower case.\n   * @param {Boolean} [options.skipComments=false] If `false`, comment nodes will be converted to `$comment`\n   * {@link module:engine/view/uielement~UIElement view UI elements}.\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n   * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n   */\n\n\n  domToView(domNode) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.isBlockFiller(domNode)) {\n      return null;\n    } // When node is inside a UIElement or a RawElement return that parent as it's view representation.\n\n\n    const hostElement = this.getHostViewElement(domNode);\n\n    if (hostElement) {\n      return hostElement;\n    }\n\n    if (this.isComment(domNode) && options.skipComments) {\n      return null;\n    }\n\n    if (isText(domNode)) {\n      if (isInlineFiller(domNode)) {\n        return null;\n      } else {\n        const textData = this._processDataFromDomText(domNode);\n\n        return textData === '' ? null : new ViewText(this.document, textData);\n      }\n    } else {\n      if (this.mapDomToView(domNode)) {\n        return this.mapDomToView(domNode);\n      }\n\n      let viewElement;\n\n      if (this.isDocumentFragment(domNode)) {\n        // Create view document fragment.\n        viewElement = new ViewDocumentFragment(this.document);\n\n        if (options.bind) {\n          this.bindDocumentFragments(domNode, viewElement);\n        }\n      } else {\n        // Create view element.\n        viewElement = this._createViewElement(domNode, options);\n\n        if (options.bind) {\n          this.bindElements(domNode, viewElement);\n        } // Copy element's attributes.\n\n\n        const attrs = domNode.attributes;\n\n        if (attrs) {\n          for (let i = attrs.length - 1; i >= 0; i--) {\n            viewElement._setAttribute(attrs[i].name, attrs[i].value);\n          }\n        } // Treat this element's content as a raw data if it was registered as such.\n        // Comment node is also treated as an element with raw data.\n\n\n        if (this._isViewElementWithRawContent(viewElement, options) || this.isComment(domNode)) {\n          const rawContent = this.isComment(domNode) ? domNode.data : domNode.innerHTML;\n\n          viewElement._setCustomProperty('$rawContent', rawContent); // Store a DOM node to prevent left trimming of the following text node.\n\n\n          this._encounteredRawContentDomNodes.add(domNode);\n\n          return viewElement;\n        }\n      }\n\n      if (options.withChildren !== false) {\n        for (const child of this.domChildrenToView(domNode, options)) {\n          viewElement._appendChild(child);\n        }\n      }\n\n      return viewElement;\n    }\n  }\n  /**\n   * Converts children of the DOM element to view nodes using\n   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n   *\n   * @param {HTMLElement} domElement Parent DOM element.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n   */\n\n\n  *domChildrenToView(domElement) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (let i = 0; i < domElement.childNodes.length; i++) {\n      const domChild = domElement.childNodes[i];\n      const viewChild = this.domToView(domChild, options);\n\n      if (viewChild !== null) {\n        yield viewChild;\n      }\n    }\n  }\n  /**\n   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n   * Ranges which cannot be converted will be omitted.\n   *\n   * @param {Selection} domSelection DOM selection.\n   * @returns {module:engine/view/selection~Selection} View selection.\n   */\n\n\n  domSelectionToView(domSelection) {\n    // DOM selection might be placed in fake selection container.\n    // If container contains fake selection - return corresponding view selection.\n    if (domSelection.rangeCount === 1) {\n      let container = domSelection.getRangeAt(0).startContainer; // The DOM selection might be moved to the text node inside the fake selection container.\n\n      if (isText(container)) {\n        container = container.parentNode;\n      }\n\n      const viewSelection = this.fakeSelectionToView(container);\n\n      if (viewSelection) {\n        return viewSelection;\n      }\n    }\n\n    const isBackward = this.isDomSelectionBackward(domSelection);\n    const viewRanges = [];\n\n    for (let i = 0; i < domSelection.rangeCount; i++) {\n      // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n      const domRange = domSelection.getRangeAt(i);\n      const viewRange = this.domRangeToView(domRange);\n\n      if (viewRange) {\n        viewRanges.push(viewRange);\n      }\n    }\n\n    return new ViewSelection(viewRanges, {\n      backward: isBackward\n    });\n  }\n  /**\n   * Converts DOM Range to view {@link module:engine/view/range~Range}.\n   * If the start or end position can not be converted `null` is returned.\n   *\n   * @param {Range} domRange DOM range.\n   * @returns {module:engine/view/range~Range|null} View range.\n   */\n\n\n  domRangeToView(domRange) {\n    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);\n    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);\n\n    if (viewStart && viewEnd) {\n      return new ViewRange(viewStart, viewEnd);\n    }\n\n    return null;\n  }\n  /**\n   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n   *\n   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n   * position of the filler will be converted and returned.\n   *\n   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n   * that position will be converted to view position before that UIElement.\n   *\n   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n   *\n   * @param {Node} domParent DOM position parent.\n   * @param {Number} [domOffset=0] DOM position offset. You can skip it when converting the inline filler node.\n   * @returns {module:engine/view/position~Position} viewPosition View position.\n   */\n\n\n  domPositionToView(domParent) {\n    let domOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (this.isBlockFiller(domParent)) {\n      return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n    } // If position is somewhere inside UIElement or a RawElement - return position before that element.\n\n\n    const viewElement = this.mapDomToView(domParent);\n\n    if (viewElement && (viewElement.is('uiElement') || viewElement.is('rawElement'))) {\n      return ViewPosition._createBefore(viewElement);\n    }\n\n    if (isText(domParent)) {\n      if (isInlineFiller(domParent)) {\n        return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n      }\n\n      const viewParent = this.findCorrespondingViewText(domParent);\n      let offset = domOffset;\n\n      if (!viewParent) {\n        return null;\n      }\n\n      if (startsWithFiller(domParent)) {\n        offset -= INLINE_FILLER_LENGTH;\n        offset = offset < 0 ? 0 : offset;\n      }\n\n      return new ViewPosition(viewParent, offset);\n    } // domParent instanceof HTMLElement.\n    else {\n      if (domOffset === 0) {\n        const viewParent = this.mapDomToView(domParent);\n\n        if (viewParent) {\n          return new ViewPosition(viewParent, 0);\n        }\n      } else {\n        const domBefore = domParent.childNodes[domOffset - 1];\n        const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore); // TODO #663\n\n        if (viewBefore && viewBefore.parent) {\n          return new ViewPosition(viewBefore.parent, viewBefore.index + 1);\n        }\n      }\n\n      return null;\n    }\n  }\n  /**\n   * Returns corresponding view {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * to the given DOM - `undefined` is returned.\n   *\n   * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or\n   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n   *\n   * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n   * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n   * Corresponding view element, document fragment or `undefined` if no element was bound.\n   */\n\n\n  mapDomToView(domElementOrDocumentFragment) {\n    const hostElement = this.getHostViewElement(domElementOrDocumentFragment);\n    return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or\n   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n   *\n   * Otherwise `null` is returned.\n   *\n   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n   *\n   * @param {Text} domText DOM text node.\n   * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n   * corresponding node.\n   */\n\n\n  findCorrespondingViewText(domText) {\n    if (isInlineFiller(domText)) {\n      return null;\n    } // If DOM text was rendered by a UIElement or a RawElement - return this parent element.\n\n\n    const hostElement = this.getHostViewElement(domText);\n\n    if (hostElement) {\n      return hostElement;\n    }\n\n    const previousSibling = domText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n    if (previousSibling) {\n      if (!this.isElement(previousSibling)) {\n        // The previous is text or comment.\n        return null;\n      }\n\n      const viewElement = this.mapDomToView(previousSibling);\n\n      if (viewElement) {\n        const nextSibling = viewElement.nextSibling; // It might be filler which has no corresponding view node.\n\n        if (nextSibling instanceof ViewText) {\n          return viewElement.nextSibling;\n        } else {\n          return null;\n        }\n      }\n    } // Try to use parent to find the corresponding text node.\n    else {\n      const viewElement = this.mapDomToView(domText.parentNode);\n\n      if (viewElement) {\n        const firstChild = viewElement.getChild(0); // It might be filler which has no corresponding view node.\n\n        if (firstChild instanceof ViewText) {\n          return firstChild;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n   * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n   * use {@link #findCorrespondingDomText}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View element or document fragment.\n   * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n   */\n\n\n  mapViewToDom(documentFragmentOrElement) {\n    return this._viewToDomMapping.get(documentFragmentOrElement);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * Otherwise `null` is returned.\n   *\n   * @param {module:engine/view/text~Text} viewText View text node.\n   * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n   */\n\n\n  findCorrespondingDomText(viewText) {\n    const previousSibling = viewText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n    if (previousSibling && this.mapViewToDom(previousSibling)) {\n      return this.mapViewToDom(previousSibling).nextSibling;\n    } // If this is a first node, try to use parent to find the corresponding text node.\n\n\n    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {\n      return this.mapViewToDom(viewText.parent).childNodes[0];\n    }\n\n    return null;\n  }\n  /**\n   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n   *\n   * @param {module:engine/view/editableelement~EditableElement} viewEditable\n   */\n\n\n  focus(viewEditable) {\n    const domEditable = this.mapViewToDom(viewEditable);\n\n    if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {\n      // Save the scrollX and scrollY positions before the focus.\n      const {\n        scrollX,\n        scrollY\n      } = global.window;\n      const scrollPositions = []; // Save all scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n\n      forEachDomNodeAncestor(domEditable, node => {\n        const {\n          scrollLeft,\n          scrollTop\n        } = node;\n        scrollPositions.push([scrollLeft, scrollTop]);\n      });\n      domEditable.focus(); // Restore scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n      // https://github.com/ckeditor/ckeditor5-engine/issues/957\n\n      forEachDomNodeAncestor(domEditable, node => {\n        const [scrollLeft, scrollTop] = scrollPositions.shift();\n        node.scrollLeft = scrollLeft;\n        node.scrollTop = scrollTop;\n      }); // Restore the scrollX and scrollY positions after the focus.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n\n      global.window.scrollTo(scrollX, scrollY);\n    }\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isElement(node) {\n    return node && node.nodeType == Node.ELEMENT_NODE;\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isDocumentFragment(node) {\n    return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isComment(node) {\n    return node && node.nodeType == Node.COMMENT_NODE;\n  }\n  /**\n   * Checks if the node is an instance of the block filler for this DOM converter.\n   *\n   *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n   *\n   *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n   *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n   *\n   * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n   *\n   * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n   *\n   * @param {Node} domNode DOM node to check.\n   * @returns {Boolean} True if a node is considered a block filler for given mode.\n   */\n\n\n  isBlockFiller(domNode) {\n    if (this.blockFillerMode == 'br') {\n      return domNode.isEqualNode(BR_FILLER_REF);\n    } // Special case for <p><br></p> in which <br> should be treated as filler even when we are not in the 'br' mode. See ckeditor5#5564.\n\n\n    if (domNode.tagName === 'BR' && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {\n      return true;\n    } // If not in 'br' mode, try recognizing both marked and regular nbsp block fillers.\n\n\n    return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);\n  }\n  /**\n   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n   *\n   * @param {Selection} DOM Selection instance to check.\n   * @returns {Boolean}\n   */\n\n\n  isDomSelectionBackward(selection) {\n    if (selection.isCollapsed) {\n      return false;\n    } // Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n    // we will use the fact that range will collapse if it's end is before it's start.\n\n\n    const range = document.createRange();\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(selection.focusNode, selection.focusOffset);\n    const backward = range.collapsed;\n    range.detach();\n    return backward;\n  }\n  /**\n   * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}\n   * that hosts the provided DOM node. Returns `null` if there is no such parent.\n   *\n   * @param {Node} domNode\n   * @returns {module:engine/view/uielement~UIElement|module:engine/view/rawelement~RawElement|null}\n   */\n\n\n  getHostViewElement(domNode) {\n    const ancestors = getAncestors(domNode); // Remove domNode from the list.\n\n    ancestors.pop();\n\n    while (ancestors.length) {\n      const domNode = ancestors.pop();\n\n      const viewNode = this._domToViewMapping.get(domNode);\n\n      if (viewNode && (viewNode.is('uiElement') || viewNode.is('rawElement'))) {\n        return viewNode;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Checks if the given selection's boundaries are at correct places.\n   *\n   * The following places are considered as incorrect for selection boundaries:\n   *\n   * * before or in the middle of an inline filler sequence,\n   * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},\n   * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.\n   *\n   * @param {Selection} domSelection The DOM selection object to be checked.\n   * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n   */\n\n\n  isDomSelectionCorrect(domSelection) {\n    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);\n  }\n  /**\n   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data\n   * and not processed during the conversion from DOM nodes to view elements.\n   *\n   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and\n   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.\n   *\n   * The raw data can be later accessed by a\n   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `\"$rawContent\"`.\n   *\n   * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching a view element whose content should\n   * be treated as raw data.\n   */\n\n\n  registerRawContentMatcher(pattern) {\n    this._rawContentElementMatcher.add(pattern);\n  }\n  /**\n   * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.\n   *\n   * @private\n   * @params {Document} domDocument\n   * @returns {Node} filler\n   */\n\n\n  _getBlockFiller(domDocument) {\n    switch (this.blockFillerMode) {\n      case 'nbsp':\n        return NBSP_FILLER(domDocument);\n      // eslint-disable-line new-cap\n\n      case 'markedNbsp':\n        return MARKED_NBSP_FILLER(domDocument);\n      // eslint-disable-line new-cap\n\n      case 'br':\n        return BR_FILLER(domDocument);\n      // eslint-disable-line new-cap\n    }\n  }\n  /**\n   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n   *\n   * @private\n   * @param {Element} domParent Position parent.\n   * @param {Number} offset Position offset.\n   * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n   */\n\n\n  _isDomSelectionPositionCorrect(domParent, offset) {\n    // If selection is before or in the middle of inline filler string, it is incorrect.\n    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {\n      // Selection in a text node, at wrong position (before or in the middle of filler).\n      return false;\n    }\n\n    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {\n      // Selection in an element node, before filler text node.\n      return false;\n    }\n\n    const viewParent = this.mapDomToView(domParent); // The position is incorrect when anchored inside a UIElement or a RawElement.\n    // Note: In case of UIElement and RawElement, mapDomToView() returns a parent element for any DOM child\n    // so there's no need to perform any additional checks.\n\n    if (viewParent && (viewParent.is('uiElement') || viewParent.is('rawElement'))) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n   * it is correctly displayed in the DOM.\n   *\n   * Following changes are done:\n   *\n   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n   * element or if a previous text node ends with a space character,\n   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container,\n   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n   *\n   * Content of {@link #preElements} is not processed.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node View text node to process.\n   * @returns {String} Processed text data.\n   */\n\n\n  _processDataFromViewText(node) {\n    let data = node.data; // If any of node ancestors has a name which is in `preElements` array, then currently processed\n    // view text node is (will be) in preformatted element. We should not change whitespaces then.\n\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return data;\n    } // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n    // (container element boundary).\n\n\n    if (data.charAt(0) == ' ') {\n      const prevNode = this._getTouchingInlineViewNode(node, false);\n\n      const prevEndsWithSpace = prevNode && prevNode.is('$textProxy') && this._nodeEndsWithSpace(prevNode);\n\n      if (prevEndsWithSpace || !prevNode) {\n        data = '\\u00A0' + data.substr(1);\n      }\n    } // 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n    // next node (container element boundary).\n    //\n    // Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n    //\n    // Foo <span>&nbsp;bar</span>  <-- bad.\n    // Foo&nbsp;<span> bar</span>  <-- good.\n    //\n    // More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\n\n    if (data.charAt(data.length - 1) == ' ') {\n      const nextNode = this._getTouchingInlineViewNode(node, true);\n\n      const nextStartsWithSpace = nextNode && nextNode.is('$textProxy') && nextNode.data.charAt(0) == ' ';\n\n      if (data.charAt(data.length - 2) == ' ' || !nextNode || nextStartsWithSpace) {\n        data = data.substr(0, data.length - 1) + '\\u00A0';\n      }\n    } // 3. Create space+nbsp pairs.\n\n\n    return data.replace(/ {2}/g, ' \\u00A0');\n  }\n  /**\n   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node Node to check.\n   * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n   */\n\n\n  _nodeEndsWithSpace(node) {\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return false;\n    }\n\n    const data = this._processDataFromViewText(node);\n\n    return data.charAt(data.length - 1) == ' ';\n  }\n  /**\n   * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n   *\n   * Following changes are done:\n   *\n   * * multiple whitespaces are replaced to a single space,\n   * * space at the beginning of a text node is removed if it is the first text node in its container\n   * element or if the previous text node ends with a space character,\n   * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container\n   * * nbsps are converted to spaces.\n   *\n   * @param {Node} node DOM text node to process.\n   * @returns {String} Processed data.\n   * @private\n   */\n\n\n  _processDataFromDomText(node) {\n    let data = node.data;\n\n    if (_hasDomParentOfType(node, this.preElements)) {\n      return getDataWithoutFiller(node);\n    } // Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n    // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n    // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n    // We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\n\n    data = data.replace(/[ \\n\\t\\r]{1,}/g, ' ');\n\n    const prevNode = this._getTouchingInlineDomNode(node, false);\n\n    const nextNode = this._getTouchingInlineDomNode(node, true);\n\n    const shouldLeftTrim = this._checkShouldLeftTrimDomText(node, prevNode);\n\n    const shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode); // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n    // of this text node. Such space character is treated as a whitespace.\n\n\n    if (shouldLeftTrim) {\n      data = data.replace(/^ /, '');\n    } // If the next text node does not exist remove space character from the end of this text node.\n\n\n    if (shouldRightTrim) {\n      data = data.replace(/ $/, '');\n    } // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n    // This means that the text node starts/end with normal space instead of non-breaking space.\n    // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n    // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\n\n    data = getDataWithoutFiller(new Text(data)); // At this point we should have removed all whitespaces from DOM text data.\n    //\n    // Now, We will reverse the process that happens in `_processDataFromViewText`.\n    //\n    // We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n    // First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n    // ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\n    data = data.replace(/ \\u00A0/g, '  ');\n    const isNextNodeInlineObjectElement = nextNode && this.isElement(nextNode) && nextNode.tagName != 'BR';\n    const isNextNodeStartingWithSpace = nextNode && isText(nextNode) && nextNode.data.charAt(0) == ' '; // Then, let's change the last nbsp to a space.\n\n    if (/( |\\u00A0)\\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {\n      data = data.replace(/\\u00A0$/, ' ');\n    } // Then, change &nbsp; character that is at the beginning of the text node to space character.\n    // We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\n\n    if (shouldLeftTrim || prevNode && this.isElement(prevNode) && prevNode.tagName != 'BR') {\n      data = data.replace(/^\\u00A0/, ' ');\n    } // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n    // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\n\n    return data;\n  }\n  /**\n   * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n   * be trimmed from the left side.\n   *\n   * @private\n   * @param {Node} node\n   * @param {Node} prevNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n   */\n\n\n  _checkShouldLeftTrimDomText(node, prevNode) {\n    if (!prevNode) {\n      return true;\n    }\n\n    if (this.isElement(prevNode)) {\n      return prevNode.tagName === 'BR';\n    } // Shouldn't left trim if previous node is a node that was encountered as a raw content node.\n\n\n    if (this._encounteredRawContentDomNodes.has(node.previousSibling)) {\n      return false;\n    }\n\n    return /[^\\S\\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));\n  }\n  /**\n   * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n   * be trimmed from the right side.\n   *\n   * @private\n   * @param {Node} node\n   * @param {Node} nextNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n   */\n\n\n  _checkShouldRightTrimDomText(node, nextNode) {\n    if (nextNode) {\n      return false;\n    }\n\n    return !startsWithFiller(node);\n  }\n  /**\n   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n   * that is contained in the same container element. If there is no such sibling, `null` is returned.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node Reference node.\n   * @param {Boolean} getNext\n   * @returns {module:engine/view/text~Text|module:engine/view/element~Element|null} Touching text node, an inline object\n   * or `null` if there is no next or previous touching text node.\n   */\n\n\n  _getTouchingInlineViewNode(node, getNext) {\n    const treeWalker = new ViewTreeWalker({\n      startPosition: getNext ? ViewPosition._createAfter(node) : ViewPosition._createBefore(node),\n      direction: getNext ? 'forward' : 'backward'\n    });\n\n    for (const value of treeWalker) {\n      // Found an inline object (for example an image).\n      if (value.item.is('element') && this.inlineObjectElements.includes(value.item.name)) {\n        return value.item;\n      } // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n      // text node in its container element.\n      else if (value.item.is('containerElement')) {\n        return null;\n      } // <br> found – it works like a block boundary, so do not scan further.\n      else if (value.item.is('element', 'br')) {\n        return null;\n      } // Found a text node in the same container element.\n      else if (value.item.is('$textProxy')) {\n        return value.item;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Helper function. For the given text node, it finds the closest touching node which is either\n   * a text, `<br>` or an {@link #inlineObjectElements inline object}.\n   *\n   * If no such node is found, `null` is returned.\n   *\n   * For instance, in the following DOM structure:\n   *\n   *\t\t<p>foo<b>bar</b><br>bom</p>\n   *\n   * * `foo` doesn't have its previous touching inline node (`null` is returned),\n   * * `foo`'s next touching inline node is `bar`\n   * * `bar`'s next touching inline node is `<br>`\n   *\n   * This method returns text nodes and `<br>` elements because these types of nodes affect how\n   * spaces in the given text node need to be converted.\n   *\n   * @private\n   * @param {Text} node\n   * @param {Boolean} getNext\n   * @returns {Text|Element|null}\n   */\n\n\n  _getTouchingInlineDomNode(node, getNext) {\n    if (!node.parentNode) {\n      return null;\n    }\n\n    const stepInto = getNext ? 'firstChild' : 'lastChild';\n    const stepOver = getNext ? 'nextSibling' : 'previousSibling';\n    let skipChildren = true;\n\n    do {\n      if (!skipChildren && node[stepInto]) {\n        node = node[stepInto];\n      } else if (node[stepOver]) {\n        node = node[stepOver];\n        skipChildren = false;\n      } else {\n        node = node.parentNode;\n        skipChildren = true;\n      }\n\n      if (!node || this._isBlockElement(node)) {\n        return null;\n      }\n    } while (!(isText(node) || node.tagName == 'BR' || this._isInlineObjectElement(node)));\n\n    return node;\n  }\n  /**\n   * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.\n   *\n   * @private\n   * @param {Node} node\n   * @returns {Boolean}\n   */\n\n\n  _isBlockElement(node) {\n    return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());\n  }\n  /**\n   * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.\n   *\n   * @private\n   * @param {Node} node\n   * @returns {Boolean}\n   */\n\n\n  _isInlineObjectElement(node) {\n    return this.isElement(node) && this.inlineObjectElements.includes(node.tagName.toLowerCase());\n  }\n  /**\n   * Creates view element basing on the node type.\n   *\n   * @private\n   * @param {Node} node DOM node to check.\n   * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Element}\n   */\n\n\n  _createViewElement(node, options) {\n    if (this.isComment(node)) {\n      return new ViewUIElement(this.document, '$comment');\n    }\n\n    const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();\n    return new ViewElement(this.document, viewName);\n  }\n  /**\n   * Checks if view element's content should be treated as a raw data.\n   *\n   * @private\n   * @param {Element} viewElement View element to check.\n   * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Boolean}\n   */\n\n\n  _isViewElementWithRawContent(viewElement, options) {\n    return options.withChildren !== false && this._rawContentElementMatcher.match(viewElement);\n  }\n  /**\n   * Checks whether given element name should be renamed in a current rendering mode.\n   *\n   * @private\n   * @param {String} elementName The name of view element.\n   * @returns {Boolean}\n   */\n\n\n  _shouldRenameElement(elementName) {\n    return this.experimentalRenderingMode && this.renderingMode == 'editing' && elementName == 'script';\n  }\n  /**\n   * Return a <span> element with special attribute holding the name of the original element.\n   * Optionally, copy all the attributes of the original element if that element is provided.\n   *\n   * @private\n   * @param {String} elementName The name of view element.\n   * @param {Element} [originalDomElement] The original DOM element to copy attributes and content from.\n   * @returns {Element}\n   */\n\n\n  _createReplacementDomElement(elementName) {\n    let originalDomElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const newDomElement = document.createElement('span'); // Mark the span replacing a script as hidden.\n\n    newDomElement.setAttribute('data-ck-hidden', elementName);\n\n    if (originalDomElement) {\n      while (originalDomElement.firstChild) {\n        newDomElement.appendChild(originalDomElement.firstChild);\n      }\n\n      for (const attributeName of originalDomElement.getAttributeNames()) {\n        newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));\n      }\n    }\n\n    return newDomElement;\n  }\n\n} // Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\n\nfunction _hasDomParentOfType(node, types) {\n  const parents = getAncestors(node);\n  return parents.some(parent => parent.tagName && types.includes(parent.tagName.toLowerCase()));\n} // A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\n\n\nfunction forEachDomNodeAncestor(node, callback) {\n  while (node && node != global.document) {\n    callback(node);\n    node = node.parentNode;\n  }\n} // Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\n\n\nfunction isNbspBlockFiller(domNode, blockElements) {\n  const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);\n  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;\n} // Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\n\n\nfunction hasBlockParent(domNode, blockElements) {\n  const parent = domNode.parentNode;\n  return parent && parent.tagName && blockElements.includes(parent.tagName.toLowerCase());\n}\n/**\n * Enum representing the type of the block filler.\n *\n * Possible values:\n *\n * * `br` &ndash; For the `<br data-cke-filler=\"true\">` block filler used in the editing view.\n * * `nbsp` &ndash; For the `&nbsp;` block fillers used in the data.\n * * `markedNbsp` &ndash; For the `&nbsp;` block fillers wrapped in `<span>` elements: `<span data-cke-filler=\"true\">&nbsp;</span>`\n * used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js"],"names":["ViewText","ViewElement","ViewUIElement","ViewPosition","ViewRange","ViewSelection","ViewDocumentFragment","ViewTreeWalker","Matcher","BR_FILLER","INLINE_FILLER_LENGTH","NBSP_FILLER","MARKED_NBSP_FILLER","getDataWithoutFiller","isInlineFiller","startsWithFiller","global","indexOf","getAncestors","isText","BR_FILLER_REF","document","NBSP_FILLER_REF","MARKED_NBSP_FILLER_REF","DomConverter","constructor","options","renderingMode","experimentalRenderingMode","blockFillerMode","preElements","blockElements","inlineObjectElements","_domToViewMapping","WeakMap","_viewToDomMapping","_fakeSelectionMapping","_rawContentElementMatcher","_encounteredRawContentDomNodes","WeakSet","bindFakeSelection","domElement","viewDocumentSelection","set","fakeSelectionToView","get","bindElements","viewElement","unbindDomElement","delete","child","childNodes","bindDocumentFragments","domFragment","viewFragment","shouldRenderAttribute","attributeKey","attributeValue","toLowerCase","startsWith","match","setContentOf","html","innerHTML","DOMParser","parseFromString","fragment","createDocumentFragment","bodyChildNodes","body","length","appendChild","treeWalker","createTreeWalker","NodeFilter","SHOW_ELEMENT","nodes","currentNode","nextNode","push","attributeName","getAttributeNames","getAttribute","removeAttribute","elementName","tagName","_shouldRenameElement","replaceWith","_createReplacementDomElement","firstChild","remove","append","viewToDom","viewNode","domDocument","is","textData","_processDataFromViewText","createTextNode","mapViewToDom","bind","name","createComment","getCustomProperty","render","hasAttribute","createElementNS","createElement","key","getAttributeKeys","value","setAttribute","withChildren","viewChildrenToDom","fillerPositionOffset","getFillerOffset","offset","childView","getChildren","_getBlockFiller","viewRangeToDom","viewRange","domStart","viewPositionToDom","start","domEnd","end","domRange","createRange","setStart","parent","setEnd","viewPosition","viewParent","domParent","findCorrespondingDomText","domBefore","domAfter","nodeBefore","parentNode","nextSibling","domToView","domNode","isBlockFiller","hostElement","getHostViewElement","isComment","skipComments","_processDataFromDomText","mapDomToView","isDocumentFragment","_createViewElement","attrs","attributes","i","_setAttribute","_isViewElementWithRawContent","rawContent","data","_setCustomProperty","add","domChildrenToView","_appendChild","domChild","viewChild","domSelectionToView","domSelection","rangeCount","container","getRangeAt","startContainer","viewSelection","isBackward","isDomSelectionBackward","viewRanges","domRangeToView","backward","viewStart","domPositionToView","startOffset","viewEnd","endContainer","endOffset","domOffset","_createBefore","findCorrespondingViewText","viewBefore","index","domElementOrDocumentFragment","domText","previousSibling","isElement","getChild","documentFragmentOrElement","viewText","focus","viewEditable","domEditable","ownerDocument","activeElement","scrollX","scrollY","window","scrollPositions","forEachDomNodeAncestor","node","scrollLeft","scrollTop","shift","scrollTo","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","isEqualNode","hasBlockParent","isNbspBlockFiller","selection","isCollapsed","range","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","detach","ancestors","pop","isDomSelectionCorrect","_isDomSelectionPositionCorrect","registerRawContentMatcher","pattern","some","includes","charAt","prevNode","_getTouchingInlineViewNode","prevEndsWithSpace","_nodeEndsWithSpace","substr","nextStartsWithSpace","replace","_hasDomParentOfType","_getTouchingInlineDomNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","Text","isNextNodeInlineObjectElement","isNextNodeStartingWithSpace","test","has","getNext","startPosition","_createAfter","direction","item","stepInto","stepOver","skipChildren","_isBlockElement","_isInlineObjectElement","viewName","keepOriginalCase","originalDomElement","newDomElement","types","parents","callback","isNBSP"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, DOMParser, Text */\n\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewUIElement from './uielement';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport Matcher from './matcher';\nimport {\n\tBR_FILLER, INLINE_FILLER_LENGTH, NBSP_FILLER, MARKED_NBSP_FILLER,\n\tgetDataWithoutFiller, isInlineFiller, startsWithFiller\n} from './filler';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\n\nconst BR_FILLER_REF = BR_FILLER( document ); // eslint-disable-line new-cap\nconst NBSP_FILLER_REF = NBSP_FILLER( document ); // eslint-disable-line new-cap\nconst MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER( document ); // eslint-disable-line new-cap\n\n/**\n * `DomConverter` is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements bindings} between these nodes.\n *\n * An instance of the DOM converter is available under\n * {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * The DOM converter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep the\n * state of a tree nor keeps the synchronization between the tree view and the DOM tree (use {@link module:engine/view/document~Document}).\n *\n * The DOM converter keeps DOM elements to view element bindings, so when the converter gets destroyed, the bindings are lost.\n * Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n\t/**\n\t * Creates a DOM converter.\n\t *\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t * @param {Object} options An object with configuration options.\n\t * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode] The type of the block filler to use.\n\t * Default value depends on the options.renderingMode:\n\t *  'nbsp' when options.renderingMode == 'data',\n\t *  'br' when options.renderingMode == 'editing'.\n\t * @param {'data'|'editing'} [options.renderingMode='editing'] Whether to leave the View-to-DOM conversion result unchanged\n\t * or improve editing experience by filtering out interactive data.\n\t */\n\tconstructor( document, options = {} ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.\n\t\t *\n\t\t * @member {'data'|'editing'} module:engine/view/domconverter~DomConverter#renderingMode\n\t\t */\n\t\tthis.renderingMode = options.renderingMode || 'editing';\n\n\t\t/**\n\t\t * Main switch for new rendering approach in the editing view.\n\t\t *\n\t\t * @protected\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.experimentalRenderingMode = false;\n\n\t\t/**\n\t\t * The mode of a block filler used by the DOM converter.\n\t\t *\n\t\t * @member {'br'|'nbsp'|'markedNbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n\t\t */\n\t\tthis.blockFillerMode = options.blockFillerMode || ( this.renderingMode === 'editing' ? 'br' : 'nbsp' );\n\n\t\t/**\n\t\t * Elements which are considered pre-formatted elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n\t\t */\n\t\tthis.preElements = [ 'pre' ];\n\n\t\t/**\n\t\t * Elements which are considered block elements (and hence should be filled with a\n\t\t * {@link #isBlockFiller block filler}).\n\t\t *\n\t\t * Whether an element is considered a block element also affects handling of trailing whitespaces.\n\t\t *\n\t\t * You can extend this array if you introduce support for block elements which are not yet recognized here.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n\t\t */\n\t\tthis.blockElements = [\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'center', 'dd', 'details', 'dir', 'div',\n\t\t\t'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header',\n\t\t\t'hgroup', 'legend', 'li', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'summary', 'table', 'tbody',\n\t\t\t'td', 'tfoot', 'th', 'thead', 'tr', 'ul'\n\t\t];\n\n\t\t/**\n\t\t * A list of elements that exist inline (in text) but their inner structure cannot be edited because\n\t\t * of the way they are rendered by the browser. They are mostly HTML form elements but there are other\n\t\t * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.\n\t\t *\n\t\t * Whether an element is considered an inline object has an impact on white space rendering (trimming)\n\t\t * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.\n\t\t *\n\t\t * You can extend this array if you introduce support for inline object elements which are not yet recognized here.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#inlineObjectElements\n\t\t */\n\t\tthis.inlineObjectElements = [\n\t\t\t'object', 'iframe', 'input', 'button', 'textarea', 'select', 'option', 'video', 'embed', 'audio', 'img', 'canvas'\n\t\t];\n\n\t\t/**\n\t\t * The DOM-to-view mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n\t\t */\n\t\tthis._domToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * The view-to-DOM mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n\t\t */\n\t\tthis._viewToDomMapping = new WeakMap();\n\n\t\t/**\n\t\t * Holds the mapping between fake selection containers and corresponding view selections.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n\t\t */\n\t\tthis._fakeSelectionMapping = new WeakMap();\n\n\t\t/**\n\t\t * Matcher for view elements whose content should be treated as raw data\n\t\t * and not processed during the conversion from DOM nodes to view elements.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/view/matcher~Matcher}\n\t\t */\n\t\tthis._rawContentElementMatcher = new Matcher();\n\n\t\t/**\n\t\t * A set of encountered raw content DOM nodes. It is used for preventing left trimming of the following text node.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakSet.<Node>}\n\t\t */\n\t\tthis._encounteredRawContentDomNodes = new WeakSet();\n\t}\n\n\t/**\n\t * Binds a given DOM element that represents fake selection to a **position** of a\n\t * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n\t * Document selection copy is stored and can be retrieved by the\n\t * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n\t */\n\tbindFakeSelection( domElement, viewDocumentSelection ) {\n\t\tthis._fakeSelectionMapping.set( domElement, new ViewSelection( viewDocumentSelection ) );\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given\n\t * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @returns {module:engine/view/selection~Selection|undefined}\n\t */\n\tfakeSelectionToView( domElement ) {\n\t\treturn this._fakeSelectionMapping.get( domElement );\n\t}\n\n\t/**\n\t * Binds DOM and view elements, so it will be possible to get corresponding elements using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {HTMLElement} domElement The DOM element to bind.\n\t * @param {module:engine/view/element~Element} viewElement The view element to bind.\n\t */\n\tbindElements( domElement, viewElement ) {\n\t\tthis._domToViewMapping.set( domElement, viewElement );\n\t\tthis._viewToDomMapping.set( viewElement, domElement );\n\t}\n\n\t/**\n\t * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of\n\t * the DOM element will be unbound too.\n\t *\n\t * @param {HTMLElement} domElement The DOM element to unbind.\n\t */\n\tunbindDomElement( domElement ) {\n\t\tconst viewElement = this._domToViewMapping.get( domElement );\n\n\t\tif ( viewElement ) {\n\t\t\tthis._domToViewMapping.delete( domElement );\n\t\t\tthis._viewToDomMapping.delete( viewElement );\n\n\t\t\tfor ( const child of domElement.childNodes ) {\n\t\t\t\tthis.unbindDomElement( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {DocumentFragment} domFragment The DOM document fragment to bind.\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment The view document fragment to bind.\n\t */\n\tbindDocumentFragments( domFragment, viewFragment ) {\n\t\tthis._domToViewMapping.set( domFragment, viewFragment );\n\t\tthis._viewToDomMapping.set( viewFragment, domFragment );\n\t}\n\n\t/**\n\t * Decides whether given pair of attribute key and value should be passed further down the pipeline.\n\t *\n\t * @param {String} attributeKey\n\t * @param {String} attributeValue\n\t * @returns {Boolean}\n\t */\n\tshouldRenderAttribute( attributeKey, attributeValue ) {\n\t\tif ( !this.experimentalRenderingMode || this.renderingMode === 'data' ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !( attributeKey.toLowerCase().startsWith( 'on' ) ||\n\t\t\tattributeValue.match( /(\\b)(on\\S+)(\\s*)=|javascript:|(<\\s*)(\\/*)script/i ) ||\n\t\t\tattributeValue.match( /data:(?!image\\/(png|jpeg|gif|webp))/i )\n\t\t);\n\t}\n\n\t/**\n\t * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.\n\t *\n\t * @param {Element} domElement DOM element that should have `html` set as its content.\n\t * @param {String} html Textual representation of the HTML that will be set on `domElement`.\n\t */\n\tsetContentOf( domElement, html ) {\n\t\t// For data pipeline we pass the HTML as-is.\n\t\tif ( !this.experimentalRenderingMode || this.renderingMode === 'data' ) {\n\t\t\tdomElement.innerHTML = html;\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst document = new DOMParser().parseFromString( html, 'text/html' );\n\t\tconst fragment = document.createDocumentFragment();\n\t\tconst bodyChildNodes = document.body.childNodes;\n\n\t\twhile ( bodyChildNodes.length > 0 ) {\n\t\t\tfragment.appendChild( bodyChildNodes[ 0 ] );\n\t\t}\n\n\t\tconst treeWalker = document.createTreeWalker( fragment, NodeFilter.SHOW_ELEMENT );\n\t\tconst nodes = [];\n\n\t\tlet currentNode;\n\n\t\t// eslint-disable-next-line no-cond-assign\n\t\twhile ( currentNode = treeWalker.nextNode() ) {\n\t\t\tnodes.push( currentNode );\n\t\t}\n\n\t\tfor ( const currentNode of nodes ) {\n\t\t\t// Go through nodes to remove those that are prohibited in editing pipeline.\n\t\t\tfor ( const attributeName of currentNode.getAttributeNames() ) {\n\t\t\t\tconst attributeValue = currentNode.getAttribute( attributeName );\n\n\t\t\t\tif ( !this.shouldRenderAttribute( attributeName, attributeValue ) ) {\n\t\t\t\t\tcurrentNode.removeAttribute( attributeName );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst elementName = currentNode.tagName.toLowerCase();\n\n\t\t\t// There are certain nodes, that should be renamed to <span> in editing pipeline.\n\t\t\tif ( this._shouldRenameElement( elementName ) ) {\n\t\t\t\tcurrentNode.replaceWith( this._createReplacementDomElement( elementName, currentNode ) );\n\t\t\t}\n\t\t}\n\n\t\t// Empty the target element.\n\t\twhile ( domElement.firstChild ) {\n\t\t\tdomElement.firstChild.remove();\n\t\t}\n\n\t\tdomElement.append( fragment );\n\t}\n\n\t/**\n\t * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments the method will return corresponding items.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View node or document fragment to transform.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n\t */\n\tviewToDom( viewNode, domDocument, options = {} ) {\n\t\tif ( viewNode.is( '$text' ) ) {\n\t\t\tconst textData = this._processDataFromViewText( viewNode );\n\n\t\t\treturn domDocument.createTextNode( textData );\n\t\t} else {\n\t\t\tif ( this.mapViewToDom( viewNode ) ) {\n\t\t\t\treturn this.mapViewToDom( viewNode );\n\t\t\t}\n\n\t\t\tlet domElement;\n\n\t\t\tif ( viewNode.is( 'documentFragment' ) ) {\n\t\t\t\t// Create DOM document fragment.\n\t\t\t\tdomElement = domDocument.createDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domElement, viewNode );\n\t\t\t\t}\n\t\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\t\tif ( viewNode.name === '$comment' ) {\n\t\t\t\t\tdomElement = domDocument.createComment( viewNode.getCustomProperty( '$rawContent' ) );\n\t\t\t\t} else {\n\t\t\t\t\t// UIElement has its own render() method (see #799).\n\t\t\t\t\tdomElement = viewNode.render( domDocument, this );\n\t\t\t\t}\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\treturn domElement;\n\t\t\t} else {\n\t\t\t\t// Create DOM element.\n\t\t\t\tif ( this._shouldRenameElement( viewNode.name ) ) {\n\t\t\t\t\tdomElement = this._createReplacementDomElement( viewNode.name );\n\t\t\t\t} else if ( viewNode.hasAttribute( 'xmlns' ) ) {\n\t\t\t\t\tdomElement = domDocument.createElementNS( viewNode.getAttribute( 'xmlns' ), viewNode.name );\n\t\t\t\t} else {\n\t\t\t\t\tdomElement = domDocument.createElement( viewNode.name );\n\t\t\t\t}\n\n\t\t\t\t// RawElement take care of their children in RawElement#render() method which can be customized\n\t\t\t\t// (see https://github.com/ckeditor/ckeditor5/issues/4469).\n\t\t\t\tif ( viewNode.is( 'rawElement' ) ) {\n\t\t\t\t\tviewNode.render( domElement, this );\n\t\t\t\t}\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tfor ( const key of viewNode.getAttributeKeys() ) {\n\t\t\t\t\tconst value = viewNode.getAttribute( key );\n\n\t\t\t\t\tif ( !this.shouldRenderAttribute( key, value ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdomElement.setAttribute( key, value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren !== false ) {\n\t\t\t\tfor ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {\n\t\t\t\t\tdomElement.appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the view element to DOM using the\n\t * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n\t * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n\t * @returns {Iterable.<Node>} DOM nodes.\n\t */\n\t* viewChildrenToDom( viewElement, domDocument, options = {} ) {\n\t\tconst fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n\t\tlet offset = 0;\n\n\t\tfor ( const childView of viewElement.getChildren() ) {\n\t\t\tif ( fillerPositionOffset === offset ) {\n\t\t\t\tyield this._getBlockFiller( domDocument );\n\t\t\t}\n\n\t\t\tyield this.viewToDom( childView, domDocument, options );\n\n\t\t\toffset++;\n\t\t}\n\n\t\tif ( fillerPositionOffset === offset ) {\n\t\t\tyield this._getBlockFiller( domDocument );\n\t\t}\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/range~Range} to DOM range.\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {Range} DOM range.\n\t */\n\tviewRangeToDom( viewRange ) {\n\t\tconst domStart = this.viewPositionToDom( viewRange.start );\n\t\tconst domEnd = this.viewPositionToDom( viewRange.end );\n\n\t\tconst domRange = document.createRange();\n\t\tdomRange.setStart( domStart.parent, domStart.offset );\n\t\tdomRange.setEnd( domEnd.parent, domEnd.offset );\n\n\t\treturn domRange;\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n\t *\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t * If the converted position is directly before inline filler it is moved inside the filler.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n\t * @returns {Node} position.parent DOM position parent.\n\t * @returns {Number} position.offset DOM position offset.\n\t */\n\tviewPositionToDom( viewPosition ) {\n\t\tconst viewParent = viewPosition.parent;\n\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\tconst domParent = this.findCorrespondingDomText( viewParent );\n\n\t\t\tif ( !domParent ) {\n\t\t\t\t// Position is in a view text node that has not been rendered to DOM yet.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet offset = viewPosition.offset;\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset += INLINE_FILLER_LENGTH;\n\t\t\t}\n\n\t\t\treturn { parent: domParent, offset };\n\t\t} else {\n\t\t\t// viewParent is instance of ViewElement.\n\t\t\tlet domParent, domBefore, domAfter;\n\n\t\t\tif ( viewPosition.offset === 0 ) {\n\t\t\t\tdomParent = this.mapViewToDom( viewParent );\n\n\t\t\t\tif ( !domParent ) {\n\t\t\t\t\t// Position is in a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomAfter = domParent.childNodes[ 0 ];\n\t\t\t} else {\n\t\t\t\tconst nodeBefore = viewPosition.nodeBefore;\n\n\t\t\t\tdomBefore = nodeBefore.is( '$text' ) ?\n\t\t\t\t\tthis.findCorrespondingDomText( nodeBefore ) :\n\t\t\t\t\tthis.mapViewToDom( viewPosition.nodeBefore );\n\n\t\t\t\tif ( !domBefore ) {\n\t\t\t\t\t// Position is after a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomParent = domBefore.parentNode;\n\t\t\t\tdomAfter = domBefore.nextSibling;\n\t\t\t}\n\n\t\t\t// If there is an inline filler at position return position inside the filler. We should never return\n\t\t\t// the position before the inline filler.\n\t\t\tif ( isText( domAfter ) && startsWithFiller( domAfter ) ) {\n\t\t\t\treturn { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n\t\t\t}\n\n\t\t\tconst offset = domBefore ? indexOf( domBefore ) + 1 : 0;\n\n\t\t\treturn { parent: domParent, offset };\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items. For\n\t * {@link module:engine/view/filler fillers} `null` will be returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converted to lower case.\n\t * @param {Boolean} [options.skipComments=false] If `false`, comment nodes will be converted to `$comment`\n\t * {@link module:engine/view/uielement~UIElement view UI elements}.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n\t * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n\t */\n\tdomToView( domNode, options = {} ) {\n\t\tif ( this.isBlockFiller( domNode ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When node is inside a UIElement or a RawElement return that parent as it's view representation.\n\t\tconst hostElement = this.getHostViewElement( domNode );\n\n\t\tif ( hostElement ) {\n\t\t\treturn hostElement;\n\t\t}\n\n\t\tif ( this.isComment( domNode ) && options.skipComments ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( isText( domNode ) ) {\n\t\t\tif ( isInlineFiller( domNode ) ) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst textData = this._processDataFromDomText( domNode );\n\n\t\t\t\treturn textData === '' ? null : new ViewText( this.document, textData );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( this.mapDomToView( domNode ) ) {\n\t\t\t\treturn this.mapDomToView( domNode );\n\t\t\t}\n\n\t\t\tlet viewElement;\n\n\t\t\tif ( this.isDocumentFragment( domNode ) ) {\n\t\t\t\t// Create view document fragment.\n\t\t\t\tviewElement = new ViewDocumentFragment( this.document );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domNode, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create view element.\n\t\t\t\tviewElement = this._createViewElement( domNode, options );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domNode, viewElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tconst attrs = domNode.attributes;\n\n\t\t\t\tif ( attrs ) {\n\t\t\t\t\tfor ( let i = attrs.length - 1; i >= 0; i-- ) {\n\t\t\t\t\t\tviewElement._setAttribute( attrs[ i ].name, attrs[ i ].value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Treat this element's content as a raw data if it was registered as such.\n\t\t\t\t// Comment node is also treated as an element with raw data.\n\t\t\t\tif ( this._isViewElementWithRawContent( viewElement, options ) || this.isComment( domNode ) ) {\n\t\t\t\t\tconst rawContent = this.isComment( domNode ) ? domNode.data : domNode.innerHTML;\n\n\t\t\t\t\tviewElement._setCustomProperty( '$rawContent', rawContent );\n\n\t\t\t\t\t// Store a DOM node to prevent left trimming of the following text node.\n\t\t\t\t\tthis._encounteredRawContentDomNodes.add( domNode );\n\n\t\t\t\t\treturn viewElement;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren !== false ) {\n\t\t\t\tfor ( const child of this.domChildrenToView( domNode, options ) ) {\n\t\t\t\t\tviewElement._appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn viewElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the DOM element to view nodes using\n\t * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n\t * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n\t *\n\t * @param {HTMLElement} domElement Parent DOM element.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n\t */\n\t* domChildrenToView( domElement, options = {} ) {\n\t\tfor ( let i = 0; i < domElement.childNodes.length; i++ ) {\n\t\t\tconst domChild = domElement.childNodes[ i ];\n\t\t\tconst viewChild = this.domToView( domChild, options );\n\n\t\t\tif ( viewChild !== null ) {\n\t\t\t\tyield viewChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n\t * Ranges which cannot be converted will be omitted.\n\t *\n\t * @param {Selection} domSelection DOM selection.\n\t * @returns {module:engine/view/selection~Selection} View selection.\n\t */\n\tdomSelectionToView( domSelection ) {\n\t\t// DOM selection might be placed in fake selection container.\n\t\t// If container contains fake selection - return corresponding view selection.\n\t\tif ( domSelection.rangeCount === 1 ) {\n\t\t\tlet container = domSelection.getRangeAt( 0 ).startContainer;\n\n\t\t\t// The DOM selection might be moved to the text node inside the fake selection container.\n\t\t\tif ( isText( container ) ) {\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tconst viewSelection = this.fakeSelectionToView( container );\n\n\t\t\tif ( viewSelection ) {\n\t\t\t\treturn viewSelection;\n\t\t\t}\n\t\t}\n\n\t\tconst isBackward = this.isDomSelectionBackward( domSelection );\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( let i = 0; i < domSelection.rangeCount; i++ ) {\n\t\t\t// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n\t\t\tconst domRange = domSelection.getRangeAt( i );\n\t\t\tconst viewRange = this.domRangeToView( domRange );\n\n\t\t\tif ( viewRange ) {\n\t\t\t\tviewRanges.push( viewRange );\n\t\t\t}\n\t\t}\n\n\t\treturn new ViewSelection( viewRanges, { backward: isBackward } );\n\t}\n\n\t/**\n\t * Converts DOM Range to view {@link module:engine/view/range~Range}.\n\t * If the start or end position can not be converted `null` is returned.\n\t *\n\t * @param {Range} domRange DOM range.\n\t * @returns {module:engine/view/range~Range|null} View range.\n\t */\n\tdomRangeToView( domRange ) {\n\t\tconst viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );\n\t\tconst viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );\n\n\t\tif ( viewStart && viewEnd ) {\n\t\t\treturn new ViewRange( viewStart, viewEnd );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n\t *\n\t * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n\t * position of the filler will be converted and returned.\n\t *\n\t * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n\t * that position will be converted to view position before that UIElement.\n\t *\n\t * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n\t *\n\t * @param {Node} domParent DOM position parent.\n\t * @param {Number} [domOffset=0] DOM position offset. You can skip it when converting the inline filler node.\n\t * @returns {module:engine/view/position~Position} viewPosition View position.\n\t */\n\tdomPositionToView( domParent, domOffset = 0 ) {\n\t\tif ( this.isBlockFiller( domParent ) ) {\n\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t}\n\n\t\t// If position is somewhere inside UIElement or a RawElement - return position before that element.\n\t\tconst viewElement = this.mapDomToView( domParent );\n\n\t\tif ( viewElement && ( viewElement.is( 'uiElement' ) || viewElement.is( 'rawElement' ) ) ) {\n\t\t\treturn ViewPosition._createBefore( viewElement );\n\t\t}\n\n\t\tif ( isText( domParent ) ) {\n\t\t\tif ( isInlineFiller( domParent ) ) {\n\t\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t\t}\n\n\t\t\tconst viewParent = this.findCorrespondingViewText( domParent );\n\t\t\tlet offset = domOffset;\n\n\t\t\tif ( !viewParent ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset -= INLINE_FILLER_LENGTH;\n\t\t\t\toffset = offset < 0 ? 0 : offset;\n\t\t\t}\n\n\t\t\treturn new ViewPosition( viewParent, offset );\n\t\t}\n\t\t// domParent instanceof HTMLElement.\n\t\telse {\n\t\t\tif ( domOffset === 0 ) {\n\t\t\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t\t\tif ( viewParent ) {\n\t\t\t\t\treturn new ViewPosition( viewParent, 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst domBefore = domParent.childNodes[ domOffset - 1 ];\n\t\t\t\tconst viewBefore = isText( domBefore ) ?\n\t\t\t\t\tthis.findCorrespondingViewText( domBefore ) :\n\t\t\t\t\tthis.mapDomToView( domBefore );\n\n\t\t\t\t// TODO #663\n\t\t\t\tif ( viewBefore && viewBefore.parent ) {\n\t\t\t\t\treturn new ViewPosition( viewBefore.parent, viewBefore.index + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns corresponding view {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n\t * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * to the given DOM - `undefined` is returned.\n\t *\n\t * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or\n\t * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n\t *\n\t * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n\t * Corresponding view element, document fragment or `undefined` if no element was bound.\n\t */\n\tmapDomToView( domElementOrDocumentFragment ) {\n\t\tconst hostElement = this.getHostViewElement( domElementOrDocumentFragment );\n\n\t\treturn hostElement || this._domToViewMapping.get( domElementOrDocumentFragment );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or\n\t * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n\t *\n\t * @param {Text} domText DOM text node.\n\t * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n\t * corresponding node.\n\t */\n\tfindCorrespondingViewText( domText ) {\n\t\tif ( isInlineFiller( domText ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If DOM text was rendered by a UIElement or a RawElement - return this parent element.\n\t\tconst hostElement = this.getHostViewElement( domText );\n\n\t\tif ( hostElement ) {\n\t\t\treturn hostElement;\n\t\t}\n\n\t\tconst previousSibling = domText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling ) {\n\t\t\tif ( !( this.isElement( previousSibling ) ) ) {\n\t\t\t\t// The previous is text or comment.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewElement = this.mapDomToView( previousSibling );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst nextSibling = viewElement.nextSibling;\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( nextSibling instanceof ViewText ) {\n\t\t\t\t\treturn viewElement.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to use parent to find the corresponding text node.\n\t\telse {\n\t\t\tconst viewElement = this.mapDomToView( domText.parentNode );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst firstChild = viewElement.getChild( 0 );\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( firstChild instanceof ViewText ) {\n\t\t\t\t\treturn firstChild;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n\t * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n\t * use {@link #findCorrespondingDomText}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View element or document fragment.\n\t * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n\t */\n\tmapViewToDom( documentFragmentOrElement ) {\n\t\treturn this._viewToDomMapping.get( documentFragmentOrElement );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} viewText View text node.\n\t * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n\t */\n\tfindCorrespondingDomText( viewText ) {\n\t\tconst previousSibling = viewText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling && this.mapViewToDom( previousSibling ) ) {\n\t\t\treturn this.mapViewToDom( previousSibling ).nextSibling;\n\t\t}\n\n\t\t// If this is a first node, try to use parent to find the corresponding text node.\n\t\tif ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {\n\t\t\treturn this.mapViewToDom( viewText.parent ).childNodes[ 0 ];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t * @param {module:engine/view/editableelement~EditableElement} viewEditable\n\t */\n\tfocus( viewEditable ) {\n\t\tconst domEditable = this.mapViewToDom( viewEditable );\n\n\t\tif ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {\n\t\t\t// Save the scrollX and scrollY positions before the focus.\n\t\t\tconst { scrollX, scrollY } = global.window;\n\t\t\tconst scrollPositions = [];\n\n\t\t\t// Save all scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst { scrollLeft, scrollTop } = node;\n\n\t\t\t\tscrollPositions.push( [ scrollLeft, scrollTop ] );\n\t\t\t} );\n\n\t\t\tdomEditable.focus();\n\n\t\t\t// Restore scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/957\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst [ scrollLeft, scrollTop ] = scrollPositions.shift();\n\n\t\t\t\tnode.scrollLeft = scrollLeft;\n\t\t\t\tnode.scrollTop = scrollTop;\n\t\t\t} );\n\n\t\t\t// Restore the scrollX and scrollY positions after the focus.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\tglobal.window.scrollTo( scrollX, scrollY );\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisElement( node ) {\n\t\treturn node && node.nodeType == Node.ELEMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisDocumentFragment( node ) {\n\t\treturn node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisComment( node ) {\n\t\treturn node && node.nodeType == Node.COMMENT_NODE;\n\t}\n\n\t/**\n\t * Checks if the node is an instance of the block filler for this DOM converter.\n\t *\n\t *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n\t *\n\t *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n\t *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n\t *\n\t * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n\t *\n\t * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n\t *\n\t * @param {Node} domNode DOM node to check.\n\t * @returns {Boolean} True if a node is considered a block filler for given mode.\n\t */\n\tisBlockFiller( domNode ) {\n\t\tif ( this.blockFillerMode == 'br' ) {\n\t\t\treturn domNode.isEqualNode( BR_FILLER_REF );\n\t\t}\n\n\t\t// Special case for <p><br></p> in which <br> should be treated as filler even when we are not in the 'br' mode. See ckeditor5#5564.\n\t\tif ( domNode.tagName === 'BR' && hasBlockParent( domNode, this.blockElements ) && domNode.parentNode.childNodes.length === 1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If not in 'br' mode, try recognizing both marked and regular nbsp block fillers.\n\t\treturn domNode.isEqualNode( MARKED_NBSP_FILLER_REF ) || isNbspBlockFiller( domNode, this.blockElements );\n\t}\n\n\t/**\n\t * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n\t *\n\t * @param {Selection} DOM Selection instance to check.\n\t * @returns {Boolean}\n\t */\n\tisDomSelectionBackward( selection ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n\t\t// we will use the fact that range will collapse if it's end is before it's start.\n\t\tconst range = document.createRange();\n\n\t\trange.setStart( selection.anchorNode, selection.anchorOffset );\n\t\trange.setEnd( selection.focusNode, selection.focusOffset );\n\n\t\tconst backward = range.collapsed;\n\n\t\trange.detach();\n\n\t\treturn backward;\n\t}\n\n\t/**\n\t * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}\n\t * that hosts the provided DOM node. Returns `null` if there is no such parent.\n\t *\n\t * @param {Node} domNode\n\t * @returns {module:engine/view/uielement~UIElement|module:engine/view/rawelement~RawElement|null}\n\t */\n\tgetHostViewElement( domNode ) {\n\t\tconst ancestors = getAncestors( domNode );\n\n\t\t// Remove domNode from the list.\n\t\tancestors.pop();\n\n\t\twhile ( ancestors.length ) {\n\t\t\tconst domNode = ancestors.pop();\n\t\t\tconst viewNode = this._domToViewMapping.get( domNode );\n\n\t\t\tif ( viewNode && ( viewNode.is( 'uiElement' ) || viewNode.is( 'rawElement' ) ) ) {\n\t\t\t\treturn viewNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if the given selection's boundaries are at correct places.\n\t *\n\t * The following places are considered as incorrect for selection boundaries:\n\t *\n\t * * before or in the middle of an inline filler sequence,\n\t * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},\n\t * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.\n\t *\n\t * @param {Selection} domSelection The DOM selection object to be checked.\n\t * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n\t */\n\tisDomSelectionCorrect( domSelection ) {\n\t\treturn this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&\n\t\t\tthis._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );\n\t}\n\n\t/**\n\t * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data\n\t * and not processed during the conversion from DOM nodes to view elements.\n\t *\n\t * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.\n\t *\n\t * The raw data can be later accessed by a\n\t * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `\"$rawContent\"`.\n\t *\n\t * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching a view element whose content should\n\t * be treated as raw data.\n\t */\n\tregisterRawContentMatcher( pattern ) {\n\t\tthis._rawContentElementMatcher.add( pattern );\n\t}\n\n\t/**\n\t * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.\n\t *\n\t * @private\n\t * @params {Document} domDocument\n\t * @returns {Node} filler\n\t */\n\t_getBlockFiller( domDocument ) {\n\t\tswitch ( this.blockFillerMode ) {\n\t\t\tcase 'nbsp':\n\t\t\t\treturn NBSP_FILLER( domDocument ); // eslint-disable-line new-cap\n\t\t\tcase 'markedNbsp':\n\t\t\t\treturn MARKED_NBSP_FILLER( domDocument ); // eslint-disable-line new-cap\n\t\t\tcase 'br':\n\t\t\t\treturn BR_FILLER( domDocument ); // eslint-disable-line new-cap\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n\t *\n\t * @private\n\t * @param {Element} domParent Position parent.\n\t * @param {Number} offset Position offset.\n\t * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n\t */\n\t_isDomSelectionPositionCorrect( domParent, offset ) {\n\t\t// If selection is before or in the middle of inline filler string, it is incorrect.\n\t\tif ( isText( domParent ) && startsWithFiller( domParent ) && offset < INLINE_FILLER_LENGTH ) {\n\t\t\t// Selection in a text node, at wrong position (before or in the middle of filler).\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isElement( domParent ) && startsWithFiller( domParent.childNodes[ offset ] ) ) {\n\t\t\t// Selection in an element node, before filler text node.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t// The position is incorrect when anchored inside a UIElement or a RawElement.\n\t\t// Note: In case of UIElement and RawElement, mapDomToView() returns a parent element for any DOM child\n\t\t// so there's no need to perform any additional checks.\n\t\tif ( viewParent && ( viewParent.is( 'uiElement' ) || viewParent.is( 'rawElement' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n\t * it is correctly displayed in the DOM.\n\t *\n\t * Following changes are done:\n\t *\n\t * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n\t * element or if a previous text node ends with a space character,\n\t * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container,\n\t * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n\t *\n\t * Content of {@link #preElements} is not processed.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node View text node to process.\n\t * @returns {String} Processed text data.\n\t */\n\t_processDataFromViewText( node ) {\n\t\tlet data = node.data;\n\n\t\t// If any of node ancestors has a name which is in `preElements` array, then currently processed\n\t\t// view text node is (will be) in preformatted element. We should not change whitespaces then.\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n\t\t// (container element boundary).\n\t\tif ( data.charAt( 0 ) == ' ' ) {\n\t\t\tconst prevNode = this._getTouchingInlineViewNode( node, false );\n\t\t\tconst prevEndsWithSpace = prevNode && prevNode.is( '$textProxy' ) && this._nodeEndsWithSpace( prevNode );\n\n\t\t\tif ( prevEndsWithSpace || !prevNode ) {\n\t\t\t\tdata = '\\u00A0' + data.substr( 1 );\n\t\t\t}\n\t\t}\n\n\t\t// 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n\t\t// next node (container element boundary).\n\t\t//\n\t\t// Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n\t\t//\n\t\t// Foo <span>&nbsp;bar</span>  <-- bad.\n\t\t// Foo&nbsp;<span> bar</span>  <-- good.\n\t\t//\n\t\t// More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\t\tif ( data.charAt( data.length - 1 ) == ' ' ) {\n\t\t\tconst nextNode = this._getTouchingInlineViewNode( node, true );\n\t\t\tconst nextStartsWithSpace = nextNode && nextNode.is( '$textProxy' ) && nextNode.data.charAt( 0 ) == ' ';\n\n\t\t\tif ( data.charAt( data.length - 2 ) == ' ' || !nextNode || nextStartsWithSpace ) {\n\t\t\t\tdata = data.substr( 0, data.length - 1 ) + '\\u00A0';\n\t\t\t}\n\t\t}\n\n\t\t// 3. Create space+nbsp pairs.\n\t\treturn data.replace( / {2}/g, ' \\u00A0' );\n\t}\n\n\t/**\n\t * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Node to check.\n\t * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n\t */\n\t_nodeEndsWithSpace( node ) {\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst data = this._processDataFromViewText( node );\n\n\t\treturn data.charAt( data.length - 1 ) == ' ';\n\t}\n\n\t/**\n\t * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n\t *\n\t * Following changes are done:\n\t *\n\t * * multiple whitespaces are replaced to a single space,\n\t * * space at the beginning of a text node is removed if it is the first text node in its container\n\t * element or if the previous text node ends with a space character,\n\t * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container\n\t * * nbsps are converted to spaces.\n\t *\n\t * @param {Node} node DOM text node to process.\n\t * @returns {String} Processed data.\n\t * @private\n\t */\n\t_processDataFromDomText( node ) {\n\t\tlet data = node.data;\n\n\t\tif ( _hasDomParentOfType( node, this.preElements ) ) {\n\t\t\treturn getDataWithoutFiller( node );\n\t\t}\n\n\t\t// Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n\t\t// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n\t\t// We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\t\tdata = data.replace( /[ \\n\\t\\r]{1,}/g, ' ' );\n\n\t\tconst prevNode = this._getTouchingInlineDomNode( node, false );\n\t\tconst nextNode = this._getTouchingInlineDomNode( node, true );\n\n\t\tconst shouldLeftTrim = this._checkShouldLeftTrimDomText( node, prevNode );\n\t\tconst shouldRightTrim = this._checkShouldRightTrimDomText( node, nextNode );\n\n\t\t// If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n\t\t// of this text node. Such space character is treated as a whitespace.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^ /, '' );\n\t\t}\n\n\t\t// If the next text node does not exist remove space character from the end of this text node.\n\t\tif ( shouldRightTrim ) {\n\t\t\tdata = data.replace( / $/, '' );\n\t\t}\n\n\t\t// At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n\t\t// This means that the text node starts/end with normal space instead of non-breaking space.\n\t\t// This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n\t\t// the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\t\tdata = getDataWithoutFiller( new Text( data ) );\n\n\t\t// At this point we should have removed all whitespaces from DOM text data.\n\t\t//\n\t\t// Now, We will reverse the process that happens in `_processDataFromViewText`.\n\t\t//\n\t\t// We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n\t\t// First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n\t\t// ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\t\tdata = data.replace( / \\u00A0/g, '  ' );\n\n\t\tconst isNextNodeInlineObjectElement = nextNode && this.isElement( nextNode ) && nextNode.tagName != 'BR';\n\t\tconst isNextNodeStartingWithSpace = nextNode && isText( nextNode ) && nextNode.data.charAt( 0 ) == ' ';\n\n\t\t// Then, let's change the last nbsp to a space.\n\t\tif ( /( |\\u00A0)\\u00A0$/.test( data ) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace ) {\n\t\t\tdata = data.replace( /\\u00A0$/, ' ' );\n\t\t}\n\n\t\t// Then, change &nbsp; character that is at the beginning of the text node to space character.\n\t\t// We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\t\tif ( shouldLeftTrim || prevNode && this.isElement( prevNode ) && prevNode.tagName != 'BR' ) {\n\t\t\tdata = data.replace( /^\\u00A0/, ' ' );\n\t\t}\n\n\t\t// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n\t\t// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\t\treturn data;\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n\t * be trimmed from the left side.\n\t *\n\t * @private\n\t * @param {Node} node\n\t * @param {Node} prevNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n\t */\n\t_checkShouldLeftTrimDomText( node, prevNode ) {\n\t\tif ( !prevNode ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( this.isElement( prevNode ) ) {\n\t\t\treturn prevNode.tagName === 'BR';\n\t\t}\n\n\t\t// Shouldn't left trim if previous node is a node that was encountered as a raw content node.\n\t\tif ( this._encounteredRawContentDomNodes.has( node.previousSibling ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn /[^\\S\\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) );\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n\t * be trimmed from the right side.\n\t *\n\t * @private\n\t * @param {Node} node\n\t * @param {Node} nextNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n\t */\n\t_checkShouldRightTrimDomText( node, nextNode ) {\n\t\tif ( nextNode ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !startsWithFiller( node );\n\t}\n\n\t/**\n\t * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n\t * that is contained in the same container element. If there is no such sibling, `null` is returned.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Reference node.\n\t * @param {Boolean} getNext\n\t * @returns {module:engine/view/text~Text|module:engine/view/element~Element|null} Touching text node, an inline object\n\t * or `null` if there is no next or previous touching text node.\n\t */\n\t_getTouchingInlineViewNode( node, getNext ) {\n\t\tconst treeWalker = new ViewTreeWalker( {\n\t\t\tstartPosition: getNext ? ViewPosition._createAfter( node ) : ViewPosition._createBefore( node ),\n\t\t\tdirection: getNext ? 'forward' : 'backward'\n\t\t} );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\t// Found an inline object (for example an image).\n\t\t\tif ( value.item.is( 'element' ) && this.inlineObjectElements.includes( value.item.name ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t\t// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n\t\t\t// text node in its container element.\n\t\t\telse if ( value.item.is( 'containerElement' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// <br> found – it works like a block boundary, so do not scan further.\n\t\t\telse if ( value.item.is( 'element', 'br' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Found a text node in the same container element.\n\t\t\telse if ( value.item.is( '$textProxy' ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper function. For the given text node, it finds the closest touching node which is either\n\t * a text, `<br>` or an {@link #inlineObjectElements inline object}.\n\t *\n\t * If no such node is found, `null` is returned.\n\t *\n\t * For instance, in the following DOM structure:\n\t *\n\t *\t\t<p>foo<b>bar</b><br>bom</p>\n\t *\n\t * * `foo` doesn't have its previous touching inline node (`null` is returned),\n\t * * `foo`'s next touching inline node is `bar`\n\t * * `bar`'s next touching inline node is `<br>`\n\t *\n\t * This method returns text nodes and `<br>` elements because these types of nodes affect how\n\t * spaces in the given text node need to be converted.\n\t *\n\t * @private\n\t * @param {Text} node\n\t * @param {Boolean} getNext\n\t * @returns {Text|Element|null}\n\t */\n\t_getTouchingInlineDomNode( node, getNext ) {\n\t\tif ( !node.parentNode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst stepInto = getNext ? 'firstChild' : 'lastChild';\n\t\tconst stepOver = getNext ? 'nextSibling' : 'previousSibling';\n\n\t\tlet skipChildren = true;\n\n\t\tdo {\n\t\t\tif ( !skipChildren && node[ stepInto ] ) {\n\t\t\t\tnode = node[ stepInto ];\n\t\t\t} else if ( node[ stepOver ] ) {\n\t\t\t\tnode = node[ stepOver ];\n\t\t\t\tskipChildren = false;\n\t\t\t} else {\n\t\t\t\tnode = node.parentNode;\n\t\t\t\tskipChildren = true;\n\t\t\t}\n\n\t\t\tif ( !node || this._isBlockElement( node ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} while (\n\t\t\t!( isText( node ) || node.tagName == 'BR' || this._isInlineObjectElement( node ) )\n\t\t);\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.\n\t *\n\t * @private\n\t * @param {Node} node\n\t * @returns {Boolean}\n\t */\n\t_isBlockElement( node ) {\n\t\treturn this.isElement( node ) && this.blockElements.includes( node.tagName.toLowerCase() );\n\t}\n\n\t/**\n\t * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.\n\t *\n\t * @private\n\t * @param {Node} node\n\t * @returns {Boolean}\n\t */\n\t_isInlineObjectElement( node ) {\n\t\treturn this.isElement( node ) && this.inlineObjectElements.includes( node.tagName.toLowerCase() );\n\t}\n\n\t/**\n\t * Creates view element basing on the node type.\n\t *\n\t * @private\n\t * @param {Node} node DOM node to check.\n\t * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Element}\n\t */\n\t_createViewElement( node, options ) {\n\t\tif ( this.isComment( node ) ) {\n\t\t\treturn new ViewUIElement( this.document, '$comment' );\n\t\t}\n\n\t\tconst viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();\n\n\t\treturn new ViewElement( this.document, viewName );\n\t}\n\n\t/**\n\t * Checks if view element's content should be treated as a raw data.\n\t *\n\t * @private\n\t * @param {Element} viewElement View element to check.\n\t * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Boolean}\n\t */\n\t_isViewElementWithRawContent( viewElement, options ) {\n\t\treturn options.withChildren !== false && this._rawContentElementMatcher.match( viewElement );\n\t}\n\n\t/**\n\t * Checks whether given element name should be renamed in a current rendering mode.\n\t *\n\t * @private\n\t * @param {String} elementName The name of view element.\n\t * @returns {Boolean}\n\t */\n\t_shouldRenameElement( elementName ) {\n\t\treturn this.experimentalRenderingMode && this.renderingMode == 'editing' && elementName == 'script';\n\t}\n\n\t/**\n\t * Return a <span> element with special attribute holding the name of the original element.\n\t * Optionally, copy all the attributes of the original element if that element is provided.\n\t *\n\t * @private\n\t * @param {String} elementName The name of view element.\n\t * @param {Element} [originalDomElement] The original DOM element to copy attributes and content from.\n\t * @returns {Element}\n\t */\n\t_createReplacementDomElement( elementName, originalDomElement = null ) {\n\t\tconst newDomElement = document.createElement( 'span' );\n\n\t\t// Mark the span replacing a script as hidden.\n\t\tnewDomElement.setAttribute( 'data-ck-hidden', elementName );\n\n\t\tif ( originalDomElement ) {\n\t\t\twhile ( originalDomElement.firstChild ) {\n\t\t\t\tnewDomElement.appendChild( originalDomElement.firstChild );\n\t\t\t}\n\n\t\t\tfor ( const attributeName of originalDomElement.getAttributeNames() ) {\n\t\t\t\tnewDomElement.setAttribute( attributeName, originalDomElement.getAttribute( attributeName ) );\n\t\t\t}\n\t\t}\n\n\t\treturn newDomElement;\n\t}\n}\n\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType( node, types ) {\n\tconst parents = getAncestors( node );\n\n\treturn parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );\n}\n\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomNodeAncestor( node, callback ) {\n\twhile ( node && node != global.document ) {\n\t\tcallback( node );\n\t\tnode = node.parentNode;\n\t}\n}\n\n// Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\nfunction isNbspBlockFiller( domNode, blockElements ) {\n\tconst isNBSP = domNode.isEqualNode( NBSP_FILLER_REF );\n\n\treturn isNBSP && hasBlockParent( domNode, blockElements ) && domNode.parentNode.childNodes.length === 1;\n}\n\n// Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\nfunction hasBlockParent( domNode, blockElements ) {\n\tconst parent = domNode.parentNode;\n\n\treturn parent && parent.tagName && blockElements.includes( parent.tagName.toLowerCase() );\n}\n\n/**\n * Enum representing the type of the block filler.\n *\n * Possible values:\n *\n * * `br` &ndash; For the `<br data-cke-filler=\"true\">` block filler used in the editing view.\n * * `nbsp` &ndash; For the `&nbsp;` block fillers used in the data.\n * * `markedNbsp` &ndash; For the `&nbsp;` block fillers wrapped in `<span>` elements: `<span data-cke-filler=\"true\">&nbsp;</span>`\n * used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */\n"]},"metadata":{},"sourceType":"module"}