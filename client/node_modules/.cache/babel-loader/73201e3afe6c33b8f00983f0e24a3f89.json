{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/collection\n */\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport isIterable from './isiterable';\nimport mix from './mix';\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Collection {\n  /**\n   * Creates a new Collection instance.\n   *\n   * You can provide an iterable of initial items the collection will be created with:\n   *\n   *\t\tconst collection = new Collection( [ { id: 'John' }, { id: 'Mike' } ] );\n   *\n   *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n   *\t\tconsole.log( collection.get( 1 ) ); // -> { id: 'Mike' }\n   *\t\tconsole.log( collection.get( 'Mike' ) ); // -> { id: 'Mike' }\n   *\n   * Or you can first create a collection and then add new items using the {@link #add} method:\n   *\n   *\t\tconst collection = new Collection();\n   *\n   *\t\tcollection.add( { id: 'John' } );\n   *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n   *\n   * Whatever option you choose, you can always pass a configuration object as the last argument\n   * of the constructor:\n   *\n   *\t\tconst emptyCollection = new Collection( { idProperty: 'name' } );\n   *\t\temptyCollection.add( { name: 'John' } );\n   *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n   *\n   *\t\tconst nonEmptyCollection = new Collection( [ { name: 'John' } ], { idProperty: 'name' } );\n   *\t\tnonEmptyCollection.add( { name: 'George' } );\n   *\t\tconsole.log( collection.get( 'George' ) ); // -> { name: 'George' }\n   *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n   *\n   * @param {Iterable.<Object>|Object} [initialItemsOrOptions] The initial items of the collection or\n   * the options object.\n   * @param {Object} [options={}] The options object, when the first argument is an array of initial items.\n   * @param {String} [options.idProperty='id'] The name of the property which is used to identify an item.\n   * Items that do not have such a property will be assigned one when added to the collection.\n   */\n  constructor() {\n    let initialItemsOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const hasInitialItems = isIterable(initialItemsOrOptions);\n\n    if (!hasInitialItems) {\n      options = initialItemsOrOptions;\n    }\n    /**\n     * The internal list of items in the collection.\n     *\n     * @private\n     * @member {Object[]}\n     */\n\n\n    this._items = [];\n    /**\n     * The internal map of items in the collection.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._itemMap = new Map();\n    /**\n     * The name of the property which is considered to identify an item.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._idProperty = options.idProperty || 'id';\n    /**\n     * A helper mapping external items of a bound collection ({@link #bindTo})\n     * and actual items of this collection. It provides information\n     * necessary to properly remove items bound to another collection.\n     *\n     * See {@link #_bindToInternalToExternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToExternalToInternalMap = new WeakMap();\n    /**\n     * A helper mapping items of this collection to external items of a bound collection\n     * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n     * to avoid loops in twoâ€“way bindings.\n     *\n     * See {@link #_bindToExternalToInternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToInternalToExternalMap = new WeakMap();\n    /**\n     * Stores indexes of skipped items from bound external collection.\n     *\n     * @private\n     * @member {Array}\n     */\n\n    this._skippedIndexesFromExternal = []; // Set the initial content of the collection (if provided in the constructor).\n\n    if (hasInitialItems) {\n      for (const item of initialItemsOrOptions) {\n        this._items.push(item);\n\n        this._itemMap.set(this._getItemIdBeforeAdding(item), item);\n      }\n    }\n    /**\n     * A collection instance this collection is bound to as a result\n     * of calling {@link #bindTo} method.\n     *\n     * @protected\n     * @member {module:utils/collection~Collection} #_bindToCollection\n     */\n\n  }\n  /**\n   * The number of items available in the collection.\n   *\n   * @member {Number} #length\n   */\n\n\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Returns the first item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The first item or `null` if collection is empty.\n   */\n\n\n  get first() {\n    return this._items[0] || null;\n  }\n  /**\n   * Returns the last item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The last item or `null` if collection is empty.\n   */\n\n\n  get last() {\n    return this._items[this.length - 1] || null;\n  }\n  /**\n   * Adds an item into the collection.\n   *\n   * If the item does not have an id, then it will be automatically generated and set on the item.\n   *\n   * @chainable\n   * @param {Object} item\n   * @param {Number} [index] The position of the item in the collection. The item\n   * is pushed to the collection when `index` not specified.\n   * @fires add\n   * @fires change\n   */\n\n\n  add(item, index) {\n    return this.addMany([item], index);\n  }\n  /**\n   * Adds multiple items into the collection.\n   *\n   * Any item not containing an id will get an automatically generated one.\n   *\n   * @chainable\n   * @param {Iterable.<Object>} item\n   * @param {Number} [index] The position of the insertion. Items will be appended if no `index` is specified.\n   * @fires add\n   * @fires change\n   */\n\n\n  addMany(items, index) {\n    if (index === undefined) {\n      index = this._items.length;\n    } else if (index > this._items.length || index < 0) {\n      /**\n       * The `index` passed to {@link module:utils/collection~Collection#addMany `Collection#addMany()`}\n       * is invalid. It must be a number between 0 and the collection's length.\n       *\n       * @error collection-add-item-invalid-index\n       */\n      throw new CKEditorError('collection-add-item-invalid-index', this);\n    }\n\n    for (let offset = 0; offset < items.length; offset++) {\n      const item = items[offset];\n\n      const itemId = this._getItemIdBeforeAdding(item);\n\n      const currentItemIndex = index + offset;\n\n      this._items.splice(currentItemIndex, 0, item);\n\n      this._itemMap.set(itemId, item);\n\n      this.fire('add', item, currentItemIndex);\n    }\n\n    this.fire('change', {\n      added: items,\n      removed: [],\n      index\n    });\n    return this;\n  }\n  /**\n   * Gets an item by its ID or index.\n   *\n   * @param {String|Number} idOrIndex The item ID or index in the collection.\n   * @returns {Object|null} The requested item or `null` if such item does not exist.\n   */\n\n\n  get(idOrIndex) {\n    let item;\n\n    if (typeof idOrIndex == 'string') {\n      item = this._itemMap.get(idOrIndex);\n    } else if (typeof idOrIndex == 'number') {\n      item = this._items[idOrIndex];\n    } else {\n      /**\n       * An index or ID must be given.\n       *\n       * @error collection-get-invalid-arg\n       */\n      throw new CKEditorError('collection-get-invalid-arg', this);\n    }\n\n    return item || null;\n  }\n  /**\n   * Returns a Boolean indicating whether the collection contains an item.\n   *\n   * @param {Object|String} itemOrId The item or its ID in the collection.\n   * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n   */\n\n\n  has(itemOrId) {\n    if (typeof itemOrId == 'string') {\n      return this._itemMap.has(itemOrId);\n    } else {\n      // Object\n      const idProperty = this._idProperty;\n      const id = itemOrId[idProperty];\n      return this._itemMap.has(id);\n    }\n  }\n  /**\n   * Gets an index of an item in the collection.\n   * When an item is not defined in the collection, the index will equal -1.\n   *\n   * @param {Object|String} itemOrId The item or its ID in the collection.\n   * @returns {Number} The index of a given item.\n   */\n\n\n  getIndex(itemOrId) {\n    let item;\n\n    if (typeof itemOrId == 'string') {\n      item = this._itemMap.get(itemOrId);\n    } else {\n      item = itemOrId;\n    }\n\n    return this._items.indexOf(item);\n  }\n  /**\n   * Removes an item from the collection.\n   *\n   * @param {Object|Number|String} subject The item to remove, its ID or index in the collection.\n   * @returns {Object} The removed item.\n   * @fires remove\n   * @fires change\n   */\n\n\n  remove(subject) {\n    const [item, index] = this._remove(subject);\n\n    this.fire('change', {\n      added: [],\n      removed: [item],\n      index\n    });\n    return item;\n  }\n  /**\n   * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Array} The result of mapping.\n   */\n\n\n  map(callback, ctx) {\n    return this._items.map(callback, ctx);\n  }\n  /**\n   * Finds the first item in the collection for which the `callback` returns a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Object} The item for which `callback` returned a true value.\n   */\n\n\n  find(callback, ctx) {\n    return this._items.find(callback, ctx);\n  }\n  /**\n   * Returns an array with items for which the `callback` returned a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Object[]} The array with matching items.\n   */\n\n\n  filter(callback, ctx) {\n    return this._items.filter(callback, ctx);\n  }\n  /**\n   * Removes all items from the collection and destroys the binding created using\n   * {@link #bindTo}.\n   *\n   * @fires remove\n   * @fires change\n   */\n\n\n  clear() {\n    if (this._bindToCollection) {\n      this.stopListening(this._bindToCollection);\n      this._bindToCollection = null;\n    }\n\n    const removedItems = Array.from(this._items);\n\n    while (this.length) {\n      this._remove(0);\n    }\n\n    this.fire('change', {\n      added: [],\n      removed: removedItems,\n      index: 0\n    });\n  }\n  /**\n   * Binds and synchronizes the collection with another one.\n   *\n   * The binding can be a simple factory:\n   *\n   *\t\tclass FactoryClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).as( FactoryClass );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n   *\n   *\t\tsource.remove( 0 );\n   *\t\tconsole.log( target.length ); // 1\n   *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n   *\n   * or the factory driven by a custom callback:\n   *\n   *\t\tclass FooClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tclass BarClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( ( item ) => {\n   *\t\t\tif ( item.label == 'foo' ) {\n   *\t\t\t\treturn new FooClass( item );\n   *\t\t\t} else {\n   *\t\t\t\treturn new BarClass( item );\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n   *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n   *\n   * or the factory out of property name:\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( 'label' );\n   *\n   *\t\tsource.add( { label: { value: 'foo' } } );\n   *\t\tsource.add( { label: { value: 'bar' } } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n   *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n   *\n   * It's possible to skip specified items by returning falsy value:\n   *\n   *\t\tconst source = new Collection();\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( item => {\n   *\t\t\tif ( item.hidden ) {\n   *\t\t\t\treturn null;\n   *\t\t\t}\n   *\n   *\t\t\treturn item;\n   *\t\t} );\n   *\n   *\t\tsource.add( { hidden: true } );\n   *\t\tsource.add( { hidden: false } );\n   *\n   *\t\tconsole.log( source.length ); // 2\n   *\t\tconsole.log( target.length ); // 1\n   *\n   * **Note**: {@link #clear} can be used to break the binding.\n   *\n   * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n   * @returns {Object}\n   * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n   */\n\n\n  bindTo(externalCollection) {\n    if (this._bindToCollection) {\n      /**\n       * The collection cannot be bound more than once.\n       *\n       * @error collection-bind-to-rebind\n       */\n      throw new CKEditorError('collection-bind-to-rebind', this);\n    }\n\n    this._bindToCollection = externalCollection;\n    return {\n      as: Class => {\n        this._setUpBindToBinding(item => new Class(item));\n      },\n      using: callbackOrProperty => {\n        if (typeof callbackOrProperty == 'function') {\n          this._setUpBindToBinding(item => callbackOrProperty(item));\n        } else {\n          this._setUpBindToBinding(item => item[callbackOrProperty]);\n        }\n      }\n    };\n  }\n  /**\n   * Finalizes and activates a binding initiated by {#bindTo}.\n   *\n   * @protected\n   * @param {Function} factory A function which produces collection items.\n   */\n\n\n  _setUpBindToBinding(factory) {\n    const externalCollection = this._bindToCollection; // Adds the item to the collection once a change has been done to the external collection.\n    //\n    // @private\n\n    const addItem = (evt, externalItem, index) => {\n      const isExternalBoundToThis = externalCollection._bindToCollection == this;\n\n      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem); // If an external collection is bound to this collection, which makes it a 2â€“way binding,\n      // and the particular external collection item is already bound, don't add it here.\n      // The external item has been created **out of this collection's item** and (re)adding it will\n      // cause a loop.\n\n\n      if (isExternalBoundToThis && externalItemBound) {\n        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);\n\n        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);\n      } else {\n        const item = factory(externalItem); // When there is no item we need to remember skipped index first and then we can skip this item.\n\n        if (!item) {\n          this._skippedIndexesFromExternal.push(index);\n\n          return;\n        } // Lets try to put item at the same index as index in external collection\n        // but when there are a skipped items in one or both collections we need to recalculate this index.\n\n\n        let finalIndex = index; // When we try to insert item after some skipped items from external collection we need\n        // to include this skipped items and decrease index.\n        //\n        // For the following example:\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n        // internal -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n        //\n        // We can't just add 'D' to internal at the same index as index in external because\n        // this will produce empty indexes what is invalid:\n        // internal -> [ 'A', empty, empty, 'D' ]\n        //\n        // So we need to include skipped items and decrease index\n        // internal -> [ 'A', 'D' ]\n\n        for (const skipped of this._skippedIndexesFromExternal) {\n          if (index > skipped) {\n            finalIndex--;\n          }\n        } // We need to take into consideration that external collection could skip some items from\n        // internal collection.\n        //\n        // For the following example:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n        // external -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'D' ]\n        //\n        // We need to include skipped items and place new item after them:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\n\n        for (const skipped of externalCollection._skippedIndexesFromExternal) {\n          if (finalIndex >= skipped) {\n            finalIndex++;\n          }\n        }\n\n        this._bindToExternalToInternalMap.set(externalItem, item);\n\n        this._bindToInternalToExternalMap.set(item, externalItem);\n\n        this.add(item, finalIndex); // After adding new element to internal collection we need update indexes\n        // of skipped items in external collection.\n\n        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {\n          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {\n            externalCollection._skippedIndexesFromExternal[i]++;\n          }\n        }\n      }\n    }; // Load the initial content of the collection.\n\n\n    for (const externalItem of externalCollection) {\n      addItem(null, externalItem, externalCollection.getIndex(externalItem));\n    } // Synchronize the with collection as new items are added.\n\n\n    this.listenTo(externalCollection, 'add', addItem); // Synchronize the with collection as new items are removed.\n\n    this.listenTo(externalCollection, 'remove', (evt, externalItem, index) => {\n      const item = this._bindToExternalToInternalMap.get(externalItem);\n\n      if (item) {\n        this.remove(item);\n      } // After removing element from external collection we need update/remove indexes\n      // of skipped items in internal collection.\n\n\n      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {\n        if (index < skipped) {\n          result.push(skipped - 1);\n        }\n\n        if (index > skipped) {\n          result.push(skipped);\n        }\n\n        return result;\n      }, []);\n    });\n  }\n  /**\n   * Returns an unique id property for a given `item`.\n   *\n   * The method will generate new id and assign it to the `item` if it doesn't have any.\n   *\n   * @private\n   * @param {Object} item Item to be added.\n   * @returns {String}\n   */\n\n\n  _getItemIdBeforeAdding(item) {\n    const idProperty = this._idProperty;\n    let itemId;\n\n    if (idProperty in item) {\n      itemId = item[idProperty];\n\n      if (typeof itemId != 'string') {\n        /**\n         * This item's ID should be a string.\n         *\n         * @error collection-add-invalid-id\n         */\n        throw new CKEditorError('collection-add-invalid-id', this);\n      }\n\n      if (this.get(itemId)) {\n        /**\n         * This item already exists in the collection.\n         *\n         * @error collection-add-item-already-exists\n         */\n        throw new CKEditorError('collection-add-item-already-exists', this);\n      }\n    } else {\n      item[idProperty] = itemId = uid();\n    }\n\n    return itemId;\n  }\n  /**\n   * Core {@link #remove} method implementation shared in other functions.\n   *\n   * In contrast this method **does not** fire the {@link #event:change} event.\n   *\n   * @private\n   * @param {Object} subject The item to remove, its id or index in the collection.\n   * @returns {Array} Returns an array with the removed item and its index.\n   * @fires remove\n   */\n\n\n  _remove(subject) {\n    let index, id, item;\n    let itemDoesNotExist = false;\n    const idProperty = this._idProperty;\n\n    if (typeof subject == 'string') {\n      id = subject;\n      item = this._itemMap.get(id);\n      itemDoesNotExist = !item;\n\n      if (item) {\n        index = this._items.indexOf(item);\n      }\n    } else if (typeof subject == 'number') {\n      index = subject;\n      item = this._items[index];\n      itemDoesNotExist = !item;\n\n      if (item) {\n        id = item[idProperty];\n      }\n    } else {\n      item = subject;\n      id = item[idProperty];\n      index = this._items.indexOf(item);\n      itemDoesNotExist = index == -1 || !this._itemMap.get(id);\n    }\n\n    if (itemDoesNotExist) {\n      /**\n       * Item not found.\n       *\n       * @error collection-remove-404\n       */\n      throw new CKEditorError('collection-remove-404', this);\n    }\n\n    this._items.splice(index, 1);\n\n    this._itemMap.delete(id);\n\n    const externalItem = this._bindToInternalToExternalMap.get(item);\n\n    this._bindToInternalToExternalMap.delete(item);\n\n    this._bindToExternalToInternalMap.delete(externalItem);\n\n    this.fire('remove', item, index);\n    return [item, index];\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._items[Symbol.iterator]();\n  }\n  /**\n   * Fired when an item is added to the collection.\n   *\n   * @event add\n   * @param {Object} item The added item.\n   */\n\n  /**\n   * Fired when the collection was changed due to adding or removing items.\n   *\n   * @event change\n   * @param {Iterable.<Object>} added A list of added items.\n   * @param {Iterable.<Object>} removed A list of removed items.\n   * @param {Number} index An index where the addition or removal occurred.\n   */\n\n  /**\n   * Fired when an item is removed from the collection.\n   *\n   * @event remove\n   * @param {Object} item The removed item.\n   * @param {Number} index Index from which item was removed.\n   */\n\n\n}\nmix(Collection, EmitterMixin);\n/**\n * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method\n * providing functions that specify the type of the binding.\n *\n * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.\n *\n * @interface module:utils/collection~CollectionBindToChain\n */\n\n/**\n * Creates a callback or a property binding.\n *\n * @method #using\n * @param {Function|String} callbackOrProperty  When the function is passed, it should return\n * the collection items. When the string is provided, the property value is used to create the bound collection items.\n */\n\n/**\n * Creates the class factory binding in which items of the source collection are passed to\n * the constructor of the specified class.\n *\n * @method #as\n * @param {Function} Class The class constructor used to create instances in the factory.\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/collection.js"],"names":["EmitterMixin","CKEditorError","uid","isIterable","mix","Collection","constructor","initialItemsOrOptions","options","hasInitialItems","_items","_itemMap","Map","_idProperty","idProperty","_bindToExternalToInternalMap","WeakMap","_bindToInternalToExternalMap","_skippedIndexesFromExternal","item","push","set","_getItemIdBeforeAdding","length","first","last","add","index","addMany","items","undefined","offset","itemId","currentItemIndex","splice","fire","added","removed","get","idOrIndex","has","itemOrId","id","getIndex","indexOf","remove","subject","_remove","map","callback","ctx","find","filter","clear","_bindToCollection","stopListening","removedItems","Array","from","bindTo","externalCollection","as","Class","_setUpBindToBinding","using","callbackOrProperty","factory","addItem","evt","externalItem","isExternalBoundToThis","externalItemBound","finalIndex","skipped","i","listenTo","reduce","result","itemDoesNotExist","delete","Symbol","iterator"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,YAAP,MAAyB,gBAAzB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,UAAN,CAAiB;AAC/B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,GAA6C;AAAA,QAA3CC,qBAA2C,uEAAnB,EAAmB;AAAA,QAAfC,OAAe,uEAAL,EAAK;AACvD,UAAMC,eAAe,GAAGN,UAAU,CAAEI,qBAAF,CAAlC;;AAEA,QAAK,CAACE,eAAN,EAAwB;AACvBD,MAAAA,OAAO,GAAGD,qBAAV;AACA;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE,SAAKG,MAAL,GAAc,EAAd;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,WAAL,GAAmBL,OAAO,CAACM,UAAR,IAAsB,IAAzC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,4BAAL,GAAoC,IAAIC,OAAJ,EAApC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,4BAAL,GAAoC,IAAID,OAAJ,EAApC;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKE,2BAAL,GAAmC,EAAnC,CA7DuD,CA+DvD;;AACA,QAAKT,eAAL,EAAuB;AACtB,WAAM,MAAMU,IAAZ,IAAoBZ,qBAApB,EAA4C;AAC3C,aAAKG,MAAL,CAAYU,IAAZ,CAAkBD,IAAlB;;AACA,aAAKR,QAAL,CAAcU,GAAd,CAAmB,KAAKC,sBAAL,CAA6BH,IAA7B,CAAnB,EAAwDA,IAAxD;AACA;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AAED;AACD;AACA;AACA;AACA;;;AACW,MAANI,MAAM,GAAG;AACZ,WAAO,KAAKb,MAAL,CAAYa,MAAnB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACU,MAALC,KAAK,GAAG;AACX,WAAO,KAAKd,MAAL,CAAa,CAAb,KAAoB,IAA3B;AACA;AAED;AACD;AACA;AACA;AACA;;;AACS,MAAJe,IAAI,GAAG;AACV,WAAO,KAAKf,MAAL,CAAa,KAAKa,MAAL,GAAc,CAA3B,KAAkC,IAAzC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,GAAG,CAAEP,IAAF,EAAQQ,KAAR,EAAgB;AAClB,WAAO,KAAKC,OAAL,CAAc,CAAET,IAAF,CAAd,EAAwBQ,KAAxB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,OAAO,CAAEC,KAAF,EAASF,KAAT,EAAiB;AACvB,QAAKA,KAAK,KAAKG,SAAf,EAA2B;AAC1BH,MAAAA,KAAK,GAAG,KAAKjB,MAAL,CAAYa,MAApB;AACA,KAFD,MAEO,IAAKI,KAAK,GAAG,KAAKjB,MAAL,CAAYa,MAApB,IAA8BI,KAAK,GAAG,CAA3C,EAA+C;AACrD;AACH;AACA;AACA;AACA;AACA;AACG,YAAM,IAAI1B,aAAJ,CAAmB,mCAAnB,EAAwD,IAAxD,CAAN;AACA;;AAED,SAAM,IAAI8B,MAAM,GAAG,CAAnB,EAAsBA,MAAM,GAAGF,KAAK,CAACN,MAArC,EAA6CQ,MAAM,EAAnD,EAAwD;AACvD,YAAMZ,IAAI,GAAGU,KAAK,CAAEE,MAAF,CAAlB;;AACA,YAAMC,MAAM,GAAG,KAAKV,sBAAL,CAA6BH,IAA7B,CAAf;;AACA,YAAMc,gBAAgB,GAAGN,KAAK,GAAGI,MAAjC;;AAEA,WAAKrB,MAAL,CAAYwB,MAAZ,CAAoBD,gBAApB,EAAsC,CAAtC,EAAyCd,IAAzC;;AACA,WAAKR,QAAL,CAAcU,GAAd,CAAmBW,MAAnB,EAA2Bb,IAA3B;;AAEA,WAAKgB,IAAL,CAAW,KAAX,EAAkBhB,IAAlB,EAAwBc,gBAAxB;AACA;;AAED,SAAKE,IAAL,CAAW,QAAX,EAAqB;AACpBC,MAAAA,KAAK,EAAEP,KADa;AAEpBQ,MAAAA,OAAO,EAAE,EAFW;AAGpBV,MAAAA;AAHoB,KAArB;AAMA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCW,EAAAA,GAAG,CAAEC,SAAF,EAAc;AAChB,QAAIpB,IAAJ;;AAEA,QAAK,OAAOoB,SAAP,IAAoB,QAAzB,EAAoC;AACnCpB,MAAAA,IAAI,GAAG,KAAKR,QAAL,CAAc2B,GAAd,CAAmBC,SAAnB,CAAP;AACA,KAFD,MAEO,IAAK,OAAOA,SAAP,IAAoB,QAAzB,EAAoC;AAC1CpB,MAAAA,IAAI,GAAG,KAAKT,MAAL,CAAa6B,SAAb,CAAP;AACA,KAFM,MAEA;AACN;AACH;AACA;AACA;AACA;AACG,YAAM,IAAItC,aAAJ,CAAmB,4BAAnB,EAAiD,IAAjD,CAAN;AACA;;AAED,WAAOkB,IAAI,IAAI,IAAf;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCqB,EAAAA,GAAG,CAAEC,QAAF,EAAa;AACf,QAAK,OAAOA,QAAP,IAAmB,QAAxB,EAAmC;AAClC,aAAO,KAAK9B,QAAL,CAAc6B,GAAd,CAAmBC,QAAnB,CAAP;AACA,KAFD,MAEO;AAAE;AACR,YAAM3B,UAAU,GAAG,KAAKD,WAAxB;AACA,YAAM6B,EAAE,GAAGD,QAAQ,CAAE3B,UAAF,CAAnB;AAEA,aAAO,KAAKH,QAAL,CAAc6B,GAAd,CAAmBE,EAAnB,CAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,QAAQ,CAAEF,QAAF,EAAa;AACpB,QAAItB,IAAJ;;AAEA,QAAK,OAAOsB,QAAP,IAAmB,QAAxB,EAAmC;AAClCtB,MAAAA,IAAI,GAAG,KAAKR,QAAL,CAAc2B,GAAd,CAAmBG,QAAnB,CAAP;AACA,KAFD,MAEO;AACNtB,MAAAA,IAAI,GAAGsB,QAAP;AACA;;AAED,WAAO,KAAK/B,MAAL,CAAYkC,OAAZ,CAAqBzB,IAArB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC0B,EAAAA,MAAM,CAAEC,OAAF,EAAY;AACjB,UAAM,CAAE3B,IAAF,EAAQQ,KAAR,IAAkB,KAAKoB,OAAL,CAAcD,OAAd,CAAxB;;AAEA,SAAKX,IAAL,CAAW,QAAX,EAAqB;AACpBC,MAAAA,KAAK,EAAE,EADa;AAEpBC,MAAAA,OAAO,EAAE,CAAElB,IAAF,CAFW;AAGpBQ,MAAAA;AAHoB,KAArB;AAMA,WAAOR,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC6B,EAAAA,GAAG,CAAEC,QAAF,EAAYC,GAAZ,EAAkB;AACpB,WAAO,KAAKxC,MAAL,CAAYsC,GAAZ,CAAiBC,QAAjB,EAA2BC,GAA3B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,IAAI,CAAEF,QAAF,EAAYC,GAAZ,EAAkB;AACrB,WAAO,KAAKxC,MAAL,CAAYyC,IAAZ,CAAkBF,QAAlB,EAA4BC,GAA5B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,MAAM,CAAEH,QAAF,EAAYC,GAAZ,EAAkB;AACvB,WAAO,KAAKxC,MAAL,CAAY0C,MAAZ,CAAoBH,QAApB,EAA8BC,GAA9B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,KAAK,GAAG;AACP,QAAK,KAAKC,iBAAV,EAA8B;AAC7B,WAAKC,aAAL,CAAoB,KAAKD,iBAAzB;AACA,WAAKA,iBAAL,GAAyB,IAAzB;AACA;;AAED,UAAME,YAAY,GAAGC,KAAK,CAACC,IAAN,CAAY,KAAKhD,MAAjB,CAArB;;AAEA,WAAQ,KAAKa,MAAb,EAAsB;AACrB,WAAKwB,OAAL,CAAc,CAAd;AACA;;AAED,SAAKZ,IAAL,CAAW,QAAX,EAAqB;AACpBC,MAAAA,KAAK,EAAE,EADa;AAEpBC,MAAAA,OAAO,EAAEmB,YAFW;AAGpB7B,MAAAA,KAAK,EAAE;AAHa,KAArB;AAKA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCgC,EAAAA,MAAM,CAAEC,kBAAF,EAAuB;AAC5B,QAAK,KAAKN,iBAAV,EAA8B;AAC7B;AACH;AACA;AACA;AACA;AACG,YAAM,IAAIrD,aAAJ,CAAmB,2BAAnB,EAAgD,IAAhD,CAAN;AACA;;AAED,SAAKqD,iBAAL,GAAyBM,kBAAzB;AAEA,WAAO;AACNC,MAAAA,EAAE,EAAEC,KAAK,IAAI;AACZ,aAAKC,mBAAL,CAA0B5C,IAAI,IAAI,IAAI2C,KAAJ,CAAW3C,IAAX,CAAlC;AACA,OAHK;AAKN6C,MAAAA,KAAK,EAAEC,kBAAkB,IAAI;AAC5B,YAAK,OAAOA,kBAAP,IAA6B,UAAlC,EAA+C;AAC9C,eAAKF,mBAAL,CAA0B5C,IAAI,IAAI8C,kBAAkB,CAAE9C,IAAF,CAApD;AACA,SAFD,MAEO;AACN,eAAK4C,mBAAL,CAA0B5C,IAAI,IAAIA,IAAI,CAAE8C,kBAAF,CAAtC;AACA;AACD;AAXK,KAAP;AAaA;AAED;AACD;AACA;AACA;AACA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/collection\n */\n\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport isIterable from './isiterable';\nimport mix from './mix';\n\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Collection {\n\t/**\n\t * Creates a new Collection instance.\n\t *\n\t * You can provide an iterable of initial items the collection will be created with:\n\t *\n\t *\t\tconst collection = new Collection( [ { id: 'John' }, { id: 'Mike' } ] );\n\t *\n\t *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n\t *\t\tconsole.log( collection.get( 1 ) ); // -> { id: 'Mike' }\n\t *\t\tconsole.log( collection.get( 'Mike' ) ); // -> { id: 'Mike' }\n\t *\n\t * Or you can first create a collection and then add new items using the {@link #add} method:\n\t *\n\t *\t\tconst collection = new Collection();\n\t *\n\t *\t\tcollection.add( { id: 'John' } );\n\t *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n\t *\n\t * Whatever option you choose, you can always pass a configuration object as the last argument\n\t * of the constructor:\n\t *\n\t *\t\tconst emptyCollection = new Collection( { idProperty: 'name' } );\n\t *\t\temptyCollection.add( { name: 'John' } );\n\t *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n\t *\n\t *\t\tconst nonEmptyCollection = new Collection( [ { name: 'John' } ], { idProperty: 'name' } );\n\t *\t\tnonEmptyCollection.add( { name: 'George' } );\n\t *\t\tconsole.log( collection.get( 'George' ) ); // -> { name: 'George' }\n\t *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n\t *\n\t * @param {Iterable.<Object>|Object} [initialItemsOrOptions] The initial items of the collection or\n\t * the options object.\n\t * @param {Object} [options={}] The options object, when the first argument is an array of initial items.\n\t * @param {String} [options.idProperty='id'] The name of the property which is used to identify an item.\n\t * Items that do not have such a property will be assigned one when added to the collection.\n\t */\n\tconstructor( initialItemsOrOptions = {}, options = {} ) {\n\t\tconst hasInitialItems = isIterable( initialItemsOrOptions );\n\n\t\tif ( !hasInitialItems ) {\n\t\t\toptions = initialItemsOrOptions;\n\t\t}\n\n\t\t/**\n\t\t * The internal list of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Object[]}\n\t\t */\n\t\tthis._items = [];\n\n\t\t/**\n\t\t * The internal map of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._itemMap = new Map();\n\n\t\t/**\n\t\t * The name of the property which is considered to identify an item.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._idProperty = options.idProperty || 'id';\n\n\t\t/**\n\t\t * A helper mapping external items of a bound collection ({@link #bindTo})\n\t\t * and actual items of this collection. It provides information\n\t\t * necessary to properly remove items bound to another collection.\n\t\t *\n\t\t * See {@link #_bindToInternalToExternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToExternalToInternalMap = new WeakMap();\n\n\t\t/**\n\t\t * A helper mapping items of this collection to external items of a bound collection\n\t\t * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n\t\t * to avoid loops in twoâ€“way bindings.\n\t\t *\n\t\t * See {@link #_bindToExternalToInternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToInternalToExternalMap = new WeakMap();\n\n\t\t/**\n\t\t * Stores indexes of skipped items from bound external collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Array}\n\t\t */\n\t\tthis._skippedIndexesFromExternal = [];\n\n\t\t// Set the initial content of the collection (if provided in the constructor).\n\t\tif ( hasInitialItems ) {\n\t\t\tfor ( const item of initialItemsOrOptions ) {\n\t\t\t\tthis._items.push( item );\n\t\t\t\tthis._itemMap.set( this._getItemIdBeforeAdding( item ), item );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * A collection instance this collection is bound to as a result\n\t\t * of calling {@link #bindTo} method.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:utils/collection~Collection} #_bindToCollection\n\t\t */\n\t}\n\n\t/**\n\t * The number of items available in the collection.\n\t *\n\t * @member {Number} #length\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * Returns the first item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The first item or `null` if collection is empty.\n\t */\n\tget first() {\n\t\treturn this._items[ 0 ] || null;\n\t}\n\n\t/**\n\t * Returns the last item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The last item or `null` if collection is empty.\n\t */\n\tget last() {\n\t\treturn this._items[ this.length - 1 ] || null;\n\t}\n\n\t/**\n\t * Adds an item into the collection.\n\t *\n\t * If the item does not have an id, then it will be automatically generated and set on the item.\n\t *\n\t * @chainable\n\t * @param {Object} item\n\t * @param {Number} [index] The position of the item in the collection. The item\n\t * is pushed to the collection when `index` not specified.\n\t * @fires add\n\t * @fires change\n\t */\n\tadd( item, index ) {\n\t\treturn this.addMany( [ item ], index );\n\t}\n\n\t/**\n\t * Adds multiple items into the collection.\n\t *\n\t * Any item not containing an id will get an automatically generated one.\n\t *\n\t * @chainable\n\t * @param {Iterable.<Object>} item\n\t * @param {Number} [index] The position of the insertion. Items will be appended if no `index` is specified.\n\t * @fires add\n\t * @fires change\n\t */\n\taddMany( items, index ) {\n\t\tif ( index === undefined ) {\n\t\t\tindex = this._items.length;\n\t\t} else if ( index > this._items.length || index < 0 ) {\n\t\t\t/**\n\t\t\t * The `index` passed to {@link module:utils/collection~Collection#addMany `Collection#addMany()`}\n\t\t\t * is invalid. It must be a number between 0 and the collection's length.\n\t\t\t *\n\t\t\t * @error collection-add-item-invalid-index\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-add-item-invalid-index', this );\n\t\t}\n\n\t\tfor ( let offset = 0; offset < items.length; offset++ ) {\n\t\t\tconst item = items[ offset ];\n\t\t\tconst itemId = this._getItemIdBeforeAdding( item );\n\t\t\tconst currentItemIndex = index + offset;\n\n\t\t\tthis._items.splice( currentItemIndex, 0, item );\n\t\t\tthis._itemMap.set( itemId, item );\n\n\t\t\tthis.fire( 'add', item, currentItemIndex );\n\t\t}\n\n\t\tthis.fire( 'change', {\n\t\t\tadded: items,\n\t\t\tremoved: [],\n\t\t\tindex\n\t\t} );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets an item by its ID or index.\n\t *\n\t * @param {String|Number} idOrIndex The item ID or index in the collection.\n\t * @returns {Object|null} The requested item or `null` if such item does not exist.\n\t */\n\tget( idOrIndex ) {\n\t\tlet item;\n\n\t\tif ( typeof idOrIndex == 'string' ) {\n\t\t\titem = this._itemMap.get( idOrIndex );\n\t\t} else if ( typeof idOrIndex == 'number' ) {\n\t\t\titem = this._items[ idOrIndex ];\n\t\t} else {\n\t\t\t/**\n\t\t\t * An index or ID must be given.\n\t\t\t *\n\t\t\t * @error collection-get-invalid-arg\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-get-invalid-arg', this );\n\t\t}\n\n\t\treturn item || null;\n\t}\n\n\t/**\n\t * Returns a Boolean indicating whether the collection contains an item.\n\t *\n\t * @param {Object|String} itemOrId The item or its ID in the collection.\n\t * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n\t */\n\thas( itemOrId ) {\n\t\tif ( typeof itemOrId == 'string' ) {\n\t\t\treturn this._itemMap.has( itemOrId );\n\t\t} else { // Object\n\t\t\tconst idProperty = this._idProperty;\n\t\t\tconst id = itemOrId[ idProperty ];\n\n\t\t\treturn this._itemMap.has( id );\n\t\t}\n\t}\n\n\t/**\n\t * Gets an index of an item in the collection.\n\t * When an item is not defined in the collection, the index will equal -1.\n\t *\n\t * @param {Object|String} itemOrId The item or its ID in the collection.\n\t * @returns {Number} The index of a given item.\n\t */\n\tgetIndex( itemOrId ) {\n\t\tlet item;\n\n\t\tif ( typeof itemOrId == 'string' ) {\n\t\t\titem = this._itemMap.get( itemOrId );\n\t\t} else {\n\t\t\titem = itemOrId;\n\t\t}\n\n\t\treturn this._items.indexOf( item );\n\t}\n\n\t/**\n\t * Removes an item from the collection.\n\t *\n\t * @param {Object|Number|String} subject The item to remove, its ID or index in the collection.\n\t * @returns {Object} The removed item.\n\t * @fires remove\n\t * @fires change\n\t */\n\tremove( subject ) {\n\t\tconst [ item, index ] = this._remove( subject );\n\n\t\tthis.fire( 'change', {\n\t\t\tadded: [],\n\t\t\tremoved: [ item ],\n\t\t\tindex\n\t\t} );\n\n\t\treturn item;\n\t}\n\n\t/**\n\t * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Array} The result of mapping.\n\t */\n\tmap( callback, ctx ) {\n\t\treturn this._items.map( callback, ctx );\n\t}\n\n\t/**\n\t * Finds the first item in the collection for which the `callback` returns a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Object} The item for which `callback` returned a true value.\n\t */\n\tfind( callback, ctx ) {\n\t\treturn this._items.find( callback, ctx );\n\t}\n\n\t/**\n\t * Returns an array with items for which the `callback` returned a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Object[]} The array with matching items.\n\t */\n\tfilter( callback, ctx ) {\n\t\treturn this._items.filter( callback, ctx );\n\t}\n\n\t/**\n\t * Removes all items from the collection and destroys the binding created using\n\t * {@link #bindTo}.\n\t *\n\t * @fires remove\n\t * @fires change\n\t */\n\tclear() {\n\t\tif ( this._bindToCollection ) {\n\t\t\tthis.stopListening( this._bindToCollection );\n\t\t\tthis._bindToCollection = null;\n\t\t}\n\n\t\tconst removedItems = Array.from( this._items );\n\n\t\twhile ( this.length ) {\n\t\t\tthis._remove( 0 );\n\t\t}\n\n\t\tthis.fire( 'change', {\n\t\t\tadded: [],\n\t\t\tremoved: removedItems,\n\t\t\tindex: 0\n\t\t} );\n\t}\n\n\t/**\n\t * Binds and synchronizes the collection with another one.\n\t *\n\t * The binding can be a simple factory:\n\t *\n\t *\t\tclass FactoryClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).as( FactoryClass );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n\t *\n\t *\t\tsource.remove( 0 );\n\t *\t\tconsole.log( target.length ); // 1\n\t *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n\t *\n\t * or the factory driven by a custom callback:\n\t *\n\t *\t\tclass FooClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tclass BarClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( ( item ) => {\n\t *\t\t\tif ( item.label == 'foo' ) {\n\t *\t\t\t\treturn new FooClass( item );\n\t *\t\t\t} else {\n\t *\t\t\t\treturn new BarClass( item );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n\t *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n\t *\n\t * or the factory out of property name:\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( 'label' );\n\t *\n\t *\t\tsource.add( { label: { value: 'foo' } } );\n\t *\t\tsource.add( { label: { value: 'bar' } } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n\t *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n\t *\n\t * It's possible to skip specified items by returning falsy value:\n\t *\n\t *\t\tconst source = new Collection();\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( item => {\n\t *\t\t\tif ( item.hidden ) {\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn item;\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { hidden: true } );\n\t *\t\tsource.add( { hidden: false } );\n\t *\n\t *\t\tconsole.log( source.length ); // 2\n\t *\t\tconsole.log( target.length ); // 1\n\t *\n\t * **Note**: {@link #clear} can be used to break the binding.\n\t *\n\t * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n\t * @returns {Object}\n\t * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n\t */\n\tbindTo( externalCollection ) {\n\t\tif ( this._bindToCollection ) {\n\t\t\t/**\n\t\t\t * The collection cannot be bound more than once.\n\t\t\t *\n\t\t\t * @error collection-bind-to-rebind\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-bind-to-rebind', this );\n\t\t}\n\n\t\tthis._bindToCollection = externalCollection;\n\n\t\treturn {\n\t\t\tas: Class => {\n\t\t\t\tthis._setUpBindToBinding( item => new Class( item ) );\n\t\t\t},\n\n\t\t\tusing: callbackOrProperty => {\n\t\t\t\tif ( typeof callbackOrProperty == 'function' ) {\n\t\t\t\t\tthis._setUpBindToBinding( item => callbackOrProperty( item ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis._setUpBindToBinding( item => item[ callbackOrProperty ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Finalizes and activates a binding initiated by {#bindTo}.\n\t *\n\t * @protected\n\t * @param {Function} factory A function which produces collection items.\n\t */\n\t_setUpBindToBinding( factory ) {\n\t\tconst externalCollection = this._bindToCollection;\n\n\t\t// Adds the item to the collection once a change has been done to the external collection.\n\t\t//\n\t\t// @private\n\t\tconst addItem = ( evt, externalItem, index ) => {\n\t\t\tconst isExternalBoundToThis = externalCollection._bindToCollection == this;\n\t\t\tconst externalItemBound = externalCollection._bindToInternalToExternalMap.get( externalItem );\n\n\t\t\t// If an external collection is bound to this collection, which makes it a 2â€“way binding,\n\t\t\t// and the particular external collection item is already bound, don't add it here.\n\t\t\t// The external item has been created **out of this collection's item** and (re)adding it will\n\t\t\t// cause a loop.\n\t\t\tif ( isExternalBoundToThis && externalItemBound ) {\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, externalItemBound );\n\t\t\t\tthis._bindToInternalToExternalMap.set( externalItemBound, externalItem );\n\t\t\t} else {\n\t\t\t\tconst item = factory( externalItem );\n\n\t\t\t\t// When there is no item we need to remember skipped index first and then we can skip this item.\n\t\t\t\tif ( !item ) {\n\t\t\t\t\tthis._skippedIndexesFromExternal.push( index );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Lets try to put item at the same index as index in external collection\n\t\t\t\t// but when there are a skipped items in one or both collections we need to recalculate this index.\n\t\t\t\tlet finalIndex = index;\n\n\t\t\t\t// When we try to insert item after some skipped items from external collection we need\n\t\t\t\t// to include this skipped items and decrease index.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n\t\t\t\t// internal -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We can't just add 'D' to internal at the same index as index in external because\n\t\t\t\t// this will produce empty indexes what is invalid:\n\t\t\t\t// internal -> [ 'A', empty, empty, 'D' ]\n\t\t\t\t//\n\t\t\t\t// So we need to include skipped items and decrease index\n\t\t\t\t// internal -> [ 'A', 'D' ]\n\t\t\t\tfor ( const skipped of this._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\t\tfinalIndex--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration that external collection could skip some items from\n\t\t\t\t// internal collection.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n\t\t\t\t// external -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We need to include skipped items and place new item after them:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\t\t\t\tfor ( const skipped of externalCollection._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( finalIndex >= skipped ) {\n\t\t\t\t\t\tfinalIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, item );\n\t\t\t\tthis._bindToInternalToExternalMap.set( item, externalItem );\n\t\t\t\tthis.add( item, finalIndex );\n\n\t\t\t\t// After adding new element to internal collection we need update indexes\n\t\t\t\t// of skipped items in external collection.\n\t\t\t\tfor ( let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++ ) {\n\t\t\t\t\tif ( finalIndex <= externalCollection._skippedIndexesFromExternal[ i ] ) {\n\t\t\t\t\t\texternalCollection._skippedIndexesFromExternal[ i ]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Load the initial content of the collection.\n\t\tfor ( const externalItem of externalCollection ) {\n\t\t\taddItem( null, externalItem, externalCollection.getIndex( externalItem ) );\n\t\t}\n\n\t\t// Synchronize the with collection as new items are added.\n\t\tthis.listenTo( externalCollection, 'add', addItem );\n\n\t\t// Synchronize the with collection as new items are removed.\n\t\tthis.listenTo( externalCollection, 'remove', ( evt, externalItem, index ) => {\n\t\t\tconst item = this._bindToExternalToInternalMap.get( externalItem );\n\n\t\t\tif ( item ) {\n\t\t\t\tthis.remove( item );\n\t\t\t}\n\n\t\t\t// After removing element from external collection we need update/remove indexes\n\t\t\t// of skipped items in internal collection.\n\t\t\tthis._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce( ( result, skipped ) => {\n\t\t\t\tif ( index < skipped ) {\n\t\t\t\t\tresult.push( skipped - 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\tresult.push( skipped );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [] );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns an unique id property for a given `item`.\n\t *\n\t * The method will generate new id and assign it to the `item` if it doesn't have any.\n\t *\n\t * @private\n\t * @param {Object} item Item to be added.\n\t * @returns {String}\n\t */\n\t_getItemIdBeforeAdding( item ) {\n\t\tconst idProperty = this._idProperty;\n\t\tlet itemId;\n\n\t\tif ( ( idProperty in item ) ) {\n\t\t\titemId = item[ idProperty ];\n\n\t\t\tif ( typeof itemId != 'string' ) {\n\t\t\t\t/**\n\t\t\t\t * This item's ID should be a string.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-invalid-id\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-invalid-id', this );\n\t\t\t}\n\n\t\t\tif ( this.get( itemId ) ) {\n\t\t\t\t/**\n\t\t\t\t * This item already exists in the collection.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-item-already-exists\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-item-already-exists', this );\n\t\t\t}\n\t\t} else {\n\t\t\titem[ idProperty ] = itemId = uid();\n\t\t}\n\n\t\treturn itemId;\n\t}\n\n\t/**\n\t * Core {@link #remove} method implementation shared in other functions.\n\t *\n\t * In contrast this method **does not** fire the {@link #event:change} event.\n\t *\n\t * @private\n\t * @param {Object} subject The item to remove, its id or index in the collection.\n\t * @returns {Array} Returns an array with the removed item and its index.\n\t * @fires remove\n\t */\n\t_remove( subject ) {\n\t\tlet index, id, item;\n\t\tlet itemDoesNotExist = false;\n\t\tconst idProperty = this._idProperty;\n\n\t\tif ( typeof subject == 'string' ) {\n\t\t\tid = subject;\n\t\t\titem = this._itemMap.get( id );\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tindex = this._items.indexOf( item );\n\t\t\t}\n\t\t} else if ( typeof subject == 'number' ) {\n\t\t\tindex = subject;\n\t\t\titem = this._items[ index ];\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tid = item[ idProperty ];\n\t\t\t}\n\t\t} else {\n\t\t\titem = subject;\n\t\t\tid = item[ idProperty ];\n\t\t\tindex = this._items.indexOf( item );\n\t\t\titemDoesNotExist = ( index == -1 || !this._itemMap.get( id ) );\n\t\t}\n\n\t\tif ( itemDoesNotExist ) {\n\t\t\t/**\n\t\t\t * Item not found.\n\t\t\t *\n\t\t\t * @error collection-remove-404\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-remove-404', this );\n\t\t}\n\n\t\tthis._items.splice( index, 1 );\n\t\tthis._itemMap.delete( id );\n\n\t\tconst externalItem = this._bindToInternalToExternalMap.get( item );\n\t\tthis._bindToInternalToExternalMap.delete( item );\n\t\tthis._bindToExternalToInternalMap.delete( externalItem );\n\n\t\tthis.fire( 'remove', item, index );\n\n\t\treturn [ item, index ];\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Fired when an item is added to the collection.\n\t *\n\t * @event add\n\t * @param {Object} item The added item.\n\t */\n\n\t/**\n\t * Fired when the collection was changed due to adding or removing items.\n\t *\n\t * @event change\n\t * @param {Iterable.<Object>} added A list of added items.\n\t * @param {Iterable.<Object>} removed A list of removed items.\n\t * @param {Number} index An index where the addition or removal occurred.\n\t */\n\n\t/**\n\t * Fired when an item is removed from the collection.\n\t *\n\t * @event remove\n\t * @param {Object} item The removed item.\n\t * @param {Number} index Index from which item was removed.\n\t */\n}\n\nmix( Collection, EmitterMixin );\n\n/**\n * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method\n * providing functions that specify the type of the binding.\n *\n * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.\n *\n * @interface module:utils/collection~CollectionBindToChain\n */\n\n/**\n * Creates a callback or a property binding.\n *\n * @method #using\n * @param {Function|String} callbackOrProperty  When the function is passed, it should return\n * the collection items. When the string is provided, the property value is used to create the bound collection items.\n */\n\n/**\n * Creates the class factory binding in which items of the source collection are passed to\n * the constructor of the specified class.\n *\n * @method #as\n * @param {Function} Class The class constructor used to create instances in the factory.\n */\n"]},"metadata":{},"sourceType":"module"}