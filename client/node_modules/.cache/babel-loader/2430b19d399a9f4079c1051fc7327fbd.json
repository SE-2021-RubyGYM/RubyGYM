{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n  /**\n   * Creates an empty History instance.\n   */\n  constructor() {\n    /**\n     * Operations added to the history.\n     *\n     * @protected\n     * @member {Array.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_operations\n     */\n    this._operations = [];\n    /**\n     * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     *\n     * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n     * value is an operation that has been undone by the \"undoing operation\".\n     *\n     * @private\n     * @member {Map} module:engine/model/history~History#_undoPairs\n     */\n\n    this._undoPairs = new Map();\n    /**\n     * Holds all undone operations.\n     *\n     * @private\n     * @member {Set.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_undoneOperations\n     */\n\n    this._undoneOperations = new Set();\n  }\n  /**\n   * Adds an operation to the history.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n   */\n\n\n  addOperation(operation) {\n    if (this._operations.includes(operation)) {\n      return;\n    }\n\n    this._operations.push(operation);\n  }\n  /**\n   * Returns operations added to the history.\n   *\n   * @param {Number} [from=Number.NEGATIVE_INFINITY] Base version from which operations should be returned (inclusive).\n   * Defaults to `Number.NEGATIVE_INFINITY`, which means that operations from the first one will be returned.\n   * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which operations should be returned (exclusive).\n   * Defaults to `Number.POSITIVE_INFINITY` which means that operations up to the last one will be returned.\n   * @returns {Array.<module:engine/model/operation/operation~Operation>} Operations added to the history.\n   */\n\n\n  getOperations() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NEGATIVE_INFINITY;\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    const operations = [];\n\n    for (const operation of this._operations) {\n      if (operation.baseVersion >= from && operation.baseVersion < to) {\n        operations.push(operation);\n      }\n    }\n\n    return operations;\n  }\n  /**\n   * Returns operation from the history that bases on given `baseVersion`.\n   *\n   * @param {Number} baseVersion Base version of the operation to get.\n   * @returns {module:engine/model/operation/operation~Operation|undefined} Operation with given base version or `undefined` if\n   * there is no such operation in history.\n   */\n\n\n  getOperation(baseVersion) {\n    for (const operation of this._operations) {\n      if (operation.baseVersion == baseVersion) {\n        return operation;\n      }\n    }\n  }\n  /**\n   * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n   * history is keeping more context information about operations, which helps in operational transformation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n   */\n\n\n  setOperationAsUndone(undoneOperation, undoingOperation) {\n    this._undoPairs.set(undoingOperation, undoneOperation);\n\n    this._undoneOperations.add(undoneOperation);\n  }\n  /**\n   * Checks whether given `operation` is undoing any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n   */\n\n\n  isUndoingOperation(operation) {\n    return this._undoPairs.has(operation);\n  }\n  /**\n   * Checks whether given `operation` has been undone by any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n   */\n\n\n  isUndoneOperation(operation) {\n    return this._undoneOperations.has(operation);\n  }\n  /**\n   * For given `undoingOperation`, returns the operation which has been undone by it.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation\n   * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n   * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n   */\n\n\n  getUndoneOperation(undoingOperation) {\n    return this._undoPairs.get(undoingOperation);\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/history.js"],"names":["History","constructor","_operations","_undoPairs","Map","_undoneOperations","Set","addOperation","operation","includes","push","getOperations","from","Number","NEGATIVE_INFINITY","to","POSITIVE_INFINITY","operations","baseVersion","getOperation","setOperationAsUndone","undoneOperation","undoingOperation","set","add","isUndoingOperation","has","isUndoneOperation","getUndoneOperation","get"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAMA,OAAN,CAAc;AAC5B;AACD;AACA;AACCC,EAAAA,WAAW,GAAG;AACb;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,WAAL,GAAmB,EAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,iBAAL,GAAyB,IAAIC,GAAJ,EAAzB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAAEC,SAAF,EAAc;AACzB,QAAK,KAAKN,WAAL,CAAiBO,QAAjB,CAA2BD,SAA3B,CAAL,EAA8C;AAC7C;AACA;;AAED,SAAKN,WAAL,CAAiBQ,IAAjB,CAAuBF,SAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,aAAa,GAAmE;AAAA,QAAjEC,IAAiE,uEAA1DC,MAAM,CAACC,iBAAmD;AAAA,QAAhCC,EAAgC,uEAA3BF,MAAM,CAACG,iBAAoB;AAC/E,UAAMC,UAAU,GAAG,EAAnB;;AAEA,SAAM,MAAMT,SAAZ,IAAyB,KAAKN,WAA9B,EAA4C;AAC3C,UAAKM,SAAS,CAACU,WAAV,IAAyBN,IAAzB,IAAiCJ,SAAS,CAACU,WAAV,GAAwBH,EAA9D,EAAmE;AAClEE,QAAAA,UAAU,CAACP,IAAX,CAAiBF,SAAjB;AACA;AACD;;AAED,WAAOS,UAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,YAAY,CAAED,WAAF,EAAgB;AAC3B,SAAM,MAAMV,SAAZ,IAAyB,KAAKN,WAA9B,EAA4C;AAC3C,UAAKM,SAAS,CAACU,WAAV,IAAyBA,WAA9B,EAA4C;AAC3C,eAAOV,SAAP;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCY,EAAAA,oBAAoB,CAAEC,eAAF,EAAmBC,gBAAnB,EAAsC;AACzD,SAAKnB,UAAL,CAAgBoB,GAAhB,CAAqBD,gBAArB,EAAuCD,eAAvC;;AACA,SAAKhB,iBAAL,CAAuBmB,GAAvB,CAA4BH,eAA5B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCI,EAAAA,kBAAkB,CAAEjB,SAAF,EAAc;AAC/B,WAAO,KAAKL,UAAL,CAAgBuB,GAAhB,CAAqBlB,SAArB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCmB,EAAAA,iBAAiB,CAAEnB,SAAF,EAAc;AAC9B,WAAO,KAAKH,iBAAL,CAAuBqB,GAAvB,CAA4BlB,SAA5B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCoB,EAAAA,kBAAkB,CAAEN,gBAAF,EAAqB;AACtC,WAAO,KAAKnB,UAAL,CAAgB0B,GAAhB,CAAqBP,gBAArB,CAAP;AACA;;AA5H2B","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n\t/**\n\t * Creates an empty History instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Operations added to the history.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_operations\n\t\t */\n\t\tthis._operations = [];\n\n\t\t/**\n\t\t * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n\t\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t\t *\n\t\t * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n\t\t * value is an operation that has been undone by the \"undoing operation\".\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/history~History#_undoPairs\n\t\t */\n\t\tthis._undoPairs = new Map();\n\n\t\t/**\n\t\t * Holds all undone operations.\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_undoneOperations\n\t\t */\n\t\tthis._undoneOperations = new Set();\n\t}\n\n\t/**\n\t * Adds an operation to the history.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n\t */\n\taddOperation( operation ) {\n\t\tif ( this._operations.includes( operation ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._operations.push( operation );\n\t}\n\n\t/**\n\t * Returns operations added to the history.\n\t *\n\t * @param {Number} [from=Number.NEGATIVE_INFINITY] Base version from which operations should be returned (inclusive).\n\t * Defaults to `Number.NEGATIVE_INFINITY`, which means that operations from the first one will be returned.\n\t * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which operations should be returned (exclusive).\n\t * Defaults to `Number.POSITIVE_INFINITY` which means that operations up to the last one will be returned.\n\t * @returns {Array.<module:engine/model/operation/operation~Operation>} Operations added to the history.\n\t */\n\tgetOperations( from = Number.NEGATIVE_INFINITY, to = Number.POSITIVE_INFINITY ) {\n\t\tconst operations = [];\n\n\t\tfor ( const operation of this._operations ) {\n\t\t\tif ( operation.baseVersion >= from && operation.baseVersion < to ) {\n\t\t\t\toperations.push( operation );\n\t\t\t}\n\t\t}\n\n\t\treturn operations;\n\t}\n\n\t/**\n\t * Returns operation from the history that bases on given `baseVersion`.\n\t *\n\t * @param {Number} baseVersion Base version of the operation to get.\n\t * @returns {module:engine/model/operation/operation~Operation|undefined} Operation with given base version or `undefined` if\n\t * there is no such operation in history.\n\t */\n\tgetOperation( baseVersion ) {\n\t\tfor ( const operation of this._operations ) {\n\t\t\tif ( operation.baseVersion == baseVersion ) {\n\t\t\t\treturn operation;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n\t * history is keeping more context information about operations, which helps in operational transformation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n\t * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n\t */\n\tsetOperationAsUndone( undoneOperation, undoingOperation ) {\n\t\tthis._undoPairs.set( undoingOperation, undoneOperation );\n\t\tthis._undoneOperations.add( undoneOperation );\n\t}\n\n\t/**\n\t * Checks whether given `operation` is undoing any other operation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n\t * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n\t */\n\tisUndoingOperation( operation ) {\n\t\treturn this._undoPairs.has( operation );\n\t}\n\n\t/**\n\t * Checks whether given `operation` has been undone by any other operation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n\t * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n\t */\n\tisUndoneOperation( operation ) {\n\t\treturn this._undoneOperations.has( operation );\n\t}\n\n\t/**\n\t * For given `undoingOperation`, returns the operation which has been undone by it.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} undoingOperation\n\t * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n\t * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n\t */\n\tgetUndoneOperation( undoingOperation ) {\n\t\treturn this._undoPairs.get( undoingOperation );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}