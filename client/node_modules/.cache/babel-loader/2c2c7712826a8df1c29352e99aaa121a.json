{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/rect\n */\nimport isRange from './isrange';\nimport isWindow from './iswindow';\nimport getBorderWidths from './getborderwidths';\nimport isText from './istext';\nimport { isElement } from 'lodash-es';\nconst rectProperties = ['top', 'right', 'bottom', 'left', 'width', 'height'];\n/**\n * A helper class representing a `ClientRect` object, e.g. value returned by\n * the native `object.getBoundingClientRect()` method. Provides a set of methods\n * to manipulate the rect and compare it against other rect instances.\n */\n\nexport default class Rect {\n  /**\n   * Creates an instance of rect.\n   *\n   *\t\t// Rect of an HTMLElement.\n   *\t\tconst rectA = new Rect( document.body );\n   *\n   *\t\t// Rect of a DOM Range.\n   *\t\tconst rectB = new Rect( document.getSelection().getRangeAt( 0 ) );\n   *\n   *\t\t// Rect of a window (web browser viewport).\n   *\t\tconst rectC = new Rect( window );\n   *\n   *\t\t// Rect out of an object.\n   *\t\tconst rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );\n   *\n   *\t\t// Rect out of another Rect instance.\n   *\t\tconst rectE = new Rect( rectD );\n   *\n   *\t\t// Rect out of a ClientRect.\n   *\t\tconst rectF = new Rect( document.body.getClientRects().item( 0 ) );\n   *\n   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)\n   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}\n   * to get the inner part of the rect.\n   *\n   * @param {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object} source A source object to create the rect.\n   */\n  constructor(source) {\n    const isSourceRange = isRange(source);\n    /**\n     * The object this rect is for.\n     *\n     * @protected\n     * @readonly\n     * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object} #_source\n     */\n\n    Object.defineProperty(this, '_source', {\n      // If the source is a Rect instance, copy it's #_source.\n      value: source._source || source,\n      writable: true,\n      enumerable: false\n    });\n\n    if (isElement(source) || isSourceRange) {\n      // The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods. If the source\n      // of a rect in an HTML element or a DOM range but it does not belong to any rendered DOM tree, these methods\n      // will fail to obtain the geometry and the rect instance makes little sense to the features using it.\n      // To get rid of this warning make sure the source passed to the constructor is a descendant of `window.document.body`.\n      // @if CK_DEBUG // const sourceNode = isSourceRange ? source.startContainer : source;\n      // @if CK_DEBUG // if ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {\n      // @if CK_DEBUG // \tconsole.warn(\n      // @if CK_DEBUG // \t\t'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',\n      // @if CK_DEBUG // \t\t{ source } );\n      // @if CK_DEBUG // }\n      if (isSourceRange) {\n        const rangeRects = Rect.getDomRangeRects(source);\n        copyRectProperties(this, Rect.getBoundingRect(rangeRects));\n      } else {\n        copyRectProperties(this, source.getBoundingClientRect());\n      }\n    } else if (isWindow(source)) {\n      const {\n        innerWidth,\n        innerHeight\n      } = source;\n      copyRectProperties(this, {\n        top: 0,\n        right: innerWidth,\n        bottom: innerHeight,\n        left: 0,\n        width: innerWidth,\n        height: innerHeight\n      });\n    } else {\n      copyRectProperties(this, source);\n    }\n    /**\n     * The \"top\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #top\n     */\n\n    /**\n     * The \"right\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #right\n     */\n\n    /**\n     * The \"bottom\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #bottom\n     */\n\n    /**\n     * The \"left\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #left\n     */\n\n    /**\n     * The \"width\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #width\n     */\n\n    /**\n     * The \"height\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #height\n     */\n\n  }\n  /**\n   * Returns a clone of the rect.\n   *\n   * @returns {module:utils/dom/rect~Rect} A cloned rect.\n   */\n\n\n  clone() {\n    return new Rect(this);\n  }\n  /**\n   * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.\n   *\n   * @param {Number} x Desired horizontal location.\n   * @param {Number} y Desired vertical location.\n   * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n   */\n\n\n  moveTo(x, y) {\n    this.top = y;\n    this.right = x + this.width;\n    this.bottom = y + this.height;\n    this.left = x;\n    return this;\n  }\n  /**\n   * Moves the rect in–place by a dedicated offset.\n   *\n   * @param {Number} x A horizontal offset.\n   * @param {Number} y A vertical offset\n   * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n   */\n\n\n  moveBy(x, y) {\n    this.top += y;\n    this.right += x;\n    this.left += x;\n    this.bottom += y;\n    return this;\n  }\n  /**\n   * Returns a new rect a a result of intersection with another rect.\n   *\n   * @param {module:utils/dom/rect~Rect} anotherRect\n   * @returns {module:utils/dom/rect~Rect}\n   */\n\n\n  getIntersection(anotherRect) {\n    const rect = {\n      top: Math.max(this.top, anotherRect.top),\n      right: Math.min(this.right, anotherRect.right),\n      bottom: Math.min(this.bottom, anotherRect.bottom),\n      left: Math.max(this.left, anotherRect.left)\n    };\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n\n    if (rect.width < 0 || rect.height < 0) {\n      return null;\n    } else {\n      return new Rect(rect);\n    }\n  }\n  /**\n   * Returns the area of intersection with another rect.\n   *\n   * @param {module:utils/dom/rect~Rect} anotherRect [description]\n   * @returns {Number} Area of intersection.\n   */\n\n\n  getIntersectionArea(anotherRect) {\n    const rect = this.getIntersection(anotherRect);\n\n    if (rect) {\n      return rect.getArea();\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Returns the area of the rect.\n   *\n   * @returns {Number}\n   */\n\n\n  getArea() {\n    return this.width * this.height;\n  }\n  /**\n   * Returns a new rect, a part of the original rect, which is actually visible to the user,\n   * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS\n   * other than `\"visible\"`.\n   *\n   * If there's no such visible rect, which is when the rect is limited by one or many of\n   * the ancestors, `null` is returned.\n   *\n   * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.\n   */\n\n\n  getVisible() {\n    const source = this._source;\n    let visibleRect = this.clone(); // There's no ancestor to crop <body> with the overflow.\n\n    if (!isBody(source)) {\n      let parent = source.parentNode || source.commonAncestorContainer; // Check the ancestors all the way up to the <body>.\n\n      while (parent && !isBody(parent)) {\n        const parentRect = new Rect(parent);\n        const intersectionRect = visibleRect.getIntersection(parentRect);\n\n        if (intersectionRect) {\n          if (intersectionRect.getArea() < visibleRect.getArea()) {\n            // Reduce the visible rect to the intersection.\n            visibleRect = intersectionRect;\n          }\n        } else {\n          // There's no intersection, the rect is completely invisible.\n          return null;\n        }\n\n        parent = parent.parentNode;\n      }\n    }\n\n    return visibleRect;\n  }\n  /**\n   * Checks if all property values ({@link #top}, {@link #left}, {@link #right},\n   * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect\n   * instances.\n   *\n   * @param {module:utils/dom/rect~Rect} rect A rect instance to compare with.\n   * @returns {Boolean} `true` when Rects are equal. `false` otherwise.\n   */\n\n\n  isEqual(anotherRect) {\n    for (const prop of rectProperties) {\n      if (this[prop] !== anotherRect[prop]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Checks whether a rect fully contains another rect instance.\n   *\n   * @param {module:utils/dom/rect~Rect} anotherRect\n   * @returns {Boolean} `true` if contains, `false` otherwise.\n   */\n\n\n  contains(anotherRect) {\n    const intersectRect = this.getIntersection(anotherRect);\n    return !!(intersectRect && intersectRect.isEqual(anotherRect));\n  }\n  /**\n   * Excludes scrollbars and CSS borders from the rect.\n   *\n   * * Borders are removed when {@link #_source} is an HTML element.\n   * * Scrollbars are excluded from HTML elements and the `window`.\n   *\n   * @returns {module:utils/dom/rect~Rect} A rect which has been updated.\n   */\n\n\n  excludeScrollbarsAndBorders() {\n    const source = this._source;\n    let scrollBarWidth, scrollBarHeight, direction;\n\n    if (isWindow(source)) {\n      scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;\n      scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;\n      direction = source.getComputedStyle(source.document.documentElement).direction;\n    } else {\n      const borderWidths = getBorderWidths(this._source);\n      scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;\n      scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;\n      direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;\n      this.left += borderWidths.left;\n      this.top += borderWidths.top;\n      this.right -= borderWidths.right;\n      this.bottom -= borderWidths.bottom;\n      this.width = this.right - this.left;\n      this.height = this.bottom - this.top;\n    }\n\n    this.width -= scrollBarWidth;\n\n    if (direction === 'ltr') {\n      this.right -= scrollBarWidth;\n    } else {\n      this.left += scrollBarWidth;\n    }\n\n    this.height -= scrollBarHeight;\n    this.bottom -= scrollBarHeight;\n    return this;\n  }\n  /**\n   * Returns an array of rects of the given native DOM Range.\n   *\n   * @param {Range} range A native DOM range.\n   * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.\n   */\n\n\n  static getDomRangeRects(range) {\n    const rects = []; // Safari does not iterate over ClientRectList using for...of loop.\n\n    const clientRects = Array.from(range.getClientRects());\n\n    if (clientRects.length) {\n      for (const rect of clientRects) {\n        rects.push(new Rect(rect));\n      }\n    } // If there's no client rects for the Range, use parent container's bounding rect\n    // instead and adjust rect's width to simulate the actual geometry of such range.\n    // https://github.com/ckeditor/ckeditor5-utils/issues/153\n    // https://github.com/ckeditor/ckeditor5-ui/issues/317\n    else {\n      let startContainer = range.startContainer;\n\n      if (isText(startContainer)) {\n        startContainer = startContainer.parentNode;\n      }\n\n      const rect = new Rect(startContainer.getBoundingClientRect());\n      rect.right = rect.left;\n      rect.width = 0;\n      rects.push(rect);\n    }\n\n    return rects;\n  }\n  /**\n   * Returns a bounding rectangle that contains all the given `rects`.\n   *\n   * @param {Iterable.<module:utils/dom/rect~Rect>} rects A list of rectangles that should be contained in the result rectangle.\n   * @returns {module:utils/dom/rect~Rect|null} Bounding rectangle or `null` if no `rects` were given.\n   */\n\n\n  static getBoundingRect(rects) {\n    const boundingRectData = {\n      left: Number.POSITIVE_INFINITY,\n      top: Number.POSITIVE_INFINITY,\n      right: Number.NEGATIVE_INFINITY,\n      bottom: Number.NEGATIVE_INFINITY\n    };\n    let rectangleCount = 0;\n\n    for (const rect of rects) {\n      rectangleCount++;\n      boundingRectData.left = Math.min(boundingRectData.left, rect.left);\n      boundingRectData.top = Math.min(boundingRectData.top, rect.top);\n      boundingRectData.right = Math.max(boundingRectData.right, rect.right);\n      boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);\n    }\n\n    if (rectangleCount == 0) {\n      return null;\n    }\n\n    boundingRectData.width = boundingRectData.right - boundingRectData.left;\n    boundingRectData.height = boundingRectData.bottom - boundingRectData.top;\n    return new Rect(boundingRectData);\n  }\n\n} // Acquires all the rect properties from the passed source.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect\n// @param {ClientRect|module:utils/dom/rect~Rect|Object} source\n\nfunction copyRectProperties(rect, source) {\n  for (const p of rectProperties) {\n    rect[p] = source[p];\n  }\n} // Checks if provided object is a <body> HTML element.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {Boolean}\n\n\nfunction isBody(elementOrRange) {\n  if (!isElement(elementOrRange)) {\n    return false;\n  }\n\n  return elementOrRange === elementOrRange.ownerDocument.body;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/dom/rect.js"],"names":["isRange","isWindow","getBorderWidths","isText","isElement","rectProperties","Rect","constructor","source","isSourceRange","Object","defineProperty","value","_source","writable","enumerable","rangeRects","getDomRangeRects","copyRectProperties","getBoundingRect","getBoundingClientRect","innerWidth","innerHeight","top","right","bottom","left","width","height","clone","moveTo","x","y","moveBy","getIntersection","anotherRect","rect","Math","max","min","getIntersectionArea","getArea","getVisible","visibleRect","isBody","parent","parentNode","commonAncestorContainer","parentRect","intersectionRect","isEqual","prop","contains","intersectRect","excludeScrollbarsAndBorders","scrollBarWidth","scrollBarHeight","direction","document","documentElement","clientWidth","clientHeight","getComputedStyle","borderWidths","offsetWidth","offsetHeight","ownerDocument","defaultView","range","rects","clientRects","Array","from","getClientRects","length","push","startContainer","boundingRectData","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","rectangleCount","p","elementOrRange","body"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/rect\n */\n\nimport isRange from './isrange';\nimport isWindow from './iswindow';\nimport getBorderWidths from './getborderwidths';\nimport isText from './istext';\nimport { isElement } from 'lodash-es';\n\nconst rectProperties = [ 'top', 'right', 'bottom', 'left', 'width', 'height' ];\n\n/**\n * A helper class representing a `ClientRect` object, e.g. value returned by\n * the native `object.getBoundingClientRect()` method. Provides a set of methods\n * to manipulate the rect and compare it against other rect instances.\n */\nexport default class Rect {\n\t/**\n\t * Creates an instance of rect.\n\t *\n\t *\t\t// Rect of an HTMLElement.\n\t *\t\tconst rectA = new Rect( document.body );\n\t *\n\t *\t\t// Rect of a DOM Range.\n\t *\t\tconst rectB = new Rect( document.getSelection().getRangeAt( 0 ) );\n\t *\n\t *\t\t// Rect of a window (web browser viewport).\n\t *\t\tconst rectC = new Rect( window );\n\t *\n\t *\t\t// Rect out of an object.\n\t *\t\tconst rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );\n\t *\n\t *\t\t// Rect out of another Rect instance.\n\t *\t\tconst rectE = new Rect( rectD );\n\t *\n\t *\t\t// Rect out of a ClientRect.\n\t *\t\tconst rectF = new Rect( document.body.getClientRects().item( 0 ) );\n\t *\n\t * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)\n\t * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}\n\t * to get the inner part of the rect.\n\t *\n\t * @param {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object} source A source object to create the rect.\n\t */\n\tconstructor( source ) {\n\t\tconst isSourceRange = isRange( source );\n\n\t\t/**\n\t\t * The object this rect is for.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object} #_source\n\t\t */\n\t\tObject.defineProperty( this, '_source', {\n\t\t\t// If the source is a Rect instance, copy it's #_source.\n\t\t\tvalue: source._source || source,\n\t\t\twritable: true,\n\t\t\tenumerable: false\n\t\t} );\n\n\t\tif ( isElement( source ) || isSourceRange ) {\n\t\t\t// The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods. If the source\n\t\t\t// of a rect in an HTML element or a DOM range but it does not belong to any rendered DOM tree, these methods\n\t\t\t// will fail to obtain the geometry and the rect instance makes little sense to the features using it.\n\t\t\t// To get rid of this warning make sure the source passed to the constructor is a descendant of `window.document.body`.\n\t\t\t// @if CK_DEBUG // const sourceNode = isSourceRange ? source.startContainer : source;\n\t\t\t// @if CK_DEBUG // if ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {\n\t\t\t// @if CK_DEBUG // \tconsole.warn(\n\t\t\t// @if CK_DEBUG // \t\t'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',\n\t\t\t// @if CK_DEBUG // \t\t{ source } );\n\t\t\t// @if CK_DEBUG // }\n\n\t\t\tif ( isSourceRange ) {\n\t\t\t\tconst rangeRects = Rect.getDomRangeRects( source );\n\t\t\t\tcopyRectProperties( this, Rect.getBoundingRect( rangeRects ) );\n\t\t\t} else {\n\t\t\t\tcopyRectProperties( this, source.getBoundingClientRect() );\n\t\t\t}\n\t\t} else if ( isWindow( source ) ) {\n\t\t\tconst { innerWidth, innerHeight } = source;\n\n\t\t\tcopyRectProperties( this, {\n\t\t\t\ttop: 0,\n\t\t\t\tright: innerWidth,\n\t\t\t\tbottom: innerHeight,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: innerWidth,\n\t\t\t\theight: innerHeight\n\t\t\t} );\n\t\t} else {\n\t\t\tcopyRectProperties( this, source );\n\t\t}\n\n\t\t/**\n\t\t * The \"top\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #top\n\t\t */\n\n\t\t/**\n\t\t * The \"right\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #right\n\t\t */\n\n\t\t/**\n\t\t * The \"bottom\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #bottom\n\t\t */\n\n\t\t/**\n\t\t * The \"left\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #left\n\t\t */\n\n\t\t/**\n\t\t * The \"width\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #width\n\t\t */\n\n\t\t/**\n\t\t * The \"height\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #height\n\t\t */\n\t}\n\n\t/**\n\t * Returns a clone of the rect.\n\t *\n\t * @returns {module:utils/dom/rect~Rect} A cloned rect.\n\t */\n\tclone() {\n\t\treturn new Rect( this );\n\t}\n\n\t/**\n\t * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.\n\t *\n\t * @param {Number} x Desired horizontal location.\n\t * @param {Number} y Desired vertical location.\n\t * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n\t */\n\tmoveTo( x, y ) {\n\t\tthis.top = y;\n\t\tthis.right = x + this.width;\n\t\tthis.bottom = y + this.height;\n\t\tthis.left = x;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves the rect in–place by a dedicated offset.\n\t *\n\t * @param {Number} x A horizontal offset.\n\t * @param {Number} y A vertical offset\n\t * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n\t */\n\tmoveBy( x, y ) {\n\t\tthis.top += y;\n\t\tthis.right += x;\n\t\tthis.left += x;\n\t\tthis.bottom += y;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a new rect a a result of intersection with another rect.\n\t *\n\t * @param {module:utils/dom/rect~Rect} anotherRect\n\t * @returns {module:utils/dom/rect~Rect}\n\t */\n\tgetIntersection( anotherRect ) {\n\t\tconst rect = {\n\t\t\ttop: Math.max( this.top, anotherRect.top ),\n\t\t\tright: Math.min( this.right, anotherRect.right ),\n\t\t\tbottom: Math.min( this.bottom, anotherRect.bottom ),\n\t\t\tleft: Math.max( this.left, anotherRect.left )\n\t\t};\n\n\t\trect.width = rect.right - rect.left;\n\t\trect.height = rect.bottom - rect.top;\n\n\t\tif ( rect.width < 0 || rect.height < 0 ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn new Rect( rect );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the area of intersection with another rect.\n\t *\n\t * @param {module:utils/dom/rect~Rect} anotherRect [description]\n\t * @returns {Number} Area of intersection.\n\t */\n\tgetIntersectionArea( anotherRect ) {\n\t\tconst rect = this.getIntersection( anotherRect );\n\n\t\tif ( rect ) {\n\t\t\treturn rect.getArea();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the area of the rect.\n\t *\n\t * @returns {Number}\n\t */\n\tgetArea() {\n\t\treturn this.width * this.height;\n\t}\n\n\t/**\n\t * Returns a new rect, a part of the original rect, which is actually visible to the user,\n\t * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS\n\t * other than `\"visible\"`.\n\t *\n\t * If there's no such visible rect, which is when the rect is limited by one or many of\n\t * the ancestors, `null` is returned.\n\t *\n\t * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.\n\t */\n\tgetVisible() {\n\t\tconst source = this._source;\n\t\tlet visibleRect = this.clone();\n\n\t\t// There's no ancestor to crop <body> with the overflow.\n\t\tif ( !isBody( source ) ) {\n\t\t\tlet parent = source.parentNode || source.commonAncestorContainer;\n\n\t\t\t// Check the ancestors all the way up to the <body>.\n\t\t\twhile ( parent && !isBody( parent ) ) {\n\t\t\t\tconst parentRect = new Rect( parent );\n\t\t\t\tconst intersectionRect = visibleRect.getIntersection( parentRect );\n\n\t\t\t\tif ( intersectionRect ) {\n\t\t\t\t\tif ( intersectionRect.getArea() < visibleRect.getArea() ) {\n\t\t\t\t\t\t// Reduce the visible rect to the intersection.\n\t\t\t\t\t\tvisibleRect = intersectionRect;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// There's no intersection, the rect is completely invisible.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\t}\n\n\t\treturn visibleRect;\n\t}\n\n\t/**\n\t * Checks if all property values ({@link #top}, {@link #left}, {@link #right},\n\t * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect\n\t * instances.\n\t *\n\t * @param {module:utils/dom/rect~Rect} rect A rect instance to compare with.\n\t * @returns {Boolean} `true` when Rects are equal. `false` otherwise.\n\t */\n\tisEqual( anotherRect ) {\n\t\tfor ( const prop of rectProperties ) {\n\t\t\tif ( this[ prop ] !== anotherRect[ prop ] ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether a rect fully contains another rect instance.\n\t *\n\t * @param {module:utils/dom/rect~Rect} anotherRect\n\t * @returns {Boolean} `true` if contains, `false` otherwise.\n\t */\n\tcontains( anotherRect ) {\n\t\tconst intersectRect = this.getIntersection( anotherRect );\n\n\t\treturn !!( intersectRect && intersectRect.isEqual( anotherRect ) );\n\t}\n\n\t/**\n\t * Excludes scrollbars and CSS borders from the rect.\n\t *\n\t * * Borders are removed when {@link #_source} is an HTML element.\n\t * * Scrollbars are excluded from HTML elements and the `window`.\n\t *\n\t * @returns {module:utils/dom/rect~Rect} A rect which has been updated.\n\t */\n\texcludeScrollbarsAndBorders() {\n\t\tconst source = this._source;\n\t\tlet scrollBarWidth, scrollBarHeight, direction;\n\n\t\tif ( isWindow( source ) ) {\n\t\t\tscrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;\n\t\t\tscrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;\n\t\t\tdirection = source.getComputedStyle( source.document.documentElement ).direction;\n\t\t} else {\n\t\t\tconst borderWidths = getBorderWidths( this._source );\n\n\t\t\tscrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;\n\t\t\tscrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;\n\t\t\tdirection = source.ownerDocument.defaultView.getComputedStyle( source ).direction;\n\n\t\t\tthis.left += borderWidths.left;\n\t\t\tthis.top += borderWidths.top;\n\t\t\tthis.right -= borderWidths.right;\n\t\t\tthis.bottom -= borderWidths.bottom;\n\t\t\tthis.width = this.right - this.left;\n\t\t\tthis.height = this.bottom - this.top;\n\t\t}\n\n\t\tthis.width -= scrollBarWidth;\n\n\t\tif ( direction === 'ltr' ) {\n\t\t\tthis.right -= scrollBarWidth;\n\t\t} else {\n\t\t\tthis.left += scrollBarWidth;\n\t\t}\n\n\t\tthis.height -= scrollBarHeight;\n\t\tthis.bottom -= scrollBarHeight;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of rects of the given native DOM Range.\n\t *\n\t * @param {Range} range A native DOM range.\n\t * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.\n\t */\n\tstatic getDomRangeRects( range ) {\n\t\tconst rects = [];\n\t\t// Safari does not iterate over ClientRectList using for...of loop.\n\t\tconst clientRects = Array.from( range.getClientRects() );\n\n\t\tif ( clientRects.length ) {\n\t\t\tfor ( const rect of clientRects ) {\n\t\t\t\trects.push( new Rect( rect ) );\n\t\t\t}\n\t\t}\n\t\t// If there's no client rects for the Range, use parent container's bounding rect\n\t\t// instead and adjust rect's width to simulate the actual geometry of such range.\n\t\t// https://github.com/ckeditor/ckeditor5-utils/issues/153\n\t\t// https://github.com/ckeditor/ckeditor5-ui/issues/317\n\t\telse {\n\t\t\tlet startContainer = range.startContainer;\n\n\t\t\tif ( isText( startContainer ) ) {\n\t\t\t\tstartContainer = startContainer.parentNode;\n\t\t\t}\n\n\t\t\tconst rect = new Rect( startContainer.getBoundingClientRect() );\n\t\t\trect.right = rect.left;\n\t\t\trect.width = 0;\n\n\t\t\trects.push( rect );\n\t\t}\n\n\t\treturn rects;\n\t}\n\n\t/**\n\t * Returns a bounding rectangle that contains all the given `rects`.\n\t *\n\t * @param {Iterable.<module:utils/dom/rect~Rect>} rects A list of rectangles that should be contained in the result rectangle.\n\t * @returns {module:utils/dom/rect~Rect|null} Bounding rectangle or `null` if no `rects` were given.\n\t */\n\tstatic getBoundingRect( rects ) {\n\t\tconst boundingRectData = {\n\t\t\tleft: Number.POSITIVE_INFINITY,\n\t\t\ttop: Number.POSITIVE_INFINITY,\n\t\t\tright: Number.NEGATIVE_INFINITY,\n\t\t\tbottom: Number.NEGATIVE_INFINITY\n\t\t};\n\t\tlet rectangleCount = 0;\n\n\t\tfor ( const rect of rects ) {\n\t\t\trectangleCount++;\n\n\t\t\tboundingRectData.left = Math.min( boundingRectData.left, rect.left );\n\t\t\tboundingRectData.top = Math.min( boundingRectData.top, rect.top );\n\t\t\tboundingRectData.right = Math.max( boundingRectData.right, rect.right );\n\t\t\tboundingRectData.bottom = Math.max( boundingRectData.bottom, rect.bottom );\n\t\t}\n\n\t\tif ( rectangleCount == 0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboundingRectData.width = boundingRectData.right - boundingRectData.left;\n\t\tboundingRectData.height = boundingRectData.bottom - boundingRectData.top;\n\n\t\treturn new Rect( boundingRectData );\n\t}\n}\n\n// Acquires all the rect properties from the passed source.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect\n// @param {ClientRect|module:utils/dom/rect~Rect|Object} source\nfunction copyRectProperties( rect, source ) {\n\tfor ( const p of rectProperties ) {\n\t\trect[ p ] = source[ p ];\n\t}\n}\n\n// Checks if provided object is a <body> HTML element.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {Boolean}\nfunction isBody( elementOrRange ) {\n\tif ( !isElement( elementOrRange ) ) {\n\t\treturn false;\n\t}\n\n\treturn elementOrRange === elementOrRange.ownerDocument.body;\n}\n"]},"metadata":{},"sourceType":"module"}