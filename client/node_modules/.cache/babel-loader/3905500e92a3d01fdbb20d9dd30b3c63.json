{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcasthelpers';\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class DataController {\n  /**\n   * Creates a data controller instance.\n   *\n   * @param {module:engine/model/model~Model} model Data model.\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  constructor(model, stylesProcessor) {\n    /**\n     * Data model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n     * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n     * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n     *\n     * @readonly\n     * @member {module:engine/conversion/mapper~Mapper}\n     */\n\n    this.mapper = new Mapper();\n    /**\n     * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n     */\n\n    this.downcastDispatcher = new DowncastDispatcher({\n      mapper: this.mapper,\n      schema: model.schema\n    });\n    this.downcastDispatcher.on('insert:$text', insertText(), {\n      priority: 'lowest'\n    });\n    /**\n     * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n     */\n\n    this.upcastDispatcher = new UpcastDispatcher({\n      schema: model.schema\n    });\n    /**\n     * The view document used by the data controller.\n     *\n     * @readonly\n     * @member {module:engine/view/document~Document}\n     */\n\n    this.viewDocument = new ViewDocument(stylesProcessor);\n    /**\n     * Styles processor used during the conversion.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Data processor used specifically for HTML conversion.\n     *\n     * @readonly\n     * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n     */\n\n    this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);\n    /**\n     * Data processor used during the conversion.\n     * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n     *\n     * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n     */\n\n    this.processor = this.htmlProcessor;\n    /**\n     * The view downcast writer just for data conversion purposes, i.e. to modify\n     * the {@link #viewDocument}.\n     *\n     * @private\n     * @readonly\n     * @member {module:engine/view/downcastwriter~DowncastWriter}\n     */\n\n    this._viewWriter = new ViewDowncastWriter(this.viewDocument); // Define default converters for text and elements.\n    //\n    // Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n    // converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n    // element to the document fragment and so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\n    this.upcastDispatcher.on('text', convertText(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('element', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('documentFragment', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.decorate('init');\n    this.decorate('set');\n    this.decorate('get'); // Fire the `ready` event when the initialization has completed. Such low-level listener gives possibility\n    // to plug into the initialization pipeline without interrupting the initialization flow.\n\n    this.on('init', () => {\n      this.fire('ready');\n    }, {\n      priority: 'lowest'\n    }); // Fix empty roots after DataController is 'ready' (note that init method could be decorated and stopped).\n    // We need to handle this event because initial data could be empty and post-fixer would not get triggered.\n\n    this.on('ready', () => {\n      this.model.enqueueChange('transparent', autoParagraphEmptyRoots);\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n   * formatted by the {@link #processor data processor}.\n   *\n   * @fires get\n   * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n   * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n   * @param {String} [options.rootName='main'] Root name.\n   * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n   * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).\n   * @returns {String} Output data.\n   */\n\n\n  get() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      rootName = 'main',\n      trim = 'empty'\n    } = options;\n\n    if (!this._checkIfRootsExists([rootName])) {\n      /**\n       * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #get} like:\n       *\n       *\t\tdata.get( { rootName: 'root2' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-get-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-get-non-existent-root', this);\n    }\n\n    const root = this.model.document.getRoot(rootName);\n\n    if (trim === 'empty' && !this.model.hasContent(root, {\n      ignoreWhitespaces: true\n    })) {\n      return '';\n    }\n\n    return this.stringify(root, options);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n   * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * Element whose content will be stringified.\n   * @param {Object} [options] Additional configuration passed to the conversion process.\n   * @returns {String} Output data.\n   */\n\n\n  stringify(modelElementOrFragment) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Model -> view.\n    const viewDocumentFragment = this.toView(modelElementOrFragment, options); // View -> data.\n\n    return this.processor.toData(viewDocumentFragment);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n   * converters attached to {@link #downcastDispatcher} to a\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * Element or document fragment whose content will be converted.\n   * @param {Object} [options={}] Additional configuration that will be available through\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n   */\n\n\n  toView(modelElementOrFragment) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const viewDocument = this.viewDocument;\n    const viewWriter = this._viewWriter; // Clear bindings so the call to this method gives correct results.\n\n    this.mapper.clearBindings(); // First, convert elements.\n\n    const modelRange = ModelRange._createIn(modelElementOrFragment);\n\n    const viewDocumentFragment = new ViewDocumentFragment(viewDocument);\n    this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment); // Make additional options available during conversion process through `conversionApi`.\n\n    this.downcastDispatcher.conversionApi.options = options; // We have no view controller and rendering to DOM in DataController so view.change() block is not used here.\n\n    this.downcastDispatcher.convertInsert(modelRange, viewWriter); // Convert markers.\n    // For document fragment, simply take the markers assigned to this document fragment.\n    // For model root, all markers in that root will be taken.\n    // For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n    // Collapsed markers at element boundary, although considered as not intersecting with the element, will also be returned.\n\n    const markers = modelElementOrFragment.is('documentFragment') ? Array.from(modelElementOrFragment.markers) : _getMarkersRelativeToElement(modelElementOrFragment);\n\n    for (const [name, range] of markers) {\n      this.downcastDispatcher.convertMarkerAdd(name, range, viewWriter);\n    } // Clean `conversionApi`.\n\n\n    delete this.downcastDispatcher.conversionApi.options;\n    return viewDocumentFragment;\n  }\n  /**\n   * Sets initial input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n   *\n   * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n   * used by e.g. collaborative editing plugin that syncs remote data on init.\n   *\n   * When data is passed as a string it is initialized on a default `main` root:\n   *\n   *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.\n   *\n   * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.\n   *\n   * @fires init\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n   * pairs to initialize data on multiple roots at once.\n   * @returns {Promise} Promise that is resolved after the data is set on the editor.\n   */\n\n\n  init(data) {\n    if (this.model.document.version) {\n      /**\n       * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n       * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n       * when the {@link module:engine/model/document~Document#version} is equal 0.\n       *\n       * @error datacontroller-init-document-not-empty\n       */\n      throw new CKEditorError('datacontroller-init-document-not-empty', this);\n    }\n\n    let initialData = {};\n\n    if (typeof data === 'string') {\n      initialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n    } else {\n      initialData = data;\n    }\n\n    if (!this._checkIfRootsExists(Object.keys(initialData))) {\n      /**\n       * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #init} like:\n       *\n       * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-init-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-init-non-existent-root', this);\n    }\n\n    this.model.enqueueChange('transparent', writer => {\n      for (const rootName of Object.keys(initialData)) {\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n    return Promise.resolve();\n  }\n  /**\n   * Sets input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * This method can be used any time to replace existing editor data by the new one without clearing the\n   * {@link module:engine/model/document~Document#history document history}.\n   *\n   * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n   * the {@link #parse} method.\n   *\n   * When data is passed as a string it is set on a default `main` root:\n   *\n   *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.\n   *\n   * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.\n   *\n   * To set the data with preserved undo stacks and set the current change to this stack, use the `{ batchType: 'default' }` option.\n   *\n   *\t\tdataController.set( '<p>Foo</p>', { batchType: 'default' } ); // Sets data as a new change.\n   *\n   * @fires set\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n   * pairs to set data on multiple roots at once.\n   * @param {Object} [options={}] Options for setting data.\n   * @param {'default'|'transparent'} [options.batchType='default'] The batch type that will be used to create a batch for the changes.\n   * When set to `default`, the undo and redo stacks will be preserved. Note that when not set, the undo feature (when present) will\n   * override it to `transparent` and all undo steps will be lost.\n   */\n\n\n  set(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let newData = {};\n\n    if (typeof data === 'string') {\n      newData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.\n    } else {\n      newData = data;\n    }\n\n    if (!this._checkIfRootsExists(Object.keys(newData))) {\n      /**\n       * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #set} like:\n       *\n       * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-set-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-set-non-existent-root', this);\n    }\n\n    const batchType = options.batchType || 'default';\n    this.model.enqueueChange(batchType, writer => {\n      writer.setSelection(null);\n      writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());\n\n      for (const rootName of Object.keys(newData)) {\n        // Save to model.\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.remove(writer.createRangeIn(modelRoot));\n        writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n  }\n  /**\n   * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n   * attached to the {@link #upcastDispatcher}.\n   *\n   * @see #set\n   * @param {String} data Data to parse.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n   */\n\n\n  parse(data) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n    // data -> view\n    const viewDocumentFragment = this.processor.toView(data); // view -> model\n\n    return this.toModel(viewDocumentFragment, context);\n  }\n  /**\n   * Returns the result of the given {@link module:engine/view/element~Element view element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n   * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n   *\n   * When marker elements were converted during the conversion process, it will be set as a document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n   * Element or document fragment whose content will be converted.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n   */\n\n\n  toModel(viewElementOrFragment) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n    return this.model.change(writer => {\n      return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);\n    });\n  }\n  /**\n   * Adds a style processor normalization rules.\n   *\n   * You can implement your own rules as well as use one of the available processor rules:\n   *\n   * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n   * * border: {@link module:engine/view/styles/border~addBorderRules}\n   * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n   * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n   *\n   * @param {Function} callback\n   */\n\n\n  addStyleProcessorRules(callback) {\n    callback(this.stylesProcessor);\n  }\n  /**\n   * Registers a {@link module:engine/view/matcher~MatcherPattern} on {@link #htmlProcessor htmlProcessor}\n   * and {@link #processor processor} for view elements whose content should be treated as a raw data\n   * and not processed during conversion from DOM to view elements.\n   *\n   * The raw data can be later accessed by {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n   * `\"$rawContent\"`.\n   *\n   * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n   * be treated as a raw data.\n   */\n\n\n  registerRawContentMatcher(pattern) {\n    // No need to register the pattern if both `htmlProcessor` and `processor` are the same instances.\n    if (this.processor && this.processor !== this.htmlProcessor) {\n      this.processor.registerRawContentMatcher(pattern);\n    }\n\n    this.htmlProcessor.registerRawContentMatcher(pattern);\n  }\n  /**\n   * Removes all event listeners set by the DataController.\n   */\n\n\n  destroy() {\n    this.stopListening();\n  }\n  /**\n   * Checks if all provided root names are existing editor roots.\n   *\n   * @private\n   * @param {Array.<String>} rootNames Root names to check.\n   * @returns {Boolean} Whether all provided root names are existing editor roots.\n   */\n\n\n  _checkIfRootsExists(rootNames) {\n    for (const rootName of rootNames) {\n      if (!this.model.document.getRootNames().includes(rootName)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Event fired once the data initialization has finished.\n   *\n   * @event ready\n   */\n\n  /**\n   * Event fired after the {@link #init `init()` method} was run. It can be {@link #listenTo listened to} in order to adjust or modify\n   * the initialization flow. However, if the `init` event is stopped or prevented, the {@link #event:ready `ready` event}\n   * should be fired manually.\n   *\n   * The `init` event is fired by the decorated {@link #init} method.\n   * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n   *\n   * @event init\n   */\n\n  /**\n   * Event fired after {@link #set set() method} has been run.\n   *\n   * The `set` event is fired by decorated {@link #set} method.\n   * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n   *\n   * @event set\n   */\n\n  /**\n   * Event fired after {@link #get get() method} has been run.\n   *\n   * The `get` event is fired by decorated {@link #get} method.\n   * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n   *\n   * @event get\n   */\n\n\n}\nmix(DataController, ObservableMixin); // Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it. If the marker is collapsed\n// at element boundary, it is considered as contained inside the element and marker range is returned. Otherwise, if the marker is\n// intersecting with the element, the intersection is returned.\n\nfunction _getMarkersRelativeToElement(element) {\n  const result = [];\n  const doc = element.root.document;\n\n  if (!doc) {\n    return [];\n  }\n\n  const elementRange = ModelRange._createIn(element);\n\n  for (const marker of doc.model.markers) {\n    const markerRange = marker.getRange();\n    const isMarkerCollapsed = markerRange.isCollapsed;\n    const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);\n\n    if (isMarkerCollapsed && isMarkerAtElementBoundary) {\n      result.push([marker.name, markerRange]);\n    } else {\n      const updatedMarkerRange = elementRange.getIntersection(markerRange);\n\n      if (updatedMarkerRange) {\n        result.push([marker.name, updatedMarkerRange]);\n      }\n    }\n  } // Sort the markers in a stable fashion to ensure that the order that they are\n  // added to the model's marker collection does not affect how they are\n  // downcast. One particular use case that we're targeting here is one where\n  // two markers are adjacent but not overlapping, such as an insertion/deletion\n  // suggestion pair represting the replacement of a range of text. In this\n  // case, putting the markers in DOM order causes the first marker's end to be\n  // serialized right after the second marker's start, while putting the markers\n  // in reverse DOM order causes it to be right before the second marker's\n  // start. So, we sort in a way that ensures non-intersecting ranges are in\n  // reverse DOM order, and intersecting ranges are in something approximating\n  // reverse DOM order (since reverse DOM order doesn't have a precise meaning\n  // when working with intersectng ranges).\n\n\n  return result.sort((_ref, _ref2) => {\n    let [n1, r1] = _ref;\n    let [n2, r2] = _ref2;\n\n    if (r1.end.compareWith(r2.start) !== 'after') {\n      // m1.end <= m2.start -- m1 is entirely <= m2\n      return 1;\n    } else if (r1.start.compareWith(r2.end) !== 'before') {\n      // m1.start >= m2.end -- m1 is entirely >= m2\n      return -1;\n    } else {\n      // they overlap, so use their start positions as the primary sort key and\n      // end positions as the secondary sort key\n      switch (r1.start.compareWith(r2.start)) {\n        case 'before':\n          return 1;\n\n        case 'after':\n          return -1;\n\n        default:\n          switch (r1.end.compareWith(r2.end)) {\n            case 'before':\n              return 1;\n\n            case 'after':\n              return -1;\n\n            default:\n              return n2.localeCompare(n1);\n          }\n\n      }\n    }\n  });\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js"],"names":["mix","ObservableMixin","CKEditorError","Mapper","DowncastDispatcher","insertText","UpcastDispatcher","convertText","convertToModelFragment","ViewDocumentFragment","ViewDocument","ViewDowncastWriter","ModelRange","autoParagraphEmptyRoots","HtmlDataProcessor","DataController","constructor","model","stylesProcessor","mapper","downcastDispatcher","schema","on","priority","upcastDispatcher","viewDocument","htmlProcessor","processor","_viewWriter","decorate","fire","enqueueChange","get","options","rootName","trim","_checkIfRootsExists","root","document","getRoot","hasContent","ignoreWhitespaces","stringify","modelElementOrFragment","viewDocumentFragment","toView","toData","viewWriter","clearBindings","modelRange","_createIn","bindElements","conversionApi","convertInsert","markers","is","Array","from","_getMarkersRelativeToElement","name","range","convertMarkerAdd","init","data","version","initialData","main","Object","keys","writer","modelRoot","insert","parse","Promise","resolve","set","newData","batchType","setSelection","removeSelectionAttribute","selection","getAttributeKeys","remove","createRangeIn","context","toModel","viewElementOrFragment","change","convert","addStyleProcessorRules","callback","registerRawContentMatcher","pattern","destroy","stopListening","rootNames","getRootNames","includes","element","result","doc","elementRange","marker","markerRange","getRange","isMarkerCollapsed","isCollapsed","isMarkerAtElementBoundary","start","isEqual","end","push","updatedMarkerRange","getIntersection","sort","n1","r1","n2","r2","compareWith","localeCompare"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport Mapper from '../conversion/mapper';\n\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcasthelpers';\n\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\n\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\n\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class DataController {\n\t/**\n\t * Creates a data controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model.\n\t * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n\t */\n\tconstructor( model, stylesProcessor ) {\n\t\t/**\n\t\t * Data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n\t\t * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n\t\t * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper,\n\t\t\tschema: model.schema\n\t\t} );\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\n\t\t/**\n\t\t * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t\t */\n\t\tthis.upcastDispatcher = new UpcastDispatcher( {\n\t\t\tschema: model.schema\n\t\t} );\n\n\t\t/**\n\t\t * The view document used by the data controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document}\n\t\t */\n\t\tthis.viewDocument = new ViewDocument( stylesProcessor );\n\n\t\t/**\n\t\t * Styles processor used during the conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis.stylesProcessor = stylesProcessor;\n\n\t\t/**\n\t\t * Data processor used specifically for HTML conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n\t\t */\n\t\tthis.htmlProcessor = new HtmlDataProcessor( this.viewDocument );\n\n\t\t/**\n\t\t * Data processor used during the conversion.\n\t\t * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n\t\t *\n\t\t * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n\t\t */\n\t\tthis.processor = this.htmlProcessor;\n\n\t\t/**\n\t\t * The view downcast writer just for data conversion purposes, i.e. to modify\n\t\t * the {@link #viewDocument}.\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @member {module:engine/view/downcastwriter~DowncastWriter}\n\t\t */\n\t\tthis._viewWriter = new ViewDowncastWriter( this.viewDocument );\n\n\t\t// Define default converters for text and elements.\n\t\t//\n\t\t// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n\t\t// converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n\t\t// element to the document fragment and so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\t\tthis.upcastDispatcher.on( 'text', convertText(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'element', convertToModelFragment(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'documentFragment', convertToModelFragment(), { priority: 'lowest' } );\n\n\t\tthis.decorate( 'init' );\n\t\tthis.decorate( 'set' );\n\t\tthis.decorate( 'get' );\n\n\t\t// Fire the `ready` event when the initialization has completed. Such low-level listener gives possibility\n\t\t// to plug into the initialization pipeline without interrupting the initialization flow.\n\t\tthis.on( 'init', () => {\n\t\t\tthis.fire( 'ready' );\n\t\t}, { priority: 'lowest' } );\n\n\t\t// Fix empty roots after DataController is 'ready' (note that init method could be decorated and stopped).\n\t\t// We need to handle this event because initial data could be empty and post-fixer would not get triggered.\n\t\tthis.on( 'ready', () => {\n\t\t\tthis.model.enqueueChange( 'transparent', autoParagraphEmptyRoots );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n\t * formatted by the {@link #processor data processor}.\n\t *\n\t * @fires get\n\t * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n\t * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n\t * @param {String} [options.rootName='main'] Root name.\n\t * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n\t * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n\t * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).\n\t * @returns {String} Output data.\n\t */\n\tget( options = {} ) {\n\t\tconst { rootName = 'main', trim = 'empty' } = options;\n\n\t\tif ( !this._checkIfRootsExists( [ rootName ] ) ) {\n\t\t\t/**\n\t\t\t * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #get} like:\n\t\t\t *\n\t\t\t *\t\tdata.get( { rootName: 'root2' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-get-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-get-non-existent-root', this );\n\t\t}\n\n\t\tconst root = this.model.document.getRoot( rootName );\n\n\t\tif ( trim === 'empty' && !this.model.hasContent( root, { ignoreWhitespaces: true } ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.stringify( root, options );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n\t * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element whose content will be stringified.\n\t * @param {Object} [options] Additional configuration passed to the conversion process.\n\t * @returns {String} Output data.\n\t */\n\tstringify( modelElementOrFragment, options = {} ) {\n\t\t// Model -> view.\n\t\tconst viewDocumentFragment = this.toView( modelElementOrFragment, options );\n\n\t\t// View -> data.\n\t\treturn this.processor.toData( viewDocumentFragment );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n\t * converters attached to {@link #downcastDispatcher} to a\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {Object} [options={}] Additional configuration that will be available through\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n\t */\n\ttoView( modelElementOrFragment, options = {} ) {\n\t\tconst viewDocument = this.viewDocument;\n\t\tconst viewWriter = this._viewWriter;\n\n\t\t// Clear bindings so the call to this method gives correct results.\n\t\tthis.mapper.clearBindings();\n\n\t\t// First, convert elements.\n\t\tconst modelRange = ModelRange._createIn( modelElementOrFragment );\n\t\tconst viewDocumentFragment = new ViewDocumentFragment( viewDocument );\n\n\t\tthis.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );\n\n\t\t// Make additional options available during conversion process through `conversionApi`.\n\t\tthis.downcastDispatcher.conversionApi.options = options;\n\n\t\t// We have no view controller and rendering to DOM in DataController so view.change() block is not used here.\n\t\tthis.downcastDispatcher.convertInsert( modelRange, viewWriter );\n\n\t\t// Convert markers.\n\t\t// For document fragment, simply take the markers assigned to this document fragment.\n\t\t// For model root, all markers in that root will be taken.\n\t\t// For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n\t\t// Collapsed markers at element boundary, although considered as not intersecting with the element, will also be returned.\n\t\tconst markers = modelElementOrFragment.is( 'documentFragment' ) ?\n\t\t\tArray.from( modelElementOrFragment.markers ) :\n\t\t\t_getMarkersRelativeToElement( modelElementOrFragment );\n\n\t\tfor ( const [ name, range ] of markers ) {\n\t\t\tthis.downcastDispatcher.convertMarkerAdd( name, range, viewWriter );\n\t\t}\n\n\t\t// Clean `conversionApi`.\n\t\tdelete this.downcastDispatcher.conversionApi.options;\n\n\t\treturn viewDocumentFragment;\n\t}\n\n\t/**\n\t * Sets initial input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n\t *\n\t * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n\t * used by e.g. collaborative editing plugin that syncs remote data on init.\n\t *\n\t * When data is passed as a string it is initialized on a default `main` root:\n\t *\n\t *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.\n\t *\n\t * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.\n\t *\n\t * @fires init\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to initialize data on multiple roots at once.\n\t * @returns {Promise} Promise that is resolved after the data is set on the editor.\n\t */\n\tinit( data ) {\n\t\tif ( this.model.document.version ) {\n\t\t\t/**\n\t\t\t * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n\t\t\t * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n\t\t\t * when the {@link module:engine/model/document~Document#version} is equal 0.\n\t\t\t *\n\t\t\t * @error datacontroller-init-document-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-document-not-empty', this );\n\t\t}\n\n\t\tlet initialData = {};\n\t\tif ( typeof data === 'string' ) {\n\t\t\tinitialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n\t\t} else {\n\t\t\tinitialData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( initialData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #init} like:\n\t\t\t *\n\t\t\t * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-init-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-non-existent-root', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\tfor ( const rootName of Object.keys( initialData ) ) {\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\t\t\t\twriter.insert( this.parse( initialData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Sets input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * This method can be used any time to replace existing editor data by the new one without clearing the\n\t * {@link module:engine/model/document~Document#history document history}.\n\t *\n\t * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n\t * the {@link #parse} method.\n\t *\n\t * When data is passed as a string it is set on a default `main` root:\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.\n\t *\n\t * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.\n\t *\n\t * To set the data with preserved undo stacks and set the current change to this stack, use the `{ batchType: 'default' }` option.\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>', { batchType: 'default' } ); // Sets data as a new change.\n\t *\n\t * @fires set\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to set data on multiple roots at once.\n\t * @param {Object} [options={}] Options for setting data.\n\t * @param {'default'|'transparent'} [options.batchType='default'] The batch type that will be used to create a batch for the changes.\n\t * When set to `default`, the undo and redo stacks will be preserved. Note that when not set, the undo feature (when present) will\n\t * override it to `transparent` and all undo steps will be lost.\n\t */\n\tset( data, options = {} ) {\n\t\tlet newData = {};\n\n\t\tif ( typeof data === 'string' ) {\n\t\t\tnewData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.\n\t\t} else {\n\t\t\tnewData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( newData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #set} like:\n\t\t\t *\n\t\t\t * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-set-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-set-non-existent-root', this );\n\t\t}\n\n\t\tconst batchType = options.batchType || 'default';\n\n\t\tthis.model.enqueueChange( batchType, writer => {\n\t\t\twriter.setSelection( null );\n\t\t\twriter.removeSelectionAttribute( this.model.document.selection.getAttributeKeys() );\n\n\t\t\tfor ( const rootName of Object.keys( newData ) ) {\n\t\t\t\t// Save to model.\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\t\t\twriter.remove( writer.createRangeIn( modelRoot ) );\n\t\t\t\twriter.insert( this.parse( newData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n\t * attached to the {@link #upcastDispatcher}.\n\t *\n\t * @see #set\n\t * @param {String} data Data to parse.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n\t */\n\tparse( data, context = '$root' ) {\n\t\t// data -> view\n\t\tconst viewDocumentFragment = this.processor.toView( data );\n\n\t\t// view -> model\n\t\treturn this.toModel( viewDocumentFragment, context );\n\t}\n\n\t/**\n\t * Returns the result of the given {@link module:engine/view/element~Element view element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n\t * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n\t *\n\t * When marker elements were converted during the conversion process, it will be set as a document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n\t */\n\ttoModel( viewElementOrFragment, context = '$root' ) {\n\t\treturn this.model.change( writer => {\n\t\t\treturn this.upcastDispatcher.convert( viewElementOrFragment, writer, context );\n\t\t} );\n\t}\n\n\t/**\n\t * Adds a style processor normalization rules.\n\t *\n\t * You can implement your own rules as well as use one of the available processor rules:\n\t *\n\t * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n\t * * border: {@link module:engine/view/styles/border~addBorderRules}\n\t * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n\t * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n\t *\n\t * @param {Function} callback\n\t */\n\taddStyleProcessorRules( callback ) {\n\t\tcallback( this.stylesProcessor );\n\t}\n\n\t/**\n\t * Registers a {@link module:engine/view/matcher~MatcherPattern} on {@link #htmlProcessor htmlProcessor}\n\t * and {@link #processor processor} for view elements whose content should be treated as a raw data\n\t * and not processed during conversion from DOM to view elements.\n\t *\n\t * The raw data can be later accessed by {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n\t * `\"$rawContent\"`.\n\t *\n\t * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n\t * be treated as a raw data.\n\t */\n\tregisterRawContentMatcher( pattern ) {\n\t\t// No need to register the pattern if both `htmlProcessor` and `processor` are the same instances.\n\t\tif ( this.processor && this.processor !== this.htmlProcessor ) {\n\t\t\tthis.processor.registerRawContentMatcher( pattern );\n\t\t}\n\n\t\tthis.htmlProcessor.registerRawContentMatcher( pattern );\n\t}\n\n\t/**\n\t * Removes all event listeners set by the DataController.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Checks if all provided root names are existing editor roots.\n\t *\n\t * @private\n\t * @param {Array.<String>} rootNames Root names to check.\n\t * @returns {Boolean} Whether all provided root names are existing editor roots.\n\t */\n\t_checkIfRootsExists( rootNames ) {\n\t\tfor ( const rootName of rootNames ) {\n\t\t\tif ( !this.model.document.getRootNames().includes( rootName ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Event fired once the data initialization has finished.\n\t *\n\t * @event ready\n\t */\n\n\t/**\n\t * Event fired after the {@link #init `init()` method} was run. It can be {@link #listenTo listened to} in order to adjust or modify\n\t * the initialization flow. However, if the `init` event is stopped or prevented, the {@link #event:ready `ready` event}\n\t * should be fired manually.\n\t *\n\t * The `init` event is fired by the decorated {@link #init} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event init\n\t */\n\n\t/**\n\t * Event fired after {@link #set set() method} has been run.\n\t *\n\t * The `set` event is fired by decorated {@link #set} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event set\n\t */\n\n\t/**\n\t * Event fired after {@link #get get() method} has been run.\n\t *\n\t * The `get` event is fired by decorated {@link #get} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event get\n\t */\n}\n\nmix( DataController, ObservableMixin );\n\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it. If the marker is collapsed\n// at element boundary, it is considered as contained inside the element and marker range is returned. Otherwise, if the marker is\n// intersecting with the element, the intersection is returned.\nfunction _getMarkersRelativeToElement( element ) {\n\tconst result = [];\n\tconst doc = element.root.document;\n\n\tif ( !doc ) {\n\t\treturn [];\n\t}\n\n\tconst elementRange = ModelRange._createIn( element );\n\n\tfor ( const marker of doc.model.markers ) {\n\t\tconst markerRange = marker.getRange();\n\n\t\tconst isMarkerCollapsed = markerRange.isCollapsed;\n\t\tconst isMarkerAtElementBoundary = markerRange.start.isEqual( elementRange.start ) || markerRange.end.isEqual( elementRange.end );\n\n\t\tif ( isMarkerCollapsed && isMarkerAtElementBoundary ) {\n\t\t\tresult.push( [ marker.name, markerRange ] );\n\t\t} else {\n\t\t\tconst updatedMarkerRange = elementRange.getIntersection( markerRange );\n\n\t\t\tif ( updatedMarkerRange ) {\n\t\t\t\tresult.push( [ marker.name, updatedMarkerRange ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Sort the markers in a stable fashion to ensure that the order that they are\n\t// added to the model's marker collection does not affect how they are\n\t// downcast. One particular use case that we're targeting here is one where\n\t// two markers are adjacent but not overlapping, such as an insertion/deletion\n\t// suggestion pair represting the replacement of a range of text. In this\n\t// case, putting the markers in DOM order causes the first marker's end to be\n\t// serialized right after the second marker's start, while putting the markers\n\t// in reverse DOM order causes it to be right before the second marker's\n\t// start. So, we sort in a way that ensures non-intersecting ranges are in\n\t// reverse DOM order, and intersecting ranges are in something approximating\n\t// reverse DOM order (since reverse DOM order doesn't have a precise meaning\n\t// when working with intersectng ranges).\n\treturn result.sort( ( [ n1, r1 ], [ n2, r2 ] ) => {\n\t\tif ( r1.end.compareWith( r2.start ) !== 'after' ) {\n\t\t\t// m1.end <= m2.start -- m1 is entirely <= m2\n\t\t\treturn 1;\n\t\t} else if ( r1.start.compareWith( r2.end ) !== 'before' ) {\n\t\t\t// m1.start >= m2.end -- m1 is entirely >= m2\n\t\t\treturn -1;\n\t\t} else {\n\t\t\t// they overlap, so use their start positions as the primary sort key and\n\t\t\t// end positions as the secondary sort key\n\t\t\tswitch ( r1.start.compareWith( r2.start ) ) {\n\t\t\t\tcase 'before':\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 'after':\n\t\t\t\t\treturn -1;\n\t\t\t\tdefault:\n\t\t\t\t\tswitch ( r1.end.compareWith( r2.end ) ) {\n\t\t\t\t\t\tcase 'before':\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\tcase 'after':\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn n2.localeCompare( n1 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n}\n"]},"metadata":{},"sourceType":"module"}