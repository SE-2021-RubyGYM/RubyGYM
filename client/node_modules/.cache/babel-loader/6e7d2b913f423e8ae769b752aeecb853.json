{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es'; // @if CK_DEBUG_POSITION // import { RectDrawer } from '@ckeditor/ckeditor5-minimap/src/utils';\n\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options The input data and configuration of the helper.\n * @returns {module:utils/dom/position~Position}\n */\n\nexport function getOptimalPosition(_ref) {\n  let {\n    element,\n    target,\n    positions,\n    limiter,\n    fitInViewport,\n    viewportOffsetConfig\n  } = _ref;\n\n  // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-utils/issues/157\n  if (isFunction(target)) {\n    target = target();\n  } // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-ui/issues/260\n\n\n  if (isFunction(limiter)) {\n    limiter = limiter();\n  }\n\n  const positionedElementAncestor = getPositionedAncestor(element);\n  const elementRect = new Rect(element);\n  const targetRect = new Rect(target);\n  let bestPosition; // @if CK_DEBUG_POSITION // RectDrawer.clear();\n  // @if CK_DEBUG_POSITION // RectDrawer.draw( targetRect, { outlineWidth: '5px' }, 'Target' );\n\n  const positionOptions = {\n    targetRect,\n    elementRect,\n    positionedElementAncestor\n  }; // If there are no limits, just grab the very first position and be done with that drama.\n\n  if (!limiter && !fitInViewport) {\n    bestPosition = new Position(positions[0], positionOptions);\n  } else {\n    const limiterRect = limiter && new Rect(limiter).getVisible();\n    const viewportRect = fitInViewport && getConstrainedViewportRect(viewportOffsetConfig); // @if CK_DEBUG_POSITION // if ( viewportRect ) {\n    // @if CK_DEBUG_POSITION //\t\tRectDrawer.draw( viewportRect, { outlineWidth: '5px' }, 'Viewport' );\n    // @if CK_DEBUG_POSITION // }\n    // @if CK_DEBUG_POSITION // if ( limiter ) {\n    // @if CK_DEBUG_POSITION // \tRectDrawer.draw( limiterRect, { outlineWidth: '5px', outlineColor: 'green' }, 'Visible limiter' );\n    // @if CK_DEBUG_POSITION // }\n\n    Object.assign(positionOptions, {\n      limiterRect,\n      viewportRect\n    }); // If there's no best position found, i.e. when all intersections have no area because\n    // rects have no width or height, then just use the first available position.\n\n    bestPosition = getBestPosition(positions, positionOptions) || new Position(positions[0], positionOptions);\n  }\n\n  return bestPosition;\n} // Returns a viewport `Rect` shrunk by the viewport offset config from all sides.\n//\n// @private\n// @param {Object} An object containing viewportOffset config.\n// @returns {utils/dom/rect~Rect} A shrunken rect of the viewport.\n\nfunction getConstrainedViewportRect(viewportOffsetConfig) {\n  viewportOffsetConfig = Object.assign({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  }, viewportOffsetConfig);\n  const viewportRect = new Rect(global.window);\n  viewportRect.top += viewportOffsetConfig.top;\n  viewportRect.height -= viewportOffsetConfig.top;\n  viewportRect.bottom -= viewportOffsetConfig.bottom;\n  viewportRect.height -= viewportOffsetConfig.bottom;\n  return viewportRect;\n} // For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n//\n// @param {Object} options\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position}to be checked, in the order of preference.\n// @param {Object} options\n// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned\n// {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} options.viewportRect A rect of the {@link module:utils/dom/position~Options#viewport}.\n//\n// @returns {Array} An array containing the name of the position and it's rect.\n\n\nfunction getBestPosition(positions, options) {\n  const {\n    elementRect\n  } = options; // This is when element is fully visible.\n\n  const elementRectArea = elementRect.getArea();\n  const positionInstances = positions.map(positioningFunction => new Position(positioningFunction, options)) // Some positioning functions may return `null` if they don't want to participate.\n  .filter(position => !!position.name);\n  let maxFitFactor = 0;\n  let bestPosition = null;\n\n  for (const position of positionInstances) {\n    const {\n      _limiterIntersectionArea,\n      _viewportIntersectionArea\n    } = position; // If a such position is found that element is fully contained by the limiter then, obviously,\n    // there will be no better one, so finishing.\n\n    if (_limiterIntersectionArea === elementRectArea) {\n      return position;\n    } // To maximize both viewport and limiter intersection areas we use distance on _viewportIntersectionArea\n    // and _limiterIntersectionArea plane (without sqrt because we are looking for max value).\n\n\n    const fitFactor = _viewportIntersectionArea ** 2 + _limiterIntersectionArea ** 2;\n\n    if (fitFactor > maxFitFactor) {\n      maxFitFactor = fitFactor;\n      bestPosition = position;\n    }\n  }\n\n  return bestPosition;\n} // For a given absolute Rect coordinates object and a positioned element ancestor, it returns an object with\n// new Rect coordinates that make up for the position and the scroll of the ancestor.\n//\n// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates\n// are used in real–life to position elements with `position: absolute`, which are scoped by any positioned\n// (and scrollable) ancestors.\n//\n// @private\n//\n// @param {utils/dom/rect~Rect} rect A rect with absolute rect coordinates.\n// @param {Number} rect.top\n// @param {Number} rect.left\n// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.\n//\n// @returns {utils/dom/rect~Rect} A rect corresponding to `absoluteRect` input but with values shifted\n// to make up for the positioned element ancestor.\n\n\nfunction shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {\n  const ancestorPosition = getRectForAbsolutePositioning(new Rect(positionedElementAncestor));\n  const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);\n  let moveX = 0;\n  let moveY = 0; // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n  // If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n  // consideration. `Rect` is always relative to the viewport while `position: absolute` works\n  // with respect to that positioned ancestor.\n\n  moveX -= ancestorPosition.left;\n  moveY -= ancestorPosition.top; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, not only its position must be taken into\n  // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n  // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n  // must compensate that scrolling.\n\n  moveX += positionedElementAncestor.scrollLeft;\n  moveY += positionedElementAncestor.scrollTop; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n  // while `position: absolute` positioning does not consider it.\n  // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n  // not upper-left corner of its border.\n\n  moveX -= ancestorBorderWidths.left;\n  moveY -= ancestorBorderWidths.top;\n  rect.moveBy(moveX, moveY);\n} // DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\n\n\nfunction getRectForAbsolutePositioning(rect) {\n  const {\n    scrollX,\n    scrollY\n  } = global.window;\n  return rect.clone().moveBy(scrollX, scrollY);\n}\n/**\n * A position class which instances are created and used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n *\n * {@link module:utils/dom/position~Position#top} and {@link module:utils/dom/position~Position#left} properties of the position instance\n * translate directly to the `top` and `left` properties in CSS \"`position: absolute` coordinate system\". If set on the positioned element\n * in DOM, they will make it display it in the right place in the viewport.\n */\n\n\nexport class Position {\n  /**\n   * Creates an instance of the {@link module:utils/dom/position~Position} class.\n   *\n   * @param {module:utils/dom/position~positioningFunction} [positioningFunction] function The function that defines the expected\n   * coordinates the positioned element should move to.\n   * @param {Object} [options] options object.\n   * @param {module:utils/dom/rect~Rect} options.elementRect The positioned element rect.\n   * @param {module:utils/dom/rect~Rect} options.targetRect The target element rect.\n   * @param {module:utils/dom/rect~Rect} options.viewportRect The viewport rect.\n   * @param {HTMLElement|null} [options.positionedElementAncestor] Nearest element ancestor element which CSS position is not \"static\".\n   */\n  constructor(positioningFunction, options) {\n    const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect); // Nameless position for a function that didn't participate.\n\n    if (!positioningFunctionOutput) {\n      return;\n    }\n\n    const {\n      left,\n      top,\n      name,\n      config\n    } = positioningFunctionOutput;\n    Object.assign(this, {\n      name,\n      config\n    });\n    this._positioningFunctionCorrdinates = {\n      left,\n      top\n    };\n    this._options = options;\n    /**\n     * Position name.\n     *\n     * @readonly\n     * @member {String} #name\n     */\n\n    /**\n     * Additional position configuration, as passed from the {@link module:utils/dom/position~positioningFunction positioning function}.\n     *\n     * This object can be use, for instance, to pass through presentation options used by the consumer of the\n     * {@link module:utils/dom/position~getOptimalPosition} helper.\n     *\n     * @readonly\n     * @member {Object} #config\n     */\n  }\n  /**\n   * The left value in pixels in the CSS `position: absolute` coordinate system.\n   * Set it on the positioned element in DOM to move it to the position.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get left() {\n    return this._absoluteRect.left;\n  }\n  /**\n   * The top value in pixels in the CSS `position: absolute` coordinate system.\n   * Set it on the positioned element in DOM to move it to the position.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get top() {\n    return this._absoluteRect.top;\n  }\n  /**\n   * An intersection area between positioned element and limiter within viewport constraints.\n   *\n   * @readonly\n   * @private\n   * @type {Number}\n   */\n\n\n  get _limiterIntersectionArea() {\n    const limiterRect = this._options.limiterRect;\n\n    if (limiterRect) {\n      const viewportRect = this._options.viewportRect;\n\n      if (viewportRect) {\n        // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n        const limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);\n\n        if (limiterViewportIntersectRect) {\n          // If the limiter is within the viewport, then check the intersection between that part of the\n          // limiter and actual position.\n          return limiterViewportIntersectRect.getIntersectionArea(this._rect);\n        }\n      } else {\n        return limiterRect.getIntersectionArea(this._rect);\n      }\n    }\n\n    return 0;\n  }\n  /**\n   * An intersection area between positioned element and viewport.\n   *\n   * @readonly\n   * @private\n   * @type {Number}\n   */\n\n\n  get _viewportIntersectionArea() {\n    const viewportRect = this._options.viewportRect;\n\n    if (viewportRect) {\n      return viewportRect.getIntersectionArea(this._rect);\n    }\n\n    return 0;\n  }\n  /**\n   * An already positioned element rect. A clone of the element rect passed to the constructor\n   * but placed in the viewport according to the positioning function.\n   *\n   * @private\n   * @type {module:utils/dom/rect~Rect}\n   */\n\n\n  get _rect() {\n    if (this._cachedRect) {\n      return this._cachedRect;\n    }\n\n    this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top);\n    return this._cachedRect;\n  }\n  /**\n   * An already absolutely positioned element rect. See ({@link #_rect}).\n   *\n   * @private\n   * @type {module:utils/dom/rect~Rect}\n   */\n\n\n  get _absoluteRect() {\n    if (this._cachedAbsoluteRect) {\n      return this._cachedAbsoluteRect;\n    }\n\n    this._cachedAbsoluteRect = getRectForAbsolutePositioning(this._rect);\n\n    if (this._options.positionedElementAncestor) {\n      shiftRectToCompensatePositionedAncestor(this._cachedAbsoluteRect, this._options.positionedElementAncestor);\n    }\n\n    return this._cachedAbsoluteRect;\n  }\n\n}\n/**\n * The `getOptimalPosition()` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #target\n */\n\n/**\n * An array of positioning functions.\n *\n * **Note**: Positioning functions are processed in the order of preference. The first function that works\n * in the current environment (e.g. offers the complete fit in the viewport geometry) will be picked by\n * `getOptimalPosition()`.\n *\n * **Note**: Any positioning function returning `null` is ignored.\n *\n * @member {Array.<module:utils/dom/position~positioningFunction>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * Viewport offset config object. It restricts the visible viewport available to the `getOptimalPosition()` from each side.\n *\n *\t\t{\n *\t\t\ttop: 50,\n *\t\t\tright: 50,\n *\t\t\tbottom: 50,\n *\t\t\tleft: 50\n *\t\t}\n *\n * @member {Object} #viewportOffsetConfig\n */\n\n/**\n * A positioning function which, based on positioned element and target {@link module:utils/dom/rect~Rect Rects}, returns rect coordinates\n * representing the geometrical relation between them. Used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n *\n *\t\t// This simple position will place the element directly under the target, in the middle:\n *\t\t//\n *\t\t//\t    [ Target ]\n *\t\t//\t+-----------------+\n *\t\t//\t|     Element     |\n *\t\t//\t+-----------------+\n *\t\t//\n *\t\tconst position = ( targetRect, elementRect, [ viewportRect ] ) => ( {\n *\t\t\ttop: targetRect.bottom,\n *\t\t\tleft: targetRect.left + targetRect.width / 2 - elementRect.width / 2,\n *\t\t\tname: 'bottomMiddle',\n *\n *\t\t\t// Note: The config is optional.\n *\t\t\tconfig: {\n *\t\t\t\tzIndex: '999'\n *\t\t\t}\n *\t\t} );\n *\n * @callback module:utils/dom/position~positioningFunction\n * @param {module:utils/dom/rect~Rect} elementRect The rect of the element to be positioned.\n * @param {module:utils/dom/rect~Rect} targetRect The rect of the target the element (its rect) is relatively positioned to.\n * @param {module:utils/dom/rect~Rect} viewportRect The rect of the visual browser viewport.\n * @returns {Object|null} return When the function returns `null`, it will not be considered by\n * {@link module:utils/dom/position~getOptimalPosition}.\n * @returns {Number} return.top The `top` value of the element rect that would represent the position.\n * @returns {Number} return.left The `left` value of the element rect that would represent the position.\n * @returns {Number} return.name The name of the position. It helps the user of the {@link module:utils/dom/position~getOptimalPosition}\n * helper to recognize different positioning function results. It will pass through to the {@link module:utils/dom/position~Position}\n * returned by the helper.\n * @returns {Number} [return.config] An optional configuration that will pass-through the\n * {@link module:utils/dom/position~getOptimalPosition} helper to the {@link module:utils/dom/position~Position} returned by this helper.\n * This configuration may, for instance, let the user of {@link module:utils/dom/position~getOptimalPosition} know that this particular\n * position comes with a certain presentation.\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js"],"names":["global","Rect","getPositionedAncestor","getBorderWidths","isFunction","getOptimalPosition","element","target","positions","limiter","fitInViewport","viewportOffsetConfig","positionedElementAncestor","elementRect","targetRect","bestPosition","positionOptions","Position","limiterRect","getVisible","viewportRect","getConstrainedViewportRect","Object","assign","getBestPosition","top","bottom","left","right","window","height","options","elementRectArea","getArea","positionInstances","map","positioningFunction","filter","position","name","maxFitFactor","_limiterIntersectionArea","_viewportIntersectionArea","fitFactor","shiftRectToCompensatePositionedAncestor","rect","ancestorPosition","getRectForAbsolutePositioning","ancestorBorderWidths","moveX","moveY","scrollLeft","scrollTop","moveBy","scrollX","scrollY","clone","constructor","positioningFunctionOutput","config","_positioningFunctionCorrdinates","_options","_absoluteRect","limiterViewportIntersectRect","getIntersection","getIntersectionArea","_rect","_cachedRect","moveTo","_cachedAbsoluteRect"],"mappings":"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AAZ;AACA;;AAED,SAAKA,mBAAL,GAA2BtB,6BAA6B,CAAE,KAAKmB,KAAP,CAAxD;;AAEA,QAAK,KAAKL,QAAL,CAAcjD,yBAAnB,EAA+C;AAC9CgC,MAAAA,uCAAuC,CAAE,KAAKyB,mBAAP,EAA4B,KAAKR,QAAL,CAAcjD,yBAA1C,CAAvC;AACA;;AAED,WAAO,KAAKyD,mBAAZ;AACA;;AAxJoB;AA2JtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\n\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es';\n\n// @if CK_DEBUG_POSITION // import { RectDrawer } from '@ckeditor/ckeditor5-minimap/src/utils';\n\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options The input data and configuration of the helper.\n * @returns {module:utils/dom/position~Position}\n */\nexport function getOptimalPosition( { element, target, positions, limiter, fitInViewport, viewportOffsetConfig } ) {\n\t// If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-utils/issues/157\n\tif ( isFunction( target ) ) {\n\t\ttarget = target();\n\t}\n\n\t// If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-ui/issues/260\n\tif ( isFunction( limiter ) ) {\n\t\tlimiter = limiter();\n\t}\n\n\tconst positionedElementAncestor = getPositionedAncestor( element );\n\tconst elementRect = new Rect( element );\n\tconst targetRect = new Rect( target );\n\n\tlet bestPosition;\n\n\t// @if CK_DEBUG_POSITION // RectDrawer.clear();\n\t// @if CK_DEBUG_POSITION // RectDrawer.draw( targetRect, { outlineWidth: '5px' }, 'Target' );\n\n\tconst positionOptions = { targetRect, elementRect, positionedElementAncestor };\n\n\t// If there are no limits, just grab the very first position and be done with that drama.\n\tif ( !limiter && !fitInViewport ) {\n\t\tbestPosition = new Position( positions[ 0 ], positionOptions );\n\t} else {\n\t\tconst limiterRect = limiter && new Rect( limiter ).getVisible();\n\t\tconst viewportRect = fitInViewport && getConstrainedViewportRect( viewportOffsetConfig );\n\n\t\t// @if CK_DEBUG_POSITION // if ( viewportRect ) {\n\t\t// @if CK_DEBUG_POSITION //\t\tRectDrawer.draw( viewportRect, { outlineWidth: '5px' }, 'Viewport' );\n\t\t// @if CK_DEBUG_POSITION // }\n\n\t\t// @if CK_DEBUG_POSITION // if ( limiter ) {\n\t\t// @if CK_DEBUG_POSITION // \tRectDrawer.draw( limiterRect, { outlineWidth: '5px', outlineColor: 'green' }, 'Visible limiter' );\n\t\t// @if CK_DEBUG_POSITION // }\n\n\t\tObject.assign( positionOptions, { limiterRect, viewportRect } );\n\n\t\t// If there's no best position found, i.e. when all intersections have no area because\n\t\t// rects have no width or height, then just use the first available position.\n\t\tbestPosition = getBestPosition( positions, positionOptions ) || new Position( positions[ 0 ], positionOptions );\n\t}\n\n\treturn bestPosition;\n}\n\n// Returns a viewport `Rect` shrunk by the viewport offset config from all sides.\n//\n// @private\n// @param {Object} An object containing viewportOffset config.\n// @returns {utils/dom/rect~Rect} A shrunken rect of the viewport.\nfunction getConstrainedViewportRect( viewportOffsetConfig ) {\n\tviewportOffsetConfig = Object.assign( { top: 0, bottom: 0, left: 0, right: 0 }, viewportOffsetConfig );\n\n\tconst viewportRect = new Rect( global.window );\n\n\tviewportRect.top += viewportOffsetConfig.top;\n\tviewportRect.height -= viewportOffsetConfig.top;\n\tviewportRect.bottom -= viewportOffsetConfig.bottom;\n\tviewportRect.height -= viewportOffsetConfig.bottom;\n\n\treturn viewportRect;\n}\n\n// For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n//\n// @param {Object} options\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position}to be checked, in the order of preference.\n// @param {Object} options\n// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned\n// {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} options.viewportRect A rect of the {@link module:utils/dom/position~Options#viewport}.\n//\n// @returns {Array} An array containing the name of the position and it's rect.\nfunction getBestPosition( positions, options ) {\n\tconst { elementRect } = options;\n\n\t// This is when element is fully visible.\n\tconst elementRectArea = elementRect.getArea();\n\n\tconst positionInstances = positions\n\t\t.map( positioningFunction => new Position( positioningFunction, options ) )\n\t\t// Some positioning functions may return `null` if they don't want to participate.\n\t\t.filter( position => !!position.name );\n\n\tlet maxFitFactor = 0;\n\tlet bestPosition = null;\n\n\tfor ( const position of positionInstances ) {\n\t\tconst { _limiterIntersectionArea, _viewportIntersectionArea } = position;\n\n\t\t// If a such position is found that element is fully contained by the limiter then, obviously,\n\t\t// there will be no better one, so finishing.\n\t\tif ( _limiterIntersectionArea === elementRectArea ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// To maximize both viewport and limiter intersection areas we use distance on _viewportIntersectionArea\n\t\t// and _limiterIntersectionArea plane (without sqrt because we are looking for max value).\n\t\tconst fitFactor = _viewportIntersectionArea ** 2 + _limiterIntersectionArea ** 2;\n\n\t\tif ( fitFactor > maxFitFactor ) {\n\t\t\tmaxFitFactor = fitFactor;\n\t\t\tbestPosition = position;\n\t\t}\n\t}\n\n\treturn bestPosition;\n}\n\n// For a given absolute Rect coordinates object and a positioned element ancestor, it returns an object with\n// new Rect coordinates that make up for the position and the scroll of the ancestor.\n//\n// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates\n// are used in real–life to position elements with `position: absolute`, which are scoped by any positioned\n// (and scrollable) ancestors.\n//\n// @private\n//\n// @param {utils/dom/rect~Rect} rect A rect with absolute rect coordinates.\n// @param {Number} rect.top\n// @param {Number} rect.left\n// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.\n//\n// @returns {utils/dom/rect~Rect} A rect corresponding to `absoluteRect` input but with values shifted\n// to make up for the positioned element ancestor.\nfunction shiftRectToCompensatePositionedAncestor( rect, positionedElementAncestor ) {\n\tconst ancestorPosition = getRectForAbsolutePositioning( new Rect( positionedElementAncestor ) );\n\tconst ancestorBorderWidths = getBorderWidths( positionedElementAncestor );\n\n\tlet moveX = 0;\n\tlet moveY = 0;\n\n\t// (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n\t// If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n\t// consideration. `Rect` is always relative to the viewport while `position: absolute` works\n\t// with respect to that positioned ancestor.\n\tmoveX -= ancestorPosition.left;\n\tmoveY -= ancestorPosition.top;\n\n\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t// If there's some positioned ancestor of the panel, not only its position must be taken into\n\t// consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n\t// is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n\t// must compensate that scrolling.\n\tmoveX += positionedElementAncestor.scrollLeft;\n\tmoveY += positionedElementAncestor.scrollTop;\n\n\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t// If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n\t// while `position: absolute` positioning does not consider it.\n\t// E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n\t// not upper-left corner of its border.\n\tmoveX -= ancestorBorderWidths.left;\n\tmoveY -= ancestorBorderWidths.top;\n\n\trect.moveBy( moveX, moveY );\n}\n\n// DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\nfunction getRectForAbsolutePositioning( rect ) {\n\tconst { scrollX, scrollY } = global.window;\n\n\treturn rect.clone().moveBy( scrollX, scrollY );\n}\n\n/**\n * A position class which instances are created and used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n *\n * {@link module:utils/dom/position~Position#top} and {@link module:utils/dom/position~Position#left} properties of the position instance\n * translate directly to the `top` and `left` properties in CSS \"`position: absolute` coordinate system\". If set on the positioned element\n * in DOM, they will make it display it in the right place in the viewport.\n */\nexport class Position {\n\t/**\n\t * Creates an instance of the {@link module:utils/dom/position~Position} class.\n\t *\n\t * @param {module:utils/dom/position~positioningFunction} [positioningFunction] function The function that defines the expected\n\t * coordinates the positioned element should move to.\n\t * @param {Object} [options] options object.\n\t * @param {module:utils/dom/rect~Rect} options.elementRect The positioned element rect.\n\t * @param {module:utils/dom/rect~Rect} options.targetRect The target element rect.\n\t * @param {module:utils/dom/rect~Rect} options.viewportRect The viewport rect.\n\t * @param {HTMLElement|null} [options.positionedElementAncestor] Nearest element ancestor element which CSS position is not \"static\".\n\t */\n\tconstructor( positioningFunction, options ) {\n\t\tconst positioningFunctionOutput = positioningFunction( options.targetRect, options.elementRect, options.viewportRect );\n\n\t\t// Nameless position for a function that didn't participate.\n\t\tif ( !positioningFunctionOutput ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { left, top, name, config } = positioningFunctionOutput;\n\n\t\tObject.assign( this, { name, config } );\n\n\t\tthis._positioningFunctionCorrdinates = { left, top };\n\t\tthis._options = options;\n\n\t\t/**\n\t\t * Position name.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} #name\n\t\t */\n\n\t\t/**\n\t\t * Additional position configuration, as passed from the {@link module:utils/dom/position~positioningFunction positioning function}.\n\t\t *\n\t\t * This object can be use, for instance, to pass through presentation options used by the consumer of the\n\t\t * {@link module:utils/dom/position~getOptimalPosition} helper.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Object} #config\n\t\t */\n\t}\n\n\t/**\n\t * The left value in pixels in the CSS `position: absolute` coordinate system.\n\t * Set it on the positioned element in DOM to move it to the position.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget left() {\n\t\treturn this._absoluteRect.left;\n\t}\n\n\t/**\n\t * The top value in pixels in the CSS `position: absolute` coordinate system.\n\t * Set it on the positioned element in DOM to move it to the position.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget top() {\n\t\treturn this._absoluteRect.top;\n\t}\n\n\t/**\n\t * An intersection area between positioned element and limiter within viewport constraints.\n\t *\n\t * @readonly\n\t * @private\n\t * @type {Number}\n\t */\n\tget _limiterIntersectionArea() {\n\t\tconst limiterRect = this._options.limiterRect;\n\n\t\tif ( limiterRect ) {\n\t\t\tconst viewportRect = this._options.viewportRect;\n\n\t\t\tif ( viewportRect ) {\n\t\t\t\t// Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n\t\t\t\tconst limiterViewportIntersectRect = limiterRect.getIntersection( viewportRect );\n\n\t\t\t\tif ( limiterViewportIntersectRect ) {\n\t\t\t\t\t// If the limiter is within the viewport, then check the intersection between that part of the\n\t\t\t\t\t// limiter and actual position.\n\t\t\t\t\treturn limiterViewportIntersectRect.getIntersectionArea( this._rect );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn limiterRect.getIntersectionArea( this._rect );\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * An intersection area between positioned element and viewport.\n\t *\n\t * @readonly\n\t * @private\n\t * @type {Number}\n\t */\n\tget _viewportIntersectionArea() {\n\t\tconst viewportRect = this._options.viewportRect;\n\n\t\tif ( viewportRect ) {\n\t\t\treturn viewportRect.getIntersectionArea( this._rect );\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * An already positioned element rect. A clone of the element rect passed to the constructor\n\t * but placed in the viewport according to the positioning function.\n\t *\n\t * @private\n\t * @type {module:utils/dom/rect~Rect}\n\t */\n\tget _rect() {\n\t\tif ( this._cachedRect ) {\n\t\t\treturn this._cachedRect;\n\t\t}\n\n\t\tthis._cachedRect = this._options.elementRect.clone().moveTo(\n\t\t\tthis._positioningFunctionCorrdinates.left,\n\t\t\tthis._positioningFunctionCorrdinates.top\n\t\t);\n\n\t\treturn this._cachedRect;\n\t}\n\n\t/**\n\t * An already absolutely positioned element rect. See ({@link #_rect}).\n\t *\n\t * @private\n\t * @type {module:utils/dom/rect~Rect}\n\t */\n\tget _absoluteRect() {\n\t\tif ( this._cachedAbsoluteRect ) {\n\t\t\treturn this._cachedAbsoluteRect;\n\t\t}\n\n\t\tthis._cachedAbsoluteRect = getRectForAbsolutePositioning( this._rect );\n\n\t\tif ( this._options.positionedElementAncestor ) {\n\t\t\tshiftRectToCompensatePositionedAncestor( this._cachedAbsoluteRect, this._options.positionedElementAncestor );\n\t\t}\n\n\t\treturn this._cachedAbsoluteRect;\n\t}\n}\n\n/**\n * The `getOptimalPosition()` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #target\n */\n\n/**\n * An array of positioning functions.\n *\n * **Note**: Positioning functions are processed in the order of preference. The first function that works\n * in the current environment (e.g. offers the complete fit in the viewport geometry) will be picked by\n * `getOptimalPosition()`.\n *\n * **Note**: Any positioning function returning `null` is ignored.\n *\n * @member {Array.<module:utils/dom/position~positioningFunction>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * Viewport offset config object. It restricts the visible viewport available to the `getOptimalPosition()` from each side.\n *\n *\t\t{\n *\t\t\ttop: 50,\n *\t\t\tright: 50,\n *\t\t\tbottom: 50,\n *\t\t\tleft: 50\n *\t\t}\n *\n * @member {Object} #viewportOffsetConfig\n */\n\n/**\n * A positioning function which, based on positioned element and target {@link module:utils/dom/rect~Rect Rects}, returns rect coordinates\n * representing the geometrical relation between them. Used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n *\n *\t\t// This simple position will place the element directly under the target, in the middle:\n *\t\t//\n *\t\t//\t    [ Target ]\n *\t\t//\t+-----------------+\n *\t\t//\t|     Element     |\n *\t\t//\t+-----------------+\n *\t\t//\n *\t\tconst position = ( targetRect, elementRect, [ viewportRect ] ) => ( {\n *\t\t\ttop: targetRect.bottom,\n *\t\t\tleft: targetRect.left + targetRect.width / 2 - elementRect.width / 2,\n *\t\t\tname: 'bottomMiddle',\n *\n *\t\t\t// Note: The config is optional.\n *\t\t\tconfig: {\n *\t\t\t\tzIndex: '999'\n *\t\t\t}\n *\t\t} );\n *\n * @callback module:utils/dom/position~positioningFunction\n * @param {module:utils/dom/rect~Rect} elementRect The rect of the element to be positioned.\n * @param {module:utils/dom/rect~Rect} targetRect The rect of the target the element (its rect) is relatively positioned to.\n * @param {module:utils/dom/rect~Rect} viewportRect The rect of the visual browser viewport.\n * @returns {Object|null} return When the function returns `null`, it will not be considered by\n * {@link module:utils/dom/position~getOptimalPosition}.\n * @returns {Number} return.top The `top` value of the element rect that would represent the position.\n * @returns {Number} return.left The `left` value of the element rect that would represent the position.\n * @returns {Number} return.name The name of the position. It helps the user of the {@link module:utils/dom/position~getOptimalPosition}\n * helper to recognize different positioning function results. It will pass through to the {@link module:utils/dom/position~Position}\n * returned by the helper.\n * @returns {Number} [return.config] An optional configuration that will pass-through the\n * {@link module:utils/dom/position~getOptimalPosition} helper to the {@link module:utils/dom/position~Position} returned by this helper.\n * This configuration may, for instance, let the user of {@link module:utils/dom/position~getOptimalPosition} know that this particular\n * position comes with a certain presentation.\n */\n"]},"metadata":{},"sourceType":"module"}