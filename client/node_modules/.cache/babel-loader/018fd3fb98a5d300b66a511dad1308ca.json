{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/model\n */\nimport Batch from './batch';\nimport Writer from './writer';\nimport Schema from './schema';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ModelElement from './element';\nimport ModelRange from './range';\nimport ModelPosition from './position';\nimport ModelSelection from './selection';\nimport OperationFactory from './operation/operationfactory';\nimport insertContent from './utils/insertcontent';\nimport deleteContent from './utils/deletecontent';\nimport modifySelection from './utils/modifyselection';\nimport getSelectedContent from './utils/getselectedcontent';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport { autoParagraphEmptyRoots } from './utils/autoparagraphing';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror'; // @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class Model {\n  constructor() {\n    /**\n     * Model's marker collection.\n     *\n     * @readonly\n     * @member {module:engine/model/markercollection~MarkerCollection}\n     */\n    this.markers = new MarkerCollection();\n    /**\n     * Model's document.\n     *\n     * @readonly\n     * @member {module:engine/model/document~Document}\n     */\n\n    this.document = new Document(this);\n    /**\n     * Model's schema.\n     *\n     * @readonly\n     * @member {module:engine/model/schema~Schema}\n     */\n\n    this.schema = new Schema();\n    /**\n     * All callbacks added by {@link module:engine/model/model~Model#change} or\n     * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n     *\n     * @private\n     * @type {Array.<Function>}\n     */\n\n    this._pendingChanges = [];\n    /**\n     * The last created and currently used writer instance.\n     *\n     * @private\n     * @member {module:engine/model/writer~Writer}\n     */\n\n    this._currentWriter = null;\n    ['insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach(methodName => this.decorate(methodName)); // Adding operation validation with `highest` priority, so it is called before any other feature would like\n    // to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\n    this.on('applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      operation._validate();\n    }, {\n      priority: 'highest'\n    }); // Register some default abstract entities.\n\n    this.schema.register('$root', {\n      isLimit: true\n    });\n    this.schema.register('$block', {\n      allowIn: '$root',\n      isBlock: true\n    });\n    this.schema.register('$text', {\n      allowIn: '$block',\n      isInline: true,\n      isContent: true\n    });\n    this.schema.register('$clipboardHolder', {\n      allowContentOf: '$root',\n      allowChildren: '$text',\n      isLimit: true\n    });\n    this.schema.register('$documentFragment', {\n      allowContentOf: '$root',\n      allowChildren: '$text',\n      isLimit: true\n    }); // An element needed by the `upcastElementToMarker` converter.\n    // This element temporarily represents a marker boundary during the conversion process and is removed\n    // at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n    // better place for this registration but both know nothing about `Schema`.\n\n    this.schema.register('$marker');\n    this.schema.addChildCheck((context, childDefinition) => {\n      if (childDefinition.name === '$marker') {\n        return true;\n      }\n    });\n    injectSelectionPostFixer(this); // Post-fixer which takes care of adding empty paragraph elements to the empty roots.\n\n    this.document.registerPostFixer(autoParagraphEmptyRoots); // @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n    // @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n    // @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n  }\n  /**\n   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n   * (including detached nodes â€“ i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n   * the {@link module:engine/model/document~Document#selection document's selection}, and\n   * {@link module:engine/model/model~Model#markers model markers}.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t} );\n   *\n   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n   * into a single undo step.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n   *\n   *\t\t\tmodel.change( writer => {\n   *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n   *\t\t\t} );\n   *\n   * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n   *\t\t} );\n   *\n   * The callback of the `change()` block is executed synchronously.\n   *\n   * You can also return a value from the change block.\n   *\n   *\t\tconst img = model.change( writer => {\n   *\t\t\treturn writer.createElement( 'img' );\n   *\t\t} );\n   *\n   * @see #enqueueChange\n   * @param {Function} callback Callback function which may modify the model.\n   * @returns {*} Value returned by the callback.\n   */\n\n\n  change(callback) {\n    try {\n      if (this._pendingChanges.length === 0) {\n        // If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n        this._pendingChanges.push({\n          batch: new Batch(),\n          callback\n        });\n\n        return this._runPendingChanges()[0];\n      } else {\n        // If this is not the outermost block, just execute the callback.\n        return callback(this._currentWriter);\n      }\n    } catch (err) {\n      // @if CK_DEBUG // throw err;\n\n      /* istanbul ignore next */\n      CKEditorError.rethrowUnexpectedError(err, this);\n    }\n  }\n  /**\n   * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n   *\n   * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n   * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n   * it will be delayed and executed after the outermost block.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconsole.log( 1 );\n   *\n   *\t\t\tmodel.enqueueChange( writer => {\n   *\t\t\t\tconsole.log( 2 );\n   *\t\t\t} );\n   *\n   * \t\t\tconsole.log( 3 );\n   *\t\t} ); // Will log: 1, 3, 2.\n   *\n   * In addition to that, the changes enqueued with `enqueueChange()` will be converted separately from the changes\n   * done in the outer `change()` block.\n   *\n   * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n   * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different\n   * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).\n   *\n   * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n   *\n   *\t\tmodel.enqueueChange( batch, writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t} );\n   *\n   * In order to make a nested `enqueueChange()` create a single undo step together with the changes done in the outer `change()`\n   * block, you can obtain the batch instance from the  {@link module:engine/model/writer~Writer#batch writer} of the outer block.\n   *\n   * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.\n   * If not defined, a new batch will be created.\n   * @param {Function} callback Callback function which may modify the model.\n   */\n\n\n  enqueueChange(batchOrType, callback) {\n    try {\n      if (typeof batchOrType === 'string') {\n        batchOrType = new Batch(batchOrType);\n      } else if (typeof batchOrType == 'function') {\n        callback = batchOrType;\n        batchOrType = new Batch();\n      }\n\n      this._pendingChanges.push({\n        batch: batchOrType,\n        callback\n      });\n\n      if (this._pendingChanges.length == 1) {\n        this._runPendingChanges();\n      }\n    } catch (err) {\n      // @if CK_DEBUG // throw err;\n\n      /* istanbul ignore next */\n      CKEditorError.rethrowUnexpectedError(err, this);\n    }\n  }\n  /**\n   * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n   * {@link module:engine/model/operation/operation~Operation operations} to the model.\n   *\n   * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n   * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n   * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n   * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n   */\n\n\n  applyOperation(operation) {\n    // @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n    // @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n    // @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n    // @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n    // @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n    // @if CK_DEBUG_ENGINE //}\n    // @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n    operation._execute();\n  } // @if CK_DEBUG_ENGINE // getAppliedOperation() {\n  // @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n  // @if CK_DEBUG_ENGINE //\t\treturn '';\n  // @if CK_DEBUG_ENGINE //\t}\n  // @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n  // @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n  // @if CK_DEBUG_ENGINE // }\n\n  /**\n   * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n   * functionality to work.\n   *\n   * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n   * the content, clears the given selection's content before inserting nodes and moves the selection\n   * to its target position at the end of the process.\n   * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n   * pasting feature should do.\n   *\n   * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n   *\n   * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n   * inside a {@link #change `change()` block}.\n   *\n   * # Conversion and schema\n   *\n   * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n   * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n   * is only adding nodes to the model. Additionally, you need to define\n   * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n   * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n   *\n   * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n   * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n   * unless converters are defined for all elements and attributes in that HTML.\n   *\n   * # Examples\n   *\n   * Using `insertContent()` with a manually created model structure:\n   *\n   *\t\t// Let's create a document fragment containing such content as:\n   *\t\t//\n   *\t\t// <paragraph>foo</paragraph>\n   *\t\t// <blockQuote>\n   *\t\t//    <paragraph>bar</paragraph>\n   *\t\t// </blockQuote>\n   *\t\tconst docFrag = editor.model.change( writer => {\n   *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n   *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n   *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n   *\t\t\tconst docFrag = writer.createDocumentFragment();\n   *\n   *\t\t\twriter.append( p1, docFrag );\n   *\t\t\twriter.append( blockQuote, docFrag );\n   *\t\t\twriter.append( p2, blockQuote );\n   *\t\t\twriter.insertText( 'foo', p1 );\n   *\t\t\twriter.insertText( 'bar', p2 );\n   *\n   *\t\t\treturn docFrag;\n   *\t\t} );\n   *\n   *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n   *\t\t// so this code could be moved to the callback defined above.\n   *\t\teditor.model.insertContent( docFrag );\n   *\n   * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n   *\n   *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n   *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n   *\t\tconst htmlDP = new HtmlDataProcessor( viewDocument );\n   *\n   *\t\t// Convert an HTML string to a view document fragment:\n   *\t\tconst viewFragment = htmlDP.toView( htmlString );\n   *\n   *\t\t// Convert the view document fragment to a model document fragment\n   *\t\t// in the context of $root. This conversion takes the schema into\n   *\t\t// account so if, for example, the view document fragment contained a bare text node,\n   *\t\t// this text node cannot be a child of $root, so it will be automatically\n   *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n   *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n   *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n   *\t\t// which has a loosened schema.\n   *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n   *\n   *\t\teditor.model.insertContent( modelFragment );\n   *\n   * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n   *\n   *\t\t// Insert text at the current document selection position.\n   *\t\teditor.model.change( writer => {\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n   *\t\t} );\n   *\n   *\t\t// Insert text at a given position - the document selection will not be modified.\n   *\t\teditor.model.change( writer => {\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n   *\n   *\t\t\t// Which is a shorthand for:\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n   *\t\t} );\n   *\n   * If you want the document selection to be moved to the inserted content, use the\n   * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting\n   * the content:\n   *\n   *\t\teditor.model.change( writer => {\n   *\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\n   *\t\t\t// Insert an empty paragraph at the beginning of the root.\n   *\t\t\teditor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );\n   *\n   *\t\t\t// Move the document selection to the inserted paragraph.\n   *\t\t\twriter.setSelection( paragraph, 'in' );\n   *\t\t} );\n   *\n   * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,\n   * the new content will be inserted at the passed selection (instead of document selection):\n   *\n   *\t\teditor.model.change( writer => {\n   *\t\t\t// Create a selection in a paragraph that will be used as a place of insertion.\n   *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t\t// Insert the new text at the created selection.\n   *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n   *\n   *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n   *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n   *\t\t\twriter.setSelection( selection );\n   *\t\t} );\n   *\n   * @fires insertContent\n   * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n   * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n   * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n   * This param defines a position in relation to that item.\n   * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n   * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n   * at the insertion position.\n   */\n\n\n  insertContent(content, selectable, placeOrOffset) {\n    return insertContent(this, content, selectable, placeOrOffset);\n  }\n  /**\n   * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n   *\n   * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n   * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n   * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n   * then that behavior should be implemented in the view's listener. At the same time, the table feature\n   * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n   * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n   * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n   *\n   * @fires deleteContent\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * Selection of which the content should be deleted.\n   * @param {Object} [options]\n   * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n   *\n   * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n   *\n   * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n   * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n   *\n   * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n   * elements will not be merged.\n   *\n   * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n   * paragraph when the entire content was selected.\n   *\n   * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n   *\n   * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n   * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n   *\n   * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n   * to a place where text cannot be inserted.\n   *\n   * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n   *\n   * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n   * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n   *\n   * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n   *\n   * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n   *\n   * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.\n   * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to\n   * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.\n   */\n\n\n  deleteContent(selection, options) {\n    deleteContent(this, selection, options);\n  }\n  /**\n   * Modifies the selection. Currently, the supported modifications are:\n   *\n   * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n   * Possible values for `unit` are:\n   *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n   *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n   *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `qÌ‡Ì£` is a normal\n   *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n   *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n   *  why `'character'` value is most natural and common method of modifying selection.\n   *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n   *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n   *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n   *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n   *  For example `ð¨­Ž` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n   *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n   *  extension will include whole \"surrogate pair\".\n   *  * `'word'` - moves selection by a whole word.\n   *\n   * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n   *\n   * @fires modifySelection\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * The selection to modify.\n   * @param {Object} [options]\n   * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n   * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n   */\n\n\n  modifySelection(selection, options) {\n    modifySelection(this, selection, options);\n  }\n  /**\n   * Gets a clone of the selected content.\n   *\n   * For example, for the following selection:\n   *\n   * ```html\n   * <paragraph>x</paragraph>\n   * <blockQuote>\n   *\t<paragraph>y</paragraph>\n   *\t<heading1>fir[st</heading1>\n   * </blockQuote>\n   * <paragraph>se]cond</paragraph>\n   * <paragraph>z</paragraph>\n   * ```\n   *\n   * It will return a document fragment with such a content:\n   *\n   * ```html\n   * <blockQuote>\n   *\t<heading1>st</heading1>\n   * </blockQuote>\n   * <paragraph>se</paragraph>\n   * ```\n   *\n   * @fires getSelectedContent\n   * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n   * The selection of which content will be returned.\n   * @returns {module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  getSelectedContent(selection) {\n    return getSelectedContent(this, selection);\n  }\n  /**\n   * Checks whether the given {@link module:engine/model/range~Range range} or\n   * {@link module:engine/model/element~Element element} has any meaningful content.\n   *\n   * Meaningful content is:\n   *\n   * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n   * any non-whitespace characters),\n   * * or any {@link module:engine/model/schema~Schema#isContent content element},\n   * * or any {@link module:engine/model/markercollection~Marker marker} which\n   * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n   *\n   * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n   * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)\n   * is considered non-empty.\n   *\n   * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n   * @param {Object} [options]\n   * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n   * @param {Boolean} [options.ignoreMarkers] Whether markers should be ignored.\n   * @returns {Boolean}\n   */\n\n\n  hasContent(rangeOrElement) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const range = rangeOrElement instanceof ModelElement ? ModelRange._createIn(rangeOrElement) : rangeOrElement;\n\n    if (range.isCollapsed) {\n      return false;\n    }\n\n    const {\n      ignoreWhitespaces = false,\n      ignoreMarkers = false\n    } = options; // Check if there are any markers which affects data in this given range.\n\n    if (!ignoreMarkers) {\n      for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range)) {\n        if (intersectingMarker.affectsData) {\n          return true;\n        }\n      }\n    }\n\n    for (const item of range.getItems()) {\n      if (this.schema.isContent(item)) {\n        if (item.is('$textProxy')) {\n          if (!ignoreWhitespaces) {\n            return true;\n          } else if (item.data.search(/\\S/) !== -1) {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Creates a position from the given root and path in that root.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  createPositionFromPath(root, path, stickiness) {\n    return new ModelPosition(root, path, stickiness);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/model/position~Position position},\n   * * a parent element and offset in that element,\n   * * a parent element and `'end'` (the position will be set at the end of that element),\n   * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n   * (the position will be set before or after the given model item).\n   *\n   * This method is a shortcut to other factory methods such as:\n   *\n   * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n   * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  createPositionAt(itemOrPosition, offset) {\n    return ModelPosition._createAt(itemOrPosition, offset);\n  }\n  /**\n   * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  createPositionAfter(item) {\n    return ModelPosition._createAfter(item);\n  }\n  /**\n   * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n   *\n   * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  createPositionBefore(item) {\n    return ModelPosition._createBefore(item);\n  }\n  /**\n   * Creates a range spanning from the `start` position to the `end` position.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconst range = writer.createRange( start, end );\n   *\t\t} );\n   *\n   * @param {module:engine/model/position~Position} start Start position.\n   * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n   * to the `start` position.\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  createRange(start, end) {\n    return new ModelRange(start, end);\n  }\n  /**\n   * Creates a range inside the given element which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconst range = writer.createRangeIn( paragraph );\n   *\t\t} );\n   *\n   * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  createRangeIn(element) {\n    return ModelRange._createIn(element);\n  }\n  /**\n   * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n   *\n   * Note: This method is also available on `writer` instance as\n   * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\tconst range = writer.createRangeOn( paragraph );\n   *\t\t} );\n   *\n   * @param {module:engine/model/item~Item} item\n   * @returns {module:engine/model/range~Range}\n   */\n\n\n  createRangeOn(item) {\n    return ModelRange._createOn(item);\n  }\n  /**\n   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n   * or creates an empty selection if no arguments were passed.\n   *\n   * Note: This method is also available as\n   * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n   *\n   *\t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the given document selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst documentSelection = model.document.selection;\n   *\t\tconst selection = writer.createSelection( documentSelection );\n   *\n   *\t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates selection at the given offset in the given element.\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @returns {module:engine/model/selection~Selection}\n   */\n\n\n  createSelection(selectable, placeOrOffset, options) {\n    return new ModelSelection(selectable, placeOrOffset, options);\n  }\n  /**\n   * Creates a {@link module:engine/model/batch~Batch} instance.\n   *\n   * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n   *\n   * * {@link #change `change()`},\n   * * {@link #enqueueChange `enqueueChange()`}.\n   *\n   * @param {'transparent'|'default'} [type='default'] The type of the batch.\n   * @returns {module:engine/model/batch~Batch}\n   */\n\n\n  createBatch(type) {\n    return new Batch(type);\n  }\n  /**\n   * Creates an operation instance from a JSON object (parsed JSON string).\n   *\n   * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.\n   *\n   * @param {Object} json Deserialized JSON object.\n   * @returns {module:engine/model/operation/operation~Operation}\n   */\n\n\n  createOperationFromJSON(json) {\n    return OperationFactory.fromJSON(json, this.document);\n  }\n  /**\n   * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n   */\n\n\n  destroy() {\n    this.document.destroy();\n    this.stopListening();\n  }\n  /**\n   * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n   * which calls callbacks and returns array of values returned by these callbacks.\n   *\n   * @private\n   * @returns {Array.<*>} Array of values returned by callbacks.\n   */\n\n\n  _runPendingChanges() {\n    const ret = [];\n    this.fire('_beforeChanges');\n\n    while (this._pendingChanges.length) {\n      // Create a new writer using batch instance created for this chain of changes.\n      const currentBatch = this._pendingChanges[0].batch;\n      this._currentWriter = new Writer(this, currentBatch); // Execute changes callback and gather the returned value.\n\n      const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);\n\n      ret.push(callbackReturnValue);\n\n      this.document._handleChangeBlock(this._currentWriter);\n\n      this._pendingChanges.shift();\n\n      this._currentWriter = null;\n    }\n\n    this.fire('_afterChanges');\n    return ret;\n  }\n  /**\n   * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or\n   * {@link module:engine/model/model~Model#change} block.\n   *\n   * @protected\n   * @event _beforeChanges\n   */\n\n  /**\n   * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or\n   * {@link module:engine/model/model~Model#change} block.\n   *\n   * @protected\n   * @event _afterChanges\n   */\n\n  /**\n   * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n   * using {@link #applyOperation}.\n   *\n   * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n   * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n   * be used.\n   *\n   * A few callbacks are already added to this event by engine internal classes:\n   *\n   * * with `highest` priority operation is validated,\n   * * with `normal` priority operation is executed,\n   * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n   * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n   * update themselves.\n   *\n   * @event applyOperation\n   * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n   * {@link module:engine/model/operation/operation~Operation operation}.\n   */\n\n  /**\n   * Event fired when {@link #insertContent} method is called.\n   *\n   * The {@link #insertContent default action of that method} is implemented as a\n   * listener to this event so it can be fully customized by the features.\n   *\n   * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses\n   * `model.document.selection`.\n   *\n   * @event insertContent\n   * @param {Array} args The arguments passed to the original method.\n   */\n\n  /**\n   * Event fired when {@link #deleteContent} method is called.\n   *\n   * The {@link #deleteContent default action of that method} is implemented as a\n   * listener to this event so it can be fully customized by the features.\n   *\n   * @event deleteContent\n   * @param {Array} args The arguments passed to the original method.\n   */\n\n  /**\n   * Event fired when {@link #modifySelection} method is called.\n   *\n   * The {@link #modifySelection default action of that method} is implemented as a\n   * listener to this event so it can be fully customized by the features.\n   *\n   * @event modifySelection\n   * @param {Array} args The arguments passed to the original method.\n   */\n\n  /**\n   * Event fired when {@link #getSelectedContent} method is called.\n   *\n   * The {@link #getSelectedContent default action of that method} is implemented as a\n   * listener to this event so it can be fully customized by the features.\n   *\n   * @event getSelectedContent\n   * @param {Array} args The arguments passed to the original method.\n   */\n\n\n}\nmix(Model, ObservableMixin);","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js"],"names":["Batch","Writer","Schema","Document","MarkerCollection","ObservableMixin","mix","ModelElement","ModelRange","ModelPosition","ModelSelection","OperationFactory","insertContent","deleteContent","modifySelection","getSelectedContent","injectSelectionPostFixer","autoParagraphEmptyRoots","CKEditorError","Model","constructor","markers","document","schema","_pendingChanges","_currentWriter","forEach","methodName","decorate","on","evt","args","operation","_validate","priority","register","isLimit","allowIn","isBlock","isInline","isContent","allowContentOf","allowChildren","addChildCheck","context","childDefinition","name","registerPostFixer","change","callback","length","push","batch","_runPendingChanges","err","rethrowUnexpectedError","enqueueChange","batchOrType","applyOperation","_execute","content","selectable","placeOrOffset","selection","options","hasContent","rangeOrElement","range","_createIn","isCollapsed","ignoreWhitespaces","ignoreMarkers","intersectingMarker","getMarkersIntersectingRange","affectsData","item","getItems","is","data","search","createPositionFromPath","root","path","stickiness","createPositionAt","itemOrPosition","offset","_createAt","createPositionAfter","_createAfter","createPositionBefore","_createBefore","createRange","start","end","createRangeIn","element","createRangeOn","_createOn","createSelection","createBatch","type","createOperationFromJSON","json","fromJSON","destroy","stopListening","ret","fire","currentBatch","callbackReturnValue","_handleChangeBlock","shift"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,eAAP,MAA4B,+CAA5B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,YAAP,MAAyB,WAAzB;AACA,OAAOC,UAAP,MAAuB,SAAvB;AACA,OAAOC,aAAP,MAA0B,YAA1B;AACA,OAAOC,cAAP,MAA2B,aAA3B;AACA,OAAOC,gBAAP,MAA6B,8BAA7B;AAEA,OAAOC,aAAP,MAA0B,uBAA1B;AACA,OAAOC,aAAP,MAA0B,uBAA1B;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AACA,OAAOC,kBAAP,MAA+B,4BAA/B;AACA,SAASC,wBAAT,QAAyC,8BAAzC;AACA,SAASC,uBAAT,QAAwC,0BAAxC;AACA,OAAOC,aAAP,MAA0B,6CAA1B,C,CAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,KAAN,CAAY;AAC1BC,EAAAA,WAAW,GAAG;AACb;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,OAAL,GAAe,IAAIjB,gBAAJ,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKkB,QAAL,GAAgB,IAAInB,QAAJ,CAAc,IAAd,CAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKoB,MAAL,GAAc,IAAIrB,MAAJ,EAAd;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKsB,eAAL,GAAuB,EAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,cAAL,GAAsB,IAAtB;AAEA,KAAE,eAAF,EAAmB,eAAnB,EAAoC,iBAApC,EAAuD,oBAAvD,EAA6E,gBAA7E,EACEC,OADF,CACWC,UAAU,IAAI,KAAKC,QAAL,CAAeD,UAAf,CADzB,EA1Ca,CA6Cb;AACA;;AACA,SAAKE,EAAL,CAAS,gBAAT,EAA2B,CAAEC,GAAF,EAAOC,IAAP,KAAiB;AAC3C,YAAMC,SAAS,GAAGD,IAAI,CAAE,CAAF,CAAtB;;AAEAC,MAAAA,SAAS,CAACC,SAAV;AACA,KAJD,EAIG;AAAEC,MAAAA,QAAQ,EAAE;AAAZ,KAJH,EA/Ca,CAqDb;;AACA,SAAKX,MAAL,CAAYY,QAAZ,CAAsB,OAAtB,EAA+B;AAC9BC,MAAAA,OAAO,EAAE;AADqB,KAA/B;AAIA,SAAKb,MAAL,CAAYY,QAAZ,CAAsB,QAAtB,EAAgC;AAC/BE,MAAAA,OAAO,EAAE,OADsB;AAE/BC,MAAAA,OAAO,EAAE;AAFsB,KAAhC;AAKA,SAAKf,MAAL,CAAYY,QAAZ,CAAsB,OAAtB,EAA+B;AAC9BE,MAAAA,OAAO,EAAE,QADqB;AAE9BE,MAAAA,QAAQ,EAAE,IAFoB;AAG9BC,MAAAA,SAAS,EAAE;AAHmB,KAA/B;AAMA,SAAKjB,MAAL,CAAYY,QAAZ,CAAsB,kBAAtB,EAA0C;AACzCM,MAAAA,cAAc,EAAE,OADyB;AAEzCC,MAAAA,aAAa,EAAE,OAF0B;AAGzCN,MAAAA,OAAO,EAAE;AAHgC,KAA1C;AAMA,SAAKb,MAAL,CAAYY,QAAZ,CAAsB,mBAAtB,EAA2C;AAC1CM,MAAAA,cAAc,EAAE,OAD0B;AAE1CC,MAAAA,aAAa,EAAE,OAF2B;AAG1CN,MAAAA,OAAO,EAAE;AAHiC,KAA3C,EA3Ea,CAiFb;AACA;AACA;AACA;;AACA,SAAKb,MAAL,CAAYY,QAAZ,CAAsB,SAAtB;AACA,SAAKZ,MAAL,CAAYoB,aAAZ,CAA2B,CAAEC,OAAF,EAAWC,eAAX,KAAgC;AAC1D,UAAKA,eAAe,CAACC,IAAhB,KAAyB,SAA9B,EAA0C;AACzC,eAAO,IAAP;AACA;AACD,KAJD;AAMA9B,IAAAA,wBAAwB,CAAE,IAAF,CAAxB,CA5Fa,CA8Fb;;AACA,SAAKM,QAAL,CAAcyB,iBAAd,CAAiC9B,uBAAjC,EA/Fa,CAiGb;AACA;AACA;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC+B,EAAAA,MAAM,CAAEC,QAAF,EAAa;AAClB,QAAI;AACH,UAAK,KAAKzB,eAAL,CAAqB0B,MAArB,KAAgC,CAArC,EAAyC;AACxC;AACA,aAAK1B,eAAL,CAAqB2B,IAArB,CAA2B;AAAEC,UAAAA,KAAK,EAAE,IAAIpD,KAAJ,EAAT;AAAsBiD,UAAAA;AAAtB,SAA3B;;AAEA,eAAO,KAAKI,kBAAL,GAA2B,CAA3B,CAAP;AACA,OALD,MAKO;AACN;AACA,eAAOJ,QAAQ,CAAE,KAAKxB,cAAP,CAAf;AACA;AACD,KAVD,CAUE,OAAQ6B,GAAR,EAAc;AACf;;AACA;AACApC,MAAAA,aAAa,CAACqC,sBAAd,CAAsCD,GAAtC,EAA2C,IAA3C;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,aAAa,CAAEC,WAAF,EAAeR,QAAf,EAA0B;AACtC,QAAI;AACH,UAAK,OAAOQ,WAAP,KAAuB,QAA5B,EAAuC;AACtCA,QAAAA,WAAW,GAAG,IAAIzD,KAAJ,CAAWyD,WAAX,CAAd;AACA,OAFD,MAEO,IAAK,OAAOA,WAAP,IAAsB,UAA3B,EAAwC;AAC9CR,QAAAA,QAAQ,GAAGQ,WAAX;AACAA,QAAAA,WAAW,GAAG,IAAIzD,KAAJ,EAAd;AACA;;AAED,WAAKwB,eAAL,CAAqB2B,IAArB,CAA2B;AAAEC,QAAAA,KAAK,EAAEK,WAAT;AAAsBR,QAAAA;AAAtB,OAA3B;;AAEA,UAAK,KAAKzB,eAAL,CAAqB0B,MAArB,IAA+B,CAApC,EAAwC;AACvC,aAAKG,kBAAL;AACA;AACD,KAbD,CAaE,OAAQC,GAAR,EAAc;AACf;;AACA;AACApC,MAAAA,aAAa,CAACqC,sBAAd,CAAsCD,GAAtC,EAA2C,IAA3C;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCI,EAAAA,cAAc,CAAE1B,SAAF,EAAc;AAC3B;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEAA,IAAAA,SAAS,CAAC2B,QAAV;AACA,GAjPyB,CAmP1B;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC/C,EAAAA,aAAa,CAAEgD,OAAF,EAAWC,UAAX,EAAuBC,aAAvB,EAAuC;AACnD,WAAOlD,aAAa,CAAE,IAAF,EAAQgD,OAAR,EAAiBC,UAAjB,EAA6BC,aAA7B,CAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCjD,EAAAA,aAAa,CAAEkD,SAAF,EAAaC,OAAb,EAAuB;AACnCnD,IAAAA,aAAa,CAAE,IAAF,EAAQkD,SAAR,EAAmBC,OAAnB,CAAb;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACClD,EAAAA,eAAe,CAAEiD,SAAF,EAAaC,OAAb,EAAuB;AACrClD,IAAAA,eAAe,CAAE,IAAF,EAAQiD,SAAR,EAAmBC,OAAnB,CAAf;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCjD,EAAAA,kBAAkB,CAAEgD,SAAF,EAAc;AAC/B,WAAOhD,kBAAkB,CAAE,IAAF,EAAQgD,SAAR,CAAzB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,UAAU,CAAEC,cAAF,EAAiC;AAAA,QAAfF,OAAe,uEAAL,EAAK;AAC1C,UAAMG,KAAK,GAAGD,cAAc,YAAY3D,YAA1B,GAAyCC,UAAU,CAAC4D,SAAX,CAAsBF,cAAtB,CAAzC,GAAkFA,cAAhG;;AAEA,QAAKC,KAAK,CAACE,WAAX,EAAyB;AACxB,aAAO,KAAP;AACA;;AAED,UAAM;AAAEC,MAAAA,iBAAiB,GAAG,KAAtB;AAA6BC,MAAAA,aAAa,GAAG;AAA7C,QAAuDP,OAA7D,CAP0C,CAS1C;;AACA,QAAK,CAACO,aAAN,EAAsB;AACrB,WAAM,MAAMC,kBAAZ,IAAkC,KAAKnD,OAAL,CAAaoD,2BAAb,CAA0CN,KAA1C,CAAlC,EAAsF;AACrF,YAAKK,kBAAkB,CAACE,WAAxB,EAAsC;AACrC,iBAAO,IAAP;AACA;AACD;AACD;;AAED,SAAM,MAAMC,IAAZ,IAAoBR,KAAK,CAACS,QAAN,EAApB,EAAuC;AACtC,UAAK,KAAKrD,MAAL,CAAYiB,SAAZ,CAAuBmC,IAAvB,CAAL,EAAqC;AACpC,YAAKA,IAAI,CAACE,EAAL,CAAS,YAAT,CAAL,EAA+B;AAC9B,cAAK,CAACP,iBAAN,EAA0B;AACzB,mBAAO,IAAP;AACA,WAFD,MAEO,IAAKK,IAAI,CAACG,IAAL,CAAUC,MAAV,CAAkB,IAAlB,MAA6B,CAAC,CAAnC,EAAuC;AAC7C,mBAAO,IAAP;AACA;AACD,SAND,MAMO;AACN,iBAAO,IAAP;AACA;AACD;AACD;;AAED,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,sBAAsB,CAAEC,IAAF,EAAQC,IAAR,EAAcC,UAAd,EAA2B;AAChD,WAAO,IAAI1E,aAAJ,CAAmBwE,IAAnB,EAAyBC,IAAzB,EAA+BC,UAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,gBAAgB,CAAEC,cAAF,EAAkBC,MAAlB,EAA2B;AAC1C,WAAO7E,aAAa,CAAC8E,SAAd,CAAyBF,cAAzB,EAAyCC,MAAzC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCE,EAAAA,mBAAmB,CAAEb,IAAF,EAAS;AAC3B,WAAOlE,aAAa,CAACgF,YAAd,CAA4Bd,IAA5B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCe,EAAAA,oBAAoB,CAAEf,IAAF,EAAS;AAC5B,WAAOlE,aAAa,CAACkF,aAAd,CAA6BhB,IAA7B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCiB,EAAAA,WAAW,CAAEC,KAAF,EAASC,GAAT,EAAe;AACzB,WAAO,IAAItF,UAAJ,CAAgBqF,KAAhB,EAAuBC,GAAvB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,aAAa,CAAEC,OAAF,EAAY;AACxB,WAAOxF,UAAU,CAAC4D,SAAX,CAAsB4B,OAAtB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,aAAa,CAAEtB,IAAF,EAAS;AACrB,WAAOnE,UAAU,CAAC0F,SAAX,CAAsBvB,IAAtB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCwB,EAAAA,eAAe,CAAEtC,UAAF,EAAcC,aAAd,EAA6BE,OAA7B,EAAuC;AACrD,WAAO,IAAItD,cAAJ,CAAoBmD,UAApB,EAAgCC,aAAhC,EAA+CE,OAA/C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCoC,EAAAA,WAAW,CAAEC,IAAF,EAAS;AACnB,WAAO,IAAIrG,KAAJ,CAAWqG,IAAX,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,uBAAuB,CAAEC,IAAF,EAAS;AAC/B,WAAO5F,gBAAgB,CAAC6F,QAAjB,CAA2BD,IAA3B,EAAiC,KAAKjF,QAAtC,CAAP;AACA;AAED;AACD;AACA;;;AACCmF,EAAAA,OAAO,GAAG;AACT,SAAKnF,QAAL,CAAcmF,OAAd;AACA,SAAKC,aAAL;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCrD,EAAAA,kBAAkB,GAAG;AACpB,UAAMsD,GAAG,GAAG,EAAZ;AAEA,SAAKC,IAAL,CAAW,gBAAX;;AAEA,WAAQ,KAAKpF,eAAL,CAAqB0B,MAA7B,EAAsC;AACrC;AACA,YAAM2D,YAAY,GAAG,KAAKrF,eAAL,CAAsB,CAAtB,EAA0B4B,KAA/C;AACA,WAAK3B,cAAL,GAAsB,IAAIxB,MAAJ,CAAY,IAAZ,EAAkB4G,YAAlB,CAAtB,CAHqC,CAKrC;;AACA,YAAMC,mBAAmB,GAAG,KAAKtF,eAAL,CAAsB,CAAtB,EAA0ByB,QAA1B,CAAoC,KAAKxB,cAAzC,CAA5B;;AACAkF,MAAAA,GAAG,CAACxD,IAAJ,CAAU2D,mBAAV;;AAEA,WAAKxF,QAAL,CAAcyF,kBAAd,CAAkC,KAAKtF,cAAvC;;AAEA,WAAKD,eAAL,CAAqBwF,KAArB;;AACA,WAAKvF,cAAL,GAAsB,IAAtB;AACA;;AAED,SAAKmF,IAAL,CAAW,eAAX;AAEA,WAAOD,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA33B2B;AA83B3BrG,GAAG,CAAEa,KAAF,EAASd,eAAT,CAAH","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/model\n */\n\nimport Batch from './batch';\nimport Writer from './writer';\nimport Schema from './schema';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ModelElement from './element';\nimport ModelRange from './range';\nimport ModelPosition from './position';\nimport ModelSelection from './selection';\nimport OperationFactory from './operation/operationfactory';\n\nimport insertContent from './utils/insertcontent';\nimport deleteContent from './utils/deletecontent';\nimport modifySelection from './utils/modifyselection';\nimport getSelectedContent from './utils/getselectedcontent';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport { autoParagraphEmptyRoots } from './utils/autoparagraphing';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Model {\n\tconstructor() {\n\t\t/**\n\t\t * Model's marker collection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis.markers = new MarkerCollection();\n\n\t\t/**\n\t\t * Model's document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/document~Document}\n\t\t */\n\t\tthis.document = new Document( this );\n\n\t\t/**\n\t\t * Model's schema.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/schema~Schema}\n\t\t */\n\t\tthis.schema = new Schema();\n\n\t\t/**\n\t\t * All callbacks added by {@link module:engine/model/model~Model#change} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Function>}\n\t\t */\n\t\tthis._pendingChanges = [];\n\n\t\t/**\n\t\t * The last created and currently used writer instance.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/writer~Writer}\n\t\t */\n\t\tthis._currentWriter = null;\n\n\t\t[ 'insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation' ]\n\t\t\t.forEach( methodName => this.decorate( methodName ) );\n\n\t\t// Adding operation validation with `highest` priority, so it is called before any other feature would like\n\t\t// to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\t\tthis.on( 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\toperation._validate();\n\t\t}, { priority: 'highest' } );\n\n\t\t// Register some default abstract entities.\n\t\tthis.schema.register( '$root', {\n\t\t\tisLimit: true\n\t\t} );\n\n\t\tthis.schema.register( '$block', {\n\t\t\tallowIn: '$root',\n\t\t\tisBlock: true\n\t\t} );\n\n\t\tthis.schema.register( '$text', {\n\t\t\tallowIn: '$block',\n\t\t\tisInline: true,\n\t\t\tisContent: true\n\t\t} );\n\n\t\tthis.schema.register( '$clipboardHolder', {\n\t\t\tallowContentOf: '$root',\n\t\t\tallowChildren: '$text',\n\t\t\tisLimit: true\n\t\t} );\n\n\t\tthis.schema.register( '$documentFragment', {\n\t\t\tallowContentOf: '$root',\n\t\t\tallowChildren: '$text',\n\t\t\tisLimit: true\n\t\t} );\n\n\t\t// An element needed by the `upcastElementToMarker` converter.\n\t\t// This element temporarily represents a marker boundary during the conversion process and is removed\n\t\t// at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n\t\t// better place for this registration but both know nothing about `Schema`.\n\t\tthis.schema.register( '$marker' );\n\t\tthis.schema.addChildCheck( ( context, childDefinition ) => {\n\t\t\tif ( childDefinition.name === '$marker' ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\tinjectSelectionPostFixer( this );\n\n\t\t// Post-fixer which takes care of adding empty paragraph elements to the empty roots.\n\t\tthis.document.registerPostFixer( autoParagraphEmptyRoots );\n\n\t\t// @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n\t\t// @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n\t\t// @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n\t * (including detached nodes â€“ i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n\t * the {@link module:engine/model/document~Document#selection document's selection}, and\n\t * {@link module:engine/model/model~Model#markers model markers}.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n\t * into a single undo step.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n\t *\n\t *\t\t\tmodel.change( writer => {\n\t *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n\t *\t\t\t} );\n\t *\n\t * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n\t *\t\t} );\n\t *\n\t * The callback of the `change()` block is executed synchronously.\n\t *\n\t * You can also return a value from the change block.\n\t *\n\t *\t\tconst img = model.change( writer => {\n\t *\t\t\treturn writer.createElement( 'img' );\n\t *\t\t} );\n\t *\n\t * @see #enqueueChange\n\t * @param {Function} callback Callback function which may modify the model.\n\t * @returns {*} Value returned by the callback.\n\t */\n\tchange( callback ) {\n\t\ttry {\n\t\t\tif ( this._pendingChanges.length === 0 ) {\n\t\t\t\t// If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n\t\t\t\tthis._pendingChanges.push( { batch: new Batch(), callback } );\n\n\t\t\t\treturn this._runPendingChanges()[ 0 ];\n\t\t\t} else {\n\t\t\t\t// If this is not the outermost block, just execute the callback.\n\t\t\t\treturn callback( this._currentWriter );\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n\t *\n\t * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n\t * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n\t * it will be delayed and executed after the outermost block.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconsole.log( 1 );\n\t *\n\t *\t\t\tmodel.enqueueChange( writer => {\n\t *\t\t\t\tconsole.log( 2 );\n\t *\t\t\t} );\n\t *\n\t * \t\t\tconsole.log( 3 );\n\t *\t\t} ); // Will log: 1, 3, 2.\n\t *\n\t * In addition to that, the changes enqueued with `enqueueChange()` will be converted separately from the changes\n\t * done in the outer `change()` block.\n\t *\n\t * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n\t * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different\n\t * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).\n\t *\n\t * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n\t *\n\t *\t\tmodel.enqueueChange( batch, writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * In order to make a nested `enqueueChange()` create a single undo step together with the changes done in the outer `change()`\n\t * block, you can obtain the batch instance from the  {@link module:engine/model/writer~Writer#batch writer} of the outer block.\n\t *\n\t * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.\n\t * If not defined, a new batch will be created.\n\t * @param {Function} callback Callback function which may modify the model.\n\t */\n\tenqueueChange( batchOrType, callback ) {\n\t\ttry {\n\t\t\tif ( typeof batchOrType === 'string' ) {\n\t\t\t\tbatchOrType = new Batch( batchOrType );\n\t\t\t} else if ( typeof batchOrType == 'function' ) {\n\t\t\t\tcallback = batchOrType;\n\t\t\t\tbatchOrType = new Batch();\n\t\t\t}\n\n\t\t\tthis._pendingChanges.push( { batch: batchOrType, callback } );\n\n\t\t\tif ( this._pendingChanges.length == 1 ) {\n\t\t\t\tthis._runPendingChanges();\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n\t * {@link module:engine/model/operation/operation~Operation operations} to the model.\n\t *\n\t * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n\t * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n\t * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n\t * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n\t */\n\tapplyOperation( operation ) {\n\t\t// @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n\n\t\t// @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n\t\t// @if CK_DEBUG_ENGINE // }\n\n\t\t// @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n\n\t\t// @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n\t\t// @if CK_DEBUG_ENGINE //}\n\n\t\t// @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n\n\t\toperation._execute();\n\t}\n\n\t// @if CK_DEBUG_ENGINE // getAppliedOperation() {\n\t// @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\t\treturn '';\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t/**\n\t * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n\t * functionality to work.\n\t *\n\t * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n\t * the content, clears the given selection's content before inserting nodes and moves the selection\n\t * to its target position at the end of the process.\n\t * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n\t * pasting feature should do.\n\t *\n\t * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n\t *\n\t * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n\t * inside a {@link #change `change()` block}.\n\t *\n\t * # Conversion and schema\n\t *\n\t * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n\t * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n\t * is only adding nodes to the model. Additionally, you need to define\n\t * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n\t * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n\t *\n\t * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n\t * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n\t * unless converters are defined for all elements and attributes in that HTML.\n\t *\n\t * # Examples\n\t *\n\t * Using `insertContent()` with a manually created model structure:\n\t *\n\t *\t\t// Let's create a document fragment containing such content as:\n\t *\t\t//\n\t *\t\t// <paragraph>foo</paragraph>\n\t *\t\t// <blockQuote>\n\t *\t\t//    <paragraph>bar</paragraph>\n\t *\t\t// </blockQuote>\n\t *\t\tconst docFrag = editor.model.change( writer => {\n\t *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n\t *\t\t\tconst docFrag = writer.createDocumentFragment();\n\t *\n\t *\t\t\twriter.append( p1, docFrag );\n\t *\t\t\twriter.append( blockQuote, docFrag );\n\t *\t\t\twriter.append( p2, blockQuote );\n\t *\t\t\twriter.insertText( 'foo', p1 );\n\t *\t\t\twriter.insertText( 'bar', p2 );\n\t *\n\t *\t\t\treturn docFrag;\n\t *\t\t} );\n\t *\n\t *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n\t *\t\t// so this code could be moved to the callback defined above.\n\t *\t\teditor.model.insertContent( docFrag );\n\t *\n\t * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n\t *\n\t *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n\t *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n\t *\t\tconst htmlDP = new HtmlDataProcessor( viewDocument );\n\t *\n\t *\t\t// Convert an HTML string to a view document fragment:\n\t *\t\tconst viewFragment = htmlDP.toView( htmlString );\n\t *\n\t *\t\t// Convert the view document fragment to a model document fragment\n\t *\t\t// in the context of $root. This conversion takes the schema into\n\t *\t\t// account so if, for example, the view document fragment contained a bare text node,\n\t *\t\t// this text node cannot be a child of $root, so it will be automatically\n\t *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n\t *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n\t *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n\t *\t\t// which has a loosened schema.\n\t *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n\t *\n\t *\t\teditor.model.insertContent( modelFragment );\n\t *\n\t * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n\t *\n\t *\t\t// Insert text at the current document selection position.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n\t *\t\t} );\n\t *\n\t *\t\t// Insert text at a given position - the document selection will not be modified.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n\t *\n\t *\t\t\t// Which is a shorthand for:\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n\t *\t\t} );\n\t *\n\t * If you want the document selection to be moved to the inserted content, use the\n\t * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting\n\t * the content:\n\t *\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\n\t *\t\t\t// Insert an empty paragraph at the beginning of the root.\n\t *\t\t\teditor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );\n\t *\n\t *\t\t\t// Move the document selection to the inserted paragraph.\n\t *\t\t\twriter.setSelection( paragraph, 'in' );\n\t *\t\t} );\n\t *\n\t * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,\n\t * the new content will be inserted at the passed selection (instead of document selection):\n\t *\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\t// Create a selection in a paragraph that will be used as a place of insertion.\n\t *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t\t// Insert the new text at the created selection.\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n\t *\n\t *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n\t *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n\t *\t\t\twriter.setSelection( selection );\n\t *\t\t} );\n\t *\n\t * @fires insertContent\n\t * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n\t * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n\t * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n\t * This param defines a position in relation to that item.\n\t * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n\t * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n\t * at the insertion position.\n\t */\n\tinsertContent( content, selectable, placeOrOffset ) {\n\t\treturn insertContent( this, content, selectable, placeOrOffset );\n\t}\n\n\t/**\n\t * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n\t *\n\t * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n\t * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n\t * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n\t * then that behavior should be implemented in the view's listener. At the same time, the table feature\n\t * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n\t * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n\t * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n\t *\n\t * @fires deleteContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection of which the content should be deleted.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n\t *\n\t * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n\t *\n\t * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n\t * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n\t *\n\t * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n\t * elements will not be merged.\n\t *\n\t * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n\t * paragraph when the entire content was selected.\n\t *\n\t * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n\t *\n\t * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n\t * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n\t *\n\t * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n\t * to a place where text cannot be inserted.\n\t *\n\t * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n\t *\n\t * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n\t * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n\t *\n\t * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n\t *\n\t * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n\t *\n\t * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.\n\t * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to\n\t * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.\n\t */\n\tdeleteContent( selection, options ) {\n\t\tdeleteContent( this, selection, options );\n\t}\n\n\t/**\n\t * Modifies the selection. Currently, the supported modifications are:\n\t *\n\t * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n\t * Possible values for `unit` are:\n\t *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n\t *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n\t *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `qÌ‡Ì£` is a normal\n\t *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n\t *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n\t *  why `'character'` value is most natural and common method of modifying selection.\n\t *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n\t *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n\t *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n\t *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n\t *  For example `ð¨­Ž` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n\t *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n\t *  extension will include whole \"surrogate pair\".\n\t *  * `'word'` - moves selection by a whole word.\n\t *\n\t * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n\t *\n\t * @fires modifySelection\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection to modify.\n\t * @param {Object} [options]\n\t * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n\t * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n\t */\n\tmodifySelection( selection, options ) {\n\t\tmodifySelection( this, selection, options );\n\t}\n\n\t/**\n\t * Gets a clone of the selected content.\n\t *\n\t * For example, for the following selection:\n\t *\n\t * ```html\n\t * <paragraph>x</paragraph>\n\t * <blockQuote>\n\t *\t<paragraph>y</paragraph>\n\t *\t<heading1>fir[st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se]cond</paragraph>\n\t * <paragraph>z</paragraph>\n\t * ```\n\t *\n\t * It will return a document fragment with such a content:\n\t *\n\t * ```html\n\t * <blockQuote>\n\t *\t<heading1>st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se</paragraph>\n\t * ```\n\t *\n\t * @fires getSelectedContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection of which content will be returned.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetSelectedContent( selection ) {\n\t\treturn getSelectedContent( this, selection );\n\t}\n\n\t/**\n\t * Checks whether the given {@link module:engine/model/range~Range range} or\n\t * {@link module:engine/model/element~Element element} has any meaningful content.\n\t *\n\t * Meaningful content is:\n\t *\n\t * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n\t * any non-whitespace characters),\n\t * * or any {@link module:engine/model/schema~Schema#isContent content element},\n\t * * or any {@link module:engine/model/markercollection~Marker marker} which\n\t * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n\t *\n\t * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n\t * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)\n\t * is considered non-empty.\n\t *\n\t * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n\t * @param {Boolean} [options.ignoreMarkers] Whether markers should be ignored.\n\t * @returns {Boolean}\n\t */\n\thasContent( rangeOrElement, options = {} ) {\n\t\tconst range = rangeOrElement instanceof ModelElement ? ModelRange._createIn( rangeOrElement ) : rangeOrElement;\n\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { ignoreWhitespaces = false, ignoreMarkers = false } = options;\n\n\t\t// Check if there are any markers which affects data in this given range.\n\t\tif ( !ignoreMarkers ) {\n\t\t\tfor ( const intersectingMarker of this.markers.getMarkersIntersectingRange( range ) ) {\n\t\t\t\tif ( intersectingMarker.affectsData ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tif ( this.schema.isContent( item ) ) {\n\t\t\t\tif ( item.is( '$textProxy' ) ) {\n\t\t\t\t\tif ( !ignoreWhitespaces ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if ( item.data.search( /\\S/ ) !== -1 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates a position from the given root and path in that root.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionFromPath( root, path, stickiness ) {\n\t\treturn new ModelPosition( root, path, stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * a parent element and offset in that element,\n\t * * a parent element and `'end'` (the position will be set at the end of that element),\n\t * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n\t * (the position will be set before or after the given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n\t * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn ModelPosition._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn ModelPosition._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn ModelPosition._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from the `start` position to the `end` position.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRange( start, end );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n\t * to the `start` position.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new ModelRange( start, end );\n\t}\n\n\t/**\n\t * Creates a range inside the given element which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeIn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn ModelRange._createIn( element );\n\t}\n\n\t/**\n\t * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * Note: This method is also available on `writer` instance as\n\t * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeOn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn ModelRange._createOn( item );\n\t}\n\n\t/**\n\t * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n\t * or creates an empty selection if no arguments were passed.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n\t *\n\t *\t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\tconst selection = writer.createSelection( documentSelection );\n\t *\n\t *\t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates selection at the given offset in the given element.\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @returns {module:engine/model/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new ModelSelection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/batch~Batch} instance.\n\t *\n\t * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n\t *\n\t * * {@link #change `change()`},\n\t * * {@link #enqueueChange `enqueueChange()`}.\n\t *\n\t * @param {'transparent'|'default'} [type='default'] The type of the batch.\n\t * @returns {module:engine/model/batch~Batch}\n\t */\n\tcreateBatch( type ) {\n\t\treturn new Batch( type );\n\t}\n\n\t/**\n\t * Creates an operation instance from a JSON object (parsed JSON string).\n\t *\n\t * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @returns {module:engine/model/operation/operation~Operation}\n\t */\n\tcreateOperationFromJSON( json ) {\n\t\treturn OperationFactory.fromJSON( json, this.document );\n\t}\n\n\t/**\n\t * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n\t */\n\tdestroy() {\n\t\tthis.document.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n\t * which calls callbacks and returns array of values returned by these callbacks.\n\t *\n\t * @private\n\t * @returns {Array.<*>} Array of values returned by callbacks.\n\t */\n\t_runPendingChanges() {\n\t\tconst ret = [];\n\n\t\tthis.fire( '_beforeChanges' );\n\n\t\twhile ( this._pendingChanges.length ) {\n\t\t\t// Create a new writer using batch instance created for this chain of changes.\n\t\t\tconst currentBatch = this._pendingChanges[ 0 ].batch;\n\t\t\tthis._currentWriter = new Writer( this, currentBatch );\n\n\t\t\t// Execute changes callback and gather the returned value.\n\t\t\tconst callbackReturnValue = this._pendingChanges[ 0 ].callback( this._currentWriter );\n\t\t\tret.push( callbackReturnValue );\n\n\t\t\tthis.document._handleChangeBlock( this._currentWriter );\n\n\t\t\tthis._pendingChanges.shift();\n\t\t\tthis._currentWriter = null;\n\t\t}\n\n\t\tthis.fire( '_afterChanges' );\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _beforeChanges\n\t */\n\n\t/**\n\t * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _afterChanges\n\t */\n\n\t/**\n\t * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n\t * using {@link #applyOperation}.\n\t *\n\t * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n\t * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n\t * be used.\n\t *\n\t * A few callbacks are already added to this event by engine internal classes:\n\t *\n\t * * with `highest` priority operation is validated,\n\t * * with `normal` priority operation is executed,\n\t * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n\t * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n\t * update themselves.\n\t *\n\t * @event applyOperation\n\t * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t */\n\n\t/**\n\t * Event fired when {@link #insertContent} method is called.\n\t *\n\t * The {@link #insertContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses\n\t * `model.document.selection`.\n\t *\n\t * @event insertContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #deleteContent} method is called.\n\t *\n\t * The {@link #deleteContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event deleteContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #modifySelection} method is called.\n\t *\n\t * The {@link #modifySelection default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event modifySelection\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #getSelectedContent} method is called.\n\t *\n\t * The {@link #getSelectedContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event getSelectedContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n}\n\nmix( Model, ObservableMixin );\n"]},"metadata":{},"sourceType":"module"}