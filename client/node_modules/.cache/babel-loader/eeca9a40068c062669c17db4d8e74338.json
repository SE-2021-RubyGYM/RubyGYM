{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/bubblingemittermixin\n */\nimport EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport BubblingEventInfo from './bubblingeventinfo';\nconst contextsSymbol = Symbol('bubbling contexts');\n/**\n * Bubbling emitter mixin for the view document as described in the\n * {@link ~BubblingEmitter} interface.\n *\n * @mixin BubblingEmitterMixin\n * @implements module:engine/view/observer/bubblingemittermixin~BubblingEmitter\n */\n\nconst BubblingEmitterMixin = {\n  /**\n   * @inheritDoc\n   */\n  fire(eventOrInfo) {\n    try {\n      const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);\n      const eventContexts = getBubblingContexts(this);\n\n      if (!eventContexts.size) {\n        return;\n      }\n\n      updateEventInfo(eventInfo, 'capturing', this); // The capture phase of the event.\n\n      for (var _len = arguments.length, eventArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        eventArgs[_key - 1] = arguments[_key];\n      }\n\n      if (fireListenerFor(eventContexts, '$capture', eventInfo, ...eventArgs)) {\n        return eventInfo.return;\n      }\n\n      const startRange = eventInfo.startRange || this.selection.getFirstRange();\n      const selectedElement = startRange ? startRange.getContainedElement() : null;\n      const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;\n      let node = selectedElement || getDeeperRangeParent(startRange);\n      updateEventInfo(eventInfo, 'atTarget', node); // For the not yet bubbling event trigger for $text node if selection can be there and it's not a custom context selected.\n\n      if (!isCustomContext) {\n        if (fireListenerFor(eventContexts, '$text', eventInfo, ...eventArgs)) {\n          return eventInfo.return;\n        }\n\n        updateEventInfo(eventInfo, 'bubbling', node);\n      }\n\n      while (node) {\n        // Root node handling.\n        if (node.is('rootElement')) {\n          if (fireListenerFor(eventContexts, '$root', eventInfo, ...eventArgs)) {\n            return eventInfo.return;\n          }\n        } // Element node handling.\n        else if (node.is('element')) {\n          if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {\n            return eventInfo.return;\n          }\n        } // Check custom contexts (i.e., a widget).\n\n\n        if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {\n          return eventInfo.return;\n        }\n\n        node = node.parent;\n        updateEventInfo(eventInfo, 'bubbling', node);\n      }\n\n      updateEventInfo(eventInfo, 'bubbling', this); // Document context.\n\n      fireListenerFor(eventContexts, '$document', eventInfo, ...eventArgs);\n      return eventInfo.return;\n    } catch (err) {\n      // @if CK_DEBUG // throw err;\n\n      /* istanbul ignore next */\n      CKEditorError.rethrowUnexpectedError(err, this);\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  _addEventListener(event, callback, options) {\n    const contexts = toArray(options.context || '$document');\n    const eventContexts = getBubblingContexts(this);\n\n    for (const context of contexts) {\n      let emitter = eventContexts.get(context);\n\n      if (!emitter) {\n        emitter = Object.create(EmitterMixin);\n        eventContexts.set(context, emitter);\n      }\n\n      this.listenTo(emitter, event, callback, options);\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  _removeEventListener(event, callback) {\n    const eventContexts = getBubblingContexts(this);\n\n    for (const emitter of eventContexts.values()) {\n      this.stopListening(emitter, event, callback);\n    }\n  }\n\n};\nexport default BubblingEmitterMixin; // Update the event info bubbling fields.\n//\n// @param {module:utils/eventinfo~EventInfo} eventInfo The event info object to update.\n// @param {'none'|'capturing'|'atTarget'|'bubbling'} eventPhase The current event phase.\n// @param {module:engine/view/document~Document|module:engine/view/node~Node} currentTarget The current bubbling target.\n\nfunction updateEventInfo(eventInfo, eventPhase, currentTarget) {\n  if (eventInfo instanceof BubblingEventInfo) {\n    eventInfo._eventPhase = eventPhase;\n    eventInfo._currentTarget = currentTarget;\n  }\n} // Fires the listener for the specified context. Returns `true` if event was stopped.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {String|module:engine/view/node~Node} context\n// @param {module:utils/eventinfo~EventInfo} eventInfo The `EventInfo` object.\n// @param {...*} [eventArgs] Additional arguments to be passed to the callbacks.\n// @returns {Boolean} True if event stop was called.\n\n\nfunction fireListenerFor(eventContexts, context, eventInfo) {\n  const emitter = typeof context == 'string' ? eventContexts.get(context) : getCustomContext(eventContexts, context);\n\n  if (!emitter) {\n    return false;\n  }\n\n  for (var _len2 = arguments.length, eventArgs = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    eventArgs[_key2 - 3] = arguments[_key2];\n  }\n\n  emitter.fire(eventInfo, ...eventArgs);\n  return eventInfo.stop.called;\n} // Returns an emitter for a specified view node.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {module:engine/view/node~Node} node\n// @returns {module:utils/emittermixin~Emitter|null}\n\n\nfunction getCustomContext(eventContexts, node) {\n  for (const [context, emitter] of eventContexts) {\n    if (typeof context == 'function' && context(node)) {\n      return emitter;\n    }\n  }\n\n  return null;\n} // Returns bubbling contexts map for the source (emitter).\n\n\nfunction getBubblingContexts(source) {\n  if (!source[contextsSymbol]) {\n    source[contextsSymbol] = new Map();\n  }\n\n  return source[contextsSymbol];\n} // Returns the deeper parent element for the range.\n\n\nfunction getDeeperRangeParent(range) {\n  if (!range) {\n    return null;\n  }\n\n  const startParent = range.start.parent;\n  const endParent = range.end.parent;\n  const startPath = startParent.getPath();\n  const endPath = endParent.getPath();\n  return startPath.length > endPath.length ? startParent : endParent;\n}\n/**\n * Bubbling emitter for the view document.\n *\n * Bubbling emitter is triggering events in the context of specified {@link module:engine/view/element~Element view element} name,\n * predefined `'$text'`, `'$root'`, `'$document'` and `'$capture'` contexts, and context matchers provided as a function.\n *\n * Before bubbling starts, listeners for `'$capture'` context are triggered. Then the bubbling starts from the deeper selection\n * position (by firing event on the `'$text'` context) and propagates the view document tree up to the `'$root'` and finally\n * the listeners at `'$document'` context are fired (this is the default context).\n *\n * Examples:\n *\n *\t\t// Listeners registered in the context of the view element names:\n *\t\tthis.listenTo( viewDocument, 'enter', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: 'blockquote' } );\n *\n *\t\tthis.listenTo( viewDocument, 'enter', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: 'li' } );\n *\n *\t\t// Listeners registered in the context of the '$text' and '$root' nodes.\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: '$text', priority: 'high' } );\n *\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: '$root' } );\n *\n *\t\t// Listeners registered in the context of custom callback function.\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: isWidget } );\n *\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: isWidget, priority: 'high' } );\n *\n * Example flow for selection in text:\n *\n *\t\t<blockquote><p>Foo[]bar</p></blockquote>\n *\n * Fired events on contexts:\n * 1. `'$capture'`\n * 2. `'$text'`\n * 3. `'p'`\n * 4. `'blockquote'`\n * 5. `'$root'`\n * 6. `'$document'`\n *\n * Example flow for selection on element (i.e., Widget):\n *\n *\t\t<blockquote><p>Foo[<widget/>]bar</p></blockquote>\n *\n * Fired events on contexts:\n * 1. `'$capture'`\n * 2. *widget* (custom matcher)\n * 3. `'p'`\n * 4. `'blockquote'`\n * 5. `'$root'`\n * 6. `'$document'`\n *\n * There could be multiple listeners registered for the same context and at different priority levels:\n *\n *\t\t<p>Foo[]bar</p>\n *\n * 1. `'$capture'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 2. `'$text'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 3. `'p'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 4. `'$root'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 5. `'$document'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n *\n * @interface BubblingEmitter\n * @extends module:utils/emittermixin~Emitter\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/bubblingemittermixin.js"],"names":["EventInfo","CKEditorError","EmitterMixin","toArray","BubblingEventInfo","contextsSymbol","Symbol","BubblingEmitterMixin","fire","eventOrInfo","eventInfo","eventContexts","getBubblingContexts","size","updateEventInfo","eventArgs","fireListenerFor","return","startRange","selection","getFirstRange","selectedElement","getContainedElement","isCustomContext","Boolean","getCustomContext","node","getDeeperRangeParent","is","name","parent","err","rethrowUnexpectedError","_addEventListener","event","callback","options","contexts","context","emitter","get","Object","create","set","listenTo","_removeEventListener","values","stopListening","eventPhase","currentTarget","_eventPhase","_currentTarget","stop","called","source","Map","range","startParent","start","endParent","end","startPath","getPath","endPath","length"],"mappings":"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,SAAY;AAAA;;AAO3EwB,EAAAA,OAAO,CAAC/B,IAAR,CAAcE,SAAd,EAAyB,GAAGK,SAA5B;AAEA,SAAOL,SAAS,CAAC0C,IAAV,CAAeC,MAAtB;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS5B,gBAAT,CAA2Bd,aAA3B,EAA0Ce,IAA1C,EAAiD;AAChD,OAAM,MAAM,CAAEY,OAAF,EAAWC,OAAX,CAAZ,IAAoC5B,aAApC,EAAoD;AACnD,QAAK,OAAO2B,OAAP,IAAkB,UAAlB,IAAgCA,OAAO,CAAEZ,IAAF,CAA5C,EAAuD;AACtD,aAAOa,OAAP;AACA;AACD;;AAED,SAAO,IAAP;AACA,C,CAED;;;AACA,SAAS3B,mBAAT,CAA8B0C,MAA9B,EAAuC;AACtC,MAAK,CAACA,MAAM,CAAEjD,cAAF,CAAZ,EAAiC;AAChCiD,IAAAA,MAAM,CAAEjD,cAAF,CAAN,GAA2B,IAAIkD,GAAJ,EAA3B;AACA;;AAED,SAAOD,MAAM,CAAEjD,cAAF,CAAb;AACA,C,CAED;;;AACA,SAASsB,oBAAT,CAA+B6B,KAA/B,EAAuC;AACtC,MAAK,CAACA,KAAN,EAAc;AACb,WAAO,IAAP;AACA;;AAED,QAAMC,WAAW,GAAGD,KAAK,CAACE,KAAN,CAAY5B,MAAhC;AACA,QAAM6B,SAAS,GAAGH,KAAK,CAACI,GAAN,CAAU9B,MAA5B;AAEA,QAAM+B,SAAS,GAAGJ,WAAW,CAACK,OAAZ,EAAlB;AACA,QAAMC,OAAO,GAAGJ,SAAS,CAACG,OAAV,EAAhB;AAEA,SAAOD,SAAS,CAACG,MAAV,GAAmBD,OAAO,CAACC,MAA3B,GAAoCP,WAApC,GAAkDE,SAAzD;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/bubblingemittermixin\n */\n\nimport EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n\nimport BubblingEventInfo from './bubblingeventinfo';\n\nconst contextsSymbol = Symbol( 'bubbling contexts' );\n\n/**\n * Bubbling emitter mixin for the view document as described in the\n * {@link ~BubblingEmitter} interface.\n *\n * @mixin BubblingEmitterMixin\n * @implements module:engine/view/observer/bubblingemittermixin~BubblingEmitter\n */\nconst BubblingEmitterMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\tfire( eventOrInfo, ...eventArgs ) {\n\t\ttry {\n\t\t\tconst eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo( this, eventOrInfo );\n\t\t\tconst eventContexts = getBubblingContexts( this );\n\n\t\t\tif ( !eventContexts.size ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdateEventInfo( eventInfo, 'capturing', this );\n\n\t\t\t// The capture phase of the event.\n\t\t\tif ( fireListenerFor( eventContexts, '$capture', eventInfo, ...eventArgs ) ) {\n\t\t\t\treturn eventInfo.return;\n\t\t\t}\n\n\t\t\tconst startRange = eventInfo.startRange || this.selection.getFirstRange();\n\t\t\tconst selectedElement = startRange ? startRange.getContainedElement() : null;\n\t\t\tconst isCustomContext = selectedElement ? Boolean( getCustomContext( eventContexts, selectedElement ) ) : false;\n\n\t\t\tlet node = selectedElement || getDeeperRangeParent( startRange );\n\n\t\t\tupdateEventInfo( eventInfo, 'atTarget', node );\n\n\t\t\t// For the not yet bubbling event trigger for $text node if selection can be there and it's not a custom context selected.\n\t\t\tif ( !isCustomContext ) {\n\t\t\t\tif ( fireListenerFor( eventContexts, '$text', eventInfo, ...eventArgs ) ) {\n\t\t\t\t\treturn eventInfo.return;\n\t\t\t\t}\n\n\t\t\t\tupdateEventInfo( eventInfo, 'bubbling', node );\n\t\t\t}\n\n\t\t\twhile ( node ) {\n\t\t\t\t// Root node handling.\n\t\t\t\tif ( node.is( 'rootElement' ) ) {\n\t\t\t\t\tif ( fireListenerFor( eventContexts, '$root', eventInfo, ...eventArgs ) ) {\n\t\t\t\t\t\treturn eventInfo.return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Element node handling.\n\t\t\t\telse if ( node.is( 'element' ) ) {\n\t\t\t\t\tif ( fireListenerFor( eventContexts, node.name, eventInfo, ...eventArgs ) ) {\n\t\t\t\t\t\treturn eventInfo.return;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Check custom contexts (i.e., a widget).\n\t\t\t\tif ( fireListenerFor( eventContexts, node, eventInfo, ...eventArgs ) ) {\n\t\t\t\t\treturn eventInfo.return;\n\t\t\t\t}\n\n\t\t\t\tnode = node.parent;\n\n\t\t\t\tupdateEventInfo( eventInfo, 'bubbling', node );\n\t\t\t}\n\n\t\t\tupdateEventInfo( eventInfo, 'bubbling', this );\n\n\t\t\t// Document context.\n\t\t\tfireListenerFor( eventContexts, '$document', eventInfo, ...eventArgs );\n\n\t\t\treturn eventInfo.return;\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_addEventListener( event, callback, options ) {\n\t\tconst contexts = toArray( options.context || '$document' );\n\t\tconst eventContexts = getBubblingContexts( this );\n\n\t\tfor ( const context of contexts ) {\n\t\t\tlet emitter = eventContexts.get( context );\n\n\t\t\tif ( !emitter ) {\n\t\t\t\temitter = Object.create( EmitterMixin );\n\t\t\t\teventContexts.set( context, emitter );\n\t\t\t}\n\n\t\t\tthis.listenTo( emitter, event, callback, options );\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_removeEventListener( event, callback ) {\n\t\tconst eventContexts = getBubblingContexts( this );\n\n\t\tfor ( const emitter of eventContexts.values() ) {\n\t\t\tthis.stopListening( emitter, event, callback );\n\t\t}\n\t}\n};\n\nexport default BubblingEmitterMixin;\n\n// Update the event info bubbling fields.\n//\n// @param {module:utils/eventinfo~EventInfo} eventInfo The event info object to update.\n// @param {'none'|'capturing'|'atTarget'|'bubbling'} eventPhase The current event phase.\n// @param {module:engine/view/document~Document|module:engine/view/node~Node} currentTarget The current bubbling target.\nfunction updateEventInfo( eventInfo, eventPhase, currentTarget ) {\n\tif ( eventInfo instanceof BubblingEventInfo ) {\n\t\teventInfo._eventPhase = eventPhase;\n\t\teventInfo._currentTarget = currentTarget;\n\t}\n}\n\n// Fires the listener for the specified context. Returns `true` if event was stopped.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {String|module:engine/view/node~Node} context\n// @param {module:utils/eventinfo~EventInfo} eventInfo The `EventInfo` object.\n// @param {...*} [eventArgs] Additional arguments to be passed to the callbacks.\n// @returns {Boolean} True if event stop was called.\nfunction fireListenerFor( eventContexts, context, eventInfo, ...eventArgs ) {\n\tconst emitter = typeof context == 'string' ? eventContexts.get( context ) : getCustomContext( eventContexts, context );\n\n\tif ( !emitter ) {\n\t\treturn false;\n\t}\n\n\temitter.fire( eventInfo, ...eventArgs );\n\n\treturn eventInfo.stop.called;\n}\n\n// Returns an emitter for a specified view node.\n//\n// @private\n// @param {Map.<String|Function, module:utils/emittermixin~Emitter>} eventContexts\n// @param {module:engine/view/node~Node} node\n// @returns {module:utils/emittermixin~Emitter|null}\nfunction getCustomContext( eventContexts, node ) {\n\tfor ( const [ context, emitter ] of eventContexts ) {\n\t\tif ( typeof context == 'function' && context( node ) ) {\n\t\t\treturn emitter;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Returns bubbling contexts map for the source (emitter).\nfunction getBubblingContexts( source ) {\n\tif ( !source[ contextsSymbol ] ) {\n\t\tsource[ contextsSymbol ] = new Map();\n\t}\n\n\treturn source[ contextsSymbol ];\n}\n\n// Returns the deeper parent element for the range.\nfunction getDeeperRangeParent( range ) {\n\tif ( !range ) {\n\t\treturn null;\n\t}\n\n\tconst startParent = range.start.parent;\n\tconst endParent = range.end.parent;\n\n\tconst startPath = startParent.getPath();\n\tconst endPath = endParent.getPath();\n\n\treturn startPath.length > endPath.length ? startParent : endParent;\n}\n\n/**\n * Bubbling emitter for the view document.\n *\n * Bubbling emitter is triggering events in the context of specified {@link module:engine/view/element~Element view element} name,\n * predefined `'$text'`, `'$root'`, `'$document'` and `'$capture'` contexts, and context matchers provided as a function.\n *\n * Before bubbling starts, listeners for `'$capture'` context are triggered. Then the bubbling starts from the deeper selection\n * position (by firing event on the `'$text'` context) and propagates the view document tree up to the `'$root'` and finally\n * the listeners at `'$document'` context are fired (this is the default context).\n *\n * Examples:\n *\n *\t\t// Listeners registered in the context of the view element names:\n *\t\tthis.listenTo( viewDocument, 'enter', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: 'blockquote' } );\n *\n *\t\tthis.listenTo( viewDocument, 'enter', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: 'li' } );\n *\n *\t\t// Listeners registered in the context of the '$text' and '$root' nodes.\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: '$text', priority: 'high' } );\n *\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: '$root' } );\n *\n *\t\t// Listeners registered in the context of custom callback function.\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: isWidget } );\n *\n *\t\tthis.listenTo( view.document, 'arrowKey', ( evt, data ) => {\n *\t\t\t// ...\n *\t\t}, { context: isWidget, priority: 'high' } );\n *\n * Example flow for selection in text:\n *\n *\t\t<blockquote><p>Foo[]bar</p></blockquote>\n *\n * Fired events on contexts:\n * 1. `'$capture'`\n * 2. `'$text'`\n * 3. `'p'`\n * 4. `'blockquote'`\n * 5. `'$root'`\n * 6. `'$document'`\n *\n * Example flow for selection on element (i.e., Widget):\n *\n *\t\t<blockquote><p>Foo[<widget/>]bar</p></blockquote>\n *\n * Fired events on contexts:\n * 1. `'$capture'`\n * 2. *widget* (custom matcher)\n * 3. `'p'`\n * 4. `'blockquote'`\n * 5. `'$root'`\n * 6. `'$document'`\n *\n * There could be multiple listeners registered for the same context and at different priority levels:\n *\n *\t\t<p>Foo[]bar</p>\n *\n * 1. `'$capture'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 2. `'$text'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 3. `'p'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 4. `'$root'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n * 5. `'$document'` at priorities:\n *    1. `'highest'`\n *    2. `'high'`\n *    3. `'normal'`\n *    4. `'low'`\n *    5. `'lowest'`\n *\n * @interface BubblingEmitter\n * @extends module:utils/emittermixin~Emitter\n */\n"]},"metadata":{},"sourceType":"module"}