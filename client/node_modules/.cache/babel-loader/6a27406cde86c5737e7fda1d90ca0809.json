{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste functionality to work.\n *\n * It takes care of removing the selected content, splitting elements (if needed), inserting elements and merging elements appropriately.\n *\n * Some examples:\n *\n * \t\t<p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n * \t\t<p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n * \t\t<p>x^y</p> + <img /> => <p>x</p>^<p>y</p> + <img /> => <p>x</p><img /><p>y</p>\n * \t\t<p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p> (no merging)\n * \t\t<p>x</p>[<img />]<p>z</p> + <p>y</p> => <p>x</p>^<p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p>\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\n\nexport default function insertContent(model, content, selectable, placeOrOffset) {\n  return model.change(writer => {\n    let selection;\n\n    if (!selectable) {\n      selection = model.document.selection;\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      selection = selectable;\n    } else {\n      selection = writer.createSelection(selectable, placeOrOffset);\n    }\n\n    if (!selection.isCollapsed) {\n      model.deleteContent(selection, {\n        doNotAutoparagraph: true\n      });\n    }\n\n    const insertion = new Insertion(model, writer, selection.anchor);\n    let nodesToInsert;\n\n    if (content.is('documentFragment')) {\n      nodesToInsert = content.getChildren();\n    } else {\n      nodesToInsert = [content];\n    }\n\n    insertion.handleNodes(nodesToInsert);\n    const newRange = insertion.getSelectionRange();\n    /* istanbul ignore else */\n\n    if (newRange) {\n      if (selection instanceof DocumentSelection) {\n        writer.setSelection(newRange);\n      } else {\n        selection.setTo(newRange);\n      }\n    } else {// We are not testing else because it's a safe check for unpredictable edge cases:\n      // an insertion without proper range to select.\n      //\n      // @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n    }\n\n    const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);\n    insertion.destroy();\n    return affectedRange;\n  });\n}\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\n\nclass Insertion {\n  constructor(model, writer, position) {\n    /**\n     * The model in context of which the insertion should be performed.\n     *\n     * @member {module:engine/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * Batch to which operations will be added.\n     *\n     * @member {module:engine/controller/writer~Batch} #writer\n     */\n\n    this.writer = writer;\n    /**\n     * The position at which (or near which) the next node will be inserted.\n     *\n     * @member {module:engine/model/position~Position} #position\n     */\n\n    this.position = position;\n    /**\n     * Elements with which the inserted elements can be merged.\n     *\n     *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n     *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n     *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n     *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n     *\n     *\n     * @member {Set} #canMergeWith\n     */\n\n    this.canMergeWith = new Set([this.position.parent]);\n    /**\n     * Schema of the model.\n     *\n     * @member {module:engine/model/schema~Schema} #schema\n     */\n\n    this.schema = model.schema;\n    /**\n     * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.\n     *\n     * @private\n     * @type {module:engine/model/documentfragment~DocumentFragment}\n     */\n\n    this._documentFragment = writer.createDocumentFragment();\n    /**\n     * The current position in the temporary DocumentFragment.\n     *\n     * @private\n     * @type {module:engine/model/position~Position}\n     */\n\n    this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);\n    /**\n     * The reference to the first inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._firstNode = null;\n    /**\n     * The reference to the last inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._lastNode = null;\n    /**\n     * The reference to the last auto paragraph node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._lastAutoParagraph = null;\n    /**\n     * The array of nodes that should be cleaned of not allowed attributes.\n     *\n     * @private\n     * @type {Array.<module:engine/model/node~Node>}\n     */\n\n    this._filterAttributesOf = [];\n    /**\n     * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n     */\n\n    this._affectedStart = null;\n    /**\n     * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n     */\n\n    this._affectedEnd = null;\n  }\n  /**\n   * Handles insertion of a set of nodes.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n   */\n\n\n  handleNodes(nodes) {\n    for (const node of Array.from(nodes)) {\n      this._handleNode(node);\n    } // Insert nodes collected in temporary DocumentFragment.\n\n\n    this._insertPartialFragment(); // If there was an auto paragraph then we might need to adjust the end of insertion.\n\n\n    if (this._lastAutoParagraph) {\n      this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);\n    } // After the content was inserted we may try to merge it with its next sibling if the selection was in it initially.\n    // Merging with the previous sibling was performed just after inserting the first node to the document.\n\n\n    this._mergeOnRight(); // TMP this will become a post-fixer.\n\n\n    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);\n    this._filterAttributesOf = [];\n  }\n  /**\n   * Updates the last node after the auto paragraphing.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The last auto paragraphing node.\n   */\n\n\n  _updateLastNodeFromAutoParagraph(node) {\n    const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);\n    const positionAfterNode = this.writer.createPositionAfter(node); // If the real end was after the last auto paragraph then update relevant properties.\n\n    if (positionAfterNode.isAfter(positionAfterLastNode)) {\n      this._lastNode = node;\n      /* istanbul ignore if */\n\n      if (this.position.parent != node || !this.position.isAtEnd) {\n        // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n        // At this point the insertion position should be at the end of the last auto paragraph.\n        // Note: This error is documented in other place in this file.\n        throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n      }\n\n      this.position = positionAfterNode;\n\n      this._setAffectedBoundaries(this.position);\n    }\n  }\n  /**\n   * Returns range to be selected after insertion.\n   * Returns `null` if there is no valid range to select after insertion.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getSelectionRange() {\n    if (this.nodeToSelect) {\n      return Range._createOn(this.nodeToSelect);\n    }\n\n    return this.model.schema.getNearestSelectionRange(this.position);\n  }\n  /**\n   * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n   * before the insertion. Returns `null` if no changes were done.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getAffectedRange() {\n    if (!this._affectedStart) {\n      return null;\n    }\n\n    return new Range(this._affectedStart, this._affectedEnd);\n  }\n  /**\n   * Destroys `Insertion` instance.\n   */\n\n\n  destroy() {\n    if (this._affectedStart) {\n      this._affectedStart.detach();\n    }\n\n    if (this._affectedEnd) {\n      this._affectedEnd.detach();\n    }\n  }\n  /**\n   * Handles insertion of a single node.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node\n   */\n\n\n  _handleNode(node) {\n    // Let's handle object in a special way.\n    // * They should never be merged with other elements.\n    // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n    if (this.schema.isObject(node)) {\n      this._handleObject(node);\n\n      return;\n    } // Try to find a place for the given node.\n    // Check if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n    // Inserts the auto paragraph if it would allow for insertion.\n\n\n    let isAllowed = this._checkAndAutoParagraphToAllowedPosition(node);\n\n    if (!isAllowed) {\n      // Split the position.parent's branch up to a point where the node can be inserted.\n      // If it isn't allowed in the whole branch, then of course don't split anything.\n      isAllowed = this._checkAndSplitToAllowedPosition(node);\n\n      if (!isAllowed) {\n        this._handleDisallowedNode(node);\n\n        return;\n      }\n    } // Add node to the current temporary DocumentFragment.\n\n\n    this._appendToFragment(node); // Store the first and last nodes for easy access for merging with sibling nodes.\n\n\n    if (!this._firstNode) {\n      this._firstNode = node;\n    }\n\n    this._lastNode = node;\n  }\n  /**\n   * Inserts the temporary DocumentFragment into the model.\n   *\n   * @private\n   */\n\n\n  _insertPartialFragment() {\n    if (this._documentFragment.isEmpty) {\n      return;\n    }\n\n    const livePosition = LivePosition.fromPosition(this.position, 'toNext');\n\n    this._setAffectedBoundaries(this.position); // If the very first node of the whole insertion process is inserted, insert it separately for OT reasons (undo).\n    // Note: there can be multiple calls to `_insertPartialFragment()` during one insertion process.\n    // Note: only the very first node can be merged so we have to do separate operation only for it.\n\n\n    if (this._documentFragment.getChild(0) == this._firstNode) {\n      this.writer.insert(this._firstNode, this.position); // We must merge the first node just after inserting it to avoid problems with OT.\n      // (See: https://github.com/ckeditor/ckeditor5/pull/8773#issuecomment-760945652).\n\n      this._mergeOnLeft();\n\n      this.position = livePosition.toPosition();\n    } // Insert the remaining nodes from document fragment.\n\n\n    if (!this._documentFragment.isEmpty) {\n      this.writer.insert(this._documentFragment, this.position);\n    }\n\n    this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);\n    this.position = livePosition.toPosition();\n    livePosition.detach();\n  }\n  /**\n   * @private\n   * @param {module:engine/model/element~Element} node The object element.\n   */\n\n\n  _handleObject(node) {\n    // Try finding it a place in the tree.\n    if (this._checkAndSplitToAllowedPosition(node)) {\n      this._appendToFragment(node);\n    } // Try autoparagraphing.\n    else {\n      this._tryAutoparagraphing(node);\n    }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n   */\n\n\n  _handleDisallowedNode(node) {\n    // If the node is an element, try inserting its children (strip the parent).\n    if (node.is('element')) {\n      this.handleNodes(node.getChildren());\n    } // If text is not allowed, try autoparagraphing it.\n    else {\n      this._tryAutoparagraphing(node);\n    }\n  }\n  /**\n   * Append a node to the temporary DocumentFragment.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node to insert.\n   */\n\n\n  _appendToFragment(node) {\n    /* istanbul ignore if */\n    if (!this.schema.checkChild(this.position, node)) {\n      // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n      // Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\n      /**\n       * Given node cannot be inserted on the given position.\n       *\n       * @error insertcontent-wrong-position\n       * @param {module:engine/model/node~Node} node Node to insert.\n       * @param {module:engine/model/position~Position} position Position to insert the node at.\n       */\n      throw new CKEditorError('insertcontent-wrong-position', this, {\n        node,\n        position: this.position\n      });\n    }\n\n    this.writer.insert(node, this._documentFragmentPosition);\n    this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize); // The last inserted object should be selected because we can't put a collapsed selection after it.\n\n    if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {\n      this.nodeToSelect = node;\n    } else {\n      this.nodeToSelect = null;\n    }\n\n    this._filterAttributesOf.push(node);\n  }\n  /**\n   * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n   * mark the affected range.\n   *\n   * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n   * during merging, but the logic there is more complicated so it is left out of this function.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position\n   */\n\n\n  _setAffectedBoundaries(position) {\n    // Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n    // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n    // This is why it cannot be a range but two separate positions.\n    if (!this._affectedStart) {\n      this._affectedStart = LivePosition.fromPosition(position, 'toPrevious');\n    } // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n    // inserted into the parent but the next node is moved-out of that parent:\n    // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n    // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\n\n    if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {\n      if (this._affectedEnd) {\n        this._affectedEnd.detach();\n      }\n\n      this._affectedEnd = LivePosition.fromPosition(position, 'toNext');\n    }\n  }\n  /**\n   * Merges the previous sibling of the first node if it should be merged.\n   *\n   * After the content was inserted we may try to merge it with its siblings.\n   * This should happen only if the selection was in those elements initially.\n   *\n   * @private\n   */\n\n\n  _mergeOnLeft() {\n    const node = this._firstNode;\n\n    if (!(node instanceof Element)) {\n      return;\n    }\n\n    if (!this._canMergeLeft(node)) {\n      return;\n    }\n\n    const mergePosLeft = LivePosition._createBefore(node);\n\n    mergePosLeft.stickiness = 'toNext';\n    const livePosition = LivePosition.fromPosition(this.position, 'toNext'); // If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n    // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n    // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n    // shown as `][`).\n    //\n    // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n    //\n    // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n    //\n    // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\n    if (this._affectedStart.isEqual(mergePosLeft)) {\n      this._affectedStart.detach();\n\n      this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');\n    } // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n    // because the reference would point to the removed node.\n    //\n    // <p>A^A</p> + <p>X</p>\n    //\n    // <p>A</p>^<p>A</p>\n    // <p>A</p><p>X</p><p>A</p>\n    // <p>AX</p><p>A</p>\n    // <p>AXA</p>\n\n\n    if (this._firstNode === this._lastNode) {\n      this._firstNode = mergePosLeft.nodeBefore;\n      this._lastNode = mergePosLeft.nodeBefore;\n    }\n\n    this.writer.merge(mergePosLeft); // If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n    //\n    // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n    //\n    // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n    // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\n    if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {\n      this._affectedEnd.detach();\n\n      this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');\n    }\n\n    this.position = livePosition.toPosition();\n    livePosition.detach(); // After merge elements that were marked by _insert() to be filtered might be gone so\n    // we need to mark the new container.\n\n    this._filterAttributesOf.push(this.position.parent);\n\n    mergePosLeft.detach();\n  }\n  /**\n   * Merges the next sibling of the last node if it should be merged.\n   *\n   * After the content was inserted we may try to merge it with its siblings.\n   * This should happen only if the selection was in those elements initially.\n   *\n   * @private\n   */\n\n\n  _mergeOnRight() {\n    const node = this._lastNode;\n\n    if (!(node instanceof Element)) {\n      return;\n    }\n\n    if (!this._canMergeRight(node)) {\n      return;\n    }\n\n    const mergePosRight = LivePosition._createAfter(node);\n\n    mergePosRight.stickiness = 'toNext';\n    /* istanbul ignore if */\n\n    if (!this.position.isEqual(mergePosRight)) {\n      // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n      // At this point the insertion position should be after the node we'll merge. If it isn't,\n      // it should need to be secured as in the left merge case.\n\n      /**\n       * An internal error occurred when merging inserted content with its siblings.\n       * The insertion position should equal the merge position.\n       *\n       * If you encountered this error, report it back to the CKEditor 5 team\n       * with as many details as possible regarding the content being inserted and the insertion position.\n       *\n       * @error insertcontent-invalid-insertion-position\n       */\n      throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n    } // Move the position to the previous node, so it isn't moved to the graveyard on merge.\n    // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\n\n    this.position = Position._createAt(mergePosRight.nodeBefore, 'end'); // Explanation of setting position stickiness to `'toPrevious'`:\n    // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n    // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\n    const livePosition = LivePosition.fromPosition(this.position, 'toPrevious'); // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\n    if (this._affectedEnd.isEqual(mergePosRight)) {\n      this._affectedEnd.detach();\n\n      this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');\n    } // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n    // because the reference would point to the removed node.\n    //\n    // <p>A^A</p> + <p>X</p>\n    //\n    // <p>A</p>^<p>A</p>\n    // <p>A</p><p>X</p><p>A</p>\n    // <p>AX</p><p>A</p>\n    // <p>AXA</p>\n\n\n    if (this._firstNode === this._lastNode) {\n      this._firstNode = mergePosRight.nodeBefore;\n      this._lastNode = mergePosRight.nodeBefore;\n    }\n\n    this.writer.merge(mergePosRight); // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\n    if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {\n      this._affectedStart.detach();\n\n      this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');\n    }\n\n    this.position = livePosition.toPosition();\n    livePosition.detach(); // After merge elements that were marked by _insert() to be filtered might be gone so\n    // we need to mark the new container.\n\n    this._filterAttributesOf.push(this.position.parent);\n\n    mergePosRight.detach();\n  }\n  /**\n   * Checks whether specified node can be merged with previous sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @returns {Boolean}\n   */\n\n\n  _canMergeLeft(node) {\n    const previousSibling = node.previousSibling;\n    return previousSibling instanceof Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);\n  }\n  /**\n   * Checks whether specified node can be merged with next sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @returns {Boolean}\n   */\n\n\n  _canMergeRight(node) {\n    const nextSibling = node.nextSibling;\n    return nextSibling instanceof Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);\n  }\n  /**\n   * Tries wrapping the node in a new paragraph and inserting it this way.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n   */\n\n\n  _tryAutoparagraphing(node) {\n    const paragraph = this.writer.createElement('paragraph'); // Do not autoparagraph if the paragraph won't be allowed there,\n    // cause that would lead to an infinite loop. The paragraph would be rejected in\n    // the next _handleNode() call and we'd be here again.\n\n    if (this._getAllowedIn(this.position.parent, paragraph) && this.schema.checkChild(paragraph, node)) {\n      paragraph._appendChild(node);\n\n      this._handleNode(paragraph);\n    }\n  }\n  /**\n   * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n   * It also handles inserting the paragraph.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node.\n   * @returns {Boolean} Whether an allowed position was found.\n   * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.\n   */\n\n\n  _checkAndAutoParagraphToAllowedPosition(node) {\n    if (this.schema.checkChild(this.position.parent, node)) {\n      return true;\n    } // Do not auto paragraph if the paragraph won't be allowed there,\n    // cause that would lead to an infinite loop. The paragraph would be rejected in\n    // the next _handleNode() call and we'd be here again.\n\n\n    if (!this.schema.checkChild(this.position.parent, 'paragraph') || !this.schema.checkChild('paragraph', node)) {\n      return false;\n    } // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\n\n    this._insertPartialFragment(); // Insert a paragraph and move insertion position to it.\n\n\n    const paragraph = this.writer.createElement('paragraph');\n    this.writer.insert(paragraph, this.position);\n\n    this._setAffectedBoundaries(this.position);\n\n    this._lastAutoParagraph = paragraph;\n    this.position = this.writer.createPositionAt(paragraph, 0);\n    return true;\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node\n   * @returns {Boolean} Whether an allowed position was found.\n   * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n   */\n\n\n  _checkAndSplitToAllowedPosition(node) {\n    const allowedIn = this._getAllowedIn(this.position.parent, node);\n\n    if (!allowedIn) {\n      return false;\n    } // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\n\n    if (allowedIn != this.position.parent) {\n      this._insertPartialFragment();\n    }\n\n    while (allowedIn != this.position.parent) {\n      if (this.position.isAtStart) {\n        // If insertion position is at the beginning of the parent, move it out instead of splitting.\n        // <p>^Foo</p> -> ^<p>Foo</p>\n        const parent = this.position.parent;\n        this.position = this.writer.createPositionBefore(parent); // Special case – parent is empty (<p>^</p>).\n        //\n        // 1. parent.isEmpty\n        // We can remove the element after moving insertion position out of it.\n        //\n        // 2. parent.parent === allowedIn\n        // However parent should remain in place when allowed element is above limit element in document tree.\n        // For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n        // content allowed in $root.\n\n        if (parent.isEmpty && parent.parent === allowedIn) {\n          this.writer.remove(parent);\n        }\n      } else if (this.position.isAtEnd) {\n        // If insertion position is at the end of the parent, move it out instead of splitting.\n        // <p>Foo^</p> -> <p>Foo</p>^\n        this.position = this.writer.createPositionAfter(this.position.parent);\n      } else {\n        const tempPos = this.writer.createPositionAfter(this.position.parent);\n\n        this._setAffectedBoundaries(this.position);\n\n        this.writer.split(this.position);\n        this.position = tempPos;\n        this.canMergeWith.add(this.position.nodeAfter);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} contextElement The element in which context the node should be checked.\n   * @param {module:engine/model/node~Node} childNode The node to check.\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  _getAllowedIn(contextElement, childNode) {\n    if (this.schema.checkChild(contextElement, childNode)) {\n      return contextElement;\n    } // If the child wasn't allowed in the context element and the element is a limit there's no point in\n    // checking any further towards the root. This is it: the limit is unsplittable and there's nothing\n    // we can do about it. Without this check, the algorithm will analyze parent of the limit and may create\n    // an illusion of the child being allowed. There's no way to insert it down there, though. It results in\n    // infinite loops.\n\n\n    if (this.schema.isLimit(contextElement)) {\n      return null;\n    }\n\n    return this._getAllowedIn(contextElement.parent, childNode);\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js"],"names":["Position","LivePosition","Element","Range","DocumentSelection","Selection","CKEditorError","insertContent","model","content","selectable","placeOrOffset","change","writer","selection","document","createSelection","isCollapsed","deleteContent","doNotAutoparagraph","insertion","Insertion","anchor","nodesToInsert","is","getChildren","handleNodes","newRange","getSelectionRange","setSelection","setTo","affectedRange","getAffectedRange","createRange","destroy","constructor","position","canMergeWith","Set","parent","schema","_documentFragment","createDocumentFragment","_documentFragmentPosition","createPositionAt","_firstNode","_lastNode","_lastAutoParagraph","_filterAttributesOf","_affectedStart","_affectedEnd","nodes","node","Array","from","_handleNode","_insertPartialFragment","_updateLastNodeFromAutoParagraph","_mergeOnRight","removeDisallowedAttributes","positionAfterLastNode","createPositionAfter","positionAfterNode","isAfter","isAtEnd","_setAffectedBoundaries","nodeToSelect","_createOn","getNearestSelectionRange","detach","isObject","_handleObject","isAllowed","_checkAndAutoParagraphToAllowedPosition","_checkAndSplitToAllowedPosition","_handleDisallowedNode","_appendToFragment","isEmpty","livePosition","fromPosition","getChild","insert","_mergeOnLeft","toPosition","_tryAutoparagraphing","checkChild","getShiftedBy","offsetSize","push","isBefore","_canMergeLeft","mergePosLeft","_createBefore","stickiness","isEqual","_createAt","nodeBefore","merge","_canMergeRight","mergePosRight","_createAfter","previousSibling","has","checkMerge","nextSibling","paragraph","createElement","_getAllowedIn","_appendChild","allowedIn","isAtStart","createPositionBefore","remove","tempPos","split","add","nodeAfter","contextElement","childNode","isLimit"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\n\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste functionality to work.\n *\n * It takes care of removing the selected content, splitting elements (if needed), inserting elements and merging elements appropriately.\n *\n * Some examples:\n *\n * \t\t<p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n * \t\t<p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n * \t\t<p>x^y</p> + <img /> => <p>x</p>^<p>y</p> + <img /> => <p>x</p><img /><p>y</p>\n * \t\t<p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p> (no merging)\n * \t\t<p>x</p>[<img />]<p>z</p> + <p>y</p> => <p>x</p>^<p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p>\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\nexport default function insertContent( model, content, selectable, placeOrOffset ) {\n\treturn model.change( writer => {\n\t\tlet selection;\n\n\t\tif ( !selectable ) {\n\t\t\tselection = model.document.selection;\n\t\t} else if ( selectable instanceof Selection || selectable instanceof DocumentSelection ) {\n\t\t\tselection = selectable;\n\t\t} else {\n\t\t\tselection = writer.createSelection( selectable, placeOrOffset );\n\t\t}\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\tmodel.deleteContent( selection, { doNotAutoparagraph: true } );\n\t\t}\n\n\t\tconst insertion = new Insertion( model, writer, selection.anchor );\n\n\t\tlet nodesToInsert;\n\n\t\tif ( content.is( 'documentFragment' ) ) {\n\t\t\tnodesToInsert = content.getChildren();\n\t\t} else {\n\t\t\tnodesToInsert = [ content ];\n\t\t}\n\n\t\tinsertion.handleNodes( nodesToInsert );\n\n\t\tconst newRange = insertion.getSelectionRange();\n\n\t\t/* istanbul ignore else */\n\t\tif ( newRange ) {\n\t\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\t\twriter.setSelection( newRange );\n\t\t\t} else {\n\t\t\t\tselection.setTo( newRange );\n\t\t\t}\n\t\t} else {\n\t\t\t// We are not testing else because it's a safe check for unpredictable edge cases:\n\t\t\t// an insertion without proper range to select.\n\t\t\t//\n\t\t\t// @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n\t\t}\n\n\t\tconst affectedRange = insertion.getAffectedRange() || model.createRange( selection.anchor );\n\n\t\tinsertion.destroy();\n\n\t\treturn affectedRange;\n\t} );\n}\n\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\nclass Insertion {\n\tconstructor( model, writer, position ) {\n\t\t/**\n\t\t * The model in context of which the insertion should be performed.\n\t\t *\n\t\t * @member {module:engine/model~Model} #model\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Batch to which operations will be added.\n\t\t *\n\t\t * @member {module:engine/controller/writer~Batch} #writer\n\t\t */\n\t\tthis.writer = writer;\n\n\t\t/**\n\t\t * The position at which (or near which) the next node will be inserted.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} #position\n\t\t */\n\t\tthis.position = position;\n\n\t\t/**\n\t\t * Elements with which the inserted elements can be merged.\n\t\t *\n\t\t *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n\t\t *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n\t\t *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n\t\t *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n\t\t *\n\t\t *\n\t\t * @member {Set} #canMergeWith\n\t\t */\n\t\tthis.canMergeWith = new Set( [ this.position.parent ] );\n\n\t\t/**\n\t\t * Schema of the model.\n\t\t *\n\t\t * @member {module:engine/model/schema~Schema} #schema\n\t\t */\n\t\tthis.schema = model.schema;\n\n\t\t/**\n\t\t * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t\t */\n\t\tthis._documentFragment = writer.createDocumentFragment();\n\n\t\t/**\n\t\t * The current position in the temporary DocumentFragment.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position}\n\t\t */\n\t\tthis._documentFragmentPosition = writer.createPositionAt( this._documentFragment, 0 );\n\n\t\t/**\n\t\t * The reference to the first inserted node.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/node~Node}\n\t\t */\n\t\tthis._firstNode = null;\n\n\t\t/**\n\t\t * The reference to the last inserted node.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/node~Node}\n\t\t */\n\t\tthis._lastNode = null;\n\n\t\t/**\n\t\t * The reference to the last auto paragraph node.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/node~Node}\n\t\t */\n\t\tthis._lastAutoParagraph = null;\n\n\t\t/**\n\t\t * The array of nodes that should be cleaned of not allowed attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<module:engine/model/node~Node>}\n\t\t */\n\t\tthis._filterAttributesOf = [];\n\n\t\t/**\n\t\t * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n\t\t */\n\t\tthis._affectedStart = null;\n\n\t\t/**\n\t\t * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n\t\t */\n\t\tthis._affectedEnd = null;\n\t}\n\n\t/**\n\t * Handles insertion of a set of nodes.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n\t */\n\thandleNodes( nodes ) {\n\t\tfor ( const node of Array.from( nodes ) ) {\n\t\t\tthis._handleNode( node );\n\t\t}\n\n\t\t// Insert nodes collected in temporary DocumentFragment.\n\t\tthis._insertPartialFragment();\n\n\t\t// If there was an auto paragraph then we might need to adjust the end of insertion.\n\t\tif ( this._lastAutoParagraph ) {\n\t\t\tthis._updateLastNodeFromAutoParagraph( this._lastAutoParagraph );\n\t\t}\n\n\t\t// After the content was inserted we may try to merge it with its next sibling if the selection was in it initially.\n\t\t// Merging with the previous sibling was performed just after inserting the first node to the document.\n\t\tthis._mergeOnRight();\n\n\t\t// TMP this will become a post-fixer.\n\t\tthis.schema.removeDisallowedAttributes( this._filterAttributesOf, this.writer );\n\t\tthis._filterAttributesOf = [];\n\t}\n\n\t/**\n\t * Updates the last node after the auto paragraphing.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The last auto paragraphing node.\n\t */\n\t_updateLastNodeFromAutoParagraph( node ) {\n\t\tconst positionAfterLastNode = this.writer.createPositionAfter( this._lastNode );\n\t\tconst positionAfterNode = this.writer.createPositionAfter( node );\n\n\t\t// If the real end was after the last auto paragraph then update relevant properties.\n\t\tif ( positionAfterNode.isAfter( positionAfterLastNode ) ) {\n\t\t\tthis._lastNode = node;\n\n\t\t\t/* istanbul ignore if */\n\t\t\tif ( this.position.parent != node || !this.position.isAtEnd ) {\n\t\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t\t// At this point the insertion position should be at the end of the last auto paragraph.\n\t\t\t\t// Note: This error is documented in other place in this file.\n\t\t\t\tthrow new CKEditorError( 'insertcontent-invalid-insertion-position', this );\n\t\t\t}\n\n\t\t\tthis.position = positionAfterNode;\n\t\t\tthis._setAffectedBoundaries( this.position );\n\t\t}\n\t}\n\n\t/**\n\t * Returns range to be selected after insertion.\n\t * Returns `null` if there is no valid range to select after insertion.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetSelectionRange() {\n\t\tif ( this.nodeToSelect ) {\n\t\t\treturn Range._createOn( this.nodeToSelect );\n\t\t}\n\n\t\treturn this.model.schema.getNearestSelectionRange( this.position );\n\t}\n\n\t/**\n\t * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n\t * before the insertion. Returns `null` if no changes were done.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetAffectedRange() {\n\t\tif ( !this._affectedStart ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new Range( this._affectedStart, this._affectedEnd );\n\t}\n\n\t/**\n\t * Destroys `Insertion` instance.\n\t */\n\tdestroy() {\n\t\tif ( this._affectedStart ) {\n\t\t\tthis._affectedStart.detach();\n\t\t}\n\n\t\tif ( this._affectedEnd ) {\n\t\t\tthis._affectedEnd.detach();\n\t\t}\n\t}\n\n\t/**\n\t * Handles insertion of a single node.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t */\n\t_handleNode( node ) {\n\t\t// Let's handle object in a special way.\n\t\t// * They should never be merged with other elements.\n\t\t// * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n\t\tif ( this.schema.isObject( node ) ) {\n\t\t\tthis._handleObject( node );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Try to find a place for the given node.\n\n\t\t// Check if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n\t\t// Inserts the auto paragraph if it would allow for insertion.\n\t\tlet isAllowed = this._checkAndAutoParagraphToAllowedPosition( node );\n\n\t\tif ( !isAllowed ) {\n\t\t\t// Split the position.parent's branch up to a point where the node can be inserted.\n\t\t\t// If it isn't allowed in the whole branch, then of course don't split anything.\n\t\t\tisAllowed = this._checkAndSplitToAllowedPosition( node );\n\n\t\t\tif ( !isAllowed ) {\n\t\t\t\tthis._handleDisallowedNode( node );\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Add node to the current temporary DocumentFragment.\n\t\tthis._appendToFragment( node );\n\n\t\t// Store the first and last nodes for easy access for merging with sibling nodes.\n\t\tif ( !this._firstNode ) {\n\t\t\tthis._firstNode = node;\n\t\t}\n\n\t\tthis._lastNode = node;\n\t}\n\n\t/**\n\t * Inserts the temporary DocumentFragment into the model.\n\t *\n\t * @private\n\t */\n\t_insertPartialFragment() {\n\t\tif ( this._documentFragment.isEmpty ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst livePosition = LivePosition.fromPosition( this.position, 'toNext' );\n\n\t\tthis._setAffectedBoundaries( this.position );\n\n\t\t// If the very first node of the whole insertion process is inserted, insert it separately for OT reasons (undo).\n\t\t// Note: there can be multiple calls to `_insertPartialFragment()` during one insertion process.\n\t\t// Note: only the very first node can be merged so we have to do separate operation only for it.\n\t\tif ( this._documentFragment.getChild( 0 ) == this._firstNode ) {\n\t\t\tthis.writer.insert( this._firstNode, this.position );\n\n\t\t\t// We must merge the first node just after inserting it to avoid problems with OT.\n\t\t\t// (See: https://github.com/ckeditor/ckeditor5/pull/8773#issuecomment-760945652).\n\t\t\tthis._mergeOnLeft();\n\n\t\t\tthis.position = livePosition.toPosition();\n\t\t}\n\n\t\t// Insert the remaining nodes from document fragment.\n\t\tif ( !this._documentFragment.isEmpty ) {\n\t\t\tthis.writer.insert( this._documentFragment, this.position );\n\t\t}\n\n\t\tthis._documentFragmentPosition = this.writer.createPositionAt( this._documentFragment, 0 );\n\n\t\tthis.position = livePosition.toPosition();\n\t\tlivePosition.detach();\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/element~Element} node The object element.\n\t */\n\t_handleObject( node ) {\n\t\t// Try finding it a place in the tree.\n\t\tif ( this._checkAndSplitToAllowedPosition( node ) ) {\n\t\t\tthis._appendToFragment( node );\n\t\t}\n\t\t// Try autoparagraphing.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n\t */\n\t_handleDisallowedNode( node ) {\n\t\t// If the node is an element, try inserting its children (strip the parent).\n\t\tif ( node.is( 'element' ) ) {\n\t\t\tthis.handleNodes( node.getChildren() );\n\t\t}\n\t\t// If text is not allowed, try autoparagraphing it.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node );\n\t\t}\n\t}\n\n\t/**\n\t * Append a node to the temporary DocumentFragment.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node to insert.\n\t */\n\t_appendToFragment( node ) {\n\t\t/* istanbul ignore if */\n\t\tif ( !this.schema.checkChild( this.position, node ) ) {\n\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t// Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\n\t\t\t/**\n\t\t\t * Given node cannot be inserted on the given position.\n\t\t\t *\n\t\t\t * @error insertcontent-wrong-position\n\t\t\t * @param {module:engine/model/node~Node} node Node to insert.\n\t\t\t * @param {module:engine/model/position~Position} position Position to insert the node at.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'insertcontent-wrong-position',\n\t\t\t\tthis,\n\t\t\t\t{ node, position: this.position }\n\t\t\t);\n\t\t}\n\n\t\tthis.writer.insert( node, this._documentFragmentPosition );\n\t\tthis._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy( node.offsetSize );\n\n\t\t// The last inserted object should be selected because we can't put a collapsed selection after it.\n\t\tif ( this.schema.isObject( node ) && !this.schema.checkChild( this.position, '$text' ) ) {\n\t\t\tthis.nodeToSelect = node;\n\t\t} else {\n\t\t\tthis.nodeToSelect = null;\n\t\t}\n\n\t\tthis._filterAttributesOf.push( node );\n\t}\n\n\t/**\n\t * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n\t * mark the affected range.\n\t *\n\t * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n\t * during merging, but the logic there is more complicated so it is left out of this function.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position\n\t */\n\t_setAffectedBoundaries( position ) {\n\t\t// Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n\t\t// <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n\t\t// This is why it cannot be a range but two separate positions.\n\t\tif ( !this._affectedStart ) {\n\t\t\tthis._affectedStart = LivePosition.fromPosition( position, 'toPrevious' );\n\t\t}\n\n\t\t// If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n\t\t// inserted into the parent but the next node is moved-out of that parent:\n\t\t// (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n\t\t// (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\t\tif ( !this._affectedEnd || this._affectedEnd.isBefore( position ) ) {\n\t\t\tif ( this._affectedEnd ) {\n\t\t\t\tthis._affectedEnd.detach();\n\t\t\t}\n\n\t\t\tthis._affectedEnd = LivePosition.fromPosition( position, 'toNext' );\n\t\t}\n\t}\n\n\t/**\n\t * Merges the previous sibling of the first node if it should be merged.\n\t *\n\t * After the content was inserted we may try to merge it with its siblings.\n\t * This should happen only if the selection was in those elements initially.\n\t *\n\t * @private\n\t */\n\t_mergeOnLeft() {\n\t\tconst node = this._firstNode;\n\n\t\tif ( !( node instanceof Element ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this._canMergeLeft( node ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mergePosLeft = LivePosition._createBefore( node );\n\t\tmergePosLeft.stickiness = 'toNext';\n\n\t\tconst livePosition = LivePosition.fromPosition( this.position, 'toNext' );\n\n\t\t// If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n\t\t// removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n\t\t// by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n\t\t// shown as `][`).\n\t\t//\n\t\t// Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n\t\t//\n\t\t// <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n\t\t//\n\t\t// Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\t\tif ( this._affectedStart.isEqual( mergePosLeft ) ) {\n\t\t\tthis._affectedStart.detach();\n\t\t\tthis._affectedStart = LivePosition._createAt( mergePosLeft.nodeBefore, 'end', 'toPrevious' );\n\t\t}\n\n\t\t// We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n\t\t// because the reference would point to the removed node.\n\t\t//\n\t\t// <p>A^A</p> + <p>X</p>\n\t\t//\n\t\t// <p>A</p>^<p>A</p>\n\t\t// <p>A</p><p>X</p><p>A</p>\n\t\t// <p>AX</p><p>A</p>\n\t\t// <p>AXA</p>\n\t\tif ( this._firstNode === this._lastNode ) {\n\t\t\tthis._firstNode = mergePosLeft.nodeBefore;\n\t\t\tthis._lastNode = mergePosLeft.nodeBefore;\n\t\t}\n\n\t\tthis.writer.merge( mergePosLeft );\n\n\t\t// If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n\t\t//\n\t\t// Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n\t\t//\n\t\t// <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t// <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\t\tif ( mergePosLeft.isEqual( this._affectedEnd ) && this._firstNode === this._lastNode ) {\n\t\t\tthis._affectedEnd.detach();\n\t\t\tthis._affectedEnd = LivePosition._createAt( mergePosLeft.nodeBefore, 'end', 'toNext' );\n\t\t}\n\n\t\tthis.position = livePosition.toPosition();\n\t\tlivePosition.detach();\n\n\t\t// After merge elements that were marked by _insert() to be filtered might be gone so\n\t\t// we need to mark the new container.\n\t\tthis._filterAttributesOf.push( this.position.parent );\n\n\t\tmergePosLeft.detach();\n\t}\n\n\t/**\n\t * Merges the next sibling of the last node if it should be merged.\n\t *\n\t * After the content was inserted we may try to merge it with its siblings.\n\t * This should happen only if the selection was in those elements initially.\n\t *\n\t * @private\n\t */\n\t_mergeOnRight() {\n\t\tconst node = this._lastNode;\n\n\t\tif ( !( node instanceof Element ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this._canMergeRight( node ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mergePosRight = LivePosition._createAfter( node );\n\t\tmergePosRight.stickiness = 'toNext';\n\n\t\t/* istanbul ignore if */\n\t\tif ( !this.position.isEqual( mergePosRight ) ) {\n\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t// At this point the insertion position should be after the node we'll merge. If it isn't,\n\t\t\t// it should need to be secured as in the left merge case.\n\t\t\t/**\n\t\t\t * An internal error occurred when merging inserted content with its siblings.\n\t\t\t * The insertion position should equal the merge position.\n\t\t\t *\n\t\t\t * If you encountered this error, report it back to the CKEditor 5 team\n\t\t\t * with as many details as possible regarding the content being inserted and the insertion position.\n\t\t\t *\n\t\t\t * @error insertcontent-invalid-insertion-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'insertcontent-invalid-insertion-position', this );\n\t\t}\n\n\t\t// Move the position to the previous node, so it isn't moved to the graveyard on merge.\n\t\t// <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\t\tthis.position = Position._createAt( mergePosRight.nodeBefore, 'end' );\n\n\t\t// Explanation of setting position stickiness to `'toPrevious'`:\n\t\t// OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n\t\t// NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\t\tconst livePosition = LivePosition.fromPosition( this.position, 'toPrevious' );\n\n\t\t// See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\t\tif ( this._affectedEnd.isEqual( mergePosRight ) ) {\n\t\t\tthis._affectedEnd.detach();\n\t\t\tthis._affectedEnd = LivePosition._createAt( mergePosRight.nodeBefore, 'end', 'toNext' );\n\t\t}\n\n\t\t// We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n\t\t// because the reference would point to the removed node.\n\t\t//\n\t\t// <p>A^A</p> + <p>X</p>\n\t\t//\n\t\t// <p>A</p>^<p>A</p>\n\t\t// <p>A</p><p>X</p><p>A</p>\n\t\t// <p>AX</p><p>A</p>\n\t\t// <p>AXA</p>\n\t\tif ( this._firstNode === this._lastNode ) {\n\t\t\tthis._firstNode = mergePosRight.nodeBefore;\n\t\t\tthis._lastNode = mergePosRight.nodeBefore;\n\t\t}\n\n\t\tthis.writer.merge( mergePosRight );\n\n\t\t// See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\t\tif ( mergePosRight.getShiftedBy( -1 ).isEqual( this._affectedStart ) && this._firstNode === this._lastNode ) {\n\t\t\tthis._affectedStart.detach();\n\t\t\tthis._affectedStart = LivePosition._createAt( mergePosRight.nodeBefore, 0, 'toPrevious' );\n\t\t}\n\n\t\tthis.position = livePosition.toPosition();\n\t\tlivePosition.detach();\n\n\t\t// After merge elements that were marked by _insert() to be filtered might be gone so\n\t\t// we need to mark the new container.\n\t\tthis._filterAttributesOf.push( this.position.parent );\n\n\t\tmergePosRight.detach();\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with previous sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @returns {Boolean}\n\t */\n\t_canMergeLeft( node ) {\n\t\tconst previousSibling = node.previousSibling;\n\n\t\treturn ( previousSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( previousSibling ) &&\n\t\t\tthis.model.schema.checkMerge( previousSibling, node );\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with next sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @returns {Boolean}\n\t */\n\t_canMergeRight( node ) {\n\t\tconst nextSibling = node.nextSibling;\n\n\t\treturn ( nextSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( nextSibling ) &&\n\t\t\tthis.model.schema.checkMerge( node, nextSibling );\n\t}\n\n\t/**\n\t * Tries wrapping the node in a new paragraph and inserting it this way.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n\t */\n\t_tryAutoparagraphing( node ) {\n\t\tconst paragraph = this.writer.createElement( 'paragraph' );\n\n\t\t// Do not autoparagraph if the paragraph won't be allowed there,\n\t\t// cause that would lead to an infinite loop. The paragraph would be rejected in\n\t\t// the next _handleNode() call and we'd be here again.\n\t\tif ( this._getAllowedIn( this.position.parent, paragraph ) && this.schema.checkChild( paragraph, node ) ) {\n\t\t\tparagraph._appendChild( node );\n\t\t\tthis._handleNode( paragraph );\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n\t * It also handles inserting the paragraph.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node.\n\t * @returns {Boolean} Whether an allowed position was found.\n\t * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.\n\t */\n\t_checkAndAutoParagraphToAllowedPosition( node ) {\n\t\tif ( this.schema.checkChild( this.position.parent, node ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Do not auto paragraph if the paragraph won't be allowed there,\n\t\t// cause that would lead to an infinite loop. The paragraph would be rejected in\n\t\t// the next _handleNode() call and we'd be here again.\n\t\tif ( !this.schema.checkChild( this.position.parent, 'paragraph' ) || !this.schema.checkChild( 'paragraph', node ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\t\tthis._insertPartialFragment();\n\n\t\t// Insert a paragraph and move insertion position to it.\n\t\tconst paragraph = this.writer.createElement( 'paragraph' );\n\n\t\tthis.writer.insert( paragraph, this.position );\n\t\tthis._setAffectedBoundaries( this.position );\n\n\t\tthis._lastAutoParagraph = paragraph;\n\t\tthis.position = this.writer.createPositionAt( paragraph, 0 );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t * @returns {Boolean} Whether an allowed position was found.\n\t * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n\t */\n\t_checkAndSplitToAllowedPosition( node ) {\n\t\tconst allowedIn = this._getAllowedIn( this.position.parent, node );\n\n\t\tif ( !allowedIn ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\t\tif ( allowedIn != this.position.parent ) {\n\t\t\tthis._insertPartialFragment();\n\t\t}\n\n\t\twhile ( allowedIn != this.position.parent ) {\n\t\t\tif ( this.position.isAtStart ) {\n\t\t\t\t// If insertion position is at the beginning of the parent, move it out instead of splitting.\n\t\t\t\t// <p>^Foo</p> -> ^<p>Foo</p>\n\t\t\t\tconst parent = this.position.parent;\n\n\t\t\t\tthis.position = this.writer.createPositionBefore( parent );\n\n\t\t\t\t// Special case – parent is empty (<p>^</p>).\n\t\t\t\t//\n\t\t\t\t// 1. parent.isEmpty\n\t\t\t\t// We can remove the element after moving insertion position out of it.\n\t\t\t\t//\n\t\t\t\t// 2. parent.parent === allowedIn\n\t\t\t\t// However parent should remain in place when allowed element is above limit element in document tree.\n\t\t\t\t// For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n\t\t\t\t// content allowed in $root.\n\t\t\t\tif ( parent.isEmpty && parent.parent === allowedIn ) {\n\t\t\t\t\tthis.writer.remove( parent );\n\t\t\t\t}\n\t\t\t} else if ( this.position.isAtEnd ) {\n\t\t\t\t// If insertion position is at the end of the parent, move it out instead of splitting.\n\t\t\t\t// <p>Foo^</p> -> <p>Foo</p>^\n\t\t\t\tthis.position = this.writer.createPositionAfter( this.position.parent );\n\t\t\t} else {\n\t\t\t\tconst tempPos = this.writer.createPositionAfter( this.position.parent );\n\n\t\t\t\tthis._setAffectedBoundaries( this.position );\n\t\t\t\tthis.writer.split( this.position );\n\n\t\t\t\tthis.position = tempPos;\n\n\t\t\t\tthis.canMergeWith.add( this.position.nodeAfter );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} contextElement The element in which context the node should be checked.\n\t * @param {module:engine/model/node~Node} childNode The node to check.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getAllowedIn( contextElement, childNode ) {\n\t\tif ( this.schema.checkChild( contextElement, childNode ) ) {\n\t\t\treturn contextElement;\n\t\t}\n\n\t\t// If the child wasn't allowed in the context element and the element is a limit there's no point in\n\t\t// checking any further towards the root. This is it: the limit is unsplittable and there's nothing\n\t\t// we can do about it. Without this check, the algorithm will analyze parent of the limit and may create\n\t\t// an illusion of the child being allowed. There's no way to insert it down there, though. It results in\n\t\t// infinite loops.\n\t\tif ( this.schema.isLimit( contextElement ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._getAllowedIn( contextElement.parent, childNode );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}