{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/viewconsumable\n */\nimport { isArray } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Class used for handling consumption of view {@link module:engine/view/element~Element elements},\n * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.\n * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name\n * does not consume its attributes, classes and styles.\n * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.\n * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.\n * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.\n * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.\n *\n *\t\tviewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.\n *\t\tviewConsumable.add( textNode ); // Adds text node for consumption.\n *\t\tviewConsumable.add( docFragment ); // Adds document fragment for consumption.\n *\t\tviewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.\n *\t\tviewConsumable.test( textNode ); // Tests if text node can be consumed.\n *\t\tviewConsumable.test( docFragment ); // Tests if document fragment can be consumed.\n *\t\tviewConsumable.consume( element, { name: true }  ); // Consume element's name.\n *\t\tviewConsumable.consume( textNode ); // Consume text node.\n *\t\tviewConsumable.consume( docFragment ); // Consume document fragment.\n *\t\tviewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.\n *\t\tviewConsumable.revert( textNode ); // Revert already consumed text node.\n *\t\tviewConsumable.revert( docFragment ); // Revert already consumed document fragment.\n */\n\nexport default class ViewConsumable {\n  /**\n   * Creates new ViewConsumable.\n   */\n  constructor() {\n    /**\n     * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,\n     * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.\n     * For {@link module:engine/view/text~Text text nodes} and\n     * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.\n     *\n     * @protected\n     * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}\n    */\n    this._consumables = new Map();\n  }\n  /**\n   * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.\n   *\n   *\t\tviewConsumable.add( p, { name: true } ); // Adds element's name to consume.\n   *\t\tviewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.\n   *\t\tviewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.\n   *\t\tviewConsumable.add( p, { styles: 'color' } ); // Adds element's style\n   *\t\tviewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.\n   *\t\tviewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.\n   *\t\tviewConsumable.add( textNode ); // Adds text node to consume.\n   *\t\tviewConsumable.add( docFragment ); // Adds document fragment to consume.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n   * attribute is provided - it should be handled separately by providing actual style/class.\n   *\n   *\t\tviewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.\n   *\t\tviewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   */\n\n\n  add(element, consumables) {\n    let elementConsumables; // For text nodes and document fragments just mark them as consumable.\n\n    if (element.is('$text') || element.is('documentFragment')) {\n      this._consumables.set(element, true);\n\n      return;\n    } // For elements create new ViewElementConsumables or update already existing one.\n\n\n    if (!this._consumables.has(element)) {\n      elementConsumables = new ViewElementConsumables(element);\n\n      this._consumables.set(element, elementConsumables);\n    } else {\n      elementConsumables = this._consumables.get(element);\n    }\n\n    elementConsumables.add(consumables);\n  }\n  /**\n   * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.\n   * It returns `true` when all items included in method's call can be consumed. Returns `false` when\n   * first already consumed item is found and `null` when first non-consumable item is found.\n   *\n   *\t\tviewConsumable.test( p, { name: true } ); // Tests element's name.\n   *\t\tviewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.\n   *\t\tviewConsumable.test( p, { classes: 'foobar' } ); // Tests class.\n   *\t\tviewConsumable.test( p, { styles: 'color' } ); // Tests style.\n   *\t\tviewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.\n   *\t\tviewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.\n   *\t\tviewConsumable.test( textNode ); // Tests text node.\n   *\t\tviewConsumable.test( docFragment ); // Tests document fragment.\n   *\n   * Testing classes and styles as attribute will test if all added classes/styles can be consumed.\n   *\n   *\t\tviewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.\n   *\t\tviewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`\n   * when first already consumed item is found and `null` when first non-consumable item is found.\n   */\n\n\n  test(element, consumables) {\n    const elementConsumables = this._consumables.get(element);\n\n    if (elementConsumables === undefined) {\n      return null;\n    } // For text nodes and document fragments return stored boolean value.\n\n\n    if (element.is('$text') || element.is('documentFragment')) {\n      return elementConsumables;\n    } // For elements test consumables object.\n\n\n    return elementConsumables.test(consumables);\n  }\n  /**\n   * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n   * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.\n   *\n   *\t\tviewConsumable.consume( p, { name: true } ); // Consumes element's name.\n   *\t\tviewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.\n   *\t\tviewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.\n   *\t\tviewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.\n   *\t\tviewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.\n   *\t\tviewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.\n   *\t\tviewConsumable.consume( textNode ); // Consumes text node.\n   *\t\tviewConsumable.consume( docFragment ); // Consumes document fragment.\n   *\n   * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.\n   *\n   *\t\tviewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.\n   *\t\tviewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,\n   * otherwise returns `false`.\n   */\n\n\n  consume(element, consumables) {\n    if (this.test(element, consumables)) {\n      if (element.is('$text') || element.is('documentFragment')) {\n        // For text nodes and document fragments set value to false.\n        this._consumables.set(element, false);\n      } else {\n        // For elements - consume consumables object.\n        this._consumables.get(element).consume(consumables);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.\n   * Method does not revert items that were never previously added for consumption, even if they are included in\n   * method's call.\n   *\n   *\t\tviewConsumable.revert( p, { name: true } ); // Reverts element's name.\n   *\t\tviewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.\n   *\t\tviewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.\n   *\t\tviewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.\n   *\t\tviewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.\n   *\t\tviewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.\n   *\t\tviewConsumable.revert( textNode ); // Reverts text node.\n   *\t\tviewConsumable.revert( docFragment ); // Reverts document fragment.\n   *\n   * Reverting classes and styles as attribute will revert all classes/styles that were previously added for\n   * consumption.\n   *\n   *\t\tviewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.\n   *\t\tviewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n   * @param {Boolean} consumables.name If set to true element's name will be included.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n   */\n\n\n  revert(element, consumables) {\n    const elementConsumables = this._consumables.get(element);\n\n    if (elementConsumables !== undefined) {\n      if (element.is('$text') || element.is('documentFragment')) {\n        // For text nodes and document fragments - set consumable to true.\n        this._consumables.set(element, true);\n      } else {\n        // For elements - revert items from consumables object.\n        elementConsumables.revert(consumables);\n      }\n    }\n  }\n  /**\n   * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include\n   * element's name and all its attributes, classes and styles.\n   *\n   * @static\n   * @param {module:engine/view/element~Element} element\n   * @returns {Object} consumables\n   */\n\n\n  static consumablesFromElement(element) {\n    const consumables = {\n      element,\n      name: true,\n      attributes: [],\n      classes: [],\n      styles: []\n    };\n    const attributes = element.getAttributeKeys();\n\n    for (const attribute of attributes) {\n      // Skip classes and styles - will be added separately.\n      if (attribute == 'style' || attribute == 'class') {\n        continue;\n      }\n\n      consumables.attributes.push(attribute);\n    }\n\n    const classes = element.getClassNames();\n\n    for (const className of classes) {\n      consumables.classes.push(className);\n    }\n\n    const styles = element.getStyleNames();\n\n    for (const style of styles) {\n      consumables.styles.push(style);\n    }\n\n    return consumables;\n  }\n  /**\n   * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from\n   * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n   * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.\n   *\n   * @static\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n   * from which `ViewConsumable` will be created.\n   * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used\n   * to add all consumables. It will be returned instead of a new instance.\n   */\n\n\n  static createFrom(from, instance) {\n    if (!instance) {\n      instance = new ViewConsumable(from);\n    }\n\n    if (from.is('$text')) {\n      instance.add(from);\n      return instance;\n    } // Add `from` itself, if it is an element.\n\n\n    if (from.is('element')) {\n      instance.add(from, ViewConsumable.consumablesFromElement(from));\n    }\n\n    if (from.is('documentFragment')) {\n      instance.add(from);\n    }\n\n    for (const child of from.getChildren()) {\n      instance = ViewConsumable.createFrom(child, instance);\n    }\n\n    return instance;\n  }\n\n}\n/**\n * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.\n * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.\n *\n * @private\n */\n\nclass ViewElementConsumables {\n  /**\n   * Creates ViewElementConsumables instance.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n   * from which `ViewElementConsumables` is being created.\n   */\n  constructor(from) {\n    /**\n     * @readonly\n     * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n     */\n    this.element = from;\n    /**\n     * Flag indicating if name of the element can be consumed.\n     *\n     * @private\n     * @member {Boolean}\n     */\n\n    this._canConsumeName = null;\n    /**\n     * Contains maps of element's consumables: attributes, classes and styles.\n     *\n     * @private\n     * @member {Object}\n     */\n\n    this._consumables = {\n      attributes: new Map(),\n      styles: new Map(),\n      classes: new Map()\n    };\n  }\n  /**\n   * Adds consumable parts of the {@link module:engine/view/element~Element view element}.\n   * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and\n   * styles still could be consumed):\n   *\n   *\t\tconsumables.add( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n   * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.\n   *\n   * @param {Object} consumables Object describing which parts of the element can be consumed.\n   * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.\n   */\n\n\n  add(consumables) {\n    if (consumables.name) {\n      this._canConsumeName = true;\n    }\n\n    for (const type in this._consumables) {\n      if (type in consumables) {\n        this._add(type, consumables[type]);\n      }\n    }\n  }\n  /**\n   * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.\n   *\n   * Element's name can be tested:\n   *\n   *\t\tconsumables.test( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * @param {Object} consumables Object describing which parts of the element should be tested.\n   * @param {Boolean} consumables.name If set to `true` element's name will be tested.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.\n   * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items\n   * was never marked for consumption and `false` when even one of the items was already consumed.\n   */\n\n\n  test(consumables) {\n    // Check if name can be consumed.\n    if (consumables.name && !this._canConsumeName) {\n      return this._canConsumeName;\n    }\n\n    for (const type in this._consumables) {\n      if (type in consumables) {\n        const value = this._test(type, consumables[type]);\n\n        if (value !== true) {\n          return value;\n        }\n      }\n    } // Return true only if all can be consumed.\n\n\n    return true;\n  }\n  /**\n   * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item\n   * is already consumed - it consumes all consumable items provided.\n   * Element's name can be consumed:\n   *\n   *\t\tconsumables.consume( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * @param {Object} consumables Object describing which parts of the element should be consumed.\n   * @param {Boolean} consumables.name If set to `true` element's name will be consumed.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.\n   */\n\n\n  consume(consumables) {\n    if (consumables.name) {\n      this._canConsumeName = false;\n    }\n\n    for (const type in this._consumables) {\n      if (type in consumables) {\n        this._consume(type, consumables[type]);\n      }\n    }\n  }\n  /**\n   * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.\n   * Element's name can be reverted:\n   *\n   *\t\tconsumables.revert( { name: true } );\n   *\n   * Attributes classes and styles:\n   *\n   *\t\tconsumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );\n   *\t\tconsumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n   *\n   * @param {Object} consumables Object describing which parts of the element should be reverted.\n   * @param {Boolean} consumables.name If set to `true` element's name will be reverted.\n   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.\n   * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.\n   * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.\n   */\n\n\n  revert(consumables) {\n    if (consumables.name) {\n      this._canConsumeName = true;\n    }\n\n    for (const type in this._consumables) {\n      if (type in consumables) {\n        this._revert(type, consumables[type]);\n      }\n    }\n  }\n  /**\n   * Helper method that adds consumables of a given type: attribute, class or style.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n   * type is provided - it should be handled separately by providing actual style/class type.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   */\n\n\n  _add(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        /**\n         * Class and style attributes should be handled separately in\n         * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.\n         *\n         * What you have done is trying to use:\n         *\n         *\t\tconsumables.add( { attributes: [ 'class', 'style' ] } );\n         *\n         * While each class and style should be registered separately:\n         *\n         *\t\tconsumables.add( { classes: 'some-class', styles: 'font-weight' } );\n         *\n         * @error viewconsumable-invalid-attribute\n         */\n        throw new CKEditorError('viewconsumable-invalid-attribute', this);\n      }\n\n      consumables.set(name, true);\n\n      if (type === 'styles') {\n        for (const alsoName of this.element.document.stylesProcessor.getRelatedStyles(name)) {\n          consumables.set(alsoName, true);\n        }\n      }\n    }\n  }\n  /**\n   * Helper method that tests consumables of a given type: attribute, class or style.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be\n   * consumed and `false` when one of the items is already consumed.\n   */\n\n\n  _test(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        const consumableName = name == 'class' ? 'classes' : 'styles'; // Check all classes/styles if class/style attribute is tested.\n\n        const value = this._test(consumableName, [...this._consumables[consumableName].keys()]);\n\n        if (value !== true) {\n          return value;\n        }\n      } else {\n        const value = consumables.get(name); // Return null if attribute is not found.\n\n        if (value === undefined) {\n          return null;\n        }\n\n        if (!value) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Helper method that consumes items of a given type: attribute, class or style.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   */\n\n\n  _consume(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        const consumableName = name == 'class' ? 'classes' : 'styles'; // If class or style is provided for consumption - consume them all.\n\n        this._consume(consumableName, [...this._consumables[consumableName].keys()]);\n      } else {\n        consumables.set(name, false);\n\n        if (type == 'styles') {\n          for (const toConsume of this.element.document.stylesProcessor.getRelatedStyles(name)) {\n            consumables.set(toConsume, false);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Helper method that reverts items of a given type: attribute, class or style.\n   *\n   * @private\n   * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.\n   * @param {String|Array.<String>} item Consumable item or array of items.\n   */\n\n\n  _revert(type, item) {\n    const items = isArray(item) ? item : [item];\n    const consumables = this._consumables[type];\n\n    for (const name of items) {\n      if (type === 'attributes' && (name === 'class' || name === 'style')) {\n        const consumableName = name == 'class' ? 'classes' : 'styles'; // If class or style is provided for reverting - revert them all.\n\n        this._revert(consumableName, [...this._consumables[consumableName].keys()]);\n      } else {\n        const value = consumables.get(name);\n\n        if (value === false) {\n          consumables.set(name, true);\n        }\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js"],"names":["isArray","CKEditorError","ViewConsumable","constructor","_consumables","Map","add","element","consumables","elementConsumables","is","set","has","ViewElementConsumables","get","test","undefined","consume","revert","consumablesFromElement","name","attributes","classes","styles","getAttributeKeys","attribute","push","getClassNames","className","getStyleNames","style","createFrom","from","instance","child","getChildren","_canConsumeName","type","_add","value","_test","_consume","_revert","item","items","alsoName","document","stylesProcessor","getRelatedStyles","consumableName","keys","toConsume"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,OAAT,QAAwB,WAAxB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,cAAN,CAAqB;AACnC;AACD;AACA;AACCC,EAAAA,WAAW,GAAG;AACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,YAAL,GAAoB,IAAIC,GAAJ,EAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,GAAG,CAAEC,OAAF,EAAWC,WAAX,EAAyB;AAC3B,QAAIC,kBAAJ,CAD2B,CAG3B;;AACA,QAAKF,OAAO,CAACG,EAAR,CAAY,OAAZ,KAAyBH,OAAO,CAACG,EAAR,CAAY,kBAAZ,CAA9B,EAAiE;AAChE,WAAKN,YAAL,CAAkBO,GAAlB,CAAuBJ,OAAvB,EAAgC,IAAhC;;AAEA;AACA,KAR0B,CAU3B;;;AACA,QAAK,CAAC,KAAKH,YAAL,CAAkBQ,GAAlB,CAAuBL,OAAvB,CAAN,EAAyC;AACxCE,MAAAA,kBAAkB,GAAG,IAAII,sBAAJ,CAA4BN,OAA5B,CAArB;;AACA,WAAKH,YAAL,CAAkBO,GAAlB,CAAuBJ,OAAvB,EAAgCE,kBAAhC;AACA,KAHD,MAGO;AACNA,MAAAA,kBAAkB,GAAG,KAAKL,YAAL,CAAkBU,GAAlB,CAAuBP,OAAvB,CAArB;AACA;;AAEDE,IAAAA,kBAAkB,CAACH,GAAnB,CAAwBE,WAAxB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCO,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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/viewconsumable\n */\n\nimport { isArray } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Class used for handling consumption of view {@link module:engine/view/element~Element elements},\n * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.\n * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name\n * does not consume its attributes, classes and styles.\n * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.\n * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.\n * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.\n * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.\n *\n *\t\tviewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.\n *\t\tviewConsumable.add( textNode ); // Adds text node for consumption.\n *\t\tviewConsumable.add( docFragment ); // Adds document fragment for consumption.\n *\t\tviewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.\n *\t\tviewConsumable.test( textNode ); // Tests if text node can be consumed.\n *\t\tviewConsumable.test( docFragment ); // Tests if document fragment can be consumed.\n *\t\tviewConsumable.consume( element, { name: true }  ); // Consume element's name.\n *\t\tviewConsumable.consume( textNode ); // Consume text node.\n *\t\tviewConsumable.consume( docFragment ); // Consume document fragment.\n *\t\tviewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.\n *\t\tviewConsumable.revert( textNode ); // Revert already consumed text node.\n *\t\tviewConsumable.revert( docFragment ); // Revert already consumed document fragment.\n */\nexport default class ViewConsumable {\n\t/**\n\t * Creates new ViewConsumable.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,\n\t\t * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.\n\t\t * For {@link module:engine/view/text~Text text nodes} and\n\t\t * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}\n\t\t*/\n\t\tthis._consumables = new Map();\n\t}\n\n\t/**\n\t * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.\n\t *\n\t *\t\tviewConsumable.add( p, { name: true } ); // Adds element's name to consume.\n\t *\t\tviewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.\n\t *\t\tviewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // Adds element's style\n\t *\t\tviewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.\n\t *\t\tviewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.\n\t *\t\tviewConsumable.add( textNode ); // Adds text node to consume.\n\t *\t\tviewConsumable.add( docFragment ); // Adds document fragment to consume.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing actual style/class.\n\t *\n\t *\t\tviewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\tadd( element, consumables ) {\n\t\tlet elementConsumables;\n\n\t\t// For text nodes and document fragments just mark them as consumable.\n\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\tthis._consumables.set( element, true );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// For elements create new ViewElementConsumables or update already existing one.\n\t\tif ( !this._consumables.has( element ) ) {\n\t\t\telementConsumables = new ViewElementConsumables( element );\n\t\t\tthis._consumables.set( element, elementConsumables );\n\t\t} else {\n\t\t\telementConsumables = this._consumables.get( element );\n\t\t}\n\n\t\telementConsumables.add( consumables );\n\t}\n\n\t/**\n\t * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.\n\t * It returns `true` when all items included in method's call can be consumed. Returns `false` when\n\t * first already consumed item is found and `null` when first non-consumable item is found.\n\t *\n\t *\t\tviewConsumable.test( p, { name: true } ); // Tests element's name.\n\t *\t\tviewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.\n\t *\t\tviewConsumable.test( p, { classes: 'foobar' } ); // Tests class.\n\t *\t\tviewConsumable.test( p, { styles: 'color' } ); // Tests style.\n\t *\t\tviewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.\n\t *\t\tviewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.\n\t *\t\tviewConsumable.test( textNode ); // Tests text node.\n\t *\t\tviewConsumable.test( docFragment ); // Tests document fragment.\n\t *\n\t * Testing classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.\n\t *\t\tviewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`\n\t * when first already consumed item is found and `null` when first non-consumable item is found.\n\t */\n\ttest( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// For text nodes and document fragments return stored boolean value.\n\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\treturn elementConsumables;\n\t\t}\n\n\t\t// For elements test consumables object.\n\t\treturn elementConsumables.test( consumables );\n\t}\n\n\t/**\n\t * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.\n\t *\n\t *\t\tviewConsumable.consume( p, { name: true } ); // Consumes element's name.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.\n\t *\t\tviewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.\n\t *\t\tviewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.\n\t *\t\tviewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.\n\t *\t\tviewConsumable.consume( textNode ); // Consumes text node.\n\t *\t\tviewConsumable.consume( docFragment ); // Consumes document fragment.\n\t *\n\t * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.\n\t *\t\tviewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,\n\t * otherwise returns `false`.\n\t */\n\tconsume( element, consumables ) {\n\t\tif ( this.test( element, consumables ) ) {\n\t\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments set value to false.\n\t\t\t\tthis._consumables.set( element, false );\n\t\t\t} else {\n\t\t\t\t// For elements - consume consumables object.\n\t\t\t\tthis._consumables.get( element ).consume( consumables );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.\n\t * Method does not revert items that were never previously added for consumption, even if they are included in\n\t * method's call.\n\t *\n\t *\t\tviewConsumable.revert( p, { name: true } ); // Reverts element's name.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.\n\t *\t\tviewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.\n\t *\t\tviewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.\n\t *\t\tviewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.\n\t *\t\tviewConsumable.revert( textNode ); // Reverts text node.\n\t *\t\tviewConsumable.revert( docFragment ); // Reverts document fragment.\n\t *\n\t * Reverting classes and styles as attribute will revert all classes/styles that were previously added for\n\t * consumption.\n\t *\n\t *\t\tviewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.\n\t *\t\tviewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\trevert( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables !== undefined ) {\n\t\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments - set consumable to true.\n\t\t\t\tthis._consumables.set( element, true );\n\t\t\t} else {\n\t\t\t\t// For elements - revert items from consumables object.\n\t\t\t\telementConsumables.revert( consumables );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include\n\t * element's name and all its attributes, classes and styles.\n\t *\n\t * @static\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Object} consumables\n\t */\n\tstatic consumablesFromElement( element ) {\n\t\tconst consumables = {\n\t\t\telement,\n\t\t\tname: true,\n\t\t\tattributes: [],\n\t\t\tclasses: [],\n\t\t\tstyles: []\n\t\t};\n\n\t\tconst attributes = element.getAttributeKeys();\n\n\t\tfor ( const attribute of attributes ) {\n\t\t\t// Skip classes and styles - will be added separately.\n\t\t\tif ( attribute == 'style' || attribute == 'class' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconsumables.attributes.push( attribute );\n\t\t}\n\n\t\tconst classes = element.getClassNames();\n\n\t\tfor ( const className of classes ) {\n\t\t\tconsumables.classes.push( className );\n\t\t}\n\n\t\tconst styles = element.getStyleNames();\n\n\t\tfor ( const style of styles ) {\n\t\t\tconsumables.styles.push( style );\n\t\t}\n\n\t\treturn consumables;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from\n\t * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.\n\t *\n\t * @static\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n\t * from which `ViewConsumable` will be created.\n\t * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used\n\t * to add all consumables. It will be returned instead of a new instance.\n\t */\n\tstatic createFrom( from, instance ) {\n\t\tif ( !instance ) {\n\t\t\tinstance = new ViewConsumable( from );\n\t\t}\n\n\t\tif ( from.is( '$text' ) ) {\n\t\t\tinstance.add( from );\n\n\t\t\treturn instance;\n\t\t}\n\n\t\t// Add `from` itself, if it is an element.\n\t\tif ( from.is( 'element' ) ) {\n\t\t\tinstance.add( from, ViewConsumable.consumablesFromElement( from ) );\n\t\t}\n\n\t\tif ( from.is( 'documentFragment' ) ) {\n\t\t\tinstance.add( from );\n\t\t}\n\n\t\tfor ( const child of from.getChildren() ) {\n\t\t\tinstance = ViewConsumable.createFrom( child, instance );\n\t\t}\n\n\t\treturn instance;\n\t}\n}\n\n/**\n * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.\n * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.\n *\n * @private\n */\nclass ViewElementConsumables {\n\t/**\n\t * Creates ViewElementConsumables instance.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n\t * from which `ViewElementConsumables` is being created.\n\t */\n\tconstructor( from ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t\t */\n\t\tthis.element = from;\n\n\t\t/**\n\t\t * Flag indicating if name of the element can be consumed.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._canConsumeName = null;\n\n\t\t/**\n\t\t * Contains maps of element's consumables: attributes, classes and styles.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._consumables = {\n\t\t\tattributes: new Map(),\n\t\t\tstyles: new Map(),\n\t\t\tclasses: new Map()\n\t\t};\n\t}\n\n\t/**\n\t * Adds consumable parts of the {@link module:engine/view/element~Element view element}.\n\t * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and\n\t * styles still could be consumed):\n\t *\n\t *\t\tconsumables.add( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.\n\t *\n\t * @param {Object} consumables Object describing which parts of the element can be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.\n\t */\n\tadd( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._add( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.\n\t *\n\t * Element's name can be tested:\n\t *\n\t *\t\tconsumables.test( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be tested.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be tested.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.\n\t * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items\n\t * was never marked for consumption and `false` when even one of the items was already consumed.\n\t */\n\ttest( consumables ) {\n\t\t// Check if name can be consumed.\n\t\tif ( consumables.name && !this._canConsumeName ) {\n\t\t\treturn this._canConsumeName;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tconst value = this._test( type, consumables[ type ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return true only if all can be consumed.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item\n\t * is already consumed - it consumes all consumable items provided.\n\t * Element's name can be consumed:\n\t *\n\t *\t\tconsumables.consume( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be consumed.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.\n\t */\n\tconsume( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = false;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._consume( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.\n\t * Element's name can be reverted:\n\t *\n\t *\t\tconsumables.revert( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be reverted.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be reverted.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.\n\t */\n\trevert( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._revert( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that adds consumables of a given type: attribute, class or style.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * type is provided - it should be handled separately by providing actual style/class type.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_add( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Class and style attributes should be handled separately in\n\t\t\t\t * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.\n\t\t\t\t *\n\t\t\t\t * What you have done is trying to use:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { attributes: [ 'class', 'style' ] } );\n\t\t\t\t *\n\t\t\t\t * While each class and style should be registered separately:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { classes: 'some-class', styles: 'font-weight' } );\n\t\t\t\t *\n\t\t\t\t * @error viewconsumable-invalid-attribute\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'viewconsumable-invalid-attribute', this );\n\t\t\t}\n\n\t\t\tconsumables.set( name, true );\n\n\t\t\tif ( type === 'styles' ) {\n\t\t\t\tfor ( const alsoName of this.element.document.stylesProcessor.getRelatedStyles( name ) ) {\n\t\t\t\t\tconsumables.set( alsoName, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that tests consumables of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be\n\t * consumed and `false` when one of the items is already consumed.\n\t */\n\t_test( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// Check all classes/styles if class/style attribute is tested.\n\t\t\t\tconst value = this._test( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\t\t\t\t// Return null if attribute is not found.\n\t\t\t\tif ( value === undefined ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif ( !value ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper method that consumes items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_consume( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for consumption - consume them all.\n\t\t\t\tthis._consume( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconsumables.set( name, false );\n\n\t\t\t\tif ( type == 'styles' ) {\n\t\t\t\t\tfor ( const toConsume of this.element.document.stylesProcessor.getRelatedStyles( name ) ) {\n\t\t\t\t\t\tconsumables.set( toConsume, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that reverts items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_revert( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for reverting - revert them all.\n\t\t\t\tthis._revert( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\n\t\t\t\tif ( value === false ) {\n\t\t\t\t\tconsumables.set( name, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}