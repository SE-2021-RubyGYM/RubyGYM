{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/utils\n */\nimport Node from '../node';\nimport Text from '../text';\nimport TextProxy from '../textproxy';\nimport Range from '../range';\nimport DocumentFragment from '../documentfragment';\nimport NodeList from '../nodelist';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n\n/**\n * Inserts given nodes at given position.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\n\nexport function _insert(position, nodes) {\n  nodes = _normalizeNodes(nodes); // We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n\n  const offset = nodes.reduce((sum, node) => sum + node.offsetSize, 0);\n  const parent = position.parent; // Insertion might be in a text node, we should split it if that's the case.\n\n  _splitNodeAtPosition(position);\n\n  const index = position.index; // Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n  // using basic `Element` API.\n\n  parent._insertChild(index, nodes); // Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n\n\n  _mergeNodesAtIndex(parent, index + nodes.length);\n\n  _mergeNodesAtIndex(parent, index);\n\n  return new Range(position, position.getShiftedBy(offset));\n}\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\n\nexport function _remove(range) {\n  if (!range.isFlat) {\n    /**\n     * Trying to remove a range which starts and ends in different element.\n     *\n     * @error operation-utils-remove-range-not-flat\n     */\n    throw new CKEditorError('operation-utils-remove-range-not-flat', this);\n  }\n\n  const parent = range.start.parent; // Range may be inside text nodes, we have to split them if that's the case.\n\n  _splitNodeAtPosition(range.start);\n\n  _splitNodeAtPosition(range.end); // Remove the text nodes using basic `Element` API.\n\n\n  const removed = parent._removeChildren(range.start.index, range.end.index - range.start.index); // Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n  // touching at the position equal to the removed range beginning. We check merging possibility there.\n\n\n  _mergeNodesAtIndex(parent, range.start.index);\n\n  return removed;\n}\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\n\nexport function _move(sourceRange, targetPosition) {\n  if (!sourceRange.isFlat) {\n    /**\n     * Trying to move a range which starts and ends in different element.\n     *\n     * @error operation-utils-move-range-not-flat\n     */\n    throw new CKEditorError('operation-utils-move-range-not-flat', this);\n  }\n\n  const nodes = _remove(sourceRange); // We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n  // that change might have an impact on `targetPosition`.\n\n\n  targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);\n  return _insert(targetPosition, nodes);\n}\n/**\n * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\n\nexport function _setAttribute(range, key, value) {\n  // Range might start or end in text nodes, so we have to split them.\n  _splitNodeAtPosition(range.start);\n\n  _splitNodeAtPosition(range.end); // Iterate over all items in the range.\n\n\n  for (const item of range.getItems({\n    shallow: true\n  })) {\n    // Iterator will return `TextProxy` instances but we know that those text proxies will\n    // always represent full text nodes (this is guaranteed thanks to splitting we did before).\n    // So, we can operate on those text proxies' text nodes.\n    const node = item.is('$textProxy') ? item.textNode : item;\n\n    if (value !== null) {\n      node._setAttribute(key, value);\n    } else {\n      node._removeAttribute(key);\n    } // After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n\n\n    _mergeNodesAtIndex(node.parent, node.index);\n  } // Try to merge last changed node with it's previous sibling (not covered by the loop above).\n\n\n  _mergeNodesAtIndex(range.end.parent, range.end.index);\n}\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\n\nexport function _normalizeNodes(nodes) {\n  const normalized = [];\n\n  if (!(nodes instanceof Array)) {\n    nodes = [nodes];\n  } // Convert instances of classes other than Node.\n\n\n  for (let i = 0; i < nodes.length; i++) {\n    if (typeof nodes[i] == 'string') {\n      normalized.push(new Text(nodes[i]));\n    } else if (nodes[i] instanceof TextProxy) {\n      normalized.push(new Text(nodes[i].data, nodes[i].getAttributes()));\n    } else if (nodes[i] instanceof DocumentFragment || nodes[i] instanceof NodeList) {\n      for (const child of nodes[i]) {\n        normalized.push(child);\n      }\n    } else if (nodes[i] instanceof Node) {\n      normalized.push(nodes[i]);\n    } // Skip unrecognized type.\n\n  } // Merge text nodes.\n\n\n  for (let i = 1; i < normalized.length; i++) {\n    const node = normalized[i];\n    const prev = normalized[i - 1];\n\n    if (node instanceof Text && prev instanceof Text && _haveSameAttributes(node, prev)) {\n      // Doing this instead changing `prev.data` because `data` is readonly.\n      normalized.splice(i - 1, 2, new Text(prev.data + node.data, prev.getAttributes()));\n      i--;\n    }\n  }\n\n  return normalized;\n} // Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n// merges them into one node if they have same attributes.\n//\n// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n//\n// @private\n// @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n// @param {Number} index Index between nodes to merge.\n\nfunction _mergeNodesAtIndex(element, index) {\n  const nodeBefore = element.getChild(index - 1);\n  const nodeAfter = element.getChild(index); // Check if both of those nodes are text objects with same attributes.\n\n  if (nodeBefore && nodeAfter && nodeBefore.is('$text') && nodeAfter.is('$text') && _haveSameAttributes(nodeBefore, nodeAfter)) {\n    // Append text of text node after index to the before one.\n    const mergedNode = new Text(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes()); // Remove separate text nodes.\n\n    element._removeChildren(index - 1, 2); // Insert merged text node.\n\n\n    element._insertChild(index - 1, mergedNode);\n  }\n} // Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n// containing a part of original text node.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position at which node should be split.\n\n\nfunction _splitNodeAtPosition(position) {\n  const textNode = position.textNode;\n  const element = position.parent;\n\n  if (textNode) {\n    const offsetDiff = position.offset - textNode.startOffset;\n    const index = textNode.index;\n\n    element._removeChildren(index, 1);\n\n    const firstPart = new Text(textNode.data.substr(0, offsetDiff), textNode.getAttributes());\n    const secondPart = new Text(textNode.data.substr(offsetDiff), textNode.getAttributes());\n\n    element._insertChild(index, [firstPart, secondPart]);\n  }\n} // Checks whether two given nodes have same attributes.\n//\n// @private\n// @param {module:engine/model/node~Node} nodeA Node to check.\n// @param {module:engine/model/node~Node} nodeB Node to check.\n// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\n\n\nfunction _haveSameAttributes(nodeA, nodeB) {\n  const iteratorA = nodeA.getAttributes();\n  const iteratorB = nodeB.getAttributes();\n\n  for (const attr of iteratorA) {\n    if (attr[1] !== nodeB.getAttribute(attr[0])) {\n      return false;\n    }\n\n    iteratorB.next();\n  }\n\n  return iteratorB.next().done;\n}\n/**\n * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.\n *\n * Non-arrays are normalized as follows:\n * * {@link module:engine/model/node~Node Node} is left as is,\n * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},\n * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,\n * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's\n * * children.\n *\n * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in\n * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be\n * merged if they have same attributes.\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|\n * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}\n * module:engine/model/node~NodeSet\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js"],"names":["Node","Text","TextProxy","Range","DocumentFragment","NodeList","CKEditorError","_insert","position","nodes","_normalizeNodes","offset","reduce","sum","node","offsetSize","parent","_splitNodeAtPosition","index","_insertChild","_mergeNodesAtIndex","length","getShiftedBy","_remove","range","isFlat","start","end","removed","_removeChildren","_move","sourceRange","targetPosition","_getTransformedByDeletion","_setAttribute","key","value","item","getItems","shallow","is","textNode","_removeAttribute","normalized","Array","i","push","data","getAttributes","child","prev","_haveSameAttributes","splice","element","nodeBefore","getChild","nodeAfter","mergedNode","offsetDiff","startOffset","firstPart","substr","secondPart","nodeA","nodeB","iteratorA","iteratorB","attr","getAttribute","next","done"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/utils\n */\n\nimport Node from '../node';\nimport Text from '../text';\nimport TextProxy from '../textproxy';\nimport Range from '../range';\nimport DocumentFragment from '../documentfragment';\nimport NodeList from '../nodelist';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n\n/**\n * Inserts given nodes at given position.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\nexport function _insert( position, nodes ) {\n\tnodes = _normalizeNodes( nodes );\n\n\t// We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n\tconst offset = nodes.reduce( ( sum, node ) => sum + node.offsetSize, 0 );\n\tconst parent = position.parent;\n\n\t// Insertion might be in a text node, we should split it if that's the case.\n\t_splitNodeAtPosition( position );\n\tconst index = position.index;\n\n\t// Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n\t// using basic `Element` API.\n\tparent._insertChild( index, nodes );\n\n\t// Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n\t_mergeNodesAtIndex( parent, index + nodes.length );\n\t_mergeNodesAtIndex( parent, index );\n\n\treturn new Range( position, position.getShiftedBy( offset ) );\n}\n\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\nexport function _remove( range ) {\n\tif ( !range.isFlat ) {\n\t\t/**\n\t\t * Trying to remove a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-remove-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'operation-utils-remove-range-not-flat',\n\t\t\tthis\n\t\t);\n\t}\n\n\tconst parent = range.start.parent;\n\n\t// Range may be inside text nodes, we have to split them if that's the case.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Remove the text nodes using basic `Element` API.\n\tconst removed = parent._removeChildren( range.start.index, range.end.index - range.start.index );\n\n\t// Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n\t// touching at the position equal to the removed range beginning. We check merging possibility there.\n\t_mergeNodesAtIndex( parent, range.start.index );\n\n\treturn removed;\n}\n\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\nexport function _move( sourceRange, targetPosition ) {\n\tif ( !sourceRange.isFlat ) {\n\t\t/**\n\t\t * Trying to move a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-move-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'operation-utils-move-range-not-flat',\n\t\t\tthis\n\t\t);\n\t}\n\n\tconst nodes = _remove( sourceRange );\n\n\t// We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n\t// that change might have an impact on `targetPosition`.\n\ttargetPosition = targetPosition._getTransformedByDeletion( sourceRange.start, sourceRange.end.offset - sourceRange.start.offset );\n\n\treturn _insert( targetPosition, nodes );\n}\n\n/**\n * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\nexport function _setAttribute( range, key, value ) {\n\t// Range might start or end in text nodes, so we have to split them.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Iterate over all items in the range.\n\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t// Iterator will return `TextProxy` instances but we know that those text proxies will\n\t\t// always represent full text nodes (this is guaranteed thanks to splitting we did before).\n\t\t// So, we can operate on those text proxies' text nodes.\n\t\tconst node = item.is( '$textProxy' ) ? item.textNode : item;\n\n\t\tif ( value !== null ) {\n\t\t\tnode._setAttribute( key, value );\n\t\t} else {\n\t\t\tnode._removeAttribute( key );\n\t\t}\n\n\t\t// After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n\t\t_mergeNodesAtIndex( node.parent, node.index );\n\t}\n\n\t// Try to merge last changed node with it's previous sibling (not covered by the loop above).\n\t_mergeNodesAtIndex( range.end.parent, range.end.index );\n}\n\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\nexport function _normalizeNodes( nodes ) {\n\tconst normalized = [];\n\n\tif ( !( nodes instanceof Array ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Convert instances of classes other than Node.\n\tfor ( let i = 0; i < nodes.length; i++ ) {\n\t\tif ( typeof nodes[ i ] == 'string' ) {\n\t\t\tnormalized.push( new Text( nodes[ i ] ) );\n\t\t} else if ( nodes[ i ] instanceof TextProxy ) {\n\t\t\tnormalized.push( new Text( nodes[ i ].data, nodes[ i ].getAttributes() ) );\n\t\t} else if ( nodes[ i ] instanceof DocumentFragment || nodes[ i ] instanceof NodeList ) {\n\t\t\tfor ( const child of nodes[ i ] ) {\n\t\t\t\tnormalized.push( child );\n\t\t\t}\n\t\t} else if ( nodes[ i ] instanceof Node ) {\n\t\t\tnormalized.push( nodes[ i ] );\n\t\t}\n\t\t// Skip unrecognized type.\n\t}\n\n\t// Merge text nodes.\n\tfor ( let i = 1; i < normalized.length; i++ ) {\n\t\tconst node = normalized[ i ];\n\t\tconst prev = normalized[ i - 1 ];\n\n\t\tif ( node instanceof Text && prev instanceof Text && _haveSameAttributes( node, prev ) ) {\n\t\t\t// Doing this instead changing `prev.data` because `data` is readonly.\n\t\t\tnormalized.splice( i - 1, 2, new Text( prev.data + node.data, prev.getAttributes() ) );\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn normalized;\n}\n\n// Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n// merges them into one node if they have same attributes.\n//\n// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n//\n// @private\n// @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n// @param {Number} index Index between nodes to merge.\nfunction _mergeNodesAtIndex( element, index ) {\n\tconst nodeBefore = element.getChild( index - 1 );\n\tconst nodeAfter = element.getChild( index );\n\n\t// Check if both of those nodes are text objects with same attributes.\n\tif ( nodeBefore && nodeAfter && nodeBefore.is( '$text' ) && nodeAfter.is( '$text' ) && _haveSameAttributes( nodeBefore, nodeAfter ) ) {\n\t\t// Append text of text node after index to the before one.\n\t\tconst mergedNode = new Text( nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes() );\n\n\t\t// Remove separate text nodes.\n\t\telement._removeChildren( index - 1, 2 );\n\n\t\t// Insert merged text node.\n\t\telement._insertChild( index - 1, mergedNode );\n\t}\n}\n\n// Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n// containing a part of original text node.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position at which node should be split.\nfunction _splitNodeAtPosition( position ) {\n\tconst textNode = position.textNode;\n\tconst element = position.parent;\n\n\tif ( textNode ) {\n\t\tconst offsetDiff = position.offset - textNode.startOffset;\n\t\tconst index = textNode.index;\n\n\t\telement._removeChildren( index, 1 );\n\n\t\tconst firstPart = new Text( textNode.data.substr( 0, offsetDiff ), textNode.getAttributes() );\n\t\tconst secondPart = new Text( textNode.data.substr( offsetDiff ), textNode.getAttributes() );\n\n\t\telement._insertChild( index, [ firstPart, secondPart ] );\n\t}\n}\n\n// Checks whether two given nodes have same attributes.\n//\n// @private\n// @param {module:engine/model/node~Node} nodeA Node to check.\n// @param {module:engine/model/node~Node} nodeB Node to check.\n// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\nfunction _haveSameAttributes( nodeA, nodeB ) {\n\tconst iteratorA = nodeA.getAttributes();\n\tconst iteratorB = nodeB.getAttributes();\n\n\tfor ( const attr of iteratorA ) {\n\t\tif ( attr[ 1 ] !== nodeB.getAttribute( attr[ 0 ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\titeratorB.next();\n\t}\n\n\treturn iteratorB.next().done;\n}\n\n/**\n * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.\n *\n * Non-arrays are normalized as follows:\n * * {@link module:engine/model/node~Node Node} is left as is,\n * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},\n * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,\n * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's\n * * children.\n *\n * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in\n * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be\n * merged if they have same attributes.\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|\n * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}\n * module:engine/model/node~NodeSet\n */\n"]},"metadata":{},"sourceType":"module"}