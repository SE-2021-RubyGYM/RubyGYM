{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** If there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n */\n\nexport default function deleteContent(model, selection) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (selection.isCollapsed) {\n    return;\n  }\n\n  const selRange = selection.getFirstRange(); // If the selection is already removed, don't do anything.\n\n  if (selRange.root.rootName == '$graveyard') {\n    return;\n  }\n\n  const schema = model.schema;\n  model.change(writer => {\n    // 1. Replace the entire content with paragraph.\n    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n      replaceEntireContentWithParagraph(writer, selection, schema);\n      return;\n    } // Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\n\n    const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange); // 2. Remove the content if there is any.\n\n    if (!startPosition.isTouching(endPosition)) {\n      writer.remove(writer.createRange(startPosition, endPosition));\n    } // 3. Merge elements in the right branch to the elements in the left branch.\n    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n    //\n    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n    //\n    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n    // want to override that behavior anyway.\n\n\n    if (!options.leaveUnmerged) {\n      mergeBranches(writer, startPosition, endPosition); // TMP this will be replaced with a postfixer.\n      // We need to check and strip disallowed attributes in all nested nodes because after merge\n      // some attributes could end up in a path where are disallowed.\n      //\n      // e.g. bold is disallowed for <H1>\n      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\n      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);\n    }\n\n    collapseSelectionAt(writer, selection, startPosition); // 4. Add a paragraph to set selection in it.\n    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n    // If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\n    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {\n      insertParagraph(writer, startPosition, selection);\n    }\n\n    startPosition.detach();\n    endPosition.detach();\n  });\n} // Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\n\nfunction getLivePositionsForSelectedBlocks(range) {\n  const model = range.root.document.model;\n  const startPosition = range.start;\n  let endPosition = range.end; // If the end of selection is at the start position of last block in the selection, then\n  // shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\n  if (model.hasContent(range, {\n    ignoreMarkers: true\n  })) {\n    const endBlock = getParentBlock(endPosition);\n\n    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {\n      // Create forward selection as a probe to find a valid position after excluding last block from the range.\n      const selection = model.createSelection(range); // Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n      // This is how modifySelection works and here we are making use of it.\n\n      model.modifySelection(selection, {\n        direction: 'backward'\n      });\n      const newEndPosition = selection.getLastPosition(); // For such a model and selection:\n      //     <paragraph>A[</paragraph><imageBlock></imageBlock><paragraph>]B</paragraph>\n      //\n      // After modifySelection(), we would end up with this:\n      //     <paragraph>A[</paragraph>]<imageBlock></imageBlock><paragraph>B</paragraph>\n      //\n      // So we need to check if there is no content in the skipped range (because we want to include the <imageBlock>).\n\n      const skippedRange = model.createRange(newEndPosition, endPosition);\n\n      if (!model.hasContent(skippedRange, {\n        ignoreMarkers: true\n      })) {\n        endPosition = newEndPosition;\n      }\n    }\n  }\n\n  return [LivePosition.fromPosition(startPosition, 'toPrevious'), LivePosition.fromPosition(endPosition, 'toNext')];\n} // Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\n\n\nfunction getParentBlock(position) {\n  const element = position.parent;\n  const schema = element.root.document.model.schema;\n  const ancestors = element.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n\n  for (const element of ancestors) {\n    if (schema.isLimit(element)) {\n      return null;\n    }\n\n    if (schema.isBlock(element)) {\n      return element;\n    }\n  }\n} // This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\n\n\nfunction mergeBranches(writer, startPosition, endPosition) {\n  const model = writer.model; // Verify if there is a need and possibility to merge.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n  // then merge those to the right element so that it's properties are preserved (name, attributes).\n  // Because of OT merging is used instead of removing elements.\n  //\n  // Merge left:\n  //     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n  //     <paragraph>]bar</paragraph>  ->               --^\n  //\n  // Merge right:\n  //     <heading1>[</heading1>       ->\n  //     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n  //\n  // Merge left:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n  //         <paragraph>]bar</paragraph>  ->                   --^\n  //     </blockQuote>                    ->  </blockQuote>\n  //\n  // Merge right:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>[</heading1>       ->\n  //         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n  //     </blockQuote>                    ->  </blockQuote>\n  // Merging should not go deeper than common ancestor.\n\n\n  const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition); // Branches can't be merged if one of the positions is directly inside a common ancestor.\n  //\n  // Example:\n  //     <blockQuote>\n  //         <paragraph>[foo</paragraph>]\n  //         <table> ... </table>\n  //     <blockQuote>\n  //\n\n  if (!startAncestor || !endAncestor) {\n    return;\n  }\n\n  if (!model.hasContent(startAncestor, {\n    ignoreMarkers: true\n  }) && model.hasContent(endAncestor, {\n    ignoreMarkers: true\n  })) {\n    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);\n  } else {\n    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);\n  }\n} // Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\n\n\nfunction mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move endElement just after startElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n    //     </blockQuote>                    ->  </blockQuote>                ^\n    //     <blockBlock>                     ->  <blockBlock>                 |\n    //         <paragraph>]bar</paragraph>  ->      ]                     ---\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(endElement, startPosition);\n  } // Merge two siblings (nodes on sides of startPosition):\n  //\n  //     <blockQuote>                                             ->  <blockQuote>\n  //         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                                            ->  </blockQuote>\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         ]                                                    ->      ]\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n  //\n\n\n  writer.merge(startPosition); // Remove empty end ancestors:\n  //\n  //     <blockQuote>                      ->  <blockQuote>\n  //         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                     ->  </blockQuote>\n  //     <blockBlock>                      ->\n  //         ]                             ->  ]\n  //     </blockBlock>                     ->\n  //\n\n  while (endPosition.parent.isEmpty) {\n    const parentToRemove = endPosition.parent;\n    endPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Verify if there is a need and possibility to merge next level.\n\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);\n} // Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\n\n\nfunction mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move startElement just before endElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      [                   ---\n    //     </blockQuote>                    ->  </blockQuote>              |\n    //     <blockBlock>                     ->  <blockBlock>               v\n    //         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(startElement, endPosition);\n  } // Remove empty end ancestors:\n  //\n  //     <blockQuote>                                             ->\n  //         [                                                    ->  [\n  //     </blockQuote>                                            ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n\n\n  while (startPosition.parent.isEmpty) {\n    const parentToRemove = startPosition.parent;\n    startPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Update endPosition after inserting and removing elements.\n\n\n  endPosition = writer.createPositionBefore(endElement); // Merge right two siblings (nodes on sides of endPosition):\n  //                                                              ->\n  //     [                                                        ->  [\n  //                                                              ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n  //\n\n  mergeRight(writer, endPosition); // Verify if there is a need and possibility to merge next level.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);\n} // There is no right merge operation so we need to simulate it.\n\n\nfunction mergeRight(writer, position) {\n  const startElement = position.nodeBefore;\n  const endElement = position.nodeAfter;\n\n  if (startElement.name != endElement.name) {\n    writer.rename(startElement, endElement.name);\n  }\n\n  writer.clearAttributes(startElement);\n  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);\n  writer.merge(position);\n} // Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\n\n\nfunction checkShouldMerge(schema, startPosition, endPosition) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // If both positions ended up in the same parent, then there's nothing more to merge:\n  // <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\n  if (startElement == endElement) {\n    return false;\n  } // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\n\n  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {\n    return false;\n  } // Check if operations we'll need to do won't need to cross object or limit boundaries.\n  // E.g., we can't merge endElement into startElement in this case:\n  // <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\n\n  return isCrossingLimitElement(startPosition, endPosition, schema);\n} // Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\n\n\nfunction getAncestorsJustBelowCommonAncestor(positionA, positionB) {\n  const ancestorsA = positionA.getAncestors();\n  const ancestorsB = positionB.getAncestors();\n  let i = 0;\n\n  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {\n    i++;\n  }\n\n  return [ancestorsA[i], ancestorsB[i]];\n}\n\nfunction shouldAutoparagraph(schema, position) {\n  const isTextAllowed = schema.checkChild(position, '$text');\n  const isParagraphAllowed = schema.checkChild(position, 'paragraph');\n  return !isTextAllowed && isParagraphAllowed;\n} // Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\n\n\nfunction isCrossingLimitElement(leftPos, rightPos, schema) {\n  const rangeToCheck = new Range(leftPos, rightPos);\n\n  for (const value of rangeToCheck.getWalker()) {\n    if (schema.isLimit(value.item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction insertParagraph(writer, position, selection) {\n  const paragraph = writer.createElement('paragraph');\n  writer.insert(paragraph, position);\n  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\n\nfunction replaceEntireContentWithParagraph(writer, selection) {\n  const limitElement = writer.model.schema.getLimitElement(selection);\n  writer.remove(writer.createRangeIn(limitElement));\n  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n} // We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\n\n\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n  const limitElement = schema.getLimitElement(selection);\n\n  if (!selection.containsEntireContent(limitElement)) {\n    return false;\n  }\n\n  const range = selection.getFirstRange();\n\n  if (range.start.parent == range.end.parent) {\n    return false;\n  }\n\n  return schema.checkChild(limitElement, 'paragraph');\n} // Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\n\n\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n  if (selection instanceof DocumentSelection) {\n    writer.setSelection(positionOrRange);\n  } else {\n    selection.setTo(positionOrRange);\n  }\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js"],"names":["LivePosition","Range","DocumentSelection","deleteContent","model","selection","options","isCollapsed","selRange","getFirstRange","root","rootName","schema","change","writer","doNotResetEntireContent","shouldEntireContentBeReplacedWithParagraph","replaceEntireContentWithParagraph","startPosition","endPosition","getLivePositionsForSelectedBlocks","isTouching","remove","createRange","leaveUnmerged","mergeBranches","removeDisallowedAttributes","parent","getChildren","collapseSelectionAt","doNotAutoparagraph","shouldAutoparagraph","insertParagraph","detach","range","document","start","end","hasContent","ignoreMarkers","endBlock","getParentBlock","createPositionAt","createSelection","modifySelection","direction","newEndPosition","getLastPosition","skippedRange","fromPosition","position","element","ancestors","getAncestors","parentFirst","includeSelf","isLimit","isBlock","checkShouldMerge","startAncestor","endAncestor","getAncestorsJustBelowCommonAncestor","mergeBranchesRight","mergeBranchesLeft","commonAncestor","startElement","endElement","createPositionAfter","createPositionBefore","isEqual","insert","merge","isEmpty","parentToRemove","mergeRight","nodeBefore","nodeAfter","name","rename","clearAttributes","setAttributes","Object","fromEntries","getAttributes","isCrossingLimitElement","positionA","positionB","ancestorsA","ancestorsB","i","isTextAllowed","checkChild","isParagraphAllowed","leftPos","rightPos","rangeToCheck","value","getWalker","item","paragraph","createElement","limitElement","getLimitElement","createRangeIn","containsEntireContent","positionOrRange","setSelection","setTo"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\n\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** If there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n */\nexport default function deleteContent( model, selection, options = {} ) {\n\tif ( selection.isCollapsed ) {\n\t\treturn;\n\t}\n\n\tconst selRange = selection.getFirstRange();\n\n\t// If the selection is already removed, don't do anything.\n\tif ( selRange.root.rootName == '$graveyard' ) {\n\t\treturn;\n\t}\n\n\tconst schema = model.schema;\n\n\tmodel.change( writer => {\n\t\t// 1. Replace the entire content with paragraph.\n\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n\t\tif ( !options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph( schema, selection ) ) {\n\t\t\treplaceEntireContentWithParagraph( writer, selection, schema );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\t\tconst [ startPosition, endPosition ] = getLivePositionsForSelectedBlocks( selRange );\n\n\t\t// 2. Remove the content if there is any.\n\t\tif ( !startPosition.isTouching( endPosition ) ) {\n\t\t\twriter.remove( writer.createRange( startPosition, endPosition ) );\n\t\t}\n\n\t\t// 3. Merge elements in the right branch to the elements in the left branch.\n\t\t// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n\t\t//\n\t\t// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n\t\t//\n\t\t// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n\t\t// as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n\t\t// want to override that behavior anyway.\n\t\tif ( !options.leaveUnmerged ) {\n\t\t\tmergeBranches( writer, startPosition, endPosition );\n\n\t\t\t// TMP this will be replaced with a postfixer.\n\t\t\t// We need to check and strip disallowed attributes in all nested nodes because after merge\n\t\t\t// some attributes could end up in a path where are disallowed.\n\t\t\t//\n\t\t\t// e.g. bold is disallowed for <H1>\n\t\t\t// <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\t\t\tschema.removeDisallowedAttributes( startPosition.parent.getChildren(), writer );\n\t\t}\n\n\t\tcollapseSelectionAt( writer, selection, startPosition );\n\n\t\t// 4. Add a paragraph to set selection in it.\n\t\t// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\t\t// If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\t\tif ( !options.doNotAutoparagraph && shouldAutoparagraph( schema, startPosition ) ) {\n\t\t\tinsertParagraph( writer, startPosition, selection );\n\t\t}\n\n\t\tstartPosition.detach();\n\t\tendPosition.detach();\n\t} );\n}\n\n// Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\nfunction getLivePositionsForSelectedBlocks( range ) {\n\tconst model = range.root.document.model;\n\n\tconst startPosition = range.start;\n\tlet endPosition = range.end;\n\n\t// If the end of selection is at the start position of last block in the selection, then\n\t// shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\tif ( model.hasContent( range, { ignoreMarkers: true } ) ) {\n\t\tconst endBlock = getParentBlock( endPosition );\n\n\t\tif ( endBlock && endPosition.isTouching( model.createPositionAt( endBlock, 0 ) ) ) {\n\t\t\t// Create forward selection as a probe to find a valid position after excluding last block from the range.\n\t\t\tconst selection = model.createSelection( range );\n\n\t\t\t// Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n\t\t\t// This is how modifySelection works and here we are making use of it.\n\t\t\tmodel.modifySelection( selection, { direction: 'backward' } );\n\n\t\t\tconst newEndPosition = selection.getLastPosition();\n\n\t\t\t// For such a model and selection:\n\t\t\t//     <paragraph>A[</paragraph><imageBlock></imageBlock><paragraph>]B</paragraph>\n\t\t\t//\n\t\t\t// After modifySelection(), we would end up with this:\n\t\t\t//     <paragraph>A[</paragraph>]<imageBlock></imageBlock><paragraph>B</paragraph>\n\t\t\t//\n\t\t\t// So we need to check if there is no content in the skipped range (because we want to include the <imageBlock>).\n\t\t\tconst skippedRange = model.createRange( newEndPosition, endPosition );\n\n\t\t\tif ( !model.hasContent( skippedRange, { ignoreMarkers: true } ) ) {\n\t\t\t\tendPosition = newEndPosition;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [\n\t\tLivePosition.fromPosition( startPosition, 'toPrevious' ),\n\t\tLivePosition.fromPosition( endPosition, 'toNext' )\n\t];\n}\n\n// Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\nfunction getParentBlock( position ) {\n\tconst element = position.parent;\n\tconst schema = element.root.document.model.schema;\n\tconst ancestors = element.getAncestors( { parentFirst: true, includeSelf: true } );\n\n\tfor ( const element of ancestors ) {\n\t\tif ( schema.isLimit( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( schema.isBlock( element ) ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches( writer, startPosition, endPosition ) {\n\tconst model = writer.model;\n\n\t// Verify if there is a need and possibility to merge.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n\t// then merge those to the right element so that it's properties are preserved (name, attributes).\n\t// Because of OT merging is used instead of removing elements.\n\t//\n\t// Merge left:\n\t//     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n\t//     <paragraph>]bar</paragraph>  ->               --^\n\t//\n\t// Merge right:\n\t//     <heading1>[</heading1>       ->\n\t//     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n\t//\n\t// Merge left:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n\t//         <paragraph>]bar</paragraph>  ->                   --^\n\t//     </blockQuote>                    ->  </blockQuote>\n\t//\n\t// Merge right:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>[</heading1>       ->\n\t//         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n\t//     </blockQuote>                    ->  </blockQuote>\n\n\t// Merging should not go deeper than common ancestor.\n\tconst [ startAncestor, endAncestor ] = getAncestorsJustBelowCommonAncestor( startPosition, endPosition );\n\n\t// Branches can't be merged if one of the positions is directly inside a common ancestor.\n\t//\n\t// Example:\n\t//     <blockQuote>\n\t//         <paragraph>[foo</paragraph>]\n\t//         <table> ... </table>\n\t//     <blockQuote>\n\t//\n\tif ( !startAncestor || !endAncestor ) {\n\t\treturn;\n\t}\n\n\tif ( !model.hasContent( startAncestor, { ignoreMarkers: true } ) && model.hasContent( endAncestor, { ignoreMarkers: true } ) ) {\n\t\tmergeBranchesRight( writer, startPosition, endPosition, startAncestor.parent );\n\t} else {\n\t\tmergeBranchesLeft( writer, startPosition, endPosition, startAncestor.parent );\n\t}\n}\n\n// Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\nfunction mergeBranchesLeft( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move endElement just after startElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n\t\t//     </blockQuote>                    ->  </blockQuote>                ^\n\t\t//     <blockBlock>                     ->  <blockBlock>                 |\n\t\t//         <paragraph>]bar</paragraph>  ->      ]                     ---\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( endElement, startPosition );\n\t}\n\n\t// Merge two siblings (nodes on sides of startPosition):\n\t//\n\t//     <blockQuote>                                             ->  <blockQuote>\n\t//         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                                            ->  </blockQuote>\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         ]                                                    ->      ]\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n\t//\n\twriter.merge( startPosition );\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                      ->  <blockQuote>\n\t//         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                     ->  </blockQuote>\n\t//     <blockBlock>                      ->\n\t//         ]                             ->  ]\n\t//     </blockBlock>                     ->\n\t//\n\twhile ( endPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = endPosition.parent;\n\n\t\tendPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesLeft( writer, startPosition, endPosition, commonAncestor );\n}\n\n// Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\nfunction mergeBranchesRight( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move startElement just before endElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      [                   ---\n\t\t//     </blockQuote>                    ->  </blockQuote>              |\n\t\t//     <blockBlock>                     ->  <blockBlock>               v\n\t\t//         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( startElement, endPosition );\n\t}\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                                             ->\n\t//         [                                                    ->  [\n\t//     </blockQuote>                                            ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\twhile ( startPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = startPosition.parent;\n\n\t\tstartPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Update endPosition after inserting and removing elements.\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Merge right two siblings (nodes on sides of endPosition):\n\t//                                                              ->\n\t//     [                                                        ->  [\n\t//                                                              ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n\t//\n\tmergeRight( writer, endPosition );\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesRight( writer, startPosition, endPosition, commonAncestor );\n}\n\n// There is no right merge operation so we need to simulate it.\nfunction mergeRight( writer, position ) {\n\tconst startElement = position.nodeBefore;\n\tconst endElement = position.nodeAfter;\n\n\tif ( startElement.name != endElement.name ) {\n\t\twriter.rename( startElement, endElement.name );\n\t}\n\n\twriter.clearAttributes( startElement );\n\twriter.setAttributes( Object.fromEntries( endElement.getAttributes() ), startElement );\n\n\twriter.merge( position );\n}\n\n// Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\nfunction checkShouldMerge( schema, startPosition, endPosition ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// If both positions ended up in the same parent, then there's nothing more to merge:\n\t// <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\tif ( startElement == endElement ) {\n\t\treturn false;\n\t}\n\n\t// If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\tif ( schema.isLimit( startElement ) || schema.isLimit( endElement ) ) {\n\t\treturn false;\n\t}\n\n\t// Check if operations we'll need to do won't need to cross object or limit boundaries.\n\t// E.g., we can't merge endElement into startElement in this case:\n\t// <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\treturn isCrossingLimitElement( startPosition, endPosition, schema );\n}\n\n// Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\nfunction getAncestorsJustBelowCommonAncestor( positionA, positionB ) {\n\tconst ancestorsA = positionA.getAncestors();\n\tconst ancestorsB = positionB.getAncestors();\n\n\tlet i = 0;\n\n\twhile ( ancestorsA[ i ] && ancestorsA[ i ] == ancestorsB[ i ] ) {\n\t\ti++;\n\t}\n\n\treturn [ ancestorsA[ i ], ancestorsB[ i ] ];\n}\n\nfunction shouldAutoparagraph( schema, position ) {\n\tconst isTextAllowed = schema.checkChild( position, '$text' );\n\tconst isParagraphAllowed = schema.checkChild( position, 'paragraph' );\n\n\treturn !isTextAllowed && isParagraphAllowed;\n}\n\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction isCrossingLimitElement( leftPos, rightPos, schema ) {\n\tconst rangeToCheck = new Range( leftPos, rightPos );\n\n\tfor ( const value of rangeToCheck.getWalker() ) {\n\t\tif ( schema.isLimit( value.item ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction insertParagraph( writer, position, selection ) {\n\tconst paragraph = writer.createElement( 'paragraph' );\n\n\twriter.insert( paragraph, position );\n\n\tcollapseSelectionAt( writer, selection, writer.createPositionAt( paragraph, 0 ) );\n}\n\nfunction replaceEntireContentWithParagraph( writer, selection ) {\n\tconst limitElement = writer.model.schema.getLimitElement( selection );\n\n\twriter.remove( writer.createRangeIn( limitElement ) );\n\tinsertParagraph( writer, writer.createPositionAt( limitElement, 0 ), selection );\n}\n\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph( schema, selection ) {\n\tconst limitElement = schema.getLimitElement( selection );\n\n\tif ( !selection.containsEntireContent( limitElement ) ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getFirstRange();\n\n\tif ( range.start.parent == range.end.parent ) {\n\t\treturn false;\n\t}\n\n\treturn schema.checkChild( limitElement, 'paragraph' );\n}\n\n// Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\nfunction collapseSelectionAt( writer, selection, positionOrRange ) {\n\tif ( selection instanceof DocumentSelection ) {\n\t\twriter.setSelection( positionOrRange );\n\t} else {\n\t\tselection.setTo( positionOrRange );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}