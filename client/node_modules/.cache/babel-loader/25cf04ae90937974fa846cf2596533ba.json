{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/range\n */\nimport Position from './position';\nimport TreeWalker from './treewalker';\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\n\nexport default class Range {\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n   *\n   * @param {module:engine/view/position~Position} start Start position.\n   * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n   */\n  constructor(start) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    /**\n     * Start position.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position}\n     */\n    this.start = start.clone();\n    /**\n     * End position.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position}\n     */\n\n    this.end = end ? end.clone() : start.clone();\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n   * them together with additional information like length or {@link module:engine/view/position~Position positions},\n   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n   *\n   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n   * `ignoreElementEnd` option\n   * set to `true`.\n   *\n   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n   */\n\n\n  *[Symbol.iterator]() {\n    yield* new TreeWalker({\n      boundaries: this,\n      ignoreElementEnd: true\n    });\n  }\n  /**\n   * Returns whether the range is collapsed, that is it start and end positions are equal.\n   *\n   * @type {Boolean}\n   */\n\n\n  get isCollapsed() {\n    return this.start.isEqual(this.end);\n  }\n  /**\n   * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n   * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n   *\n   * @type {Boolean}\n   */\n\n\n  get isFlat() {\n    return this.start.parent === this.end.parent;\n  }\n  /**\n   * Range root element.\n   *\n   * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n   */\n\n\n  get root() {\n    return this.start.root;\n  }\n  /**\n   * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n   * and at the end).\n   *\n   * For example:\n   *\n   *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n   *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n   *\n   * Note that in the sample above:\n   *\n   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n   *\n   * @returns {module:engine/view/range~Range} Enlarged range.\n   */\n\n\n  getEnlarged() {\n    let start = this.start.getLastMatchingPosition(enlargeTrimSkip, {\n      direction: 'backward'\n    });\n    let end = this.end.getLastMatchingPosition(enlargeTrimSkip); // Fix positions, in case if they are in Text node.\n\n    if (start.parent.is('$text') && start.isAtStart) {\n      start = Position._createBefore(start.parent);\n    }\n\n    if (end.parent.is('$text') && end.isAtEnd) {\n      end = Position._createAfter(end.parent);\n    }\n\n    return new Range(start, end);\n  }\n  /**\n   * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n   * and at the end).\n   *\n   * For example:\n   *\n   *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n   *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n   *\n   * Note that in the sample above:\n   *\n   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n   *\n   * @returns {module:engine/view/range~Range} Shrink range.\n   */\n\n\n  getTrimmed() {\n    let start = this.start.getLastMatchingPosition(enlargeTrimSkip);\n\n    if (start.isAfter(this.end) || start.isEqual(this.end)) {\n      return new Range(start, start);\n    }\n\n    let end = this.end.getLastMatchingPosition(enlargeTrimSkip, {\n      direction: 'backward'\n    });\n    const nodeAfterStart = start.nodeAfter;\n    const nodeBeforeEnd = end.nodeBefore; // Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n\n    if (nodeAfterStart && nodeAfterStart.is('$text')) {\n      start = new Position(nodeAfterStart, 0);\n    }\n\n    if (nodeBeforeEnd && nodeBeforeEnd.is('$text')) {\n      end = new Position(nodeBeforeEnd, nodeBeforeEnd.data.length);\n    }\n\n    return new Range(start, end);\n  }\n  /**\n   * Two ranges are equal if their start and end positions are equal.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n   */\n\n\n  isEqual(otherRange) {\n    return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);\n  }\n  /**\n   * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n   *\n   * @param {module:engine/view/position~Position} position Position to check.\n   * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n   * `false` otherwise.\n   */\n\n\n  containsPosition(position) {\n    return position.isAfter(this.start) && position.isBefore(this.end);\n  }\n  /**\n   * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to check.\n   * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n   * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n   * otherwise.\n   */\n\n\n  containsRange(otherRange) {\n    let loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (otherRange.isCollapsed) {\n      loose = false;\n    }\n\n    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);\n    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);\n    return containsStart && containsEnd;\n  }\n  /**\n   * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n   * {@link module:engine/view/range~Range range}.\n   * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n   *\n   * Examples:\n   *\n   *\t\tlet foo = downcastWriter.createText( 'foo' );\n   *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n   *\t\tlet bar = downcastWriter.createText( 'bar' );\n   *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n   *\n   *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n   *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n   *\t\t\tview.createPositionAt( foo, 1 ),\n   *\t\t\tview.createPositionAt( bar, 2 )\n   *\t\t);\n   *\t\tlet transformed = range.getDifference( otherRange );\n   *\t\t// transformed array has no ranges because `otherRange` contains `range`\n   *\n   *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n   *\n   *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n   *\t\ttransformed = range.getDifference( otherRange );\n   *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n   * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n   */\n\n\n  getDifference(otherRange) {\n    const ranges = [];\n\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect.\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means that we have to\n        // add shrunken range - from the start to the middle of this range.\n        ranges.push(new Range(this.start, otherRange.start));\n      }\n\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // add shrunken range - from the middle of this range to the end.\n        ranges.push(new Range(otherRange.end, this.end));\n      }\n    } else {\n      // Ranges do not intersect, return the original range.\n      ranges.push(this.clone());\n    }\n\n    return ranges;\n  }\n  /**\n   * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n   *\n   * Examples:\n   *\n   *\t\tlet foo = downcastWriter.createText( 'foo' );\n   *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n   *\t\tlet bar = downcastWriter.createText( 'bar' );\n   *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n   *\n   *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n   *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n   *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n   *\n   *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n   *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n   * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n   */\n\n\n  getIntersection(otherRange) {\n    if (this.isIntersecting(otherRange)) {\n      // Ranges intersect, so a common range will be returned.\n      // At most, it will be same as this range.\n      let commonRangeStart = this.start;\n      let commonRangeEnd = this.end;\n\n      if (this.containsPosition(otherRange.start)) {\n        // Given range start is inside this range. This means thaNt we have to\n        // shrink common range to the given range start.\n        commonRangeStart = otherRange.start;\n      }\n\n      if (this.containsPosition(otherRange.end)) {\n        // Given range end is inside this range. This means that we have to\n        // shrink common range to the given range end.\n        commonRangeEnd = otherRange.end;\n      }\n\n      return new Range(commonRangeStart, commonRangeEnd);\n    } // Ranges do not intersect, so they do not have common part.\n\n\n    return null;\n  }\n  /**\n   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   * @param {module:engine/view/position~Position} [options.startPosition]\n   * @param {Boolean} [options.singleCharacters=false]\n   * @param {Boolean} [options.shallow=false]\n   * @param {Boolean} [options.ignoreElementEnd=false]\n   * @returns {module:engine/view/treewalker~TreeWalker}\n   */\n\n\n  getWalker() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    return new TreeWalker(options);\n  }\n  /**\n   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n   * which is a common ancestor of range's both ends (in which the entire range is contained).\n   *\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n   */\n\n\n  getCommonAncestor() {\n    return this.start.getCommonAncestor(this.end);\n  }\n  /**\n   * Returns an {@link module:engine/view/element~Element Element} contained by the range.\n   * The element will be returned when it is the **only** node within the range and **fully–contained**\n   * at the same time.\n   *\n   * @returns {module:engine/view/element~Element|null}\n   */\n\n\n  getContainedElement() {\n    if (this.isCollapsed) {\n      return null;\n    }\n\n    let nodeAfterStart = this.start.nodeAfter;\n    let nodeBeforeEnd = this.end.nodeBefore; // Handle the situation when the range position is at the beginning / at the end of a text node.\n    // In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning\n    // over one element.\n    //\n    // <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n    //\n    // These are basically the same range, only the difference is if the range position is at\n    // at the end/at the beginning of a text node or just before/just after the text node.\n    //\n\n    if (this.start.parent.is('$text') && this.start.isAtEnd && this.start.parent.nextSibling) {\n      nodeAfterStart = this.start.parent.nextSibling;\n    }\n\n    if (this.end.parent.is('$text') && this.end.isAtStart && this.end.parent.previousSibling) {\n      nodeBeforeEnd = this.end.parent.previousSibling;\n    }\n\n    if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n      return nodeAfterStart;\n    }\n\n    return null;\n  }\n  /**\n   * Clones this range.\n   *\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  clone() {\n    return new Range(this.start, this.end);\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n   * them.\n   *\n   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n   * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n   * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/view/item~Item>}\n   */\n\n\n  *getItems() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    options.ignoreElementEnd = true;\n    const treeWalker = new TreeWalker(options);\n\n    for (const value of treeWalker) {\n      yield value.item;\n    }\n  }\n  /**\n   * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n   * contained in this range.\n   *\n   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n   * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n   *\n   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n   * a full list of available options.\n   *\n   * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n   * @returns {Iterable.<module:engine/view/position~Position>}\n   */\n\n\n  *getPositions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.boundaries = this;\n    const treeWalker = new TreeWalker(options);\n    yield treeWalker.position;\n\n    for (const value of treeWalker) {\n      yield value.nextPosition;\n    }\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   *\t\trange.is( 'range' ); // -> true\n   *\t\trange.is( 'view:range' ); // -> true\n   *\n   *\t\trange.is( 'model:range' ); // -> false\n   *\t\trange.is( 'element' ); // -> false\n   *\t\trange.is( 'selection' ); // -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'range' || type === 'view:range';\n  }\n  /**\n   * Checks and returns whether this range intersects with the given range.\n   *\n   * @param {module:engine/view/range~Range} otherRange Range to compare with.\n   * @returns {Boolean} True if ranges intersect.\n   */\n\n\n  isIntersecting(otherRange) {\n    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n  }\n  /**\n   * Creates a range from the given parents and offsets.\n   *\n   * @protected\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n   * parent element.\n   * @param {Number} startOffset Start position offset.\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n   * parent element.\n   * @param {Number} endOffset End position offset.\n   * @returns {module:engine/view/range~Range} Created range.\n   */\n\n\n  static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {\n    return new this(new Position(startElement, startOffset), new Position(endElement, endOffset));\n  }\n  /**\n   * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n   *\n   * @protected\n   * @param {module:engine/view/position~Position} position Beginning of the range.\n   * @param {Number} shift How long the range should be.\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  static _createFromPositionAndShift(position, shift) {\n    const start = position;\n    const end = position.getShiftedBy(shift);\n    return shift > 0 ? new this(start, end) : new this(end, start);\n  }\n  /**\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * @protected\n   * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  static _createIn(element) {\n    return this._createFromParentsAndOffsets(element, 0, element, element.childCount);\n  }\n  /**\n   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n   *\n   * @protected\n   * @param {module:engine/view/item~Item} item\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  static _createOn(item) {\n    const size = item.is('$textProxy') ? item.offsetSize : 1;\n    return this._createFromPositionAndShift(Position._createBefore(item), size);\n  }\n\n} // Function used by getEnlarged and getTrimmed methods.\n\nfunction enlargeTrimSkip(value) {\n  if (value.item.is('attributeElement') || value.item.is('uiElement')) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js"],"names":["Position","TreeWalker","Range","constructor","start","end","clone","Symbol","iterator","boundaries","ignoreElementEnd","isCollapsed","isEqual","isFlat","parent","root","getEnlarged","getLastMatchingPosition","enlargeTrimSkip","direction","is","isAtStart","_createBefore","isAtEnd","_createAfter","getTrimmed","isAfter","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","data","length","otherRange","containsPosition","position","isBefore","containsRange","loose","containsStart","containsEnd","getDifference","ranges","isIntersecting","push","getIntersection","commonRangeStart","commonRangeEnd","getWalker","options","getCommonAncestor","getContainedElement","nextSibling","previousSibling","getItems","treeWalker","value","item","getPositions","nextPosition","type","_createFromParentsAndOffsets","startElement","startOffset","endElement","endOffset","_createFromPositionAndShift","shift","getShiftedBy","_createIn","element","childCount","_createOn","size","offsetSize"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\n\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.start = start.clone();\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.end = end ? end.clone() : start.clone();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/view/position~Position positions},\n\t * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n\t * `ignoreElementEnd` option\n\t * set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is it start and end positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n\t * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\treturn this.start.parent === this.end.parent;\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n\t *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Enlarged range.\n\t */\n\tgetEnlarged() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\t// Fix positions, in case if they are in Text node.\n\t\tif ( start.parent.is( '$text' ) && start.isAtStart ) {\n\t\t\tstart = Position._createBefore( start.parent );\n\t\t}\n\n\t\tif ( end.parent.is( '$text' ) && end.isAtEnd ) {\n\t\t\tend = Position._createAfter( end.parent );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n\t *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Shrink range.\n\t */\n\tgetTrimmed() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\tif ( start.isAfter( this.end ) || start.isEqual( this.end ) ) {\n\t\t\treturn new Range( start, start );\n\t\t}\n\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tconst nodeAfterStart = start.nodeAfter;\n\t\tconst nodeBeforeEnd = end.nodeBefore;\n\n\t\t// Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n\t\tif ( nodeAfterStart && nodeAfterStart.is( '$text' ) ) {\n\t\t\tstart = new Position( nodeAfterStart, 0 );\n\t\t}\n\n\t\tif ( nodeBeforeEnd && nodeBeforeEnd.is( '$text' ) ) {\n\t\t\tend = new Position( nodeBeforeEnd, nodeBeforeEnd.data.length );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Two ranges are equal if their start and end positions are equal.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this == otherRange || ( this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end ) );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n\t *\n\t * @param {module:engine/view/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n\t * `false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n\t * otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n\t * {@link module:engine/view/range~Range range}.\n\t * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n\t *\t\t\tview.createPositionAt( foo, 1 ),\n\t *\t\t\tview.createPositionAt( bar, 2 )\n\t *\t\t);\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( this.clone() );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n\t *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @param {module:engine/view/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t * @returns {module:engine/view/treewalker~TreeWalker}\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/view/element~Element Element} contained by the range.\n\t * The element will be returned when it is the **only** node within the range and **fully–contained**\n\t * at the same time.\n\t *\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetContainedElement() {\n\t\tif ( this.isCollapsed ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet nodeAfterStart = this.start.nodeAfter;\n\t\tlet nodeBeforeEnd = this.end.nodeBefore;\n\n\t\t// Handle the situation when the range position is at the beginning / at the end of a text node.\n\t\t// In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning\n\t\t// over one element.\n\t\t//\n\t\t// <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n\t\t//\n\t\t// These are basically the same range, only the difference is if the range position is at\n\t\t// at the end/at the beginning of a text node or just before/just after the text node.\n\t\t//\n\t\tif ( this.start.parent.is( '$text' ) && this.start.isAtEnd && this.start.parent.nextSibling ) {\n\t\t\tnodeAfterStart = this.start.parent.nextSibling;\n\t\t}\n\n\t\tif ( this.end.parent.is( '$text' ) && this.end.isAtStart && this.end.parent.previousSibling ) {\n\t\t\tnodeBeforeEnd = this.end.parent.previousSibling;\n\t\t}\n\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'element' ) && nodeAfterStart === nodeBeforeEnd ) {\n\t\t\treturn nodeAfterStart;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clones this range.\n\t *\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tclone() {\n\t\treturn new Range( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n\t * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'view:range' ); // -> true\n\t *\n\t *\t\trange.is( 'model:range' ); // -> false\n\t *\t\trange.is( 'element' ); // -> false\n\t *\t\trange.is( 'selection' ); // -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'range' || type === 'view:range';\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with the given range.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} True if ranges intersect.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Creates a range from the given parents and offsets.\n\t *\n\t * @protected\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n\t * parent element.\n\t * @param {Number} startOffset Start position offset.\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n\t * parent element.\n\t * @param {Number} endOffset End position offset.\n\t * @returns {module:engine/view/range~Range} Created range.\n\t */\n\tstatic _createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {\n\t\treturn new this(\n\t\t\tnew Position( startElement, startOffset ),\n\t\t\tnew Position( endElement, endOffset )\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/view/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn this._createFromParentsAndOffsets( element, 0, element, element.childCount );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\tconst size = item.is( '$textProxy' ) ? item.offsetSize : 1;\n\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), size );\n\t}\n}\n\n// Function used by getEnlarged and getTrimmed methods.\nfunction enlargeTrimSkip( value ) {\n\tif ( value.item.is( 'attributeElement' ) || value.item.is( 'uiElement' ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]},"metadata":{},"sourceType":"module"}