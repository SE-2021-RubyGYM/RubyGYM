{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/utils\n */\nimport { first } from 'ckeditor5/src/utils';\n/**\n * Creates a view element representing the image of provided image type.\n *\n * An 'imageBlock' type (block image):\n *\n *\t\t<figure class=\"image\"><img></img></figure>\n *\n * An 'imageInline' type (inline image):\n *\n *\t\t<span class=\"image-inline\"><img></img></span>\n *\n * Note that `alt` and `src` attributes are converted separately, so they are not included.\n *\n * @protected\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {'imageBlock'|'imageInline'} imageType The type of created image.\n * @returns {module:engine/view/containerelement~ContainerElement}\n */\n\nexport function createImageViewElement(writer, imageType) {\n  const emptyElement = writer.createEmptyElement('img');\n  const container = imageType === 'imageBlock' ? writer.createContainerElement('figure', {\n    class: 'image'\n  }) : writer.createContainerElement('span', {\n    class: 'image-inline'\n  }, {\n    isAllowedInsideAttributeElement: true\n  });\n  writer.insert(writer.createPositionAt(container, 0), emptyElement);\n  return container;\n}\n/**\n * A function returning a `MatcherPattern` for a particular type of View images.\n *\n * @protected\n * @param {module:core/editor/editor~Editor} editor\n * @param {'imageBlock'|'imageInline'} matchImageType The type of created image.\n * @returns {module:engine/view/matcher~MatcherPattern}\n */\n\nexport function getImgViewElementMatcher(editor, matchImageType) {\n  if (editor.plugins.has('ImageInlineEditing') !== editor.plugins.has('ImageBlockEditing')) {\n    return {\n      name: 'img'\n    };\n  }\n\n  const imageUtils = editor.plugins.get('ImageUtils');\n  return element => {\n    // Check if view element is an `img`.\n    if (!imageUtils.isInlineImageView(element)) {\n      return null;\n    } // The <img> can be standalone, wrapped in <figure>...</figure> (ImageBlock plugin) or\n    // wrapped in <figure><a>...</a></figure> (LinkImage plugin).\n\n\n    const imageType = element.findAncestor(imageUtils.isBlockImageView) ? 'imageBlock' : 'imageInline';\n\n    if (imageType !== matchImageType) {\n      return null;\n    }\n\n    return {\n      name: true\n    };\n  };\n}\n/**\n * Considering the current model selection, it returns the name of the model image element\n * (`'imageBlock'` or `'imageInline'`) that will make most sense from the UX perspective if a new\n * image was inserted (also: uploaded, dropped, pasted) at that selection.\n *\n * The assumption is that inserting images into empty blocks or on other block widgets should\n * produce block images. Inline images should be inserted in other cases, e.g. in paragraphs\n * that already contain some text.\n *\n * @protected\n * @param {module:engine/model/schema~Schema} schema\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * @returns {'imageBlock'|'imageInline'}\n */\n\nexport function determineImageTypeForInsertionAtSelection(schema, selection) {\n  const firstBlock = first(selection.getSelectedBlocks()); // Insert a block image if the selection is not in/on block elements or it's on a block widget.\n\n  if (!firstBlock || schema.isObject(firstBlock)) {\n    return 'imageBlock';\n  } // A block image should also be inserted into an empty block element\n  // (that is not an empty list item so the list won't get split).\n\n\n  if (firstBlock.isEmpty && firstBlock.name != 'listItem') {\n    return 'imageBlock';\n  } // Otherwise insert an inline image.\n\n\n  return 'imageInline';\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-image/src/image/utils.js"],"names":["first","createImageViewElement","writer","imageType","emptyElement","createEmptyElement","container","createContainerElement","class","isAllowedInsideAttributeElement","insert","createPositionAt","getImgViewElementMatcher","editor","matchImageType","plugins","has","name","imageUtils","get","element","isInlineImageView","findAncestor","isBlockImageView","determineImageTypeForInsertionAtSelection","schema","selection","firstBlock","getSelectedBlocks","isObject","isEmpty"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,KAAT,QAAsB,qBAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,sBAAT,CAAiCC,MAAjC,EAAyCC,SAAzC,EAAqD;AAC3D,QAAMC,YAAY,GAAGF,MAAM,CAACG,kBAAP,CAA2B,KAA3B,CAArB;AAEA,QAAMC,SAAS,GAAGH,SAAS,KAAK,YAAd,GACjBD,MAAM,CAACK,sBAAP,CAA+B,QAA/B,EAAyC;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAAzC,CADiB,GAEjBN,MAAM,CAACK,sBAAP,CAA+B,MAA/B,EAAuC;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAAvC,EAAkE;AAAEC,IAAAA,+BAA+B,EAAE;AAAnC,GAAlE,CAFD;AAIAP,EAAAA,MAAM,CAACQ,MAAP,CAAeR,MAAM,CAACS,gBAAP,CAAyBL,SAAzB,EAAoC,CAApC,CAAf,EAAwDF,YAAxD;AAEA,SAAOE,SAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,wBAAT,CAAmCC,MAAnC,EAA2CC,cAA3C,EAA4D;AAClE,MAAKD,MAAM,CAACE,OAAP,CAAeC,GAAf,CAAoB,oBAApB,MAA+CH,MAAM,CAACE,OAAP,CAAeC,GAAf,CAAoB,mBAApB,CAApD,EAAgG;AAC/F,WAAO;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAAP;AACA;;AAED,QAAMC,UAAU,GAAGL,MAAM,CAACE,OAAP,CAAeI,GAAf,CAAoB,YAApB,CAAnB;AAEA,SAAOC,OAAO,IAAI;AACjB;AACA,QAAK,CAACF,UAAU,CAACG,iBAAX,CAA8BD,OAA9B,CAAN,EAAgD;AAC/C,aAAO,IAAP;AACA,KAJgB,CAMjB;AACA;;;AACA,UAAMjB,SAAS,GAAGiB,OAAO,CAACE,YAAR,CAAsBJ,UAAU,CAACK,gBAAjC,IAAsD,YAAtD,GAAqE,aAAvF;;AAEA,QAAKpB,SAAS,KAAKW,cAAnB,EAAoC;AACnC,aAAO,IAAP;AACA;;AAED,WAAO;AAAEG,MAAAA,IAAI,EAAE;AAAR,KAAP;AACA,GAfD;AAgBA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,yCAAT,CAAoDC,MAApD,EAA4DC,SAA5D,EAAwE;AAC9E,QAAMC,UAAU,GAAG3B,KAAK,CAAE0B,SAAS,CAACE,iBAAV,EAAF,CAAxB,CAD8E,CAG9E;;AACA,MAAK,CAACD,UAAD,IAAeF,MAAM,CAACI,QAAP,CAAiBF,UAAjB,CAApB,EAAoD;AACnD,WAAO,YAAP;AACA,GAN6E,CAQ9E;AACA;;;AACA,MAAKA,UAAU,CAACG,OAAX,IAAsBH,UAAU,CAACV,IAAX,IAAmB,UAA9C,EAA2D;AAC1D,WAAO,YAAP;AACA,GAZ6E,CAc9E;;;AACA,SAAO,aAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/utils\n */\n\nimport { first } from 'ckeditor5/src/utils';\n\n/**\n * Creates a view element representing the image of provided image type.\n *\n * An 'imageBlock' type (block image):\n *\n *\t\t<figure class=\"image\"><img></img></figure>\n *\n * An 'imageInline' type (inline image):\n *\n *\t\t<span class=\"image-inline\"><img></img></span>\n *\n * Note that `alt` and `src` attributes are converted separately, so they are not included.\n *\n * @protected\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {'imageBlock'|'imageInline'} imageType The type of created image.\n * @returns {module:engine/view/containerelement~ContainerElement}\n */\nexport function createImageViewElement( writer, imageType ) {\n\tconst emptyElement = writer.createEmptyElement( 'img' );\n\n\tconst container = imageType === 'imageBlock' ?\n\t\twriter.createContainerElement( 'figure', { class: 'image' } ) :\n\t\twriter.createContainerElement( 'span', { class: 'image-inline' }, { isAllowedInsideAttributeElement: true } );\n\n\twriter.insert( writer.createPositionAt( container, 0 ), emptyElement );\n\n\treturn container;\n}\n\n/**\n * A function returning a `MatcherPattern` for a particular type of View images.\n *\n * @protected\n * @param {module:core/editor/editor~Editor} editor\n * @param {'imageBlock'|'imageInline'} matchImageType The type of created image.\n * @returns {module:engine/view/matcher~MatcherPattern}\n */\nexport function getImgViewElementMatcher( editor, matchImageType ) {\n\tif ( editor.plugins.has( 'ImageInlineEditing' ) !== editor.plugins.has( 'ImageBlockEditing' ) ) {\n\t\treturn { name: 'img' };\n\t}\n\n\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\treturn element => {\n\t\t// Check if view element is an `img`.\n\t\tif ( !imageUtils.isInlineImageView( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// The <img> can be standalone, wrapped in <figure>...</figure> (ImageBlock plugin) or\n\t\t// wrapped in <figure><a>...</a></figure> (LinkImage plugin).\n\t\tconst imageType = element.findAncestor( imageUtils.isBlockImageView ) ? 'imageBlock' : 'imageInline';\n\n\t\tif ( imageType !== matchImageType ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn { name: true };\n\t};\n}\n\n/**\n * Considering the current model selection, it returns the name of the model image element\n * (`'imageBlock'` or `'imageInline'`) that will make most sense from the UX perspective if a new\n * image was inserted (also: uploaded, dropped, pasted) at that selection.\n *\n * The assumption is that inserting images into empty blocks or on other block widgets should\n * produce block images. Inline images should be inserted in other cases, e.g. in paragraphs\n * that already contain some text.\n *\n * @protected\n * @param {module:engine/model/schema~Schema} schema\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * @returns {'imageBlock'|'imageInline'}\n */\nexport function determineImageTypeForInsertionAtSelection( schema, selection ) {\n\tconst firstBlock = first( selection.getSelectedBlocks() );\n\n\t// Insert a block image if the selection is not in/on block elements or it's on a block widget.\n\tif ( !firstBlock || schema.isObject( firstBlock ) ) {\n\t\treturn 'imageBlock';\n\t}\n\n\t// A block image should also be inserted into an empty block element\n\t// (that is not an empty list item so the list won't get split).\n\tif ( firstBlock.isEmpty && firstBlock.name != 'listItem' ) {\n\t\treturn 'imageBlock';\n\t}\n\n\t// Otherwise insert an inline image.\n\treturn 'imageInline';\n}\n"]},"metadata":{},"sourceType":"module"}