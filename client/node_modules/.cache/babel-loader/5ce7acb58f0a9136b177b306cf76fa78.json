{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/template\n */\n\n/* global document */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport View from './view';\nimport ViewCollection from './viewcollection';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport { isObject, cloneDeepWith } from 'lodash-es';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nconst xhtmlNs = 'http://www.w3.org/1999/xhtml';\n/**\n * A basic Template class. It renders a DOM HTML element or text from a\n * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,\n * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.\n *\n * A simple template can look like this:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tclass: 'foo',\n *\t\t\t\tstyle: {\n *\t\t\t\t\tbackgroundColor: 'yellow'\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t'A paragraph.'\n *\t\t\t]\n *\t\t} ).render();\n *\n * and it will render the following HTML element:\n *\n *\t\t<p class=\"foo\" style=\"background-color: yellow;\">A paragraph.</p>\n *\n * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.\n *\n * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex\n * template definitions.\n *\n* @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Template {\n  /**\n   * Creates an instance of the {@link ~Template} class.\n   *\n   * @param {module:ui/template~TemplateDefinition} def The definition of the template.\n   */\n  constructor(def) {\n    Object.assign(this, normalize(clone(def)));\n    /**\n     * Indicates whether this particular Template instance has been\n     * {@link #render rendered}.\n     *\n     * @readonly\n     * @protected\n     * @member {Boolean}\n     */\n\n    this._isRendered = false;\n    /**\n     * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template\n     * renders to an HTML element.\n     *\n     * @member {String} #tag\n     */\n\n    /**\n     * The text of the template. It also indicates that the template renders to a DOM text node.\n     *\n     * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text\n     */\n\n    /**\n     * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with\n     * the attributes of an HTML element.\n     *\n     * **Note**: This property only makes sense when {@link #tag} is defined.\n     *\n     * @member {Object} #attributes\n     */\n\n    /**\n     * The children of the template. They can be either:\n     * * independent instances of {@link ~Template} (subâ€“templates),\n     * * native DOM Nodes.\n     *\n     * **Note**: This property only makes sense when {@link #tag} is defined.\n     *\n     * @member {Array.<module:ui/template~Template|Node>} #children\n     */\n\n    /**\n     * The DOM event listeners of the template.\n     *\n     * @member {Object} #eventListeners\n     */\n\n    /**\n     * The data used by the {@link #revert} method to restore a node to its original state.\n     *\n     * See: {@link #apply}.\n     *\n     * @readonly\n     * @protected\n     * @member {module:ui/template~RenderData}\n     */\n\n    this._revertData = null;\n  }\n  /**\n   * Renders a DOM Node (an HTML element or text) out of the template.\n   *\n   *\t\tconst domNode = new Template( { ... } ).render();\n   *\n   * See: {@link #apply}.\n   *\n   * @returns {HTMLElement|Text}\n   */\n\n\n  render() {\n    const node = this._renderNode({\n      intoFragment: true\n    });\n\n    this._isRendered = true;\n    return node;\n  }\n  /**\n   * Applies the template to an existing DOM Node, either HTML element or text.\n   *\n   * **Note:** No new DOM nodes will be created. Applying extends:\n   *\n   * {@link module:ui/template~TemplateDefinition attributes},\n   * {@link module:ui/template~TemplateDefinition event listeners}, and\n   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.\n   *\n   * **Note:** Existing `class` and `style` attributes are extended when a template\n   * is applied to an HTML element, while other attributes and `textContent` are overridden.\n   *\n   * **Note:** The process of applying a template can be easily reverted using the\n   * {@link module:ui/template~Template#revert} method.\n   *\n   *\t\tconst element = document.createElement( 'div' );\n   *\t\tconst observable = new Model( { divClass: 'my-div' } );\n   *\t\tconst emitter = Object.create( EmitterMixin );\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tnew Template( {\n   *\t\t\tattributes: {\n   *\t\t\t\tid: 'first-div',\n   *\t\t\t\tclass: bind.to( 'divClass' )\n   *\t\t\t},\n   *\t\t\ton: {\n   *\t\t\t\tclick: bind( 'elementClicked' ) // Will be fired by the observable.\n   *\t\t\t},\n   *\t\t\tchildren: [\n   *\t\t\t\t'Div text.'\n   *\t\t\t]\n   *\t\t} ).apply( element );\n   *\n   *\t\tconsole.log( element.outerHTML ); // -> '<div id=\"first-div\" class=\"my-div\"></div>'\n   *\n   * @see module:ui/template~Template#render\n   * @see module:ui/template~Template#revert\n   * @param {Node} node Root node for the template to apply.\n   */\n\n\n  apply(node) {\n    this._revertData = getEmptyRevertData();\n\n    this._renderNode({\n      node,\n      isApplying: true,\n      revertData: this._revertData\n    });\n\n    return node;\n  }\n  /**\n   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.\n   *\n   * @param {Node} node The root node for the template to revert. In most of the cases, it is the\n   * same node used by {@link module:ui/template~Template#apply}.\n   */\n\n\n  revert(node) {\n    if (!this._revertData) {\n      /**\n       * Attempting to revert a template which has not been applied yet.\n       *\n       * @error ui-template-revert-not-applied\n       */\n      throw new CKEditorError('ui-template-revert-not-applied', [this, node]);\n    }\n\n    this._revertTemplateFromNode(node, this._revertData);\n  }\n  /**\n   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}\n   * instances and returns them one by one.\n   *\n   *\t\tconst viewFoo = new View();\n   *\t\tconst viewBar = new View();\n   *\t\tconst viewBaz = new View();\n   *\t\tconst template = new Template( {\n   *\t\t\ttag: 'div',\n   *\t\t\tchildren: [\n   *\t\t\t\tviewFoo,\n   *\t\t\t\t{\n   *\t\t\t\t\ttag: 'div',\n   *\t\t\t\t\tchildren: [\n   *\t\t\t\t\t\tviewBar\n   *\t\t\t\t\t]\n   *\t\t\t\t},\n   *\t\t\t\tviewBaz\n   *\t\t\t]\n   *\t\t} );\n   *\n   *\t\t// Logs: viewFoo, viewBar, viewBaz\n   *\t\tfor ( const view of template.getViews() ) {\n   *\t\t\tconsole.log( view );\n   *\t\t}\n   *\n   * @returns {Iterable.<module:ui/view~View>}\n   */\n\n\n  *getViews() {\n    function* search(def) {\n      if (def.children) {\n        for (const child of def.children) {\n          if (isView(child)) {\n            yield child;\n          } else if (isTemplate(child)) {\n            yield* search(child);\n          }\n        }\n      }\n    }\n\n    yield* search(this);\n  }\n  /**\n   * An entry point to the interface which binds DOM nodes to\n   * {@link module:utils/observablemixin~Observable observables}.\n   * There are two types of bindings:\n   *\n   * * HTML element attributes or text `textContent` synchronized with attributes of an\n   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}\n   * and {@link module:ui/template~BindChain#if}.\n   *\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tnew Template( {\n   *\t\t\tattributes: {\n   *\t\t\t\t// Binds the element \"class\" attribute to observable#classAttribute.\n   *\t\t\t\tclass: bind.to( 'classAttribute' )\n   *\t\t\t}\n   *\t\t} ).render();\n   *\n   * * DOM events fired on HTML element propagated through\n   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.\n   *\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tnew Template( {\n   *\t\t\ton: {\n   *\t\t\t\t// Will be fired by the observable.\n   *\t\t\t\tclick: bind( 'elementClicked' )\n   *\t\t\t}\n   *\t\t} ).render();\n   *\n   * Also see {@link module:ui/view~View#bindTemplate}.\n   *\n   * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.\n   * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute\n   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.\n   * @returns {module:ui/template~BindChain}\n   */\n\n\n  static bind(observable, emitter) {\n    return {\n      to(eventNameOrFunctionOrAttribute, callback) {\n        return new TemplateToBinding({\n          eventNameOrFunction: eventNameOrFunctionOrAttribute,\n          attribute: eventNameOrFunctionOrAttribute,\n          observable,\n          emitter,\n          callback\n        });\n      },\n\n      if(attribute, valueIfTrue, callback) {\n        return new TemplateIfBinding({\n          observable,\n          emitter,\n          attribute,\n          valueIfTrue,\n          callback\n        });\n      }\n\n    };\n  }\n  /**\n   * Extends an existing {@link module:ui/template~Template} instance with some additional content\n   * from another {@link module:ui/template~TemplateDefinition}.\n   *\n   *\t\tconst bind = Template.bind( observable, emitter );\n   *\n   *\t\tconst template = new Template( {\n   *\t\t\ttag: 'p',\n   *\t\t\tattributes: {\n   *\t\t\t\tclass: 'a',\n   *\t\t\t\tdata-x: bind.to( 'foo' )\n   *\t\t\t},\n   *\t\t\tchildren: [\n   *\t\t\t\t{\n   *\t\t\t\t\ttag: 'span',\n   *\t\t\t\t\tattributes: {\n   *\t\t\t\t\t\tclass: 'b'\n   *\t\t\t\t\t},\n   *\t\t\t\t\tchildren: [\n   *\t\t\t\t\t\t'Span'\n   *\t\t\t\t\t]\n   *\t\t\t\t}\n   *\t\t\t]\n   *\t\t } );\n   *\n   *\t\t// Instance-level extension.\n   *\t\tTemplate.extend( template, {\n   *\t\t\tattributes: {\n   *\t\t\t\tclass: 'b',\n   *\t\t\t\tdata-x: bind.to( 'bar' )\n   *\t\t\t},\n   *\t\t\tchildren: [\n   *\t\t\t\t{\n   *\t\t\t\t\tattributes: {\n   *\t\t\t\t\t\tclass: 'c'\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t]\n   *\t\t} );\n   *\n   *\t\t// Child extension.\n   *\t\tTemplate.extend( template.children[ 0 ], {\n   *\t\t\tattributes: {\n   *\t\t\t\tclass: 'd'\n   *\t\t\t}\n   *\t\t} );\n   *\n   * the `outerHTML` of `template.render()` is:\n   *\n   *\t\t<p class=\"a b\" data-x=\"{ observable.foo } { observable.bar }\">\n   *\t\t\t<span class=\"b c d\">Span</span>\n   *\t\t</p>\n   *\n   * @param {module:ui/template~Template} template An existing template instance to be extended.\n   * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.\n   */\n\n\n  static extend(template, def) {\n    if (template._isRendered) {\n      /**\n       * Extending a template after rendering may not work as expected. To make sure\n       * the {@link module:ui/template~Template.extend extending} works for an element,\n       * make sure it happens before {@link #render} is called.\n       *\n       * @error template-extend-render\n       */\n      throw new CKEditorError('template-extend-render', [this, template]);\n    }\n\n    extendTemplate(template, normalize(clone(def)));\n  }\n  /**\n   * Renders a DOM Node (either an HTML element or text) out of the template.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n\n\n  _renderNode(data) {\n    let isInvalid;\n\n    if (data.node) {\n      // When applying, a definition cannot have \"tag\" and \"text\" at the same time.\n      isInvalid = this.tag && this.text;\n    } else {\n      // When rendering, a definition must have either \"tag\" or \"text\": XOR( this.tag, this.text ).\n      isInvalid = this.tag ? this.text : !this.text;\n    }\n\n    if (isInvalid) {\n      /**\n       * Node definition cannot have the \"tag\" and \"text\" properties at the same time.\n       * Node definition must have either \"tag\" or \"text\" when rendering a new Node.\n       *\n       * @error ui-template-wrong-syntax\n       */\n      throw new CKEditorError('ui-template-wrong-syntax', this);\n    }\n\n    if (this.text) {\n      return this._renderText(data);\n    } else {\n      return this._renderElement(data);\n    }\n  }\n  /**\n   * Renders an HTML element out of the template.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n\n\n  _renderElement(data) {\n    let node = data.node;\n\n    if (!node) {\n      node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);\n    }\n\n    this._renderAttributes(data);\n\n    this._renderElementChildren(data);\n\n    this._setUpListeners(data);\n\n    return node;\n  }\n  /**\n   * Renders a text node out of {@link module:ui/template~Template#text}.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n\n\n  _renderText(data) {\n    let node = data.node; // Save the original textContent to revert it in #revert().\n\n    if (node) {\n      data.revertData.text = node.textContent;\n    } else {\n      node = data.node = document.createTextNode('');\n    } // Check if this Text Node is bound to Observable. Cases:\n    //\n    //\t\ttext: [ Template.bind( ... ).to( ... ) ]\n    //\n    //\t\ttext: [\n    //\t\t\t'foo',\n    //\t\t\tTemplate.bind( ... ).to( ... ),\n    //\t\t\t...\n    //\t\t]\n    //\n\n\n    if (hasTemplateBinding(this.text)) {\n      this._bindToObservable({\n        schema: this.text,\n        updater: getTextUpdater(node),\n        data\n      });\n    } // Simply set text. Cases:\n    //\n    //\t\ttext: [ 'all', 'are', 'static' ]\n    //\n    //\t\ttext: [ 'foo' ]\n    //\n    else {\n      node.textContent = this.text.join('');\n    }\n\n    return node;\n  }\n  /**\n   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n\n\n  _renderAttributes(data) {\n    let attrName, attrValue, domAttrValue, attrNs;\n\n    if (!this.attributes) {\n      return;\n    }\n\n    const node = data.node;\n    const revertData = data.revertData;\n\n    for (attrName in this.attributes) {\n      // Current attribute value in DOM.\n      domAttrValue = node.getAttribute(attrName); // The value to be set.\n\n      attrValue = this.attributes[attrName]; // Save revert data.\n\n      if (revertData) {\n        revertData.attributes[attrName] = domAttrValue;\n      } // Detect custom namespace:\n      //\n      //\t\tclass: {\n      //\t\t\tns: 'abc',\n      //\t\t\tvalue: Template.bind( ... ).to( ... )\n      //\t\t}\n      //\n\n\n      attrNs = isObject(attrValue[0]) && attrValue[0].ns ? attrValue[0].ns : null; // Activate binding if one is found. Cases:\n      //\n      //\t\tclass: [\n      //\t\t\tTemplate.bind( ... ).to( ... )\n      //\t\t]\n      //\n      //\t\tclass: [\n      //\t\t\t'bar',\n      //\t\t\tTemplate.bind( ... ).to( ... ),\n      //\t\t\t'baz'\n      //\t\t]\n      //\n      //\t\tclass: {\n      //\t\t\tns: 'abc',\n      //\t\t\tvalue: Template.bind( ... ).to( ... )\n      //\t\t}\n      //\n\n      if (hasTemplateBinding(attrValue)) {\n        // Normalize attributes with additional data like namespace:\n        //\n        //\t\tclass: {\n        //\t\t\tns: 'abc',\n        //\t\t\tvalue: [ ... ]\n        //\t\t}\n        //\n        const valueToBind = attrNs ? attrValue[0].value : attrValue; // Extend the original value of attributes like \"style\" and \"class\",\n        // don't override them.\n\n        if (revertData && shouldExtend(attrName)) {\n          valueToBind.unshift(domAttrValue);\n        }\n\n        this._bindToObservable({\n          schema: valueToBind,\n          updater: getAttributeUpdater(node, attrName, attrNs),\n          data\n        });\n      } // Style attribute could be an Object so it needs to be parsed in a specific way.\n      //\n      //\t\tstyle: {\n      //\t\t\twidth: '100px',\n      //\t\t\theight: Template.bind( ... ).to( ... )\n      //\t\t}\n      //\n      else if (attrName == 'style' && typeof attrValue[0] !== 'string') {\n        this._renderStyleAttribute(attrValue[0], data);\n      } // Otherwise simply set the static attribute:\n      //\n      //\t\tclass: [ 'foo' ]\n      //\n      //\t\tclass: [ 'all', 'are', 'static' ]\n      //\n      //\t\tclass: [\n      //\t\t\t{\n      //\t\t\t\tns: 'abc',\n      //\t\t\t\tvalue: [ 'foo' ]\n      //\t\t\t}\n      //\t\t]\n      //\n      else {\n        // Extend the original value of attributes like \"style\" and \"class\",\n        // don't override them.\n        if (revertData && domAttrValue && shouldExtend(attrName)) {\n          attrValue.unshift(domAttrValue);\n        }\n\n        attrValue = attrValue // Retrieve \"values\" from:\n        //\n        //\t\tclass: [\n        //\t\t\t{\n        //\t\t\t\tns: 'abc',\n        //\t\t\t\tvalue: [ ... ]\n        //\t\t\t}\n        //\t\t]\n        //\n        .map(val => val ? val.value || val : val) // Flatten the array.\n        .reduce((prev, next) => prev.concat(next), []) // Convert into string.\n        .reduce(arrayValueReducer, '');\n\n        if (!isFalsy(attrValue)) {\n          node.setAttributeNS(attrNs, attrName, attrValue);\n        }\n      }\n    }\n  }\n  /**\n   * Renders the `style` attribute of an HTML element based on\n   * {@link module:ui/template~Template#attributes}.\n   *\n   * A style attribute is an {Object} with static values:\n   *\n   *\t\tattributes: {\n   *\t\t\tstyle: {\n   *\t\t\t\tcolor: 'red'\n   *\t\t\t}\n   *\t\t}\n   *\n   * or values bound to {@link module:ui/model~Model} properties:\n   *\n   *\t\tattributes: {\n   *\t\t\tstyle: {\n   *\t\t\t\tcolor: bind.to( ... )\n   *\t\t\t}\n   *\t\t}\n   *\n   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be\n   * needed.\n   *\n   * @private\n   * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n\n\n  _renderStyleAttribute(styles, data) {\n    const node = data.node;\n\n    for (const styleName in styles) {\n      const styleValue = styles[styleName]; // Cases:\n      //\n      //\t\tstyle: {\n      //\t\t\tcolor: bind.to( 'attribute' )\n      //\t\t}\n      //\n\n      if (hasTemplateBinding(styleValue)) {\n        this._bindToObservable({\n          schema: [styleValue],\n          updater: getStyleUpdater(node, styleName),\n          data\n        });\n      } // Cases:\n      //\n      //\t\tstyle: {\n      //\t\t\tcolor: 'red'\n      //\t\t}\n      //\n      else {\n        node.style[styleName] = styleValue;\n      }\n    }\n  }\n  /**\n   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n\n\n  _renderElementChildren(data) {\n    const node = data.node;\n    const container = data.intoFragment ? document.createDocumentFragment() : node;\n    const isApplying = data.isApplying;\n    let childIndex = 0;\n\n    for (const child of this.children) {\n      if (isViewCollection(child)) {\n        if (!isApplying) {\n          child.setParent(node); // Note: ViewCollection renders its children.\n\n          for (const view of child) {\n            container.appendChild(view.element);\n          }\n        }\n      } else if (isView(child)) {\n        if (!isApplying) {\n          if (!child.isRendered) {\n            child.render();\n          }\n\n          container.appendChild(child.element);\n        }\n      } else if (isNode(child)) {\n        container.appendChild(child);\n      } else {\n        if (isApplying) {\n          const revertData = data.revertData;\n          const childRevertData = getEmptyRevertData();\n          revertData.children.push(childRevertData);\n\n          child._renderNode({\n            node: container.childNodes[childIndex++],\n            isApplying: true,\n            revertData: childRevertData\n          });\n        } else {\n          container.appendChild(child.render());\n        }\n      }\n    }\n\n    if (data.intoFragment) {\n      node.appendChild(container);\n    }\n  }\n  /**\n   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}\n   * on an HTML element.\n   *\n   * @protected\n   * @param {module:ui/template~RenderData} data Rendering data.\n   */\n\n\n  _setUpListeners(data) {\n    if (!this.eventListeners) {\n      return;\n    }\n\n    for (const key in this.eventListeners) {\n      const revertBindings = this.eventListeners[key].map(schemaItem => {\n        const [domEvtName, domSelector] = key.split('@');\n        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);\n      });\n\n      if (data.revertData) {\n        data.revertData.bindings.push(revertBindings);\n      }\n    }\n  }\n  /**\n   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}\n   * activates the binding and sets its initial value.\n   *\n   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or\n   * text node `textContent`.\n   *\n   * @protected\n   * @param {Object} options Binding options.\n   * @param {module:ui/template~TemplateValueSchema} options.schema\n   * @param {Function} options.updater A function which updates the DOM (like attribute or text).\n   * @param {module:ui/template~RenderData} options.data Rendering data.\n   */\n\n\n  _bindToObservable(_ref) {\n    let {\n      schema,\n      updater,\n      data\n    } = _ref;\n    const revertData = data.revertData; // Set initial values.\n\n    syncValueSchemaValue(schema, updater, data);\n    const revertBindings = schema // Filter \"falsy\" (false, undefined, null, '') value schema components out.\n    .filter(item => !isFalsy(item)) // Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.\n    .filter(item => item.observable) // Once only the actual binding are left, let the emitter listen to observable change:attribute event.\n    // TODO: Reduce the number of listeners attached as many bindings may listen\n    // to the same observable attribute.\n    .map(templateBinding => templateBinding.activateAttributeListener(schema, updater, data));\n\n    if (revertData) {\n      revertData.bindings.push(revertBindings);\n    }\n  }\n  /**\n   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to\n   * return it to the original state.\n   *\n   * @protected\n   * @param {HTMLElement|Text} node A node to be reverted.\n   * @param {Object} revertData An object that stores information about what changes have been made by\n   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.\n   */\n\n\n  _revertTemplateFromNode(node, revertData) {\n    for (const binding of revertData.bindings) {\n      // Each binding may consist of several observable+observable#attribute.\n      // like the following has 2:\n      //\n      //\t\tclass: [\n      //\t\t\t'x',\n      //\t\t\tbind.to( 'foo' ),\n      //\t\t\t'y',\n      //\t\t\tbind.to( 'bar' )\n      //\t\t]\n      //\n      for (const revertBinding of binding) {\n        revertBinding();\n      }\n    }\n\n    if (revertData.text) {\n      node.textContent = revertData.text;\n      return;\n    }\n\n    for (const attrName in revertData.attributes) {\n      const attrValue = revertData.attributes[attrName]; // When the attribute has **not** been set before #apply().\n\n      if (attrValue === null) {\n        node.removeAttribute(attrName);\n      } else {\n        node.setAttribute(attrName, attrValue);\n      }\n    }\n\n    for (let i = 0; i < revertData.children.length; ++i) {\n      this._revertTemplateFromNode(node.childNodes[i], revertData.children[i]);\n    }\n  }\n\n}\nmix(Template, EmitterMixin);\n/**\n * Describes a binding created by the {@link module:ui/template~Template.bind} interface.\n *\n * @protected\n */\n\nexport class TemplateBinding {\n  /**\n   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.\n   *\n   * @param {module:ui/template~TemplateDefinition} def The definition of the binding.\n   */\n  constructor(def) {\n    Object.assign(this, def);\n    /**\n     * An observable instance of the binding. It either:\n     *\n     * * provides the attribute with the value,\n     * * or passes the event when a corresponding DOM event is fired.\n     *\n     * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable\n     */\n\n    /**\n     * An {@link module:utils/emittermixin~Emitter} used by the binding to:\n     *\n     * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},\n     * * or listen to the event in the DOM.\n     *\n     * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter\n     */\n\n    /**\n     * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.\n     *\n     * @member {String} module:ui/template~TemplateBinding#attribute\n     */\n\n    /**\n     * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.\n     *\n     * @member {Function} [module:ui/template~TemplateBinding#callback]\n     */\n  }\n  /**\n   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the\n   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.\n   *\n   * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.\n   * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}.\n   */\n\n\n  getValue(node) {\n    const value = this.observable[this.attribute];\n    return this.callback ? this.callback(value, node) : value;\n  }\n  /**\n   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated\n   * value of {@link module:ui/template~TemplateValueSchema}.\n   *\n   * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.\n   * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.\n   * @param {module:ui/template~RenderData} data Rendering data.\n   * @returns {Function} A function to sever the listener binding.\n   */\n\n\n  activateAttributeListener(schema, updater, data) {\n    const callback = () => syncValueSchemaValue(schema, updater, data);\n\n    this.emitter.listenTo(this.observable, 'change:' + this.attribute, callback); // Allows revert of the listener.\n\n    return () => {\n      this.emitter.stopListening(this.observable, 'change:' + this.attribute, callback);\n    };\n  }\n\n}\n/**\n * Describes either:\n *\n * * a binding to an {@link module:utils/observablemixin~Observable},\n * * or a native DOM event binding.\n *\n * It is created by the {@link module:ui/template~BindChain#to} method.\n *\n * @protected\n */\n\nexport class TemplateToBinding extends TemplateBinding {\n  /**\n   * Activates the listener for the native DOM event, which when fired, is propagated by\n   * the {@link module:ui/template~TemplateBinding#emitter}.\n   *\n   * @param {String} domEvtName The name of the native DOM event.\n   * @param {String} domSelector The selector in the DOM to filter delegated events.\n   * @param {module:ui/template~RenderData} data Rendering data.\n   * @returns {Function} A function to sever the listener binding.\n   */\n  activateDomEventListener(domEvtName, domSelector, data) {\n    const callback = (evt, domEvt) => {\n      if (!domSelector || domEvt.target.matches(domSelector)) {\n        if (typeof this.eventNameOrFunction == 'function') {\n          this.eventNameOrFunction(domEvt);\n        } else {\n          this.observable.fire(this.eventNameOrFunction, domEvt);\n        }\n      }\n    };\n\n    this.emitter.listenTo(data.node, domEvtName, callback); // Allows revert of the listener.\n\n    return () => {\n      this.emitter.stopListening(data.node, domEvtName, callback);\n    };\n  }\n\n}\n/**\n * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}\n * method.\n *\n * @protected\n */\n\nexport class TemplateIfBinding extends TemplateBinding {\n  /**\n   * @inheritDoc\n   */\n  getValue(node) {\n    const value = super.getValue(node);\n    return isFalsy(value) ? false : this.valueIfTrue || true;\n  }\n  /**\n   * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable} is `true`.\n   *\n   * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]\n   */\n\n\n} // Checks whether given {@link module:ui/template~TemplateValueSchema} contains a\n// {@link module:ui/template~TemplateBinding}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @returns {Boolean}\n\nfunction hasTemplateBinding(schema) {\n  if (!schema) {\n    return false;\n  } // Normalize attributes with additional data like namespace:\n  //\n  //\t\tclass: {\n  //\t\t\tns: 'abc',\n  //\t\t\tvalue: [ ... ]\n  //\t\t}\n  //\n\n\n  if (schema.value) {\n    schema = schema.value;\n  }\n\n  if (Array.isArray(schema)) {\n    return schema.some(hasTemplateBinding);\n  } else if (schema instanceof TemplateBinding) {\n    return true;\n  }\n\n  return false;\n} // Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of\n// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}\n// items.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n// @returns {Array}\n\n\nfunction getValueSchemaValue(schema, node) {\n  return schema.map(schemaItem => {\n    // Process {@link module:ui/template~TemplateBinding} bindings.\n    if (schemaItem instanceof TemplateBinding) {\n      return schemaItem.getValue(node);\n    } // All static values like strings, numbers, and \"falsy\" values (false, null, undefined, '', etc.) just pass.\n\n\n    return schemaItem;\n  });\n} // A function executed each time the bound Observable attribute changes, which updates the DOM with a value\n// constructed from {@link module:ui/template~TemplateValueSchema}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Function} updater A function which updates the DOM (like attribute or text).\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n\n\nfunction syncValueSchemaValue(schema, updater, _ref2) {\n  let {\n    node\n  } = _ref2;\n  let value = getValueSchemaValue(schema, node); // Check if schema is a single Template.bind.if, like:\n  //\n  //\t\tclass: Template.bind.if( 'foo' )\n  //\n\n  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {\n    value = value[0];\n  } else {\n    value = value.reduce(arrayValueReducer, '');\n  }\n\n  if (isFalsy(value)) {\n    updater.remove();\n  } else {\n    updater.set(value);\n  }\n} // Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset `textContent`.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @returns {Object}\n\n\nfunction getTextUpdater(node) {\n  return {\n    set(value) {\n      node.textContent = value;\n    },\n\n    remove() {\n      node.textContent = '';\n    }\n\n  };\n} // Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset an attribute.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} attrName Name of the attribute to be modified.\n// @param {String} [ns=null] Namespace to use.\n// @returns {Object}\n\n\nfunction getAttributeUpdater(el, attrName, ns) {\n  return {\n    set(value) {\n      el.setAttributeNS(ns, attrName, value);\n    },\n\n    remove() {\n      el.removeAttributeNS(ns, attrName);\n    }\n\n  };\n} // Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of CSSStyleDeclaration to set or remove a style.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} styleName Name of the style to be modified.\n// @returns {Object}\n\n\nfunction getStyleUpdater(el, styleName) {\n  return {\n    set(value) {\n      el.style[styleName] = value;\n    },\n\n    remove() {\n      el.style[styleName] = null;\n    }\n\n  };\n} // Clones definition of the template.\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition}\n\n\nfunction clone(def) {\n  const clone = cloneDeepWith(def, value => {\n    // Don't clone the `Template.bind`* bindings because of the references to Observable\n    // and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy\n    // cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins\n    // along with the definition.\n    //\n    // Don't clone Template instances if provided as a child. They're simply #render()ed\n    // and nothing should interfere.\n    //\n    // Also don't clone View instances if provided as a child of the Template. The template\n    // instance will be extracted from the View during the normalization and there's no need\n    // to clone it.\n    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {\n      return value;\n    }\n  });\n  return clone;\n} // Normalizes given {@link module:ui/template~TemplateDefinition}.\n//\n// See:\n//  * {@link normalizeAttributes}\n//  * {@link normalizeListeners}\n//  * {@link normalizePlainTextDefinition}\n//  * {@link normalizeTextDefinition}\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition} Normalized definition.\n\n\nfunction normalize(def) {\n  if (typeof def == 'string') {\n    def = normalizePlainTextDefinition(def);\n  } else if (def.text) {\n    normalizeTextDefinition(def);\n  }\n\n  if (def.on) {\n    def.eventListeners = normalizeListeners(def.on); // Template mixes EmitterMixin, so delete #on to avoid collision.\n\n    delete def.on;\n  }\n\n  if (!def.text) {\n    if (def.attributes) {\n      normalizeAttributes(def.attributes);\n    }\n\n    const children = [];\n\n    if (def.children) {\n      if (isViewCollection(def.children)) {\n        children.push(def.children);\n      } else {\n        for (const child of def.children) {\n          if (isTemplate(child) || isView(child) || isNode(child)) {\n            children.push(child);\n          } else {\n            children.push(new Template(child));\n          }\n        }\n      }\n    }\n\n    def.children = children;\n  }\n\n  return def;\n} // Normalizes \"attributes\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tattributes: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: {\n//\t\t\t\tvalue: 'bar'\n//\t\t\t}\n//\t\t}\n//\n// becomes\n//\n//\t\tattributes: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: {\n//\t\t\t\tvalue: [ 'bar' ]\n//\t\t\t}\n//\t\t}\n//\n// @param {Object} attributes\n\n\nfunction normalizeAttributes(attributes) {\n  for (const a in attributes) {\n    if (attributes[a].value) {\n      attributes[a].value = toArray(attributes[a].value);\n    }\n\n    arrayify(attributes, a);\n  }\n} // Normalizes \"on\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\ton: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// becomes\n//\n//\t\ton: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// @param {Object} listeners\n// @returns {Object} Object containing normalized listeners.\n\n\nfunction normalizeListeners(listeners) {\n  for (const l in listeners) {\n    arrayify(listeners, l);\n  }\n\n  return listeners;\n} // Normalizes \"string\" {@link module:ui/template~TemplateDefinition}.\n//\n//\t\t\"foo\"\n//\n// becomes\n//\n//\t\t{ text: [ 'foo' ] },\n//\n// @param {String} def\n// @returns {module:ui/template~TemplateDefinition} Normalized template definition.\n\n\nfunction normalizePlainTextDefinition(def) {\n  return {\n    text: [def]\n  };\n} // Normalizes text {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tchildren: [\n//\t\t\t{ text: 'def' },\n//\t\t\t{ text: {@link module:ui/template~TemplateBinding} }\n//\t\t]\n//\n// becomes\n//\n//\t\tchildren: [\n//\t\t\t{ text: [ 'def' ] },\n//\t\t\t{ text: [ {@link module:ui/template~TemplateBinding} ] }\n//\t\t]\n//\n// @param {module:ui/template~TemplateDefinition} def\n\n\nfunction normalizeTextDefinition(def) {\n  def.text = toArray(def.text);\n} // Wraps an entry in Object in an Array, if not already one.\n//\n//\t\t{\n//\t\t\tx: 'y',\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// becomes\n//\n//\t\t{\n//\t\t\tx: [ 'y' ],\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// @param {Object} obj\n// @param {String} key\n\n\nfunction arrayify(obj, key) {\n  obj[key] = toArray(obj[key]);\n} // A helper which concatenates the value avoiding unwanted\n// leading white spaces.\n//\n// @param {String} prev\n// @param {String} cur\n// @returns {String}\n\n\nfunction arrayValueReducer(prev, cur) {\n  if (isFalsy(cur)) {\n    return prev;\n  } else if (isFalsy(prev)) {\n    return cur;\n  } else {\n    return `${prev} ${cur}`;\n  }\n} // Extends one object defined in the following format:\n//\n//\t\t{\n//\t\t\tkey1: [Array1],\n//\t\t\tkey2: [Array2],\n//\t\t\t...\n//\t\t\tkeyN: [ArrayN]\n//\t\t}\n//\n// with another object of the same data format.\n//\n// @param {Object} obj Base object.\n// @param {Object} ext Object extending base.\n// @returns {String}\n\n\nfunction extendObjectValueArray(obj, ext) {\n  for (const a in ext) {\n    if (obj[a]) {\n      obj[a].push(...ext[a]);\n    } else {\n      obj[a] = ext[a];\n    }\n  }\n} // A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance\n// with content from {@link module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.\n//\n// @param {module:ui/template~Template} def A template instance to be extended.\n// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.\n// @param {Object} Error context.\n\n\nfunction extendTemplate(template, def) {\n  if (def.attributes) {\n    if (!template.attributes) {\n      template.attributes = {};\n    }\n\n    extendObjectValueArray(template.attributes, def.attributes);\n  }\n\n  if (def.eventListeners) {\n    if (!template.eventListeners) {\n      template.eventListeners = {};\n    }\n\n    extendObjectValueArray(template.eventListeners, def.eventListeners);\n  }\n\n  if (def.text) {\n    template.text.push(...def.text);\n  }\n\n  if (def.children && def.children.length) {\n    if (template.children.length != def.children.length) {\n      /**\n       * The number of children in extended definition does not match.\n       *\n       * @error ui-template-extend-children-mismatch\n       */\n      throw new CKEditorError('ui-template-extend-children-mismatch', template);\n    }\n\n    let childIndex = 0;\n\n    for (const childDef of def.children) {\n      extendTemplate(template.children[childIndex++], childDef);\n    }\n  }\n} // Checks if value is \"falsy\".\n// Note: 0 (Number) is not \"falsy\" in this context.\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isFalsy(value) {\n  return !value && value !== 0;\n} // Checks if the item is an instance of {@link module:ui/view~View}\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isView(item) {\n  return item instanceof View;\n} // Checks if the item is an instance of {@link module:ui/template~Template}\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isTemplate(item) {\n  return item instanceof Template;\n} // Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isViewCollection(item) {\n  return item instanceof ViewCollection;\n} // Creates an empty skeleton for {@link module:ui/template~Template#revert}\n// data.\n//\n// @private\n\n\nfunction getEmptyRevertData() {\n  return {\n    children: [],\n    bindings: [],\n    attributes: {}\n  };\n} // Checks whether an attribute should be extended when\n// {@link module:ui/template~Template#apply} is called.\n//\n// @private\n// @param {String} attrName Attribute name to check.\n\n\nfunction shouldExtend(attrName) {\n  return attrName == 'class' || attrName == 'style';\n}\n/**\n * A definition of the {@link module:ui/template~Template}. It describes what kind of\n * node a template will render (HTML element or text), attributes of an element, DOM event\n * listeners and children.\n *\n * Also see:\n * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,\n * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.\n *\n * A sample definition on an HTML element can look like this:\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\ttag: 'span',\n *\t\t\t\t\tattributes: { ... },\n *\t\t\t\t\tchildren: [ ... ],\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\ttext: 'staticâ€“text'\n *\t\t\t\t},\n *\t\t\t\t'also-staticâ€“text',\n *\t\t\t],\n *\t\t\tattributes: {\n *\t\t\t\tclass: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tid: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tstyle: {@link module:ui/template~TemplateValueSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\t'click': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// Document.querySelector format is also accepted.\n *\t\t\t\t'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t}\n *\t\t} );\n *\n * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node\n * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:\n *\n *\t\tconst view = new SomeView();\n *\t\tconst childTemplate = new Template( { ... } );\n *\t\tconst childNode = document.createElement( 'b' );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: [\n *\t\t\t\t// view#element will be added as a child of this <p>.\n *\t\t\t\tview,\n *\n * \t\t\t\t// The output of childTemplate.render() will be added here.\n *\t\t\t\tchildTemplate,\n *\n *\t\t\t\t// Native DOM nodes are included directly in the rendered output.\n *\t\t\t\tchildNode\n *\t\t\t]\n *\t\t} );\n *\n * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:\n *\n *\t\tconst collection = new ViewCollection();\n *\t\tcollection.add( someView );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: collection\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateDefinition\n * @type Object\n *\n * @property {String} tag See the template {@link module:ui/template~Template#tag} property.\n *\n * @property {Array.<module:ui/template~TemplateDefinition>} [children]\n * See the template {@link module:ui/template~Template#children} property.\n *\n * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]\n * See the template {@link module:ui/template~Template#attributes} property.\n *\n * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]\n * See the template {@link module:ui/template~Template#text} property.\n *\n * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]\n * See the template {@link module:ui/template~Template#eventListeners} property.\n */\n\n/**\n * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple\n * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn where to use it,\n * * {@link module:ui/template~Template.bind} to learn how to configure\n * {@link module:utils/observablemixin~Observable} attribute bindings,\n * * {@link module:ui/template~Template#render} to learn how to render a template,\n * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}\n * methods to learn more about bindings.\n *\n * Attribute values can be described in many different ways:\n *\n *\t\t// Bind helper will create bindings to attributes of the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// A plain string schema.\n *\t\t\t\t'class': 'static-text',\n *\n *\t\t\t\t// An object schema, binds to the \"foo\" attribute of the\n *\t\t\t\t// observable and follows its value.\n *\t\t\t\t'class': bind.to( 'foo' ),\n *\n *\t\t\t\t// An array schema, combines the above.\n *\t\t\t\t'class': [\n *\t\t\t\t\t'static-text',\n *\t\t\t\t\tbind.to( 'bar', () => { ... } ),\n *\n * \t\t\t\t\t// Bindings can also be conditional.\n *\t\t\t\t\tbind.if( 'baz', 'class-when-baz-is-true' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema, with a custom namespace, e.g. useful for creating SVGs.\n *\t\t\t\t'class': {\n *\t\t\t\t\tns: 'http://ns.url',\n *\t\t\t\t\tvalue: [\n *\t\t\t\t\t\tbind.if( 'baz', 'value-when-true' ),\n *\t\t\t\t\t\t'static-text'\n *\t\t\t\t\t]\n *\t\t\t\t},\n *\n *\t\t\t\t// An object schema, specific for styles.\n *\t\t\t\tstyle: {\n *\t\t\t\t\tcolor: 'red',\n *\t\t\t\t\tbackgroundColor: bind.to( 'qux', () => { ... } )\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * Text nodes can also have complex values:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\t// Will render a \"foo\" text node.\n *\t\tnew Template( {\n *\t\t\ttext: 'foo'\n *\t\t} );\n *\n *\t\t// Will render a \"static text: {observable.foo}\" text node.\n *\t\t// The text of the node will be updated as the \"foo\" attribute changes.\n *\t\tnew Template( {\n *\t\t\ttext: [\n *\t\t\t\t'static text: ',\n *\t\t\t\tbind.to( 'foo', () => { ... } )\n *\t\t\t]\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateValueSchema\n * @type {Object|String|Array}\n */\n\n/**\n * Describes an event listener attached to an HTML element. Such listener can propagate DOM events\n * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks\n * or both, if necessary.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,\n * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.\n *\n * Check out different ways of attaching event listeners below:\n *\n *\t\t// Bind helper will propagate events through the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\ton: {\n *\t\t\t\t// An object schema. The observable will fire the \"clicked\" event upon DOM \"click\".\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\n *\t\t\t\t// An object schema. It will work for \"click\" event on \"a.foo\" children only.\n *\t\t\t\t'click@a.foo': bind.to( 'clicked' )\n *\n *\t\t\t\t// An array schema, makes the observable propagate multiple events.\n *\t\t\t\tclick: [\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( 'executed' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema with a custom callback.\n *\t\t\t\t'click@a.foo': {\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( evt => {\n *\t\t\t\t\t\tconsole.log( `${ evt.target } has been clicked!` );\n *\t\t\t\t\t} }\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateListenerSchema\n * @type {Object|String|Array}\n */\n\n/**\n * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`\n * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.\n *\n * @interface module:ui/template~BindChain\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to either:\n *\n * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable\n * attribute as it changes,\n * * or an HTML element DOM event, so the DOM events are propagated through an observable.\n *\n * Some common use cases of `to()` bindings are presented below:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// class=\"...\" attribute gets bound to `observable#a`\n *\t\t\t\tclass: bind.to( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t// <p>...</p> gets bound to observable#b; always `toUpperCase()`.\n *\t\t\t\t{\n *\t\t\t\t\ttext: bind.to( 'b', ( value, node ) => value.toUpperCase() )\n *\t\t\t\t}\n *\t\t\t],\n *\t\t\ton: {\n *\t\t\t\tclick: [\n *\t\t\t\t\t// An observable will fire \"clicked\" upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\n *\t\t\t\t\t// A custom callback will be executed upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( () => {\n *\t\t\t\t\t\t...\n *\t\t\t\t\t} )\n *\t\t\t\t]\n *\t\t\t}\n *\t\t} ).render();\n *\n * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and\n * {@link module:ui/template~TemplateListenerSchema}.\n *\n * @method #to\n * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of\n * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text\n * node `textContent` so it remains in sync with the observable attribute as it changes.\n *\n * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`\n * depending on the \"falseness\" of an {@link module:utils/observablemixin~Observable} attribute.\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'input',\n *\t\t\tattributes: {\n *\t\t\t\t// <input checked> when `observable#a` is not undefined/null/false/''\n *\t\t\t\t// <input> when `observable#a` is undefined/null/false\n *\t\t\t\tchecked: bind.if( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\t// <input>\"b-is-not-set\"</input> when `observable#b` is undefined/null/false/''\n *\t\t\t\t\t// <input></input> when `observable#b` is not \"falsy\"\n *\t\t\t\t\ttext: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )\n *\t\t\t\t}\n *\t\t\t]\n *\t\t} ).render();\n *\n * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.\n *\n * @method #if\n * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.\n * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not\n * undefined/null/false/'' (empty string).\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * The {@link module:ui/template~Template#_renderNode} configuration.\n *\n * @private\n * @interface module:ui/template~RenderData\n */\n\n/**\n * Tells {@link module:ui/template~Template#_renderNode} to render\n * children into `DocumentFragment` first and then append the fragment\n * to the parent element. It is a speed optimization.\n *\n * @member {Boolean} #intoFragment\n */\n\n/**\n * A node which is being rendered.\n *\n * @member {HTMLElement|Text} #node\n */\n\n/**\n * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has\n * been provided by {@module:ui/template~Template#apply}.\n *\n * @member {Boolean} #isApplying\n */\n\n/**\n * An object storing the data that helps {@module:ui/template~Template#revert}\n * bringing back an element to its initial state, i.e. before\n * {@module:ui/template~Template#apply} was called.\n *\n * @member {Object} #revertData\n */","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-ui/src/template.js"],"names":["CKEditorError","mix","EmitterMixin","View","ViewCollection","isNode","isObject","cloneDeepWith","toArray","xhtmlNs","Template","constructor","def","Object","assign","normalize","clone","_isRendered","_revertData","render","node","_renderNode","intoFragment","apply","getEmptyRevertData","isApplying","revertData","revert","_revertTemplateFromNode","getViews","search","children","child","isView","isTemplate","bind","observable","emitter","to","eventNameOrFunctionOrAttribute","callback","TemplateToBinding","eventNameOrFunction","attribute","if","valueIfTrue","TemplateIfBinding","extend","template","extendTemplate","data","isInvalid","tag","text","_renderText","_renderElement","document","createElementNS","ns","_renderAttributes","_renderElementChildren","_setUpListeners","textContent","createTextNode","hasTemplateBinding","_bindToObservable","schema","updater","getTextUpdater","join","attrName","attrValue","domAttrValue","attrNs","attributes","getAttribute","valueToBind","value","shouldExtend","unshift","getAttributeUpdater","_renderStyleAttribute","map","val","reduce","prev","next","concat","arrayValueReducer","isFalsy","setAttributeNS","styles","styleName","styleValue","getStyleUpdater","style","container","createDocumentFragment","childIndex","isViewCollection","setParent","view","appendChild","element","isRendered","childRevertData","push","childNodes","eventListeners","key","revertBindings","schemaItem","domEvtName","domSelector","split","activateDomEventListener","bindings","syncValueSchemaValue","filter","item","templateBinding","activateAttributeListener","binding","revertBinding","removeAttribute","setAttribute","i","length","TemplateBinding","getValue","listenTo","stopListening","evt","domEvt","target","matches","fire","Array","isArray","some","getValueSchemaValue","remove","set","el","removeAttributeNS","normalizePlainTextDefinition","normalizeTextDefinition","on","normalizeListeners","normalizeAttributes","a","arrayify","listeners","l","obj","cur","extendObjectValueArray","ext","childDef"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA,OAAOA,aAAP,MAA0B,6CAA1B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,MAAP,MAAmB,0CAAnB;AACA,SAASC,QAAT,EAAmBC,aAAnB,QAAwC,WAAxC;AACA,OAAOC,OAAP,MAAoB,uCAApB;AAEA,MAAMC,OAAO,GAAG,8BAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,CAAe;AAC7B;AACD;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,GAAF,EAAQ;AAClBC,IAAAA,MAAM,CAACC,MAAP,CAAe,IAAf,EAAqBC,SAAS,CAAEC,KAAK,CAAEJ,GAAF,CAAP,CAA9B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKK,WAAL,GAAmB,KAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,WAAL,GAAmB,IAAnB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,MAAM,GAAG;AACR,UAAMC,IAAI,GAAG,KAAKC,WAAL,CAAkB;AAC9BC,MAAAA,YAAY,EAAE;AADgB,KAAlB,CAAb;;AAIA,SAAKL,WAAL,GAAmB,IAAnB;AAEA,WAAOG,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,KAAK,CAAEH,IAAF,EAAS;AACb,SAAKF,WAAL,GAAmBM,kBAAkB,EAArC;;AAEA,SAAKH,WAAL,CAAkB;AACjBD,MAAAA,IADiB;AAEjBK,MAAAA,UAAU,EAAE,IAFK;AAGjBC,MAAAA,UAAU,EAAE,KAAKR;AAHA,KAAlB;;AAMA,WAAOE,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCO,EAAAA,MAAM,CAAEP,IAAF,EAAS;AACd,QAAK,CAAC,KAAKF,WAAX,EAAyB;AACxB;AACH;AACA;AACA;AACA;AACG,YAAM,IAAIlB,aAAJ,CACL,gCADK,EAEL,CAAE,IAAF,EAAQoB,IAAR,CAFK,CAAN;AAIA;;AAED,SAAKQ,uBAAL,CAA8BR,IAA9B,EAAoC,KAAKF,WAAzC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACW,GAARW,QAAQ,GAAG;AACZ,cAAUC,MAAV,CAAkBlB,GAAlB,EAAwB;AACvB,UAAKA,GAAG,CAACmB,QAAT,EAAoB;AACnB,aAAM,MAAMC,KAAZ,IAAqBpB,GAAG,CAACmB,QAAzB,EAAoC;AACnC,cAAKE,MAAM,CAAED,KAAF,CAAX,EAAuB;AACtB,kBAAMA,KAAN;AACA,WAFD,MAEO,IAAKE,UAAU,CAAEF,KAAF,CAAf,EAA2B;AACjC,mBAAOF,MAAM,CAAEE,KAAF,CAAb;AACA;AACD;AACD;AACD;;AAED,WAAOF,MAAM,CAAE,IAAF,CAAb;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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,QAAQ,EAAE,EAFJ;AAGN1C,IAAAA,UAAU,EAAE;AAHN,GAAP;AAKA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASI,YAAT,CAAuBR,QAAvB,EAAkC;AACjC,SAAOA,QAAQ,IAAI,OAAZ,IAAuBA,QAAQ,IAAI,OAA1C;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/template\n */\n\n/* global document */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport View from './view';\nimport ViewCollection from './viewcollection';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport { isObject, cloneDeepWith } from 'lodash-es';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n\nconst xhtmlNs = 'http://www.w3.org/1999/xhtml';\n\n/**\n * A basic Template class. It renders a DOM HTML element or text from a\n * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,\n * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.\n *\n * A simple template can look like this:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tclass: 'foo',\n *\t\t\t\tstyle: {\n *\t\t\t\t\tbackgroundColor: 'yellow'\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t'A paragraph.'\n *\t\t\t]\n *\t\t} ).render();\n *\n * and it will render the following HTML element:\n *\n *\t\t<p class=\"foo\" style=\"background-color: yellow;\">A paragraph.</p>\n *\n * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.\n *\n * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex\n * template definitions.\n *\n* @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Template {\n\t/**\n\t * Creates an instance of the {@link ~Template} class.\n\t *\n\t * @param {module:ui/template~TemplateDefinition} def The definition of the template.\n\t */\n\tconstructor( def ) {\n\t\tObject.assign( this, normalize( clone( def ) ) );\n\n\t\t/**\n\t\t * Indicates whether this particular Template instance has been\n\t\t * {@link #render rendered}.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._isRendered = false;\n\n\t\t/**\n\t\t * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template\n\t\t * renders to an HTML element.\n\t\t *\n\t\t * @member {String} #tag\n\t\t */\n\n\t\t/**\n\t\t * The text of the template. It also indicates that the template renders to a DOM text node.\n\t\t *\n\t\t * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text\n\t\t */\n\n\t\t/**\n\t\t * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with\n\t\t * the attributes of an HTML element.\n\t\t *\n\t\t * **Note**: This property only makes sense when {@link #tag} is defined.\n\t\t *\n\t\t * @member {Object} #attributes\n\t\t */\n\n\t\t/**\n\t\t * The children of the template. They can be either:\n\t\t * * independent instances of {@link ~Template} (subâ€“templates),\n\t\t * * native DOM Nodes.\n\t\t *\n\t\t * **Note**: This property only makes sense when {@link #tag} is defined.\n\t\t *\n\t\t * @member {Array.<module:ui/template~Template|Node>} #children\n\t\t */\n\n\t\t/**\n\t\t * The DOM event listeners of the template.\n\t\t *\n\t\t * @member {Object} #eventListeners\n\t\t */\n\n\t\t/**\n\t\t * The data used by the {@link #revert} method to restore a node to its original state.\n\t\t *\n\t\t * See: {@link #apply}.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {module:ui/template~RenderData}\n\t\t */\n\t\tthis._revertData = null;\n\t}\n\n\t/**\n\t * Renders a DOM Node (an HTML element or text) out of the template.\n\t *\n\t *\t\tconst domNode = new Template( { ... } ).render();\n\t *\n\t * See: {@link #apply}.\n\t *\n\t * @returns {HTMLElement|Text}\n\t */\n\trender() {\n\t\tconst node = this._renderNode( {\n\t\t\tintoFragment: true\n\t\t} );\n\n\t\tthis._isRendered = true;\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Applies the template to an existing DOM Node, either HTML element or text.\n\t *\n\t * **Note:** No new DOM nodes will be created. Applying extends:\n\t *\n\t * {@link module:ui/template~TemplateDefinition attributes},\n\t * {@link module:ui/template~TemplateDefinition event listeners}, and\n\t * `textContent` of {@link module:ui/template~TemplateDefinition children} only.\n\t *\n\t * **Note:** Existing `class` and `style` attributes are extended when a template\n\t * is applied to an HTML element, while other attributes and `textContent` are overridden.\n\t *\n\t * **Note:** The process of applying a template can be easily reverted using the\n\t * {@link module:ui/template~Template#revert} method.\n\t *\n\t *\t\tconst element = document.createElement( 'div' );\n\t *\t\tconst observable = new Model( { divClass: 'my-div' } );\n\t *\t\tconst emitter = Object.create( EmitterMixin );\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tid: 'first-div',\n\t *\t\t\t\tclass: bind.to( 'divClass' )\n\t *\t\t\t},\n\t *\t\t\ton: {\n\t *\t\t\t\tclick: bind( 'elementClicked' ) // Will be fired by the observable.\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t'Div text.'\n\t *\t\t\t]\n\t *\t\t} ).apply( element );\n\t *\n\t *\t\tconsole.log( element.outerHTML ); // -> '<div id=\"first-div\" class=\"my-div\"></div>'\n\t *\n\t * @see module:ui/template~Template#render\n\t * @see module:ui/template~Template#revert\n\t * @param {Node} node Root node for the template to apply.\n\t */\n\tapply( node ) {\n\t\tthis._revertData = getEmptyRevertData();\n\n\t\tthis._renderNode( {\n\t\t\tnode,\n\t\t\tisApplying: true,\n\t\t\trevertData: this._revertData\n\t\t} );\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.\n\t *\n\t * @param {Node} node The root node for the template to revert. In most of the cases, it is the\n\t * same node used by {@link module:ui/template~Template#apply}.\n\t */\n\trevert( node ) {\n\t\tif ( !this._revertData ) {\n\t\t\t/**\n\t\t\t * Attempting to revert a template which has not been applied yet.\n\t\t\t *\n\t\t\t * @error ui-template-revert-not-applied\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-revert-not-applied',\n\t\t\t\t[ this, node ]\n\t\t\t);\n\t\t}\n\n\t\tthis._revertTemplateFromNode( node, this._revertData );\n\t}\n\n\t/**\n\t * Returns an iterator which traverses the template in search of {@link module:ui/view~View}\n\t * instances and returns them one by one.\n\t *\n\t *\t\tconst viewFoo = new View();\n\t *\t\tconst viewBar = new View();\n\t *\t\tconst viewBaz = new View();\n\t *\t\tconst template = new Template( {\n\t *\t\t\ttag: 'div',\n\t *\t\t\tchildren: [\n\t *\t\t\t\tviewFoo,\n\t *\t\t\t\t{\n\t *\t\t\t\t\ttag: 'div',\n\t *\t\t\t\t\tchildren: [\n\t *\t\t\t\t\t\tviewBar\n\t *\t\t\t\t\t]\n\t *\t\t\t\t},\n\t *\t\t\t\tviewBaz\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Logs: viewFoo, viewBar, viewBaz\n\t *\t\tfor ( const view of template.getViews() ) {\n\t *\t\t\tconsole.log( view );\n\t *\t\t}\n\t *\n\t * @returns {Iterable.<module:ui/view~View>}\n\t */\n\t* getViews() {\n\t\tfunction* search( def ) {\n\t\t\tif ( def.children ) {\n\t\t\t\tfor ( const child of def.children ) {\n\t\t\t\t\tif ( isView( child ) ) {\n\t\t\t\t\t\tyield child;\n\t\t\t\t\t} else if ( isTemplate( child ) ) {\n\t\t\t\t\t\tyield* search( child );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tyield* search( this );\n\t}\n\n\t/**\n\t * An entry point to the interface which binds DOM nodes to\n\t * {@link module:utils/observablemixin~Observable observables}.\n\t * There are two types of bindings:\n\t *\n\t * * HTML element attributes or text `textContent` synchronized with attributes of an\n\t * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}\n\t * and {@link module:ui/template~BindChain#if}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\tattributes: {\n\t *\t\t\t\t// Binds the element \"class\" attribute to observable#classAttribute.\n\t *\t\t\t\tclass: bind.to( 'classAttribute' )\n\t *\t\t\t}\n\t *\t\t} ).render();\n\t *\n\t * * DOM events fired on HTML element propagated through\n\t * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\ton: {\n\t *\t\t\t\t// Will be fired by the observable.\n\t *\t\t\t\tclick: bind( 'elementClicked' )\n\t *\t\t\t}\n\t *\t\t} ).render();\n\t *\n\t * Also see {@link module:ui/view~View#bindTemplate}.\n\t *\n\t * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.\n\t * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute\n\t * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.\n\t * @returns {module:ui/template~BindChain}\n\t */\n\tstatic bind( observable, emitter ) {\n\t\treturn {\n\t\t\tto( eventNameOrFunctionOrAttribute, callback ) {\n\t\t\t\treturn new TemplateToBinding( {\n\t\t\t\t\teventNameOrFunction: eventNameOrFunctionOrAttribute,\n\t\t\t\t\tattribute: eventNameOrFunctionOrAttribute,\n\t\t\t\t\tobservable, emitter, callback\n\t\t\t\t} );\n\t\t\t},\n\n\t\t\tif( attribute, valueIfTrue, callback ) {\n\t\t\t\treturn new TemplateIfBinding( {\n\t\t\t\t\tobservable, emitter, attribute, valueIfTrue, callback\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Extends an existing {@link module:ui/template~Template} instance with some additional content\n\t * from another {@link module:ui/template~TemplateDefinition}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tconst template = new Template( {\n\t *\t\t\ttag: 'p',\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'a',\n\t *\t\t\t\tdata-x: bind.to( 'foo' )\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t{\n\t *\t\t\t\t\ttag: 'span',\n\t *\t\t\t\t\tattributes: {\n\t *\t\t\t\t\t\tclass: 'b'\n\t *\t\t\t\t\t},\n\t *\t\t\t\t\tchildren: [\n\t *\t\t\t\t\t\t'Span'\n\t *\t\t\t\t\t]\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t } );\n\t *\n\t *\t\t// Instance-level extension.\n\t *\t\tTemplate.extend( template, {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'b',\n\t *\t\t\t\tdata-x: bind.to( 'bar' )\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t{\n\t *\t\t\t\t\tattributes: {\n\t *\t\t\t\t\t\tclass: 'c'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Child extension.\n\t *\t\tTemplate.extend( template.children[ 0 ], {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'd'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * the `outerHTML` of `template.render()` is:\n\t *\n\t *\t\t<p class=\"a b\" data-x=\"{ observable.foo } { observable.bar }\">\n\t *\t\t\t<span class=\"b c d\">Span</span>\n\t *\t\t</p>\n\t *\n\t * @param {module:ui/template~Template} template An existing template instance to be extended.\n\t * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.\n\t */\n\tstatic extend( template, def ) {\n\t\tif ( template._isRendered ) {\n\t\t\t/**\n\t\t\t * Extending a template after rendering may not work as expected. To make sure\n\t\t\t * the {@link module:ui/template~Template.extend extending} works for an element,\n\t\t\t * make sure it happens before {@link #render} is called.\n\t\t\t *\n\t\t\t * @error template-extend-render\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'template-extend-render',\n\t\t\t\t[ this, template ]\n\t\t\t);\n\t\t}\n\n\t\textendTemplate( template, normalize( clone( def ) ) );\n\t}\n\n\t/**\n\t * Renders a DOM Node (either an HTML element or text) out of the template.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderNode( data ) {\n\t\tlet isInvalid;\n\n\t\tif ( data.node ) {\n\t\t\t// When applying, a definition cannot have \"tag\" and \"text\" at the same time.\n\t\t\tisInvalid = this.tag && this.text;\n\t\t} else {\n\t\t\t// When rendering, a definition must have either \"tag\" or \"text\": XOR( this.tag, this.text ).\n\t\t\tisInvalid = this.tag ? this.text : !this.text;\n\t\t}\n\n\t\tif ( isInvalid ) {\n\t\t\t/**\n\t\t\t * Node definition cannot have the \"tag\" and \"text\" properties at the same time.\n\t\t\t * Node definition must have either \"tag\" or \"text\" when rendering a new Node.\n\t\t\t *\n\t\t\t * @error ui-template-wrong-syntax\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-wrong-syntax',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tif ( this.text ) {\n\t\t\treturn this._renderText( data );\n\t\t} else {\n\t\t\treturn this._renderElement( data );\n\t\t}\n\t}\n\n\t/**\n\t * Renders an HTML element out of the template.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderElement( data ) {\n\t\tlet node = data.node;\n\n\t\tif ( !node ) {\n\t\t\tnode = data.node = document.createElementNS( this.ns || xhtmlNs, this.tag );\n\t\t}\n\n\t\tthis._renderAttributes( data );\n\t\tthis._renderElementChildren( data );\n\t\tthis._setUpListeners( data );\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Renders a text node out of {@link module:ui/template~Template#text}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderText( data ) {\n\t\tlet node = data.node;\n\n\t\t// Save the original textContent to revert it in #revert().\n\t\tif ( node ) {\n\t\t\tdata.revertData.text = node.textContent;\n\t\t} else {\n\t\t\tnode = data.node = document.createTextNode( '' );\n\t\t}\n\n\t\t// Check if this Text Node is bound to Observable. Cases:\n\t\t//\n\t\t//\t\ttext: [ Template.bind( ... ).to( ... ) ]\n\t\t//\n\t\t//\t\ttext: [\n\t\t//\t\t\t'foo',\n\t\t//\t\t\tTemplate.bind( ... ).to( ... ),\n\t\t//\t\t\t...\n\t\t//\t\t]\n\t\t//\n\t\tif ( hasTemplateBinding( this.text ) ) {\n\t\t\tthis._bindToObservable( {\n\t\t\t\tschema: this.text,\n\t\t\t\tupdater: getTextUpdater( node ),\n\t\t\t\tdata\n\t\t\t} );\n\t\t}\n\t\t// Simply set text. Cases:\n\t\t//\n\t\t//\t\ttext: [ 'all', 'are', 'static' ]\n\t\t//\n\t\t//\t\ttext: [ 'foo' ]\n\t\t//\n\t\telse {\n\t\t\tnode.textContent = this.text.join( '' );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderAttributes( data ) {\n\t\tlet attrName, attrValue, domAttrValue, attrNs;\n\n\t\tif ( !this.attributes ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = data.node;\n\t\tconst revertData = data.revertData;\n\n\t\tfor ( attrName in this.attributes ) {\n\t\t\t// Current attribute value in DOM.\n\t\t\tdomAttrValue = node.getAttribute( attrName );\n\n\t\t\t// The value to be set.\n\t\t\tattrValue = this.attributes[ attrName ];\n\n\t\t\t// Save revert data.\n\t\t\tif ( revertData ) {\n\t\t\t\trevertData.attributes[ attrName ] = domAttrValue;\n\t\t\t}\n\n\t\t\t// Detect custom namespace:\n\t\t\t//\n\t\t\t//\t\tclass: {\n\t\t\t//\t\t\tns: 'abc',\n\t\t\t//\t\t\tvalue: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tattrNs = ( isObject( attrValue[ 0 ] ) && attrValue[ 0 ].ns ) ? attrValue[ 0 ].ns : null;\n\n\t\t\t// Activate binding if one is found. Cases:\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\tTemplate.bind( ... ).to( ... )\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t'bar',\n\t\t\t//\t\t\tTemplate.bind( ... ).to( ... ),\n\t\t\t//\t\t\t'baz'\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\t//\t\tclass: {\n\t\t\t//\t\t\tns: 'abc',\n\t\t\t//\t\t\tvalue: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tif ( hasTemplateBinding( attrValue ) ) {\n\t\t\t\t// Normalize attributes with additional data like namespace:\n\t\t\t\t//\n\t\t\t\t//\t\tclass: {\n\t\t\t\t//\t\t\tns: 'abc',\n\t\t\t\t//\t\t\tvalue: [ ... ]\n\t\t\t\t//\t\t}\n\t\t\t\t//\n\t\t\t\tconst valueToBind = attrNs ? attrValue[ 0 ].value : attrValue;\n\n\t\t\t\t// Extend the original value of attributes like \"style\" and \"class\",\n\t\t\t\t// don't override them.\n\t\t\t\tif ( revertData && shouldExtend( attrName ) ) {\n\t\t\t\t\tvalueToBind.unshift( domAttrValue );\n\t\t\t\t}\n\n\t\t\t\tthis._bindToObservable( {\n\t\t\t\t\tschema: valueToBind,\n\t\t\t\t\tupdater: getAttributeUpdater( node, attrName, attrNs ),\n\t\t\t\t\tdata\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Style attribute could be an Object so it needs to be parsed in a specific way.\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\twidth: '100px',\n\t\t\t//\t\t\theight: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\telse if ( attrName == 'style' && typeof attrValue[ 0 ] !== 'string' ) {\n\t\t\t\tthis._renderStyleAttribute( attrValue[ 0 ], data );\n\t\t\t}\n\n\t\t\t// Otherwise simply set the static attribute:\n\t\t\t//\n\t\t\t//\t\tclass: [ 'foo' ]\n\t\t\t//\n\t\t\t//\t\tclass: [ 'all', 'are', 'static' ]\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t{\n\t\t\t//\t\t\t\tns: 'abc',\n\t\t\t//\t\t\t\tvalue: [ 'foo' ]\n\t\t\t//\t\t\t}\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\telse {\n\t\t\t\t// Extend the original value of attributes like \"style\" and \"class\",\n\t\t\t\t// don't override them.\n\t\t\t\tif ( revertData && domAttrValue && shouldExtend( attrName ) ) {\n\t\t\t\t\tattrValue.unshift( domAttrValue );\n\t\t\t\t}\n\n\t\t\t\tattrValue = attrValue\n\t\t\t\t\t// Retrieve \"values\" from:\n\t\t\t\t\t//\n\t\t\t\t\t//\t\tclass: [\n\t\t\t\t\t//\t\t\t{\n\t\t\t\t\t//\t\t\t\tns: 'abc',\n\t\t\t\t\t//\t\t\t\tvalue: [ ... ]\n\t\t\t\t\t//\t\t\t}\n\t\t\t\t\t//\t\t]\n\t\t\t\t\t//\n\t\t\t\t\t.map( val => val ? ( val.value || val ) : val )\n\t\t\t\t\t// Flatten the array.\n\t\t\t\t\t.reduce( ( prev, next ) => prev.concat( next ), [] )\n\t\t\t\t\t// Convert into string.\n\t\t\t\t\t.reduce( arrayValueReducer, '' );\n\n\t\t\t\tif ( !isFalsy( attrValue ) ) {\n\t\t\t\t\tnode.setAttributeNS( attrNs, attrName, attrValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders the `style` attribute of an HTML element based on\n\t * {@link module:ui/template~Template#attributes}.\n\t *\n\t * A style attribute is an {Object} with static values:\n\t *\n\t *\t\tattributes: {\n\t *\t\t\tstyle: {\n\t *\t\t\t\tcolor: 'red'\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * or values bound to {@link module:ui/model~Model} properties:\n\t *\n\t *\t\tattributes: {\n\t *\t\t\tstyle: {\n\t *\t\t\t\tcolor: bind.to( ... )\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be\n\t * needed.\n\t *\n\t * @private\n\t * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderStyleAttribute( styles, data ) {\n\t\tconst node = data.node;\n\n\t\tfor ( const styleName in styles ) {\n\t\t\tconst styleValue = styles[ styleName ];\n\n\t\t\t// Cases:\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\tcolor: bind.to( 'attribute' )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tif ( hasTemplateBinding( styleValue ) ) {\n\t\t\t\tthis._bindToObservable( {\n\t\t\t\t\tschema: [ styleValue ],\n\t\t\t\t\tupdater: getStyleUpdater( node, styleName ),\n\t\t\t\t\tdata\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Cases:\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\tcolor: 'red'\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\telse {\n\t\t\t\tnode.style[ styleName ] = styleValue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderElementChildren( data ) {\n\t\tconst node = data.node;\n\t\tconst container = data.intoFragment ? document.createDocumentFragment() : node;\n\t\tconst isApplying = data.isApplying;\n\t\tlet childIndex = 0;\n\n\t\tfor ( const child of this.children ) {\n\t\t\tif ( isViewCollection( child ) ) {\n\t\t\t\tif ( !isApplying ) {\n\t\t\t\t\tchild.setParent( node );\n\n\t\t\t\t\t// Note: ViewCollection renders its children.\n\t\t\t\t\tfor ( const view of child ) {\n\t\t\t\t\t\tcontainer.appendChild( view.element );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( isView( child ) ) {\n\t\t\t\tif ( !isApplying ) {\n\t\t\t\t\tif ( !child.isRendered ) {\n\t\t\t\t\t\tchild.render();\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer.appendChild( child.element );\n\t\t\t\t}\n\t\t\t} else if ( isNode( child ) ) {\n\t\t\t\tcontainer.appendChild( child );\n\t\t\t} else {\n\t\t\t\tif ( isApplying ) {\n\t\t\t\t\tconst revertData = data.revertData;\n\t\t\t\t\tconst childRevertData = getEmptyRevertData();\n\n\t\t\t\t\trevertData.children.push( childRevertData );\n\n\t\t\t\t\tchild._renderNode( {\n\t\t\t\t\t\tnode: container.childNodes[ childIndex++ ],\n\t\t\t\t\t\tisApplying: true,\n\t\t\t\t\t\trevertData: childRevertData\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\tcontainer.appendChild( child.render() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( data.intoFragment ) {\n\t\t\tnode.appendChild( container );\n\t\t}\n\t}\n\n\t/**\n\t * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}\n\t * on an HTML element.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_setUpListeners( data ) {\n\t\tif ( !this.eventListeners ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const key in this.eventListeners ) {\n\t\t\tconst revertBindings = this.eventListeners[ key ].map( schemaItem => {\n\t\t\t\tconst [ domEvtName, domSelector ] = key.split( '@' );\n\n\t\t\t\treturn schemaItem.activateDomEventListener( domEvtName, domSelector, data );\n\t\t\t} );\n\n\t\t\tif ( data.revertData ) {\n\t\t\t\tdata.revertData.bindings.push( revertBindings );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}\n\t * activates the binding and sets its initial value.\n\t *\n\t * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or\n\t * text node `textContent`.\n\t *\n\t * @protected\n\t * @param {Object} options Binding options.\n\t * @param {module:ui/template~TemplateValueSchema} options.schema\n\t * @param {Function} options.updater A function which updates the DOM (like attribute or text).\n\t * @param {module:ui/template~RenderData} options.data Rendering data.\n\t */\n\t_bindToObservable( { schema, updater, data } ) {\n\t\tconst revertData = data.revertData;\n\n\t\t// Set initial values.\n\t\tsyncValueSchemaValue( schema, updater, data );\n\n\t\tconst revertBindings = schema\n\t\t\t// Filter \"falsy\" (false, undefined, null, '') value schema components out.\n\t\t\t.filter( item => !isFalsy( item ) )\n\t\t\t// Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.\n\t\t\t.filter( item => item.observable )\n\t\t\t// Once only the actual binding are left, let the emitter listen to observable change:attribute event.\n\t\t\t// TODO: Reduce the number of listeners attached as many bindings may listen\n\t\t\t// to the same observable attribute.\n\t\t\t.map( templateBinding => templateBinding.activateAttributeListener( schema, updater, data ) );\n\n\t\tif ( revertData ) {\n\t\t\trevertData.bindings.push( revertBindings );\n\t\t}\n\t}\n\n\t/**\n\t * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to\n\t * return it to the original state.\n\t *\n\t * @protected\n\t * @param {HTMLElement|Text} node A node to be reverted.\n\t * @param {Object} revertData An object that stores information about what changes have been made by\n\t * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.\n\t */\n\t_revertTemplateFromNode( node, revertData ) {\n\t\tfor ( const binding of revertData.bindings ) {\n\t\t\t// Each binding may consist of several observable+observable#attribute.\n\t\t\t// like the following has 2:\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t'x',\n\t\t\t//\t\t\tbind.to( 'foo' ),\n\t\t\t//\t\t\t'y',\n\t\t\t//\t\t\tbind.to( 'bar' )\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\tfor ( const revertBinding of binding ) {\n\t\t\t\trevertBinding();\n\t\t\t}\n\t\t}\n\n\t\tif ( revertData.text ) {\n\t\t\tnode.textContent = revertData.text;\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const attrName in revertData.attributes ) {\n\t\t\tconst attrValue = revertData.attributes[ attrName ];\n\n\t\t\t// When the attribute has **not** been set before #apply().\n\t\t\tif ( attrValue === null ) {\n\t\t\t\tnode.removeAttribute( attrName );\n\t\t\t} else {\n\t\t\t\tnode.setAttribute( attrName, attrValue );\n\t\t\t}\n\t\t}\n\n\t\tfor ( let i = 0; i < revertData.children.length; ++i ) {\n\t\t\tthis._revertTemplateFromNode( node.childNodes[ i ], revertData.children[ i ] );\n\t\t}\n\t}\n}\n\nmix( Template, EmitterMixin );\n\n/**\n * Describes a binding created by the {@link module:ui/template~Template.bind} interface.\n *\n * @protected\n */\nexport class TemplateBinding {\n\t/**\n\t * Creates an instance of the {@link module:ui/template~TemplateBinding} class.\n\t *\n\t * @param {module:ui/template~TemplateDefinition} def The definition of the binding.\n\t */\n\tconstructor( def ) {\n\t\tObject.assign( this, def );\n\n\t\t/**\n\t\t * An observable instance of the binding. It either:\n\t\t *\n\t\t * * provides the attribute with the value,\n\t\t * * or passes the event when a corresponding DOM event is fired.\n\t\t *\n\t\t * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable\n\t\t */\n\n\t\t/**\n\t\t * An {@link module:utils/emittermixin~Emitter} used by the binding to:\n\t\t *\n\t\t * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},\n\t\t * * or listen to the event in the DOM.\n\t\t *\n\t\t * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter\n\t\t */\n\n\t\t/**\n\t\t * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.\n\t\t *\n\t\t * @member {String} module:ui/template~TemplateBinding#attribute\n\t\t */\n\n\t\t/**\n\t\t * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.\n\t\t *\n\t\t * @member {Function} [module:ui/template~TemplateBinding#callback]\n\t\t */\n\t}\n\n\t/**\n\t * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the\n\t * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.\n\t *\n\t * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.\n\t * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}.\n\t */\n\tgetValue( node ) {\n\t\tconst value = this.observable[ this.attribute ];\n\n\t\treturn this.callback ? this.callback( value, node ) : value;\n\t}\n\n\t/**\n\t * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated\n\t * value of {@link module:ui/template~TemplateValueSchema}.\n\t *\n\t * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.\n\t * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t * @returns {Function} A function to sever the listener binding.\n\t */\n\tactivateAttributeListener( schema, updater, data ) {\n\t\tconst callback = () => syncValueSchemaValue( schema, updater, data );\n\n\t\tthis.emitter.listenTo( this.observable, 'change:' + this.attribute, callback );\n\n\t\t// Allows revert of the listener.\n\t\treturn () => {\n\t\t\tthis.emitter.stopListening( this.observable, 'change:' + this.attribute, callback );\n\t\t};\n\t}\n}\n\n/**\n * Describes either:\n *\n * * a binding to an {@link module:utils/observablemixin~Observable},\n * * or a native DOM event binding.\n *\n * It is created by the {@link module:ui/template~BindChain#to} method.\n *\n * @protected\n */\nexport class TemplateToBinding extends TemplateBinding {\n\t/**\n\t * Activates the listener for the native DOM event, which when fired, is propagated by\n\t * the {@link module:ui/template~TemplateBinding#emitter}.\n\t *\n\t * @param {String} domEvtName The name of the native DOM event.\n\t * @param {String} domSelector The selector in the DOM to filter delegated events.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t * @returns {Function} A function to sever the listener binding.\n\t */\n\tactivateDomEventListener( domEvtName, domSelector, data ) {\n\t\tconst callback = ( evt, domEvt ) => {\n\t\t\tif ( !domSelector || domEvt.target.matches( domSelector ) ) {\n\t\t\t\tif ( typeof this.eventNameOrFunction == 'function' ) {\n\t\t\t\t\tthis.eventNameOrFunction( domEvt );\n\t\t\t\t} else {\n\t\t\t\t\tthis.observable.fire( this.eventNameOrFunction, domEvt );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.emitter.listenTo( data.node, domEvtName, callback );\n\n\t\t// Allows revert of the listener.\n\t\treturn () => {\n\t\t\tthis.emitter.stopListening( data.node, domEvtName, callback );\n\t\t};\n\t}\n}\n\n/**\n * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}\n * method.\n *\n * @protected\n */\nexport class TemplateIfBinding extends TemplateBinding {\n\t/**\n\t * @inheritDoc\n\t */\n\tgetValue( node ) {\n\t\tconst value = super.getValue( node );\n\n\t\treturn isFalsy( value ) ? false : ( this.valueIfTrue || true );\n\t}\n\n\t/**\n\t * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable} is `true`.\n\t *\n\t * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]\n\t */\n}\n\n// Checks whether given {@link module:ui/template~TemplateValueSchema} contains a\n// {@link module:ui/template~TemplateBinding}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @returns {Boolean}\nfunction hasTemplateBinding( schema ) {\n\tif ( !schema ) {\n\t\treturn false;\n\t}\n\n\t// Normalize attributes with additional data like namespace:\n\t//\n\t//\t\tclass: {\n\t//\t\t\tns: 'abc',\n\t//\t\t\tvalue: [ ... ]\n\t//\t\t}\n\t//\n\tif ( schema.value ) {\n\t\tschema = schema.value;\n\t}\n\n\tif ( Array.isArray( schema ) ) {\n\t\treturn schema.some( hasTemplateBinding );\n\t} else if ( schema instanceof TemplateBinding ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of\n// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}\n// items.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n// @returns {Array}\nfunction getValueSchemaValue( schema, node ) {\n\treturn schema.map( schemaItem => {\n\t\t// Process {@link module:ui/template~TemplateBinding} bindings.\n\t\tif ( schemaItem instanceof TemplateBinding ) {\n\t\t\treturn schemaItem.getValue( node );\n\t\t}\n\n\t\t// All static values like strings, numbers, and \"falsy\" values (false, null, undefined, '', etc.) just pass.\n\t\treturn schemaItem;\n\t} );\n}\n\n// A function executed each time the bound Observable attribute changes, which updates the DOM with a value\n// constructed from {@link module:ui/template~TemplateValueSchema}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Function} updater A function which updates the DOM (like attribute or text).\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\nfunction syncValueSchemaValue( schema, updater, { node } ) {\n\tlet value = getValueSchemaValue( schema, node );\n\n\t// Check if schema is a single Template.bind.if, like:\n\t//\n\t//\t\tclass: Template.bind.if( 'foo' )\n\t//\n\tif ( schema.length == 1 && schema[ 0 ] instanceof TemplateIfBinding ) {\n\t\tvalue = value[ 0 ];\n\t} else {\n\t\tvalue = value.reduce( arrayValueReducer, '' );\n\t}\n\n\tif ( isFalsy( value ) ) {\n\t\tupdater.remove();\n\t} else {\n\t\tupdater.set( value );\n\t}\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset `textContent`.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @returns {Object}\nfunction getTextUpdater( node ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tnode.textContent = value;\n\t\t},\n\n\t\tremove() {\n\t\t\tnode.textContent = '';\n\t\t}\n\t};\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset an attribute.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} attrName Name of the attribute to be modified.\n// @param {String} [ns=null] Namespace to use.\n// @returns {Object}\nfunction getAttributeUpdater( el, attrName, ns ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tel.setAttributeNS( ns, attrName, value );\n\t\t},\n\n\t\tremove() {\n\t\t\tel.removeAttributeNS( ns, attrName );\n\t\t}\n\t};\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of CSSStyleDeclaration to set or remove a style.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} styleName Name of the style to be modified.\n// @returns {Object}\nfunction getStyleUpdater( el, styleName ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tel.style[ styleName ] = value;\n\t\t},\n\n\t\tremove() {\n\t\t\tel.style[ styleName ] = null;\n\t\t}\n\t};\n}\n\n// Clones definition of the template.\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition}\nfunction clone( def ) {\n\tconst clone = cloneDeepWith( def, value => {\n\t\t// Don't clone the `Template.bind`* bindings because of the references to Observable\n\t\t// and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy\n\t\t// cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins\n\t\t// along with the definition.\n\t\t//\n\t\t// Don't clone Template instances if provided as a child. They're simply #render()ed\n\t\t// and nothing should interfere.\n\t\t//\n\t\t// Also don't clone View instances if provided as a child of the Template. The template\n\t\t// instance will be extracted from the View during the normalization and there's no need\n\t\t// to clone it.\n\t\tif ( value && ( value instanceof TemplateBinding || isTemplate( value ) || isView( value ) || isViewCollection( value ) ) ) {\n\t\t\treturn value;\n\t\t}\n\t} );\n\n\treturn clone;\n}\n\n// Normalizes given {@link module:ui/template~TemplateDefinition}.\n//\n// See:\n//  * {@link normalizeAttributes}\n//  * {@link normalizeListeners}\n//  * {@link normalizePlainTextDefinition}\n//  * {@link normalizeTextDefinition}\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition} Normalized definition.\nfunction normalize( def ) {\n\tif ( typeof def == 'string' ) {\n\t\tdef = normalizePlainTextDefinition( def );\n\t} else if ( def.text ) {\n\t\tnormalizeTextDefinition( def );\n\t}\n\n\tif ( def.on ) {\n\t\tdef.eventListeners = normalizeListeners( def.on );\n\n\t\t// Template mixes EmitterMixin, so delete #on to avoid collision.\n\t\tdelete def.on;\n\t}\n\n\tif ( !def.text ) {\n\t\tif ( def.attributes ) {\n\t\t\tnormalizeAttributes( def.attributes );\n\t\t}\n\n\t\tconst children = [];\n\n\t\tif ( def.children ) {\n\t\t\tif ( isViewCollection( def.children ) ) {\n\t\t\t\tchildren.push( def.children );\n\t\t\t} else {\n\t\t\t\tfor ( const child of def.children ) {\n\t\t\t\t\tif ( isTemplate( child ) || isView( child ) || isNode( child ) ) {\n\t\t\t\t\t\tchildren.push( child );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildren.push( new Template( child ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdef.children = children;\n\t}\n\n\treturn def;\n}\n\n// Normalizes \"attributes\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tattributes: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: {\n//\t\t\t\tvalue: 'bar'\n//\t\t\t}\n//\t\t}\n//\n// becomes\n//\n//\t\tattributes: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: {\n//\t\t\t\tvalue: [ 'bar' ]\n//\t\t\t}\n//\t\t}\n//\n// @param {Object} attributes\nfunction normalizeAttributes( attributes ) {\n\tfor ( const a in attributes ) {\n\t\tif ( attributes[ a ].value ) {\n\t\t\tattributes[ a ].value = toArray( attributes[ a ].value );\n\t\t}\n\n\t\tarrayify( attributes, a );\n\t}\n}\n\n// Normalizes \"on\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\ton: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// becomes\n//\n//\t\ton: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// @param {Object} listeners\n// @returns {Object} Object containing normalized listeners.\nfunction normalizeListeners( listeners ) {\n\tfor ( const l in listeners ) {\n\t\tarrayify( listeners, l );\n\t}\n\n\treturn listeners;\n}\n\n// Normalizes \"string\" {@link module:ui/template~TemplateDefinition}.\n//\n//\t\t\"foo\"\n//\n// becomes\n//\n//\t\t{ text: [ 'foo' ] },\n//\n// @param {String} def\n// @returns {module:ui/template~TemplateDefinition} Normalized template definition.\nfunction normalizePlainTextDefinition( def ) {\n\treturn {\n\t\ttext: [ def ]\n\t};\n}\n\n// Normalizes text {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tchildren: [\n//\t\t\t{ text: 'def' },\n//\t\t\t{ text: {@link module:ui/template~TemplateBinding} }\n//\t\t]\n//\n// becomes\n//\n//\t\tchildren: [\n//\t\t\t{ text: [ 'def' ] },\n//\t\t\t{ text: [ {@link module:ui/template~TemplateBinding} ] }\n//\t\t]\n//\n// @param {module:ui/template~TemplateDefinition} def\nfunction normalizeTextDefinition( def ) {\n\tdef.text = toArray( def.text );\n}\n\n// Wraps an entry in Object in an Array, if not already one.\n//\n//\t\t{\n//\t\t\tx: 'y',\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// becomes\n//\n//\t\t{\n//\t\t\tx: [ 'y' ],\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// @param {Object} obj\n// @param {String} key\nfunction arrayify( obj, key ) {\n\tobj[ key ] = toArray( obj[ key ] );\n}\n\n// A helper which concatenates the value avoiding unwanted\n// leading white spaces.\n//\n// @param {String} prev\n// @param {String} cur\n// @returns {String}\nfunction arrayValueReducer( prev, cur ) {\n\tif ( isFalsy( cur ) ) {\n\t\treturn prev;\n\t} else if ( isFalsy( prev ) ) {\n\t\treturn cur;\n\t} else {\n\t\treturn `${ prev } ${ cur }`;\n\t}\n}\n\n// Extends one object defined in the following format:\n//\n//\t\t{\n//\t\t\tkey1: [Array1],\n//\t\t\tkey2: [Array2],\n//\t\t\t...\n//\t\t\tkeyN: [ArrayN]\n//\t\t}\n//\n// with another object of the same data format.\n//\n// @param {Object} obj Base object.\n// @param {Object} ext Object extending base.\n// @returns {String}\nfunction extendObjectValueArray( obj, ext ) {\n\tfor ( const a in ext ) {\n\t\tif ( obj[ a ] ) {\n\t\t\tobj[ a ].push( ...ext[ a ] );\n\t\t} else {\n\t\t\tobj[ a ] = ext[ a ];\n\t\t}\n\t}\n}\n\n// A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance\n// with content from {@link module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.\n//\n// @param {module:ui/template~Template} def A template instance to be extended.\n// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.\n// @param {Object} Error context.\nfunction extendTemplate( template, def ) {\n\tif ( def.attributes ) {\n\t\tif ( !template.attributes ) {\n\t\t\ttemplate.attributes = {};\n\t\t}\n\n\t\textendObjectValueArray( template.attributes, def.attributes );\n\t}\n\n\tif ( def.eventListeners ) {\n\t\tif ( !template.eventListeners ) {\n\t\t\ttemplate.eventListeners = {};\n\t\t}\n\n\t\textendObjectValueArray( template.eventListeners, def.eventListeners );\n\t}\n\n\tif ( def.text ) {\n\t\ttemplate.text.push( ...def.text );\n\t}\n\n\tif ( def.children && def.children.length ) {\n\t\tif ( template.children.length != def.children.length ) {\n\t\t\t/**\n\t\t\t * The number of children in extended definition does not match.\n\t\t\t *\n\t\t\t * @error ui-template-extend-children-mismatch\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-extend-children-mismatch',\n\t\t\t\ttemplate\n\t\t\t);\n\t\t}\n\n\t\tlet childIndex = 0;\n\n\t\tfor ( const childDef of def.children ) {\n\t\t\textendTemplate( template.children[ childIndex++ ], childDef );\n\t\t}\n\t}\n}\n\n// Checks if value is \"falsy\".\n// Note: 0 (Number) is not \"falsy\" in this context.\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isFalsy( value ) {\n\treturn !value && value !== 0;\n}\n\n// Checks if the item is an instance of {@link module:ui/view~View}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isView( item ) {\n\treturn item instanceof View;\n}\n\n// Checks if the item is an instance of {@link module:ui/template~Template}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isTemplate( item ) {\n\treturn item instanceof Template;\n}\n\n// Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isViewCollection( item ) {\n\treturn item instanceof ViewCollection;\n}\n\n// Creates an empty skeleton for {@link module:ui/template~Template#revert}\n// data.\n//\n// @private\nfunction getEmptyRevertData() {\n\treturn {\n\t\tchildren: [],\n\t\tbindings: [],\n\t\tattributes: {}\n\t};\n}\n\n// Checks whether an attribute should be extended when\n// {@link module:ui/template~Template#apply} is called.\n//\n// @private\n// @param {String} attrName Attribute name to check.\nfunction shouldExtend( attrName ) {\n\treturn attrName == 'class' || attrName == 'style';\n}\n\n/**\n * A definition of the {@link module:ui/template~Template}. It describes what kind of\n * node a template will render (HTML element or text), attributes of an element, DOM event\n * listeners and children.\n *\n * Also see:\n * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,\n * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.\n *\n * A sample definition on an HTML element can look like this:\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\ttag: 'span',\n *\t\t\t\t\tattributes: { ... },\n *\t\t\t\t\tchildren: [ ... ],\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\ttext: 'staticâ€“text'\n *\t\t\t\t},\n *\t\t\t\t'also-staticâ€“text',\n *\t\t\t],\n *\t\t\tattributes: {\n *\t\t\t\tclass: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tid: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tstyle: {@link module:ui/template~TemplateValueSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\t'click': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// Document.querySelector format is also accepted.\n *\t\t\t\t'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t}\n *\t\t} );\n *\n * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node\n * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:\n *\n *\t\tconst view = new SomeView();\n *\t\tconst childTemplate = new Template( { ... } );\n *\t\tconst childNode = document.createElement( 'b' );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: [\n *\t\t\t\t// view#element will be added as a child of this <p>.\n *\t\t\t\tview,\n *\n * \t\t\t\t// The output of childTemplate.render() will be added here.\n *\t\t\t\tchildTemplate,\n *\n *\t\t\t\t// Native DOM nodes are included directly in the rendered output.\n *\t\t\t\tchildNode\n *\t\t\t]\n *\t\t} );\n *\n * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:\n *\n *\t\tconst collection = new ViewCollection();\n *\t\tcollection.add( someView );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: collection\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateDefinition\n * @type Object\n *\n * @property {String} tag See the template {@link module:ui/template~Template#tag} property.\n *\n * @property {Array.<module:ui/template~TemplateDefinition>} [children]\n * See the template {@link module:ui/template~Template#children} property.\n *\n * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]\n * See the template {@link module:ui/template~Template#attributes} property.\n *\n * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]\n * See the template {@link module:ui/template~Template#text} property.\n *\n * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]\n * See the template {@link module:ui/template~Template#eventListeners} property.\n */\n\n/**\n * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple\n * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn where to use it,\n * * {@link module:ui/template~Template.bind} to learn how to configure\n * {@link module:utils/observablemixin~Observable} attribute bindings,\n * * {@link module:ui/template~Template#render} to learn how to render a template,\n * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}\n * methods to learn more about bindings.\n *\n * Attribute values can be described in many different ways:\n *\n *\t\t// Bind helper will create bindings to attributes of the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// A plain string schema.\n *\t\t\t\t'class': 'static-text',\n *\n *\t\t\t\t// An object schema, binds to the \"foo\" attribute of the\n *\t\t\t\t// observable and follows its value.\n *\t\t\t\t'class': bind.to( 'foo' ),\n *\n *\t\t\t\t// An array schema, combines the above.\n *\t\t\t\t'class': [\n *\t\t\t\t\t'static-text',\n *\t\t\t\t\tbind.to( 'bar', () => { ... } ),\n *\n * \t\t\t\t\t// Bindings can also be conditional.\n *\t\t\t\t\tbind.if( 'baz', 'class-when-baz-is-true' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema, with a custom namespace, e.g. useful for creating SVGs.\n *\t\t\t\t'class': {\n *\t\t\t\t\tns: 'http://ns.url',\n *\t\t\t\t\tvalue: [\n *\t\t\t\t\t\tbind.if( 'baz', 'value-when-true' ),\n *\t\t\t\t\t\t'static-text'\n *\t\t\t\t\t]\n *\t\t\t\t},\n *\n *\t\t\t\t// An object schema, specific for styles.\n *\t\t\t\tstyle: {\n *\t\t\t\t\tcolor: 'red',\n *\t\t\t\t\tbackgroundColor: bind.to( 'qux', () => { ... } )\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * Text nodes can also have complex values:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\t// Will render a \"foo\" text node.\n *\t\tnew Template( {\n *\t\t\ttext: 'foo'\n *\t\t} );\n *\n *\t\t// Will render a \"static text: {observable.foo}\" text node.\n *\t\t// The text of the node will be updated as the \"foo\" attribute changes.\n *\t\tnew Template( {\n *\t\t\ttext: [\n *\t\t\t\t'static text: ',\n *\t\t\t\tbind.to( 'foo', () => { ... } )\n *\t\t\t]\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateValueSchema\n * @type {Object|String|Array}\n */\n\n/**\n * Describes an event listener attached to an HTML element. Such listener can propagate DOM events\n * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks\n * or both, if necessary.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,\n * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.\n *\n * Check out different ways of attaching event listeners below:\n *\n *\t\t// Bind helper will propagate events through the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\ton: {\n *\t\t\t\t// An object schema. The observable will fire the \"clicked\" event upon DOM \"click\".\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\n *\t\t\t\t// An object schema. It will work for \"click\" event on \"a.foo\" children only.\n *\t\t\t\t'click@a.foo': bind.to( 'clicked' )\n *\n *\t\t\t\t// An array schema, makes the observable propagate multiple events.\n *\t\t\t\tclick: [\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( 'executed' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema with a custom callback.\n *\t\t\t\t'click@a.foo': {\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( evt => {\n *\t\t\t\t\t\tconsole.log( `${ evt.target } has been clicked!` );\n *\t\t\t\t\t} }\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateListenerSchema\n * @type {Object|String|Array}\n */\n\n/**\n * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`\n * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.\n *\n * @interface module:ui/template~BindChain\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to either:\n *\n * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable\n * attribute as it changes,\n * * or an HTML element DOM event, so the DOM events are propagated through an observable.\n *\n * Some common use cases of `to()` bindings are presented below:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// class=\"...\" attribute gets bound to `observable#a`\n *\t\t\t\tclass: bind.to( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t// <p>...</p> gets bound to observable#b; always `toUpperCase()`.\n *\t\t\t\t{\n *\t\t\t\t\ttext: bind.to( 'b', ( value, node ) => value.toUpperCase() )\n *\t\t\t\t}\n *\t\t\t],\n *\t\t\ton: {\n *\t\t\t\tclick: [\n *\t\t\t\t\t// An observable will fire \"clicked\" upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\n *\t\t\t\t\t// A custom callback will be executed upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( () => {\n *\t\t\t\t\t\t...\n *\t\t\t\t\t} )\n *\t\t\t\t]\n *\t\t\t}\n *\t\t} ).render();\n *\n * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and\n * {@link module:ui/template~TemplateListenerSchema}.\n *\n * @method #to\n * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of\n * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text\n * node `textContent` so it remains in sync with the observable attribute as it changes.\n *\n * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`\n * depending on the \"falseness\" of an {@link module:utils/observablemixin~Observable} attribute.\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'input',\n *\t\t\tattributes: {\n *\t\t\t\t// <input checked> when `observable#a` is not undefined/null/false/''\n *\t\t\t\t// <input> when `observable#a` is undefined/null/false\n *\t\t\t\tchecked: bind.if( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\t// <input>\"b-is-not-set\"</input> when `observable#b` is undefined/null/false/''\n *\t\t\t\t\t// <input></input> when `observable#b` is not \"falsy\"\n *\t\t\t\t\ttext: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )\n *\t\t\t\t}\n *\t\t\t]\n *\t\t} ).render();\n *\n * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.\n *\n * @method #if\n * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.\n * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not\n * undefined/null/false/'' (empty string).\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * The {@link module:ui/template~Template#_renderNode} configuration.\n *\n * @private\n * @interface module:ui/template~RenderData\n */\n\n/**\n * Tells {@link module:ui/template~Template#_renderNode} to render\n * children into `DocumentFragment` first and then append the fragment\n * to the parent element. It is a speed optimization.\n *\n * @member {Boolean} #intoFragment\n */\n\n/**\n * A node which is being rendered.\n *\n * @member {HTMLElement|Text} #node\n */\n\n/**\n * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has\n * been provided by {@module:ui/template~Template#apply}.\n *\n * @member {Boolean} #isApplying\n */\n\n/**\n * An object storing the data that helps {@module:ui/template~Template#revert}\n * bringing back an element to its initial state, i.e. before\n * {@module:ui/template~Template#apply} was called.\n *\n * @member {Object} #revertData\n */\n"]},"metadata":{},"sourceType":"module"}