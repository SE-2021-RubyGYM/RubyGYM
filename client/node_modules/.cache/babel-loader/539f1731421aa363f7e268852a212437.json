{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widget\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport WidgetTypeAround from './widgettypearound/widgettypearound';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { getLocalizedArrowKeyCodeDirection } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport verticalNavigationHandler from './verticalnavigation';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils';\nimport '../theme/widget.css';\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class Widget extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'Widget';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [WidgetTypeAround, Delete];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    var _this = this;\n\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document;\n    /**\n     * Holds previously selected widgets.\n     *\n     * @private\n     * @type {Set.<module:engine/view/element~Element>}\n     */\n\n    this._previouslySelected = new Set(); // Model to view selection converter.\n    // Converts selection placed over widget element to fake selection.\n    //\n    // By default, the selection is downcasted by the engine to surround the attribute element, even though its only\n    // child is an inline widget. A similar thing also happens when a collapsed marker is rendered as a UI element\n    // next to an inline widget: the view selection contains both the widget and the marker.\n    //\n    // This prevents creating a correct fake selection when this inline widget is selected. Normalize the selection\n    // in these cases based on the model:\n    //\n    //\t\t[<attributeElement><inlineWidget /></attributeElement>] -> <attributeElement>[<inlineWidget />]</attributeElement>\n    //\t\t[<uiElement></uiElement><inlineWidget />] -> <uiElement></uiElement>[<inlineWidget />]\n    //\n    // Thanks to this:\n    //\n    // * fake selection can be set correctly,\n    // * any logic depending on (View)Selection#getSelectedElement() also works OK.\n    //\n    // See https://github.com/ckeditor/ckeditor5/issues/9524.\n\n    this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n      const viewWriter = conversionApi.writer;\n      const modelSelection = data.selection; // The collapsed selection can't contain any widget.\n\n      if (modelSelection.isCollapsed) {\n        return;\n      }\n\n      const selectedModelElement = modelSelection.getSelectedElement();\n\n      if (!selectedModelElement) {\n        return;\n      }\n\n      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n\n      if (!isWidget(selectedViewElement)) {\n        return;\n      }\n\n      if (!conversionApi.consumable.consume(modelSelection, 'selection')) {\n        return;\n      }\n\n      viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {\n        fake: true,\n        label: getLabel(selectedViewElement)\n      });\n    }); // Mark all widgets inside the selection with the css class.\n    // This handler is registered at the 'low' priority so it's triggered after the real selection conversion.\n\n    this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n      // Remove selected class from previously selected widgets.\n      this._clearPreviouslySelectedWidgets(conversionApi.writer);\n\n      const viewWriter = conversionApi.writer;\n      const viewSelection = viewWriter.document.selection;\n      let lastMarked = null;\n\n      for (const range of viewSelection.getRanges()) {\n        // Note: There could be multiple selected widgets in a range but no fake selection.\n        // All of them must be marked as selected, for instance [<widget></widget><widget></widget>]\n        for (const value of range) {\n          const node = value.item; // Do not mark nested widgets in selected one. See: #4594\n\n          if (isWidget(node) && !isChild(node, lastMarked)) {\n            viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);\n\n            this._previouslySelected.add(node);\n\n            lastMarked = node;\n          }\n        }\n      }\n    }, {\n      priority: 'low'\n    }); // If mouse down is pressed on widget - create selection over whole widget.\n\n    view.addObserver(MouseObserver);\n    this.listenTo(viewDocument, 'mousedown', function () {\n      return _this._onMousedown(...arguments);\n    }); // There are two keydown listeners working on different priorities. This allows other\n    // features such as WidgetTypeAround or TableKeyboard to attach their listeners in between\n    // and customize the behavior even further in different content/selection scenarios.\n    //\n    // * The first listener handles changing the selection on arrow key press\n    // if the widget is selected or if the selection is next to a widget and the widget\n    // should become selected upon the arrow key press.\n    //\n    // * The second (late) listener makes sure the default browser action on arrow key press is\n    // prevented when a widget is selected. This prevents the selection from being moved\n    // from a fake selection container.\n\n    this.listenTo(viewDocument, 'arrowKey', function () {\n      _this._handleSelectionChangeOnArrowKeyPress(...arguments);\n    }, {\n      context: [isWidget, '$text']\n    });\n    this.listenTo(viewDocument, 'arrowKey', function () {\n      _this._preventDefaultOnArrowKeyPress(...arguments);\n    }, {\n      context: '$root'\n    });\n    this.listenTo(viewDocument, 'arrowKey', verticalNavigationHandler(this.editor.editing), {\n      context: '$text'\n    }); // Handle custom delete behaviour.\n\n    this.listenTo(viewDocument, 'delete', (evt, data) => {\n      if (this._handleDelete(data.direction == 'forward')) {\n        data.preventDefault();\n        evt.stop();\n      }\n    }, {\n      context: '$root'\n    });\n  }\n  /**\n   * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n\n\n  _onMousedown(eventInfo, domEventData) {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document;\n    let element = domEventData.target; // Do nothing for single or double click inside nested editable.\n\n    if (isInsideNestedEditable(element)) {\n      // But at least triple click inside nested editable causes broken selection in Safari.\n      // For such event, we select the entire nested editable element.\n      // See: https://github.com/ckeditor/ckeditor5/issues/1463.\n      if ((env.isSafari || env.isGecko) && domEventData.domEvent.detail >= 3) {\n        const mapper = editor.editing.mapper;\n        const viewElement = element.is('attributeElement') ? element.findAncestor(element => !element.is('attributeElement')) : element;\n        const modelElement = mapper.toModelElement(viewElement);\n        domEventData.preventDefault();\n        this.editor.model.change(writer => {\n          writer.setSelection(modelElement, 'in');\n        });\n      }\n\n      return;\n    } // If target is not a widget element - check if one of the ancestors is.\n\n\n    if (!isWidget(element)) {\n      element = element.findAncestor(isWidget);\n\n      if (!element) {\n        return;\n      }\n    } // On Android selection would jump to the first table cell, on other devices\n    // we can't block it (and don't need to) because of drag and drop support.\n\n\n    if (env.isAndroid) {\n      domEventData.preventDefault();\n    } // Focus editor if is not focused already.\n\n\n    if (!viewDocument.isFocused) {\n      view.focus();\n    } // Create model selection over widget.\n\n\n    const modelElement = editor.editing.mapper.toModelElement(element);\n\n    this._setSelectionOverElement(modelElement);\n  }\n  /**\n   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes\n   * the model selection when:\n   *\n   * * arrow key is pressed when the widget is selected,\n   * * the selection is next to a widget and the widget should become selected upon the arrow key press.\n   *\n   * See {@link #_preventDefaultOnArrowKeyPress}.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n\n\n  _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {\n    const keyCode = domEventData.keyCode;\n    const model = this.editor.model;\n    const schema = model.schema;\n    const modelSelection = model.document.selection;\n    const objectElement = modelSelection.getSelectedElement();\n    const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);\n    const isForward = direction == 'down' || direction == 'right';\n    const isVerticalNavigation = direction == 'up' || direction == 'down'; // If object element is selected.\n\n    if (objectElement && schema.isObject(objectElement)) {\n      const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n      const newRange = schema.getNearestSelectionRange(position, isForward ? 'forward' : 'backward');\n\n      if (newRange) {\n        model.change(writer => {\n          writer.setSelection(newRange);\n        });\n        domEventData.preventDefault();\n        eventInfo.stop();\n      }\n\n      return;\n    } // Handle collapsing of the selection when there is any widget on the edge of selection.\n    // This is needed because browsers have problems with collapsing such selection.\n\n\n    if (!modelSelection.isCollapsed && !domEventData.shiftKey) {\n      const firstPosition = modelSelection.getFirstPosition();\n      const lastPosition = modelSelection.getLastPosition();\n      const firstSelectedNode = firstPosition.nodeAfter;\n      const lastSelectedNode = lastPosition.nodeBefore;\n\n      if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {\n        model.change(writer => {\n          writer.setSelection(isForward ? lastPosition : firstPosition);\n        });\n        domEventData.preventDefault();\n        eventInfo.stop();\n      }\n\n      return;\n    } // Return if not collapsed.\n\n\n    if (!modelSelection.isCollapsed) {\n      return;\n    } // If selection is next to object element.\n\n\n    const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);\n\n    if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {\n      // Do not select an inline widget while handling up/down arrow.\n      if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {\n        return;\n      }\n\n      this._setSelectionOverElement(objectElementNextToSelection);\n\n      domEventData.preventDefault();\n      eventInfo.stop();\n    }\n  }\n  /**\n   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents\n   * the default browser behavior to make sure the fake selection is not being moved from a fake selection\n   * container.\n   *\n   * See {@link #_handleSelectionChangeOnArrowKeyPress}.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n\n\n  _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {\n    const model = this.editor.model;\n    const schema = model.schema;\n    const objectElement = model.document.selection.getSelectedElement(); // If object element is selected.\n\n    if (objectElement && schema.isObject(objectElement)) {\n      domEventData.preventDefault();\n      eventInfo.stop();\n    }\n  }\n  /**\n   * Handles delete keys: backspace and delete.\n   *\n   * @private\n   * @param {Boolean} isForward Set to true if delete was performed in forward direction.\n   * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n   */\n\n\n  _handleDelete(isForward) {\n    // Do nothing when the read only mode is enabled.\n    if (this.editor.isReadOnly) {\n      return;\n    }\n\n    const modelDocument = this.editor.model.document;\n    const modelSelection = modelDocument.selection; // Do nothing on non-collapsed selection.\n\n    if (!modelSelection.isCollapsed) {\n      return;\n    }\n\n    const objectElement = this._getObjectElementNextToSelection(isForward);\n\n    if (objectElement) {\n      this.editor.model.change(writer => {\n        let previousNode = modelSelection.anchor.parent; // Remove previous element if empty.\n\n        while (previousNode.isEmpty) {\n          const nodeToRemove = previousNode;\n          previousNode = nodeToRemove.parent;\n          writer.remove(nodeToRemove);\n        }\n\n        this._setSelectionOverElement(objectElement);\n      });\n      return true;\n    }\n  }\n  /**\n   * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} element\n   */\n\n\n  _setSelectionOverElement(element) {\n    this.editor.model.change(writer => {\n      writer.setSelection(writer.createRangeOn(element));\n    });\n  }\n  /**\n   * Checks if {@link module:engine/model/element~Element element} placed next to the current\n   * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n   * {@link module:engine/model/schema~Schema schema} as `object`.\n   *\n   * @protected\n   * @param {Boolean} forward Direction of checking.\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  _getObjectElementNextToSelection(forward) {\n    const model = this.editor.model;\n    const schema = model.schema;\n    const modelSelection = model.document.selection; // Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n    // to its current state after undo.\n\n    const probe = model.createSelection(modelSelection);\n    model.modifySelection(probe, {\n      direction: forward ? 'forward' : 'backward'\n    }); // The selection didn't change so there is nothing there.\n\n    if (probe.isEqual(modelSelection)) {\n      return null;\n    }\n\n    const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n\n    if (!!objectElement && schema.isObject(objectElement)) {\n      return objectElement;\n    }\n\n    return null;\n  }\n  /**\n   * Removes CSS class from previously selected widgets.\n   *\n   * @private\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n   */\n\n\n  _clearPreviouslySelectedWidgets(writer) {\n    for (const widget of this._previouslySelected) {\n      writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);\n    }\n\n    this._previouslySelected.clear();\n  }\n\n} // Returns `true` when element is a nested editable or is placed inside one.\n//\n// @param {module:engine/view/element~Element}\n// @returns {Boolean}\n\nfunction isInsideNestedEditable(element) {\n  while (element) {\n    if (element.is('editableElement') && !element.is('rootElement')) {\n      return true;\n    } // Click on nested widget should select it.\n\n\n    if (isWidget(element)) {\n      return false;\n    }\n\n    element = element.parent;\n  }\n\n  return false;\n} // Checks whether the specified `element` is a child of the `parent` element.\n//\n// @param {module:engine/view/element~Element} element An element to check.\n// @param {module:engine/view/element~Element|null} parent A parent for the element.\n// @returns {Boolean}\n\n\nfunction isChild(element, parent) {\n  if (!parent) {\n    return false;\n  }\n\n  return Array.from(element.getAncestors()).includes(parent);\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-widget/src/widget.js"],"names":["Plugin","MouseObserver","WidgetTypeAround","Delete","env","getLocalizedArrowKeyCodeDirection","verticalNavigationHandler","getLabel","isWidget","WIDGET_SELECTED_CLASS_NAME","Widget","pluginName","requires","init","editor","view","editing","viewDocument","document","_previouslySelected","Set","downcastDispatcher","on","evt","data","conversionApi","viewWriter","writer","modelSelection","selection","isCollapsed","selectedModelElement","getSelectedElement","selectedViewElement","mapper","toViewElement","consumable","consume","setSelection","createRangeOn","fake","label","_clearPreviouslySelectedWidgets","viewSelection","lastMarked","range","getRanges","value","node","item","isChild","addClass","add","priority","addObserver","listenTo","_onMousedown","_handleSelectionChangeOnArrowKeyPress","context","_preventDefaultOnArrowKeyPress","_handleDelete","direction","preventDefault","stop","eventInfo","domEventData","element","target","isInsideNestedEditable","isSafari","isGecko","domEvent","detail","viewElement","is","findAncestor","modelElement","toModelElement","model","change","isAndroid","isFocused","focus","_setSelectionOverElement","keyCode","schema","objectElement","locale","contentLanguageDirection","isForward","isVerticalNavigation","isObject","position","getLastPosition","getFirstPosition","newRange","getNearestSelectionRange","shiftKey","firstPosition","lastPosition","firstSelectedNode","nodeAfter","lastSelectedNode","nodeBefore","objectElementNextToSelection","_getObjectElementNextToSelection","isInline","isReadOnly","modelDocument","previousNode","anchor","parent","isEmpty","nodeToRemove","remove","forward","probe","createSelection","modifySelection","isEqual","widget","removeClass","clear","Array","from","getAncestors","includes"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widget\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport WidgetTypeAround from './widgettypearound/widgettypearound';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { getLocalizedArrowKeyCodeDirection } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\nimport verticalNavigationHandler from './verticalnavigation';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils';\n\nimport '../theme/widget.css';\n\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Widget extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Widget';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ WidgetTypeAround, Delete ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t/**\n\t\t * Holds previously selected widgets.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<module:engine/view/element~Element>}\n\t\t */\n\t\tthis._previouslySelected = new Set();\n\n\t\t// Model to view selection converter.\n\t\t// Converts selection placed over widget element to fake selection.\n\t\t//\n\t\t// By default, the selection is downcasted by the engine to surround the attribute element, even though its only\n\t\t// child is an inline widget. A similar thing also happens when a collapsed marker is rendered as a UI element\n\t\t// next to an inline widget: the view selection contains both the widget and the marker.\n\t\t//\n\t\t// This prevents creating a correct fake selection when this inline widget is selected. Normalize the selection\n\t\t// in these cases based on the model:\n\t\t//\n\t\t//\t\t[<attributeElement><inlineWidget /></attributeElement>] -> <attributeElement>[<inlineWidget />]</attributeElement>\n\t\t//\t\t[<uiElement></uiElement><inlineWidget />] -> <uiElement></uiElement>[<inlineWidget />]\n\t\t//\n\t\t// Thanks to this:\n\t\t//\n\t\t// * fake selection can be set correctly,\n\t\t// * any logic depending on (View)Selection#getSelectedElement() also works OK.\n\t\t//\n\t\t// See https://github.com/ckeditor/ckeditor5/issues/9524.\n\t\tthis.editor.editing.downcastDispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\tconst viewWriter = conversionApi.writer;\n\t\t\tconst modelSelection = data.selection;\n\n\t\t\t// The collapsed selection can't contain any widget.\n\t\t\tif ( modelSelection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\t\tif ( !selectedModelElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedViewElement = editor.editing.mapper.toViewElement( selectedModelElement );\n\n\t\t\tif ( !isWidget( selectedViewElement ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !conversionApi.consumable.consume( modelSelection, 'selection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tviewWriter.setSelection( viewWriter.createRangeOn( selectedViewElement ), {\n\t\t\t\tfake: true,\n\t\t\t\tlabel: getLabel( selectedViewElement )\n\t\t\t} );\n\t\t} );\n\n\t\t// Mark all widgets inside the selection with the css class.\n\t\t// This handler is registered at the 'low' priority so it's triggered after the real selection conversion.\n\t\tthis.editor.editing.downcastDispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\t// Remove selected class from previously selected widgets.\n\t\t\tthis._clearPreviouslySelectedWidgets( conversionApi.writer );\n\n\t\t\tconst viewWriter = conversionApi.writer;\n\t\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\t\tlet lastMarked = null;\n\n\t\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t\t// Note: There could be multiple selected widgets in a range but no fake selection.\n\t\t\t\t// All of them must be marked as selected, for instance [<widget></widget><widget></widget>]\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tconst node = value.item;\n\t\t\t\t\t// Do not mark nested widgets in selected one. See: #4594\n\t\t\t\t\tif ( isWidget( node ) && !isChild( node, lastMarked ) ) {\n\t\t\t\t\t\tviewWriter.addClass( WIDGET_SELECTED_CLASS_NAME, node );\n\t\t\t\t\t\tthis._previouslySelected.add( node );\n\t\t\t\t\t\tlastMarked = node;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// If mouse down is pressed on widget - create selection over whole widget.\n\t\tview.addObserver( MouseObserver );\n\t\tthis.listenTo( viewDocument, 'mousedown', ( ...args ) => this._onMousedown( ...args ) );\n\n\t\t// There are two keydown listeners working on different priorities. This allows other\n\t\t// features such as WidgetTypeAround or TableKeyboard to attach their listeners in between\n\t\t// and customize the behavior even further in different content/selection scenarios.\n\t\t//\n\t\t// * The first listener handles changing the selection on arrow key press\n\t\t// if the widget is selected or if the selection is next to a widget and the widget\n\t\t// should become selected upon the arrow key press.\n\t\t//\n\t\t// * The second (late) listener makes sure the default browser action on arrow key press is\n\t\t// prevented when a widget is selected. This prevents the selection from being moved\n\t\t// from a fake selection container.\n\t\tthis.listenTo( viewDocument, 'arrowKey', ( ...args ) => {\n\t\t\tthis._handleSelectionChangeOnArrowKeyPress( ...args );\n\t\t}, { context: [ isWidget, '$text' ] } );\n\n\t\tthis.listenTo( viewDocument, 'arrowKey', ( ...args ) => {\n\t\t\tthis._preventDefaultOnArrowKeyPress( ...args );\n\t\t}, { context: '$root' } );\n\n\t\tthis.listenTo( viewDocument, 'arrowKey', verticalNavigationHandler( this.editor.editing ), { context: '$text' } );\n\n\t\t// Handle custom delete behaviour.\n\t\tthis.listenTo( viewDocument, 'delete', ( evt, data ) => {\n\t\t\tif ( this._handleDelete( data.direction == 'forward' ) ) {\n\t\t\t\tdata.preventDefault();\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { context: '$root' } );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_onMousedown( eventInfo, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\t\tlet element = domEventData.target;\n\n\t\t// Do nothing for single or double click inside nested editable.\n\t\tif ( isInsideNestedEditable( element ) ) {\n\t\t\t// But at least triple click inside nested editable causes broken selection in Safari.\n\t\t\t// For such event, we select the entire nested editable element.\n\t\t\t// See: https://github.com/ckeditor/ckeditor5/issues/1463.\n\t\t\tif ( ( env.isSafari || env.isGecko ) && domEventData.domEvent.detail >= 3 ) {\n\t\t\t\tconst mapper = editor.editing.mapper;\n\t\t\t\tconst viewElement = element.is( 'attributeElement' ) ?\n\t\t\t\t\telement.findAncestor( element => !element.is( 'attributeElement' ) ) : element;\n\t\t\t\tconst modelElement = mapper.toModelElement( viewElement );\n\n\t\t\t\tdomEventData.preventDefault();\n\n\t\t\t\tthis.editor.model.change( writer => {\n\t\t\t\t\twriter.setSelection( modelElement, 'in' );\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// If target is not a widget element - check if one of the ancestors is.\n\t\tif ( !isWidget( element ) ) {\n\t\t\telement = element.findAncestor( isWidget );\n\n\t\t\tif ( !element ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// On Android selection would jump to the first table cell, on other devices\n\t\t// we can't block it (and don't need to) because of drag and drop support.\n\t\tif ( env.isAndroid ) {\n\t\t\tdomEventData.preventDefault();\n\t\t}\n\n\t\t// Focus editor if is not focused already.\n\t\tif ( !viewDocument.isFocused ) {\n\t\t\tview.focus();\n\t\t}\n\n\t\t// Create model selection over widget.\n\t\tconst modelElement = editor.editing.mapper.toModelElement( element );\n\n\t\tthis._setSelectionOverElement( modelElement );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes\n\t * the model selection when:\n\t *\n\t * * arrow key is pressed when the widget is selected,\n\t * * the selection is next to a widget and the widget should become selected upon the arrow key press.\n\t *\n\t * See {@link #_preventDefaultOnArrowKeyPress}.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_handleSelectionChangeOnArrowKeyPress( eventInfo, domEventData ) {\n\t\tconst keyCode = domEventData.keyCode;\n\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst objectElement = modelSelection.getSelectedElement();\n\t\tconst direction = getLocalizedArrowKeyCodeDirection( keyCode, this.editor.locale.contentLanguageDirection );\n\t\tconst isForward = direction == 'down' || direction == 'right';\n\t\tconst isVerticalNavigation = direction == 'up' || direction == 'down';\n\n\t\t// If object element is selected.\n\t\tif ( objectElement && schema.isObject( objectElement ) ) {\n\t\t\tconst position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n\t\t\tconst newRange = schema.getNearestSelectionRange( position, isForward ? 'forward' : 'backward' );\n\n\t\t\tif ( newRange ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelection( newRange );\n\t\t\t\t} );\n\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t\teventInfo.stop();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Handle collapsing of the selection when there is any widget on the edge of selection.\n\t\t// This is needed because browsers have problems with collapsing such selection.\n\t\tif ( !modelSelection.isCollapsed && !domEventData.shiftKey ) {\n\t\t\tconst firstPosition = modelSelection.getFirstPosition();\n\t\t\tconst lastPosition = modelSelection.getLastPosition();\n\n\t\t\tconst firstSelectedNode = firstPosition.nodeAfter;\n\t\t\tconst lastSelectedNode = lastPosition.nodeBefore;\n\n\t\t\tif ( firstSelectedNode && schema.isObject( firstSelectedNode ) || lastSelectedNode && schema.isObject( lastSelectedNode ) ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelection( isForward ? lastPosition : firstPosition );\n\t\t\t\t} );\n\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t\teventInfo.stop();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Return if not collapsed.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If selection is next to object element.\n\n\t\tconst objectElementNextToSelection = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( objectElementNextToSelection && schema.isObject( objectElementNextToSelection ) ) {\n\t\t\t// Do not select an inline widget while handling up/down arrow.\n\t\t\tif ( schema.isInline( objectElementNextToSelection ) && isVerticalNavigation ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._setSelectionOverElement( objectElementNextToSelection );\n\n\t\t\tdomEventData.preventDefault();\n\t\t\teventInfo.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents\n\t * the default browser behavior to make sure the fake selection is not being moved from a fake selection\n\t * container.\n\t *\n\t * See {@link #_handleSelectionChangeOnArrowKeyPress}.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_preventDefaultOnArrowKeyPress( eventInfo, domEventData ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst objectElement = model.document.selection.getSelectedElement();\n\n\t\t// If object element is selected.\n\t\tif ( objectElement && schema.isObject( objectElement ) ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\teventInfo.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles delete keys: backspace and delete.\n\t *\n\t * @private\n\t * @param {Boolean} isForward Set to true if delete was performed in forward direction.\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleDelete( isForward ) {\n\t\t// Do nothing when the read only mode is enabled.\n\t\tif ( this.editor.isReadOnly ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelDocument = this.editor.model.document;\n\t\tconst modelSelection = modelDocument.selection;\n\n\t\t// Do nothing on non-collapsed selection.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst objectElement = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( objectElement ) {\n\t\t\tthis.editor.model.change( writer => {\n\t\t\t\tlet previousNode = modelSelection.anchor.parent;\n\n\t\t\t\t// Remove previous element if empty.\n\t\t\t\twhile ( previousNode.isEmpty ) {\n\t\t\t\t\tconst nodeToRemove = previousNode;\n\t\t\t\t\tpreviousNode = nodeToRemove.parent;\n\n\t\t\t\t\twriter.remove( nodeToRemove );\n\t\t\t\t}\n\n\t\t\t\tthis._setSelectionOverElement( objectElement );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_setSelectionOverElement( element ) {\n\t\tthis.editor.model.change( writer => {\n\t\t\twriter.setSelection( writer.createRangeOn( element ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Checks if {@link module:engine/model/element~Element element} placed next to the current\n\t * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n\t * {@link module:engine/model/schema~Schema schema} as `object`.\n\t *\n\t * @protected\n\t * @param {Boolean} forward Direction of checking.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getObjectElementNextToSelection( forward ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelSelection = model.document.selection;\n\n\t\t// Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n\t\t// to its current state after undo.\n\t\tconst probe = model.createSelection( modelSelection );\n\t\tmodel.modifySelection( probe, { direction: forward ? 'forward' : 'backward' } );\n\n\t\t// The selection didn't change so there is nothing there.\n\t\tif ( probe.isEqual( modelSelection ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n\n\t\tif ( !!objectElement && schema.isObject( objectElement ) ) {\n\t\t\treturn objectElement;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes CSS class from previously selected widgets.\n\t *\n\t * @private\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\t */\n\t_clearPreviouslySelectedWidgets( writer ) {\n\t\tfor ( const widget of this._previouslySelected ) {\n\t\t\twriter.removeClass( WIDGET_SELECTED_CLASS_NAME, widget );\n\t\t}\n\n\t\tthis._previouslySelected.clear();\n\t}\n}\n\n// Returns `true` when element is a nested editable or is placed inside one.\n//\n// @param {module:engine/view/element~Element}\n// @returns {Boolean}\nfunction isInsideNestedEditable( element ) {\n\twhile ( element ) {\n\t\tif ( element.is( 'editableElement' ) && !element.is( 'rootElement' ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Click on nested widget should select it.\n\t\tif ( isWidget( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\telement = element.parent;\n\t}\n\n\treturn false;\n}\n\n// Checks whether the specified `element` is a child of the `parent` element.\n//\n// @param {module:engine/view/element~Element} element An element to check.\n// @param {module:engine/view/element~Element|null} parent A parent for the element.\n// @returns {Boolean}\nfunction isChild( element, parent ) {\n\tif ( !parent ) {\n\t\treturn false;\n\t}\n\n\treturn Array.from( element.getAncestors() ).includes( parent );\n}\n"]},"metadata":{},"sourceType":"module"}