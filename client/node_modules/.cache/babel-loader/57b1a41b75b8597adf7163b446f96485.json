{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/documentfragment\n */\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * Document fragment.\n *\n * To create a new document fragment instance use the\n * {@link module:engine/view/upcastwriter~UpcastWriter#createDocumentFragment `UpcastWriter#createDocumentFragment()`}\n * method.\n */\n\nexport default class DocumentFragment {\n  /**\n   * Creates new DocumentFragment instance.\n   *\n   * @protected\n   * @param {module:engine/view/document~Document} document The document to which this document fragment belongs.\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into the created document fragment.\n   */\n  constructor(document, children) {\n    /**\n     * The document to which this document fragment belongs.\n     *\n     * @readonly\n     * @member {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Array of child nodes.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/element~Element>} module:engine/view/documentfragment~DocumentFragment#_children\n     */\n\n    this._children = [];\n\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over nodes added to this document fragment.\n   *\n   * @returns {Iterable.<module:engine/view/node~Node>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Number of child nodes in this document fragment.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isEmpty() {\n    return this.childCount === 0;\n  }\n  /**\n   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  get root() {\n    return this;\n  }\n  /**\n   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n   *\n   * @readonly\n   * @type {null}\n   */\n\n\n  get parent() {\n    return null;\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   *\t\tdocFrag.is( 'documentFragment' ); // -> true\n   *\t\tdocFrag.is( 'view:documentFragment' ); // -> true\n   *\n   *\t\tdocFrag.is( 'model:documentFragment' ); // -> false\n   *\t\tdocFrag.is( 'element' ); // -> false\n   *\t\tdocFrag.is( 'node' ); // -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'documentFragment' || type === 'view:documentFragment';\n  }\n  /**\n   * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end\n   * and sets the parent of these nodes to this fragment.\n   *\n   * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n   * @returns {Number} Number of appended nodes.\n   */\n\n\n  _appendChild(items) {\n    return this._insertChild(this.childCount, items);\n  }\n  /**\n   * Gets child at the given index.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/view/node~Node} Child node.\n   */\n\n\n  getChild(index) {\n    return this._children[index];\n  }\n  /**\n   * Gets index of the given child node. Returns `-1` if child node is not found.\n   *\n   * @param {module:engine/view/node~Node} node Child node.\n   * @returns {Number} Index of the child node.\n   */\n\n\n  getChildIndex(node) {\n    return this._children.indexOf(node);\n  }\n  /**\n   * Gets child nodes iterator.\n   *\n   * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n   */\n\n\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n   * this fragment.\n   *\n   * @param {Number} index Position where nodes should be inserted.\n   * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n   * @returns {Number} Number of inserted nodes.\n   */\n\n\n  _insertChild(index, items) {\n    this._fireChange('children', this);\n\n    let count = 0;\n    const nodes = normalize(this.document, items);\n\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n\n      node.parent = this;\n\n      this._children.splice(index, 0, node);\n\n      index++;\n      count++;\n    }\n\n    return count;\n  }\n  /**\n   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n   *\n   * @param {Number} index Number of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n   */\n\n\n  _removeChildren(index) {\n    let howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    this._fireChange('children', this);\n\n    for (let i = index; i < index + howMany; i++) {\n      this._children[i].parent = null;\n    }\n\n    return this._children.splice(index, howMany);\n  }\n  /**\n   * Fires `change` event with given type of the change.\n   *\n   * @private\n   * @param {module:engine/view/document~ChangeType} type Type of the change.\n   * @param {module:engine/view/node~Node} node Changed node.\n   * @fires module:engine/view/node~Node#change\n   */\n\n\n  _fireChange(type, node) {\n    this.fire('change:' + type, node);\n  } // @if CK_DEBUG_ENGINE // printTree() {\n  // @if CK_DEBUG_ENGINE //\tlet string = 'ViewDocumentFragment: [';\n  // @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n  // @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n  // @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + '\\t'.repeat( 1 ) + child.data;\n  // @if CK_DEBUG_ENGINE //\t\t} else {\n  // @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + child.printTree( 1 );\n  // @if CK_DEBUG_ENGINE //\t\t}\n  // @if CK_DEBUG_ENGINE //\t}\n  // @if CK_DEBUG_ENGINE //\tstring += '\\n]';\n  // @if CK_DEBUG_ENGINE //\treturn string;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logTree() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n  // @if CK_DEBUG_ENGINE // }\n\n\n}\nmix(DocumentFragment, EmitterMixin); // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\n\nfunction normalize(document, nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(document, nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(document, node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(document, node.data);\n    }\n\n    return node;\n  });\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/documentfragment.js"],"names":["Text","TextProxy","mix","isIterable","EmitterMixin","DocumentFragment","constructor","document","children","_children","_insertChild","Symbol","iterator","childCount","length","isEmpty","root","parent","is","type","_appendChild","items","getChild","index","getChildIndex","node","indexOf","getChildren","_fireChange","count","nodes","normalize","_remove","splice","_removeChildren","howMany","i","fire","Array","from","map","data"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,IAAP,MAAiB,QAAjB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,gBAAN,CAAuB;AACrC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,QAAF,EAAYC,QAAZ,EAAuB;AACjC;AACF;AACA;AACA;AACA;AACA;AACE,SAAKD,QAAL,GAAgBA,QAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKE,SAAL,GAAiB,EAAjB;;AAEA,QAAKD,QAAL,EAAgB;AACf,WAAKE,YAAL,CAAmB,CAAnB,EAAsBF,QAAtB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACkB,GAAfG,MAAM,CAACC,QAAQ,IAAK;AACrB,WAAO,KAAKH,SAAL,CAAgBE,MAAM,CAACC,QAAvB,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACe,MAAVC,UAAU,GAAG;AAChB,WAAO,KAAKJ,SAAL,CAAeK,MAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACY,MAAPC,OAAO,GAAG;AACb,WAAO,KAAKF,UAAL,KAAoB,CAA3B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACS,MAAJG,IAAI,GAAG;AACV,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACW,MAANC,MAAM,GAAG;AACZ,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,EAAE,CAAEC,IAAF,EAAS;AACV,WAAOA,IAAI,KAAK,kBAAT,IAA+BA,IAAI,KAAK,uBAA/C;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/documentfragment\n */\n\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n\n/**\n * Document fragment.\n *\n * To create a new document fragment instance use the\n * {@link module:engine/view/upcastwriter~UpcastWriter#createDocumentFragment `UpcastWriter#createDocumentFragment()`}\n * method.\n */\nexport default class DocumentFragment {\n\t/**\n\t * Creates new DocumentFragment instance.\n\t *\n\t * @protected\n\t * @param {module:engine/view/document~Document} document The document to which this document fragment belongs.\n\t * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n\t * A list of nodes to be inserted into the created document fragment.\n\t */\n\tconstructor( document, children ) {\n\t\t/**\n\t\t * The document to which this document fragment belongs.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Array of child nodes.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/view/element~Element>} module:engine/view/documentfragment~DocumentFragment#_children\n\t\t */\n\t\tthis._children = [];\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over nodes added to this document fragment.\n\t *\n\t * @returns {Iterable.<module:engine/view/node~Node>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Number of child nodes in this document fragment.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {null}\n\t */\n\tget parent() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tdocFrag.is( 'documentFragment' ); // -> true\n\t *\t\tdocFrag.is( 'view:documentFragment' ); // -> true\n\t *\n\t *\t\tdocFrag.is( 'model:documentFragment' ); // -> false\n\t *\t\tdocFrag.is( 'element' ); // -> false\n\t *\t\tdocFrag.is( 'node' ); // -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'documentFragment' || type === 'view:documentFragment';\n\t}\n\n\t/**\n\t * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end\n\t * and sets the parent of these nodes to this fragment.\n\t *\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @returns {Number} Number of appended nodes.\n\t */\n\t_appendChild( items ) {\n\t\treturn this._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Gets child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/view/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children[ index ];\n\t}\n\n\t/**\n\t * Gets index of the given child node. Returns `-1` if child node is not found.\n\t *\n\t * @param {module:engine/view/node~Node} node Child node.\n\t * @returns {Number} Index of the child node.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.indexOf( node );\n\t}\n\n\t/**\n\t * Gets child nodes iterator.\n\t *\n\t * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n\t * this fragment.\n\t *\n\t * @param {Number} index Position where nodes should be inserted.\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @returns {Number} Number of inserted nodes.\n\t */\n\t_insertChild( index, items ) {\n\t\tthis._fireChange( 'children', this );\n\t\tlet count = 0;\n\n\t\tconst nodes = normalize( this.document, items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\n\t\t\tthis._children.splice( index, 0, node );\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n\t *\n\t * @param {Number} index Number of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tthis._fireChange( 'children', this );\n\n\t\tfor ( let i = index; i < index + howMany; i++ ) {\n\t\t\tthis._children[ i ].parent = null;\n\t\t}\n\n\t\treturn this._children.splice( index, howMany );\n\t}\n\n\t/**\n\t * Fires `change` event with given type of the change.\n\t *\n\t * @private\n\t * @param {module:engine/view/document~ChangeType} type Type of the change.\n\t * @param {module:engine/view/node~Node} node Changed node.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_fireChange( type, node ) {\n\t\tthis.fire( 'change:' + type, node );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // printTree() {\n\t// @if CK_DEBUG_ENGINE //\tlet string = 'ViewDocumentFragment: [';\n\n\t// @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + '\\t'.repeat( 1 ) + child.data;\n\t// @if CK_DEBUG_ENGINE //\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += '\\n' + child.printTree( 1 );\n\t// @if CK_DEBUG_ENGINE //\t\t}\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\tstring += '\\n]';\n\n\t// @if CK_DEBUG_ENGINE //\treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\nmix( DocumentFragment, EmitterMixin );\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\nfunction normalize( document, nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( document, nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( document, node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( document, node.data );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]},"metadata":{},"sourceType":"module"}