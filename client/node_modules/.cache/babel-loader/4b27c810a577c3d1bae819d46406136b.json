{"ast":null,"code":"/**\r\n * Copyright 2013-2015, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule ReactMount\r\n */\n'use strict';\n\nvar DOMProperty = require('./DOMProperty');\n\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\n\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\n\nvar ReactElement = require('./ReactElement');\n\nvar ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');\n\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\n\nvar ReactInstanceMap = require('./ReactInstanceMap');\n\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\n\nvar ReactPerf = require('./ReactPerf');\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\n\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\n\nvar containsNode = require('fbjs/lib/containsNode');\n\nvar instantiateReactComponent = require('./instantiateReactComponent');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar setInnerHTML = require('./setInnerHTML');\n\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\n\nvar validateDOMNesting = require('./validateDOMNesting');\n\nvar warning = require('fbjs/lib/warning');\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\nvar ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);\n/** Mapping from reactRootID to React component instance. */\n\nvar instancesByReactRootID = {};\n/** Mapping from reactRootID to `container` nodes. */\n\nvar containersByReactRootID = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n} // Used to store breadth-first search state in findComponentRoot.\n\n\nvar findComponentRootReusableArray = [];\n/**\r\n * Finds the index of the first character\r\n * that's not common between the two given strings.\r\n *\r\n * @return {number} the index of the character where the strings diverge\r\n */\n\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n\n  return string1.length === string2.length ? -1 : minLen;\n}\n/**\r\n * @param {DOMElement|DOMDocument} container DOM element that may contain\r\n * a React component\r\n * @return {?*} DOM element that may have the reactRoot ID, or null.\r\n */\n\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n/**\r\n * @param {DOMElement} container DOM element that may contain a React component.\r\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\r\n */\n\n\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n/**\r\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\r\n * element can return its control whose name or ID equals ATTR_NAME. All\r\n * DOM nodes support `getAttributeNode` but this can also get called on\r\n * other objects so just return '' if we're given something other than a\r\n * DOM node (such as window).\r\n *\r\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\r\n * @return {string} ID of the supplied `domNode`.\r\n */\n\n\nfunction getID(node) {\n  var id = internalGetID(node);\n\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n\n      if (cached !== node) {\n        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n/**\r\n * Sets the React-specific ID of the given node.\r\n *\r\n * @param {DOMElement} node The DOM node whose ID will be set.\r\n * @param {string} id The value of the ID attribute.\r\n */\n\n\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n/**\r\n * Finds the node with the supplied React-generated DOM ID.\r\n *\r\n * @param {string} id A React-generated DOM ID.\r\n * @return {DOMElement} DOM node with the suppled `id`.\r\n * @internal\r\n */\n\n\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n\n  return nodeCache[id];\n}\n/**\r\n * Finds the node with the supplied public React instance.\r\n *\r\n * @param {*} instance A public React instance.\r\n * @return {?DOMElement} DOM node with the suppled `id`.\r\n * @internal\r\n */\n\n\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n\n  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {\n    return null;\n  }\n\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n\n  return nodeCache[id];\n}\n/**\r\n * A node is \"valid\" if it is contained by a currently mounted container.\r\n *\r\n * This means that the node does not have to be contained by a document in\r\n * order to be considered valid.\r\n *\r\n * @param {?DOMElement} node The candidate DOM node.\r\n * @param {string} id The expected ID of the node.\r\n * @return {boolean} Whether the node is contained by a mounted container.\r\n */\n\n\nfunction isValid(node, id) {\n  if (node) {\n    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;\n    var container = ReactMount.findReactContainerForID(id);\n\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\r\n * Causes the cache to forget about one React-specific ID.\r\n *\r\n * @param {string} id The ID to forget.\r\n */\n\n\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\n\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n/**\r\n * Return the deepest cached node whose ID is a prefix of `targetID`.\r\n */\n\n\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n/**\r\n * Mounts this component and inserts it into the DOM.\r\n *\r\n * @param {ReactComponent} componentInstance The instance to mount.\r\n * @param {string} rootID DOM ID of the root node.\r\n * @param {DOMElement} container DOM element to mount into.\r\n * @param {ReactReconcileTransaction} transaction\r\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\r\n */\n\n\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {\n  if (ReactDOMFeatureFlags.useCreateElement) {\n    context = assign({}, context);\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      context[ownerDocumentContextKey] = container;\n    } else {\n      context[ownerDocumentContextKey] = container.ownerDocument;\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (context === emptyObject) {\n      context = {};\n    }\n\n    var tag = container.nodeName.toLowerCase();\n    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);\n  }\n\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);\n  componentInstance._renderedComponent._topLevelWrapper = componentInstance;\n\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);\n}\n/**\r\n * Batched mount.\r\n *\r\n * @param {ReactComponent} componentInstance The instance to mount.\r\n * @param {string} rootID DOM ID of the root node.\r\n * @param {DOMElement} container DOM element to mount into.\r\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\r\n */\n\n\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* forceHTML */\n  shouldReuseMarkup);\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n/**\r\n * Unmounts a component and removes it from the DOM.\r\n *\r\n * @param {ReactComponent} instance React component instance.\r\n * @param {DOMElement} container DOM element to unmount from.\r\n * @final\r\n * @internal\r\n * @see {ReactMount.unmountComponentAtNode}\r\n */\n\n\nfunction unmountComponentFromNode(instance, container) {\n  ReactReconciler.unmountComponent(instance);\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    container = container.documentElement;\n  } // http://jsperf.com/emptying-a-node\n\n\n  while (container.lastChild) {\n    container.removeChild(container.lastChild);\n  }\n}\n/**\r\n * True if the supplied DOM node has a direct React-rendered child that is\r\n * not a React root element. Useful for warning in `render`,\r\n * `unmountComponentAtNode`, etc.\r\n *\r\n * @param {?DOMElement} node The candidate DOM node.\r\n * @return {boolean} True if the DOM element contains a direct child that was\r\n * rendered by React but is not a root element.\r\n * @internal\r\n */\n\n\nfunction hasNonRootReactChild(node) {\n  var reactRootID = getReactRootID(node);\n  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;\n}\n/**\r\n * Returns the first (deepest) ancestor of a node which is rendered by this copy\r\n * of React.\r\n */\n\n\nfunction findFirstReactDOMImpl(node) {\n  // This node might be from another React instance, so we make sure not to\n  // examine the node cache here\n  for (; node && node.parentNode !== node; node = node.parentNode) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      continue;\n    }\n\n    var nodeID = internalGetID(node);\n\n    if (!nodeID) {\n      continue;\n    }\n\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID); // If containersByReactRootID contains the container we find by crawling up\n    // the tree, we know that this instance of React rendered the node.\n    // nb. isValid's strategy (with containsNode) does not work because render\n    // trees may be nested and we don't want a false positive in that case.\n\n    var current = node;\n    var lastID;\n\n    do {\n      lastID = internalGetID(current);\n      current = current.parentNode;\n\n      if (current == null) {\n        // The passed-in node has been detached from the container it was\n        // originally rendered into.\n        return null;\n      }\n    } while (lastID !== reactRootID);\n\n    if (current === containersByReactRootID[reactRootID]) {\n      return node;\n    }\n  }\n\n  return null;\n}\n/**\r\n * Temporary (?) hack so that we can store all top-level pending updates on\r\n * composites instead of having to worry about different types of components\r\n * here.\r\n */\n\n\nvar TopLevelWrapper = function () {};\n\nTopLevelWrapper.prototype.isReactComponent = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\n\nTopLevelWrapper.prototype.render = function () {\n  // this.props is actually a ReactElement\n  return this.props;\n};\n/**\r\n * Mounting is the process of initializing a React component by creating its\r\n * representative DOM elements and inserting them into a supplied `container`.\r\n * Any prior content inside `container` is destroyed in the process.\r\n *\r\n *   ReactMount.render(\r\n *     component,\r\n *     document.getElementById('container')\r\n *   );\r\n *\r\n *   <div id=\"container\">                   <-- Supplied `container`.\r\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\r\n *       // ...                                 component.\r\n *     </div>\r\n *   </div>\r\n *\r\n * Inside of `container`, the first element rendered is the \"reactRoot\".\r\n */\n\n\nvar ReactMount = {\n  TopLevelWrapper: TopLevelWrapper,\n\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\r\n   * This is a hook provided to support rendering React components while\r\n   * ensuring that the apparent scroll position of its `container` does not\r\n   * change.\r\n   *\r\n   * @param {DOMElement} container The `container` being rendered into.\r\n   * @param {function} renderCallback This must be called once to do the render.\r\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\r\n   * Take a component that's already mounted into the DOM and replace its props\r\n   * @param {ReactComponent} prevComponent component instance already in the DOM\r\n   * @param {ReactElement} nextElement component instance to render\r\n   * @param {DOMElement} container container to render into\r\n   * @param {?function} callback function triggered on completion\r\n   */\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\r\n   * Register a component into the instance map and starts scroll value\r\n   * monitoring\r\n   * @param {ReactComponent} nextComponent component instance to render\r\n   * @param {DOMElement} container container to render into\r\n   * @return {string} reactRoot ID prefix\r\n   */\n  _registerComponent: function (nextComponent, container) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\r\n   * Render a new component into the DOM.\r\n   * @param {ReactElement} nextElement element to render\r\n   * @param {DOMElement} container container to render into\r\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\r\n   * @return {ReactComponent} nextComponent\r\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n    var componentInstance = instantiateReactComponent(nextElement, null);\n\n    var reactRootID = ReactMount._registerComponent(componentInstance, container); // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\r\n   * Renders a React component into the DOM in the supplied `container`.\r\n   *\r\n   * If the React component was previously rendered into `container`, this will\r\n   * perform an update on it and only mutate the DOM as necessary to reflect the\r\n   * latest React component.\r\n   *\r\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\r\n   * @param {ReactElement} nextElement Component element to render.\r\n   * @param {DOMElement} container DOM element to render into.\r\n   * @param {?function} callback function triggered on completion\r\n   * @return {ReactComponent} Component instance rendered in `container`.\r\n   */\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  },\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;\n    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevWrappedElement = prevComponent._currentElement;\n      var prevElement = prevWrappedElement.props;\n\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\n\n        var updatedCallback = callback && function () {\n          callback.call(publicInst);\n        };\n\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);\n\n        return publicInst;\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;\n\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n\n        while (rootElementSibling) {\n          if (internalGetID(rootElementSibling)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;\n            break;\n          }\n\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\n\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();\n\n    if (callback) {\n      callback.call(component);\n    }\n\n    return component;\n  },\n\n  /**\r\n   * Renders a React component into the DOM in the supplied `container`.\r\n   *\r\n   * If the React component was previously rendered into `container`, this will\r\n   * perform an update on it and only mutate the DOM as necessary to reflect the\r\n   * latest React component.\r\n   *\r\n   * @param {ReactElement} nextElement Component element to render.\r\n   * @param {DOMElement} container DOM element to render into.\r\n   * @param {?function} callback function triggered on completion\r\n   * @return {ReactComponent} Component instance rendered in `container`.\r\n   */\n  render: function (nextElement, container, callback) {\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\n  },\n\n  /**\r\n   * Registers a container node into which React components will be rendered.\r\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\r\n   * rendered within.\r\n   *\r\n   * @param {DOMElement} container DOM element to register as a container.\r\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\r\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\r\n   * Unmounts and destroys the React component rendered in the `container`.\r\n   *\r\n   * @param {DOMElement} container DOM element containing a React component.\r\n   * @return {boolean} True if a component was found in and unmounted from\r\n   *                   `container`\r\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n\n    if (!component) {\n      // Check if the node being unmounted was rendered by React, but isn't a\n      // root node.\n      var containerHasNonRootReactChild = hasNonRootReactChild(container); // Check if the container itself is a React root node.\n\n      var containerID = internalGetID(container);\n      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;\n      }\n\n      return false;\n    }\n\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n\n    if (process.env.NODE_ENV !== 'production') {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Finds the container DOM element that contains React component to which the\r\n   * supplied DOM `id` belongs.\r\n   *\r\n   * @param {string} id The ID of an element rendered by a React component.\r\n   * @return {?DOMElement} DOM element that contains the `id`.\r\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (process.env.NODE_ENV !== 'production') {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n\n      if (rootElement && rootElement.parentNode !== container) {\n        process.env.NODE_ENV !== 'production' ? warning( // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;\n        var containerChild = container.firstChild;\n\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\r\n   * Finds an element rendered by React with the supplied ID.\r\n   *\r\n   * @param {string} id ID of a DOM node in the React component.\r\n   * @return {DOMElement} Root DOM node of the React component.\r\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\r\n   * Traverses up the ancestors of the supplied node to find a node that is a\r\n   * DOM representation of a React component rendered by this copy of React.\r\n   *\r\n   * @param {*} node\r\n   * @return {?DOMEventTarget}\r\n   * @internal\r\n   */\n  getFirstReactDOM: function (node) {\n    return findFirstReactDOMImpl(node);\n  },\n\n  /**\r\n   * Finds a node with the supplied `targetID` inside of the supplied\r\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\r\n   * quickly.\r\n   *\r\n   * @param {DOMEventTarget} ancestorNode Search from this root.\r\n   * @pararm {string} targetID ID of the DOM representation of the component.\r\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\r\n   * @internal\r\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw on the next line; give an early warning\n      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\\'t find the root component node for data-reactid value ' + '`%s`. If you\\'re seeing this message, it probably means that ' + 'you\\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;\n    }\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;\n  },\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n        var normalizedMarkup = markup;\n\n        if (process.env.NODE_ENV !== 'production') {\n          // because rootMarkup is retrieved from the DOM, various normalizations\n          // will have occurred which will not be present in `markup`. Here,\n          // insert markup into a <div> or <iframe> depending on the container\n          // type to perform the same normalizations before comparing.\n          var normalizer;\n\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\n            normalizer = document.createElement('div');\n            normalizer.innerHTML = markup;\n            normalizedMarkup = normalizer.innerHTML;\n          } else {\n            normalizer = document.createElement('iframe');\n            document.body.appendChild(normalizer);\n            normalizer.contentDocument.write(markup);\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\n            document.body.removeChild(normalizer);\n          }\n        }\n\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(false) : undefined;\n\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : undefined;\n        }\n      }\n    }\n\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\n\n    if (transaction.useCreateElement) {\n      while (container.lastChild) {\n        container.removeChild(container.lastChild);\n      }\n\n      container.appendChild(markup);\n    } else {\n      setInnerHTML(container, markup);\n    }\n  },\n  ownerDocumentContextKey: ownerDocumentContextKey,\n\n  /**\r\n   * React ID utilities.\r\n   */\n  getReactRootID: getReactRootID,\n  getID: getID,\n  setID: setID,\n  getNode: getNode,\n  getNodeFromInstance: getNodeFromInstance,\n  isValid: isValid,\n  purgeID: purgeID\n};\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\nmodule.exports = ReactMount;","map":{"version":3,"sources":["C:/Users/nvtung/Các project thực hiện/RubyGYM-master_test_2/client/node_modules/jsx-to-string/node_modules/react/lib/ReactMount.js"],"names":["DOMProperty","require","ReactBrowserEventEmitter","ReactCurrentOwner","ReactDOMFeatureFlags","ReactElement","ReactEmptyComponentRegistry","ReactInstanceHandles","ReactInstanceMap","ReactMarkupChecksum","ReactPerf","ReactReconciler","ReactUpdateQueue","ReactUpdates","assign","emptyObject","containsNode","instantiateReactComponent","invariant","setInnerHTML","shouldUpdateReactComponent","validateDOMNesting","warning","ATTR_NAME","ID_ATTRIBUTE_NAME","nodeCache","ELEMENT_NODE_TYPE","DOC_NODE_TYPE","DOCUMENT_FRAGMENT_NODE_TYPE","ownerDocumentContextKey","Math","random","toString","slice","instancesByReactRootID","containersByReactRootID","process","env","NODE_ENV","rootElementsByReactRootID","findComponentRootReusableArray","firstDifferenceIndex","string1","string2","minLen","min","length","i","charAt","getReactRootElementInContainer","container","nodeType","documentElement","firstChild","getReactRootID","rootElement","ReactMount","getID","node","id","internalGetID","hasOwnProperty","cached","isValid","undefined","getAttribute","setID","oldID","setAttribute","getNode","findReactNodeByID","getNodeFromInstance","instance","get","_rootNodeID","isNullComponentID","findReactContainerForID","purgeID","deepestNodeSoFar","findDeepestCachedAncestorImpl","ancestorID","ancestor","findDeepestCachedAncestor","targetID","traverseAncestors","foundNode","mountComponentIntoNode","componentInstance","rootID","transaction","shouldReuseMarkup","context","useCreateElement","ownerDocument","tag","nodeName","toLowerCase","ancestorInfoContextKey","updatedAncestorInfo","markup","mountComponent","_renderedComponent","_topLevelWrapper","_mountImageIntoNode","batchedMountComponentIntoNode","ReactReconcileTransaction","getPooled","perform","release","unmountComponentFromNode","unmountComponent","lastChild","removeChild","hasNonRootReactChild","reactRootID","getReactRootIDFromNodeID","findFirstReactDOMImpl","parentNode","nodeID","current","lastID","TopLevelWrapper","prototype","isReactComponent","displayName","render","props","_instancesByReactRootID","scrollMonitor","renderCallback","_updateRootComponent","prevComponent","nextElement","callback","enqueueElementInternal","enqueueCallbackInternal","_registerComponent","nextComponent","ensureScrollValueMonitoring","registerContainer","_renderNewRootComponent","getName","batchedUpdates","renderSubtreeIntoContainer","parentComponent","_reactInternalInstance","_renderSubtreeIntoContainer","isValidElement","tagName","toUpperCase","nextWrappedElement","prevWrappedElement","_currentElement","prevElement","publicInst","getPublicInstance","updatedCallback","call","unmountComponentAtNode","reactRootElement","containerHasReactMarkup","containerHasNonRootReactChild","nextSibling","rootElementSibling","component","_processChildContext","_context","createReactRootID","containerID","isContainerReactRoot","containerChild","reactRoot","findComponentRoot","getFirstReactDOM","ancestorNode","firstChildren","childIndex","deepestAncestor","child","targetChild","childID","isAncestorIDOf","push","canReuseMarkup","checksum","CHECKSUM_ATTR_NAME","removeAttribute","rootMarkup","outerHTML","normalizedMarkup","normalizer","document","createElement","innerHTML","body","appendChild","contentDocument","write","diffIndex","difference","substring","measureMethods","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright 2013-2015, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule ReactMount\r\n */\r\n\r\n'use strict';\r\n\r\nvar DOMProperty = require('./DOMProperty');\r\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\r\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\r\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\r\nvar ReactElement = require('./ReactElement');\r\nvar ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');\r\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\r\nvar ReactInstanceMap = require('./ReactInstanceMap');\r\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\r\nvar ReactPerf = require('./ReactPerf');\r\nvar ReactReconciler = require('./ReactReconciler');\r\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\r\nvar ReactUpdates = require('./ReactUpdates');\r\n\r\nvar assign = require('./Object.assign');\r\nvar emptyObject = require('fbjs/lib/emptyObject');\r\nvar containsNode = require('fbjs/lib/containsNode');\r\nvar instantiateReactComponent = require('./instantiateReactComponent');\r\nvar invariant = require('fbjs/lib/invariant');\r\nvar setInnerHTML = require('./setInnerHTML');\r\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\r\nvar validateDOMNesting = require('./validateDOMNesting');\r\nvar warning = require('fbjs/lib/warning');\r\n\r\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\r\nvar nodeCache = {};\r\n\r\nvar ELEMENT_NODE_TYPE = 1;\r\nvar DOC_NODE_TYPE = 9;\r\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\r\n\r\nvar ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);\r\n\r\n/** Mapping from reactRootID to React component instance. */\r\nvar instancesByReactRootID = {};\r\n\r\n/** Mapping from reactRootID to `container` nodes. */\r\nvar containersByReactRootID = {};\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  /** __DEV__-only mapping from reactRootID to root elements. */\r\n  var rootElementsByReactRootID = {};\r\n}\r\n\r\n// Used to store breadth-first search state in findComponentRoot.\r\nvar findComponentRootReusableArray = [];\r\n\r\n/**\r\n * Finds the index of the first character\r\n * that's not common between the two given strings.\r\n *\r\n * @return {number} the index of the character where the strings diverge\r\n */\r\nfunction firstDifferenceIndex(string1, string2) {\r\n  var minLen = Math.min(string1.length, string2.length);\r\n  for (var i = 0; i < minLen; i++) {\r\n    if (string1.charAt(i) !== string2.charAt(i)) {\r\n      return i;\r\n    }\r\n  }\r\n  return string1.length === string2.length ? -1 : minLen;\r\n}\r\n\r\n/**\r\n * @param {DOMElement|DOMDocument} container DOM element that may contain\r\n * a React component\r\n * @return {?*} DOM element that may have the reactRoot ID, or null.\r\n */\r\nfunction getReactRootElementInContainer(container) {\r\n  if (!container) {\r\n    return null;\r\n  }\r\n\r\n  if (container.nodeType === DOC_NODE_TYPE) {\r\n    return container.documentElement;\r\n  } else {\r\n    return container.firstChild;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {DOMElement} container DOM element that may contain a React component.\r\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\r\n */\r\nfunction getReactRootID(container) {\r\n  var rootElement = getReactRootElementInContainer(container);\r\n  return rootElement && ReactMount.getID(rootElement);\r\n}\r\n\r\n/**\r\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\r\n * element can return its control whose name or ID equals ATTR_NAME. All\r\n * DOM nodes support `getAttributeNode` but this can also get called on\r\n * other objects so just return '' if we're given something other than a\r\n * DOM node (such as window).\r\n *\r\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\r\n * @return {string} ID of the supplied `domNode`.\r\n */\r\nfunction getID(node) {\r\n  var id = internalGetID(node);\r\n  if (id) {\r\n    if (nodeCache.hasOwnProperty(id)) {\r\n      var cached = nodeCache[id];\r\n      if (cached !== node) {\r\n        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;\r\n\r\n        nodeCache[id] = node;\r\n      }\r\n    } else {\r\n      nodeCache[id] = node;\r\n    }\r\n  }\r\n\r\n  return id;\r\n}\r\n\r\nfunction internalGetID(node) {\r\n  // If node is something like a window, document, or text node, none of\r\n  // which support attributes or a .getAttribute method, gracefully return\r\n  // the empty string, as if the attribute were missing.\r\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\r\n}\r\n\r\n/**\r\n * Sets the React-specific ID of the given node.\r\n *\r\n * @param {DOMElement} node The DOM node whose ID will be set.\r\n * @param {string} id The value of the ID attribute.\r\n */\r\nfunction setID(node, id) {\r\n  var oldID = internalGetID(node);\r\n  if (oldID !== id) {\r\n    delete nodeCache[oldID];\r\n  }\r\n  node.setAttribute(ATTR_NAME, id);\r\n  nodeCache[id] = node;\r\n}\r\n\r\n/**\r\n * Finds the node with the supplied React-generated DOM ID.\r\n *\r\n * @param {string} id A React-generated DOM ID.\r\n * @return {DOMElement} DOM node with the suppled `id`.\r\n * @internal\r\n */\r\nfunction getNode(id) {\r\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\r\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\r\n  }\r\n  return nodeCache[id];\r\n}\r\n\r\n/**\r\n * Finds the node with the supplied public React instance.\r\n *\r\n * @param {*} instance A public React instance.\r\n * @return {?DOMElement} DOM node with the suppled `id`.\r\n * @internal\r\n */\r\nfunction getNodeFromInstance(instance) {\r\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\r\n  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {\r\n    return null;\r\n  }\r\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\r\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\r\n  }\r\n  return nodeCache[id];\r\n}\r\n\r\n/**\r\n * A node is \"valid\" if it is contained by a currently mounted container.\r\n *\r\n * This means that the node does not have to be contained by a document in\r\n * order to be considered valid.\r\n *\r\n * @param {?DOMElement} node The candidate DOM node.\r\n * @param {string} id The expected ID of the node.\r\n * @return {boolean} Whether the node is contained by a mounted container.\r\n */\r\nfunction isValid(node, id) {\r\n  if (node) {\r\n    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;\r\n\r\n    var container = ReactMount.findReactContainerForID(id);\r\n    if (container && containsNode(container, node)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Causes the cache to forget about one React-specific ID.\r\n *\r\n * @param {string} id The ID to forget.\r\n */\r\nfunction purgeID(id) {\r\n  delete nodeCache[id];\r\n}\r\n\r\nvar deepestNodeSoFar = null;\r\nfunction findDeepestCachedAncestorImpl(ancestorID) {\r\n  var ancestor = nodeCache[ancestorID];\r\n  if (ancestor && isValid(ancestor, ancestorID)) {\r\n    deepestNodeSoFar = ancestor;\r\n  } else {\r\n    // This node isn't populated in the cache, so presumably none of its\r\n    // descendants are. Break out of the loop.\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Return the deepest cached node whose ID is a prefix of `targetID`.\r\n */\r\nfunction findDeepestCachedAncestor(targetID) {\r\n  deepestNodeSoFar = null;\r\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\r\n\r\n  var foundNode = deepestNodeSoFar;\r\n  deepestNodeSoFar = null;\r\n  return foundNode;\r\n}\r\n\r\n/**\r\n * Mounts this component and inserts it into the DOM.\r\n *\r\n * @param {ReactComponent} componentInstance The instance to mount.\r\n * @param {string} rootID DOM ID of the root node.\r\n * @param {DOMElement} container DOM element to mount into.\r\n * @param {ReactReconcileTransaction} transaction\r\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\r\n */\r\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {\r\n  if (ReactDOMFeatureFlags.useCreateElement) {\r\n    context = assign({}, context);\r\n    if (container.nodeType === DOC_NODE_TYPE) {\r\n      context[ownerDocumentContextKey] = container;\r\n    } else {\r\n      context[ownerDocumentContextKey] = container.ownerDocument;\r\n    }\r\n  }\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (context === emptyObject) {\r\n      context = {};\r\n    }\r\n    var tag = container.nodeName.toLowerCase();\r\n    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);\r\n  }\r\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);\r\n  componentInstance._renderedComponent._topLevelWrapper = componentInstance;\r\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);\r\n}\r\n\r\n/**\r\n * Batched mount.\r\n *\r\n * @param {ReactComponent} componentInstance The instance to mount.\r\n * @param {string} rootID DOM ID of the root node.\r\n * @param {DOMElement} container DOM element to mount into.\r\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\r\n */\r\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {\r\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\r\n  /* forceHTML */shouldReuseMarkup);\r\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);\r\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\r\n}\r\n\r\n/**\r\n * Unmounts a component and removes it from the DOM.\r\n *\r\n * @param {ReactComponent} instance React component instance.\r\n * @param {DOMElement} container DOM element to unmount from.\r\n * @final\r\n * @internal\r\n * @see {ReactMount.unmountComponentAtNode}\r\n */\r\nfunction unmountComponentFromNode(instance, container) {\r\n  ReactReconciler.unmountComponent(instance);\r\n\r\n  if (container.nodeType === DOC_NODE_TYPE) {\r\n    container = container.documentElement;\r\n  }\r\n\r\n  // http://jsperf.com/emptying-a-node\r\n  while (container.lastChild) {\r\n    container.removeChild(container.lastChild);\r\n  }\r\n}\r\n\r\n/**\r\n * True if the supplied DOM node has a direct React-rendered child that is\r\n * not a React root element. Useful for warning in `render`,\r\n * `unmountComponentAtNode`, etc.\r\n *\r\n * @param {?DOMElement} node The candidate DOM node.\r\n * @return {boolean} True if the DOM element contains a direct child that was\r\n * rendered by React but is not a root element.\r\n * @internal\r\n */\r\nfunction hasNonRootReactChild(node) {\r\n  var reactRootID = getReactRootID(node);\r\n  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;\r\n}\r\n\r\n/**\r\n * Returns the first (deepest) ancestor of a node which is rendered by this copy\r\n * of React.\r\n */\r\nfunction findFirstReactDOMImpl(node) {\r\n  // This node might be from another React instance, so we make sure not to\r\n  // examine the node cache here\r\n  for (; node && node.parentNode !== node; node = node.parentNode) {\r\n    if (node.nodeType !== 1) {\r\n      // Not a DOMElement, therefore not a React component\r\n      continue;\r\n    }\r\n    var nodeID = internalGetID(node);\r\n    if (!nodeID) {\r\n      continue;\r\n    }\r\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\r\n\r\n    // If containersByReactRootID contains the container we find by crawling up\r\n    // the tree, we know that this instance of React rendered the node.\r\n    // nb. isValid's strategy (with containsNode) does not work because render\r\n    // trees may be nested and we don't want a false positive in that case.\r\n    var current = node;\r\n    var lastID;\r\n    do {\r\n      lastID = internalGetID(current);\r\n      current = current.parentNode;\r\n      if (current == null) {\r\n        // The passed-in node has been detached from the container it was\r\n        // originally rendered into.\r\n        return null;\r\n      }\r\n    } while (lastID !== reactRootID);\r\n\r\n    if (current === containersByReactRootID[reactRootID]) {\r\n      return node;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Temporary (?) hack so that we can store all top-level pending updates on\r\n * composites instead of having to worry about different types of components\r\n * here.\r\n */\r\nvar TopLevelWrapper = function () {};\r\nTopLevelWrapper.prototype.isReactComponent = {};\r\nif (process.env.NODE_ENV !== 'production') {\r\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\r\n}\r\nTopLevelWrapper.prototype.render = function () {\r\n  // this.props is actually a ReactElement\r\n  return this.props;\r\n};\r\n\r\n/**\r\n * Mounting is the process of initializing a React component by creating its\r\n * representative DOM elements and inserting them into a supplied `container`.\r\n * Any prior content inside `container` is destroyed in the process.\r\n *\r\n *   ReactMount.render(\r\n *     component,\r\n *     document.getElementById('container')\r\n *   );\r\n *\r\n *   <div id=\"container\">                   <-- Supplied `container`.\r\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\r\n *       // ...                                 component.\r\n *     </div>\r\n *   </div>\r\n *\r\n * Inside of `container`, the first element rendered is the \"reactRoot\".\r\n */\r\nvar ReactMount = {\r\n\r\n  TopLevelWrapper: TopLevelWrapper,\r\n\r\n  /** Exposed for debugging purposes **/\r\n  _instancesByReactRootID: instancesByReactRootID,\r\n\r\n  /**\r\n   * This is a hook provided to support rendering React components while\r\n   * ensuring that the apparent scroll position of its `container` does not\r\n   * change.\r\n   *\r\n   * @param {DOMElement} container The `container` being rendered into.\r\n   * @param {function} renderCallback This must be called once to do the render.\r\n   */\r\n  scrollMonitor: function (container, renderCallback) {\r\n    renderCallback();\r\n  },\r\n\r\n  /**\r\n   * Take a component that's already mounted into the DOM and replace its props\r\n   * @param {ReactComponent} prevComponent component instance already in the DOM\r\n   * @param {ReactElement} nextElement component instance to render\r\n   * @param {DOMElement} container container to render into\r\n   * @param {?function} callback function triggered on completion\r\n   */\r\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\r\n    ReactMount.scrollMonitor(container, function () {\r\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\r\n      if (callback) {\r\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\r\n      }\r\n    });\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // Record the root element in case it later gets transplanted.\r\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\r\n    }\r\n\r\n    return prevComponent;\r\n  },\r\n\r\n  /**\r\n   * Register a component into the instance map and starts scroll value\r\n   * monitoring\r\n   * @param {ReactComponent} nextComponent component instance to render\r\n   * @param {DOMElement} container container to render into\r\n   * @return {string} reactRoot ID prefix\r\n   */\r\n  _registerComponent: function (nextComponent, container) {\r\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;\r\n\r\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\r\n\r\n    var reactRootID = ReactMount.registerContainer(container);\r\n    instancesByReactRootID[reactRootID] = nextComponent;\r\n    return reactRootID;\r\n  },\r\n\r\n  /**\r\n   * Render a new component into the DOM.\r\n   * @param {ReactElement} nextElement element to render\r\n   * @param {DOMElement} container container to render into\r\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\r\n   * @return {ReactComponent} nextComponent\r\n   */\r\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\r\n    // Various parts of our code (such as ReactCompositeComponent's\r\n    // _renderValidatedComponent) assume that calls to render aren't nested;\r\n    // verify that that's the case.\r\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\r\n\r\n    var componentInstance = instantiateReactComponent(nextElement, null);\r\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\r\n\r\n    // The initial render is synchronous but any updates that happen during\r\n    // rendering, in componentWillMount or componentDidMount, will be batched\r\n    // according to the current batching strategy.\r\n\r\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // Record the root element in case it later gets transplanted.\r\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\r\n    }\r\n\r\n    return componentInstance;\r\n  },\r\n\r\n  /**\r\n   * Renders a React component into the DOM in the supplied `container`.\r\n   *\r\n   * If the React component was previously rendered into `container`, this will\r\n   * perform an update on it and only mutate the DOM as necessary to reflect the\r\n   * latest React component.\r\n   *\r\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\r\n   * @param {ReactElement} nextElement Component element to render.\r\n   * @param {DOMElement} container DOM element to render into.\r\n   * @param {?function} callback function triggered on completion\r\n   * @return {ReactComponent} Component instance rendered in `container`.\r\n   */\r\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\r\n    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;\r\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\r\n  },\r\n\r\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\r\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :\r\n    // Check if it quacks like an element\r\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;\r\n\r\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;\r\n\r\n    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\r\n\r\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\r\n\r\n    if (prevComponent) {\r\n      var prevWrappedElement = prevComponent._currentElement;\r\n      var prevElement = prevWrappedElement.props;\r\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\r\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\r\n        var updatedCallback = callback && function () {\r\n          callback.call(publicInst);\r\n        };\r\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);\r\n        return publicInst;\r\n      } else {\r\n        ReactMount.unmountComponentAtNode(container);\r\n      }\r\n    }\r\n\r\n    var reactRootElement = getReactRootElementInContainer(container);\r\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\r\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;\r\n\r\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\r\n        var rootElementSibling = reactRootElement;\r\n        while (rootElementSibling) {\r\n          if (internalGetID(rootElementSibling)) {\r\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;\r\n            break;\r\n          }\r\n          rootElementSibling = rootElementSibling.nextSibling;\r\n        }\r\n      }\r\n    }\r\n\r\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\r\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();\r\n    if (callback) {\r\n      callback.call(component);\r\n    }\r\n    return component;\r\n  },\r\n\r\n  /**\r\n   * Renders a React component into the DOM in the supplied `container`.\r\n   *\r\n   * If the React component was previously rendered into `container`, this will\r\n   * perform an update on it and only mutate the DOM as necessary to reflect the\r\n   * latest React component.\r\n   *\r\n   * @param {ReactElement} nextElement Component element to render.\r\n   * @param {DOMElement} container DOM element to render into.\r\n   * @param {?function} callback function triggered on completion\r\n   * @return {ReactComponent} Component instance rendered in `container`.\r\n   */\r\n  render: function (nextElement, container, callback) {\r\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\r\n  },\r\n\r\n  /**\r\n   * Registers a container node into which React components will be rendered.\r\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\r\n   * rendered within.\r\n   *\r\n   * @param {DOMElement} container DOM element to register as a container.\r\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\r\n   */\r\n  registerContainer: function (container) {\r\n    var reactRootID = getReactRootID(container);\r\n    if (reactRootID) {\r\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\r\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\r\n    }\r\n    if (!reactRootID) {\r\n      // No valid \"reactRoot\" ID found, create one.\r\n      reactRootID = ReactInstanceHandles.createReactRootID();\r\n    }\r\n    containersByReactRootID[reactRootID] = container;\r\n    return reactRootID;\r\n  },\r\n\r\n  /**\r\n   * Unmounts and destroys the React component rendered in the `container`.\r\n   *\r\n   * @param {DOMElement} container DOM element containing a React component.\r\n   * @return {boolean} True if a component was found in and unmounted from\r\n   *                   `container`\r\n   */\r\n  unmountComponentAtNode: function (container) {\r\n    // Various parts of our code (such as ReactCompositeComponent's\r\n    // _renderValidatedComponent) assume that calls to render aren't nested;\r\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\r\n    // render but we still don't expect to be in a render call here.)\r\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\r\n\r\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;\r\n\r\n    var reactRootID = getReactRootID(container);\r\n    var component = instancesByReactRootID[reactRootID];\r\n    if (!component) {\r\n      // Check if the node being unmounted was rendered by React, but isn't a\r\n      // root node.\r\n      var containerHasNonRootReactChild = hasNonRootReactChild(container);\r\n\r\n      // Check if the container itself is a React root node.\r\n      var containerID = internalGetID(container);\r\n      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;\r\n      }\r\n\r\n      return false;\r\n    }\r\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);\r\n    delete instancesByReactRootID[reactRootID];\r\n    delete containersByReactRootID[reactRootID];\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      delete rootElementsByReactRootID[reactRootID];\r\n    }\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Finds the container DOM element that contains React component to which the\r\n   * supplied DOM `id` belongs.\r\n   *\r\n   * @param {string} id The ID of an element rendered by a React component.\r\n   * @return {?DOMElement} DOM element that contains the `id`.\r\n   */\r\n  findReactContainerForID: function (id) {\r\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\r\n    var container = containersByReactRootID[reactRootID];\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      var rootElement = rootElementsByReactRootID[reactRootID];\r\n      if (rootElement && rootElement.parentNode !== container) {\r\n        process.env.NODE_ENV !== 'production' ? warning(\r\n        // Call internalGetID here because getID calls isValid which calls\r\n        // findReactContainerForID (this function).\r\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;\r\n        var containerChild = container.firstChild;\r\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\r\n          // If the container has a new child with the same ID as the old\r\n          // root element, then rootElementsByReactRootID[reactRootID] is\r\n          // just stale and needs to be updated. The case that deserves a\r\n          // warning is when the container is empty.\r\n          rootElementsByReactRootID[reactRootID] = containerChild;\r\n        } else {\r\n          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    return container;\r\n  },\r\n\r\n  /**\r\n   * Finds an element rendered by React with the supplied ID.\r\n   *\r\n   * @param {string} id ID of a DOM node in the React component.\r\n   * @return {DOMElement} Root DOM node of the React component.\r\n   */\r\n  findReactNodeByID: function (id) {\r\n    var reactRoot = ReactMount.findReactContainerForID(id);\r\n    return ReactMount.findComponentRoot(reactRoot, id);\r\n  },\r\n\r\n  /**\r\n   * Traverses up the ancestors of the supplied node to find a node that is a\r\n   * DOM representation of a React component rendered by this copy of React.\r\n   *\r\n   * @param {*} node\r\n   * @return {?DOMEventTarget}\r\n   * @internal\r\n   */\r\n  getFirstReactDOM: function (node) {\r\n    return findFirstReactDOMImpl(node);\r\n  },\r\n\r\n  /**\r\n   * Finds a node with the supplied `targetID` inside of the supplied\r\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\r\n   * quickly.\r\n   *\r\n   * @param {DOMEventTarget} ancestorNode Search from this root.\r\n   * @pararm {string} targetID ID of the DOM representation of the component.\r\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\r\n   * @internal\r\n   */\r\n  findComponentRoot: function (ancestorNode, targetID) {\r\n    var firstChildren = findComponentRootReusableArray;\r\n    var childIndex = 0;\r\n\r\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // This will throw on the next line; give an early warning\r\n      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\\'t find the root component node for data-reactid value ' + '`%s`. If you\\'re seeing this message, it probably means that ' + 'you\\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;\r\n    }\r\n\r\n    firstChildren[0] = deepestAncestor.firstChild;\r\n    firstChildren.length = 1;\r\n\r\n    while (childIndex < firstChildren.length) {\r\n      var child = firstChildren[childIndex++];\r\n      var targetChild;\r\n\r\n      while (child) {\r\n        var childID = ReactMount.getID(child);\r\n        if (childID) {\r\n          // Even if we find the node we're looking for, we finish looping\r\n          // through its siblings to ensure they're cached so that we don't have\r\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\r\n          // when visiting the many children of a single node in order.\r\n\r\n          if (targetID === childID) {\r\n            targetChild = child;\r\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\r\n            // If we find a child whose ID is an ancestor of the given ID,\r\n            // then we can be sure that we only want to search the subtree\r\n            // rooted at this child, so we can throw out the rest of the\r\n            // search state.\r\n            firstChildren.length = childIndex = 0;\r\n            firstChildren.push(child.firstChild);\r\n          }\r\n        } else {\r\n          // If this child had no ID, then there's a chance that it was\r\n          // injected automatically by the browser, as when a `<table>`\r\n          // element sprouts an extra `<tbody>` child as a side effect of\r\n          // `.innerHTML` parsing. Optimistically continue down this\r\n          // branch, but not before examining the other siblings.\r\n          firstChildren.push(child.firstChild);\r\n        }\r\n\r\n        child = child.nextSibling;\r\n      }\r\n\r\n      if (targetChild) {\r\n        // Emptying firstChildren/findComponentRootReusableArray is\r\n        // not necessary for correctness, but it helps the GC reclaim\r\n        // any nodes that were left at the end of the search.\r\n        firstChildren.length = 0;\r\n\r\n        return targetChild;\r\n      }\r\n    }\r\n\r\n    firstChildren.length = 0;\r\n\r\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;\r\n  },\r\n\r\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {\r\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;\r\n\r\n    if (shouldReuseMarkup) {\r\n      var rootElement = getReactRootElementInContainer(container);\r\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\r\n        return;\r\n      } else {\r\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\r\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\r\n\r\n        var rootMarkup = rootElement.outerHTML;\r\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\r\n\r\n        var normalizedMarkup = markup;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          // because rootMarkup is retrieved from the DOM, various normalizations\r\n          // will have occurred which will not be present in `markup`. Here,\r\n          // insert markup into a <div> or <iframe> depending on the container\r\n          // type to perform the same normalizations before comparing.\r\n          var normalizer;\r\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\r\n            normalizer = document.createElement('div');\r\n            normalizer.innerHTML = markup;\r\n            normalizedMarkup = normalizer.innerHTML;\r\n          } else {\r\n            normalizer = document.createElement('iframe');\r\n            document.body.appendChild(normalizer);\r\n            normalizer.contentDocument.write(markup);\r\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\r\n            document.body.removeChild(normalizer);\r\n          }\r\n        }\r\n\r\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\r\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\r\n\r\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(false) : undefined;\r\n\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\r\n\r\n    if (transaction.useCreateElement) {\r\n      while (container.lastChild) {\r\n        container.removeChild(container.lastChild);\r\n      }\r\n      container.appendChild(markup);\r\n    } else {\r\n      setInnerHTML(container, markup);\r\n    }\r\n  },\r\n\r\n  ownerDocumentContextKey: ownerDocumentContextKey,\r\n\r\n  /**\r\n   * React ID utilities.\r\n   */\r\n\r\n  getReactRootID: getReactRootID,\r\n\r\n  getID: getID,\r\n\r\n  setID: setID,\r\n\r\n  getNode: getNode,\r\n\r\n  getNodeFromInstance: getNodeFromInstance,\r\n\r\n  isValid: isValid,\r\n\r\n  purgeID: purgeID\r\n};\r\n\r\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\r\n  _renderNewRootComponent: '_renderNewRootComponent',\r\n  _mountImageIntoNode: '_mountImageIntoNode'\r\n});\r\n\r\nmodule.exports = ReactMount;"]},"metadata":{},"sourceType":"script"}