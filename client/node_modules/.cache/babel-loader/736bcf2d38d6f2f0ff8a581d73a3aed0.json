{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module engine/view/renderer\n */\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller } from './filler';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport '../../theme/renderer.css';\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\n\nexport default class Renderer {\n  /**\n   * Creates a renderer instance.\n   *\n   * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n   * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n   */\n  constructor(domConverter, selection) {\n    /**\n     * Set of DOM Documents instances.\n     *\n     * @readonly\n     * @member {Set.<Document>}\n     */\n    this.domDocuments = new Set();\n    /**\n     * Converter instance.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n\n    this.domConverter = domConverter;\n    /**\n     * Set of nodes which attributes changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedAttributes = new Set();\n    /**\n     * Set of elements which child lists changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedChildren = new Set();\n    /**\n     * Set of text nodes which text data changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedTexts = new Set();\n    /**\n     * View selection. Renderer updates DOM selection based on the view selection.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     */\n\n    this.selection = selection;\n    /**\n     * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n     * this is set to `false`.\n     *\n     * @member {Boolean}\n     * @observable\n     */\n\n    this.set('isFocused', false);\n    /**\n     * Indicates whether the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n     * When they stop selecting, the property goes back to `false`.\n     *\n     * Note: In some browsers, the renderer will stop rendering the selection and inline fillers while the user is making\n     * a selection to avoid glitches in DOM selection\n     * (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n     *\n     * @member {Boolean}\n     * @observable\n     */\n\n    this.set('isSelecting', false); // Rendering the selection and inline filler manipulation should be postponed in (non-Android) Blink until the user finishes\n    // creating the selection in DOM to avoid accidental selection collapsing\n    // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n    // When the user stops, selecting, all pending changes should be rendered ASAP, though.\n\n    if (env.isBlink && !env.isAndroid) {\n      this.on('change:isSelecting', () => {\n        if (!this.isSelecting) {\n          this.render();\n        }\n      });\n    }\n    /**\n     * The text node in which the inline filler was rendered.\n     *\n     * @private\n     * @member {Text}\n     */\n\n\n    this._inlineFiller = null;\n    /**\n     * DOM element containing fake selection.\n     *\n     * @private\n     * @type {null|HTMLElement}\n     */\n\n    this._fakeSelectionContainer = null;\n  }\n  /**\n   * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n   *\n   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n   *\n   * @see #markedAttributes\n   * @see #markedChildren\n   * @see #markedTexts\n   *\n   * @param {module:engine/view/document~ChangeType} type Type of the change.\n   * @param {module:engine/view/node~Node} node Node to be marked.\n   */\n\n\n  markToSync(type, node) {\n    if (type === 'text') {\n      if (this.domConverter.mapViewToDom(node.parent)) {\n        this.markedTexts.add(node);\n      }\n    } else {\n      // If the node has no DOM element it is not rendered yet,\n      // its children/attributes do not need to be marked to be sync.\n      if (!this.domConverter.mapViewToDom(node)) {\n        return;\n      }\n\n      if (type === 'attributes') {\n        this.markedAttributes.add(node);\n      } else if (type === 'children') {\n        this.markedChildren.add(node);\n      } else {\n        /**\n         * Unknown type passed to Renderer.markToSync.\n         *\n         * @error view-renderer-unknown-type\n         */\n        throw new CKEditorError('view-renderer-unknown-type', this);\n      }\n    }\n  }\n  /**\n   * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n   * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n   *\n   * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n   * so it does as little as it is needed to update the DOM.\n   *\n   * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n   * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n   * removed as long as the selection is in the text node which needed it at first.\n   */\n\n\n  render() {\n    let inlineFillerPosition;\n    const isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true; // Refresh mappings.\n\n    for (const element of this.markedChildren) {\n      this._updateChildrenMappings(element);\n    } // Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n    // DOM selection collapsing\n    // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\n\n    if (isInlineFillerRenderingPossible) {\n      // There was inline filler rendered in the DOM but it's not\n      // at the selection position any more, so we can remove it\n      // (cause even if it's needed, it must be placed in another location).\n      if (this._inlineFiller && !this._isSelectionInInlineFiller()) {\n        this._removeInlineFiller();\n      } // If we've got the filler, let's try to guess its position in the view.\n\n\n      if (this._inlineFiller) {\n        inlineFillerPosition = this._getInlineFillerPosition();\n      } // Otherwise, if it's needed, create it at the selection position.\n      else if (this._needsInlineFillerAtSelection()) {\n        inlineFillerPosition = this.selection.getFirstPosition(); // Do not use `markToSync` so it will be added even if the parent is already added.\n\n        this.markedChildren.add(inlineFillerPosition.parent);\n      }\n    } // Paranoid check: we make sure the inline filler has any parent so it can be mapped to view position\n    // by DomConverter.\n    else if (this._inlineFiller && this._inlineFiller.parentNode) {\n      // While the user is making selection, preserve the inline filler at its original position.\n      inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);\n    }\n\n    for (const element of this.markedAttributes) {\n      this._updateAttrs(element);\n    }\n\n    for (const element of this.markedChildren) {\n      this._updateChildren(element, {\n        inlineFillerPosition\n      });\n    }\n\n    for (const node of this.markedTexts) {\n      if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {\n        this._updateText(node, {\n          inlineFillerPosition\n        });\n      }\n    } // * Check whether the inline filler is required and where it really is in the DOM.\n    //   At this point in most cases it will be in the DOM, but there are exceptions.\n    //   For example, if the inline filler was deep in the created DOM structure, it will not be created.\n    //   Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n    //   it will not be present. Fix those and similar scenarios.\n    // * Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n    //   DOM selection collapsing\n    //   (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\n\n    if (isInlineFillerRenderingPossible) {\n      if (inlineFillerPosition) {\n        const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);\n        const domDocument = fillerDomPosition.parent.ownerDocument;\n\n        if (!startsWithFiller(fillerDomPosition.parent)) {\n          // Filler has not been created at filler position. Create it now.\n          this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);\n        } else {\n          // Filler has been found, save it.\n          this._inlineFiller = fillerDomPosition.parent;\n        }\n      } else {\n        // There is no filler needed.\n        this._inlineFiller = null;\n      }\n    } // First focus the new editing host, then update the selection.\n    // Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\n\n    this._updateFocus();\n\n    this._updateSelection();\n\n    this.markedTexts.clear();\n    this.markedAttributes.clear();\n    this.markedChildren.clear();\n  }\n  /**\n   * Updates mappings of view element's children.\n   *\n   * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n   * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n   * Thanks to that these elements do not need to be re-rendered completely.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n   */\n\n\n  _updateChildrenMappings(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n      return;\n    } // Removing nodes from the DOM as we iterate can cause `actualDomChildren`\n    // (which is a live-updating `NodeList`) to get out of sync with the\n    // indices that we compute as we iterate over `actions`.\n    // This would produce incorrect element mappings.\n    //\n    // Converting live list to an array to make the list static.\n\n\n    const actualDomChildren = Array.from(this.domConverter.mapViewToDom(viewElement).childNodes);\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n      withChildren: false\n    }));\n\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n    const actions = this._findReplaceActions(diff, actualDomChildren, expectedDomChildren);\n\n    if (actions.indexOf('replace') !== -1) {\n      const counter = {\n        equal: 0,\n        insert: 0,\n        delete: 0\n      };\n\n      for (const action of actions) {\n        if (action === 'replace') {\n          const insertIndex = counter.equal + counter.insert;\n          const deleteIndex = counter.equal + counter.delete;\n          const viewChild = viewElement.getChild(insertIndex); // UIElement and RawElement are special cases. Their children are not stored in a view (#799)\n          // so we cannot use them with replacing flow (since they use view children during rendering\n          // which will always result in rendering empty elements).\n\n          if (viewChild && !(viewChild.is('uiElement') || viewChild.is('rawElement'))) {\n            this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);\n          }\n\n          remove(expectedDomChildren[insertIndex]);\n          counter.equal++;\n        } else {\n          counter[action]++;\n        }\n      }\n    }\n  }\n  /**\n   * Updates mappings of a given view element.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n   * @param {Node} domElement The DOM element representing the given view element.\n   */\n\n\n  _updateElementMappings(viewElement, domElement) {\n    // Remap 'DomConverter' bindings.\n    this.domConverter.unbindDomElement(domElement);\n    this.domConverter.bindElements(domElement, viewElement); // View element may have children which needs to be updated, but are not marked, mark them to update.\n\n    this.markedChildren.add(viewElement); // Because we replace new view element mapping with the existing one, the corresponding DOM element\n    // will not be rerendered. The new view element may have different attributes than the previous one.\n    // Since its corresponding DOM element will not be rerendered, new attributes will not be added\n    // to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n    // detailed case study.\n    // Also there are cases where replaced element is removed from the view structure and then has\n    // its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n    // and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n    // To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n\n    this.markedAttributes.add(viewElement);\n  }\n  /**\n   * Gets the position of the inline filler based on the current selection.\n   * Here, we assume that we know that the filler is needed and\n   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n   * it is somewhere at the selection position.\n   *\n   * Note: The filler position cannot be restored based on the filler's DOM text node, because\n   * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n   * bindings are only dependable after rendering.\n   *\n   * @private\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  _getInlineFillerPosition() {\n    const firstPos = this.selection.getFirstPosition();\n\n    if (firstPos.parent.is('$text')) {\n      return ViewPosition._createBefore(this.selection.getFirstPosition().parent);\n    } else {\n      return firstPos;\n    }\n  }\n  /**\n   * Returns `true` if the selection has not left the inline filler's text node.\n   * If it is `true`, it means that the filler had been added for a reason and the selection did not\n   * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n   */\n\n\n  _isSelectionInInlineFiller() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    } // Note, we can't check if selection's position equals position of the\n    // this._inlineFiller node, because of #663. We may not be able to calculate\n    // the filler's position in the view at this stage.\n    // Instead, we check it the other way – whether selection is anchored in\n    // that text node or next to it.\n    // Possible options are:\n    // \"FILLER{}\"\n    // \"FILLERadded-text{}\"\n\n\n    const selectionPosition = this.selection.getFirstPosition();\n    const position = this.domConverter.viewPositionToDom(selectionPosition);\n\n    if (position && isText(position.parent) && startsWithFiller(position.parent)) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Removes the inline filler.\n   *\n   * @private\n   */\n\n\n  _removeInlineFiller() {\n    const domFillerNode = this._inlineFiller; // Something weird happened and the stored node doesn't contain the filler's text.\n\n    if (!startsWithFiller(domFillerNode)) {\n      /**\n       * The inline filler node was lost. Most likely, something overwrote the filler text node\n       * in the DOM.\n       *\n       * @error view-renderer-filler-was-lost\n       */\n      throw new CKEditorError('view-renderer-filler-was-lost', this);\n    }\n\n    if (isInlineFiller(domFillerNode)) {\n      domFillerNode.remove();\n    } else {\n      domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);\n    }\n\n    this._inlineFiller = null;\n  }\n  /**\n   * Checks if the inline {@link module:engine/view/filler filler} should be added.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler should be added.\n   */\n\n\n  _needsInlineFillerAtSelection() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    }\n\n    const selectionPosition = this.selection.getFirstPosition();\n    const selectionParent = selectionPosition.parent;\n    const selectionOffset = selectionPosition.offset; // If there is no DOM root we do not care about fillers.\n\n    if (!this.domConverter.mapViewToDom(selectionParent.root)) {\n      return false;\n    }\n\n    if (!selectionParent.is('element')) {\n      return false;\n    } // Prevent adding inline filler inside elements with contenteditable=false.\n    // https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\n\n    if (!isEditable(selectionParent)) {\n      return false;\n    } // We have block filler, we do not need inline one.\n\n\n    if (selectionOffset === selectionParent.getFillerOffset()) {\n      return false;\n    }\n\n    const nodeBefore = selectionPosition.nodeBefore;\n    const nodeAfter = selectionPosition.nodeAfter;\n\n    if (nodeBefore instanceof ViewText || nodeAfter instanceof ViewText) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Checks if text needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} viewText View text to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n\n\n  _updateText(viewText, options) {\n    const domText = this.domConverter.findCorrespondingDomText(viewText);\n    const newDomText = this.domConverter.viewToDom(viewText, domText.ownerDocument);\n    const actualText = domText.data;\n    let expectedText = newDomText.data;\n    const filler = options.inlineFillerPosition;\n\n    if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {\n      expectedText = INLINE_FILLER + expectedText;\n    }\n\n    if (actualText != expectedText) {\n      const actions = fastDiff(actualText, expectedText);\n\n      for (const action of actions) {\n        if (action.type === 'insert') {\n          domText.insertData(action.index, action.values.join(''));\n        } else {\n          // 'delete'\n          domText.deleteData(action.index, action.howMany);\n        }\n      }\n    }\n  }\n  /**\n   * Checks if attribute list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement The view element to update.\n   */\n\n\n  _updateAttrs(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n      // in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n      // replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n      // in 'this._updateChildrenMappings()' so it will be processed separately.\n      return;\n    }\n\n    const domAttrKeys = Array.from(domElement.attributes).map(attr => attr.name);\n    const viewAttrKeys = viewElement.getAttributeKeys(); // Add or overwrite attributes.\n\n    for (const key of viewAttrKeys) {\n      const value = viewElement.getAttribute(key);\n\n      if (!this.domConverter.shouldRenderAttribute(key, value)) {\n        domElement.removeAttribute(key);\n      } else {\n        domElement.setAttribute(key, value);\n      }\n    } // Remove from DOM attributes which do not exists in the view.\n\n\n    for (const key of domAttrKeys) {\n      // Do not remove attributes on `script` elements with special data attributes `data-ck-hidden`.\n      if (viewElement.name === 'script' && key === 'data-ck-hidden') {\n        continue;\n      } // All other attributes not present in the DOM should be removed.\n\n\n      if (!viewElement.hasAttribute(key)) {\n        domElement.removeAttribute(key);\n      }\n    }\n  }\n  /**\n   * Checks if elements child list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement View element to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n\n\n  _updateChildren(viewElement, options) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM.\n      // There is no need to process it. It will be processed when re-inserted.\n      return;\n    }\n\n    const inlineFillerPosition = options.inlineFillerPosition;\n    const actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n      bind: true\n    })); // Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n    // during diffing so text nodes could be compared correctly and also during rendering to maintain\n    // proper order and indexes while updating the DOM.\n\n    if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {\n      addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);\n    }\n\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n    let i = 0;\n    const nodesToUnbind = new Set(); // Handle deletions first.\n    // This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different\n    // index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,\n    // and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.\n    //\n    // It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.\n\n    for (const action of diff) {\n      if (action === 'delete') {\n        nodesToUnbind.add(actualDomChildren[i]);\n        remove(actualDomChildren[i]);\n      } else if (action === 'equal') {\n        i++;\n      }\n    }\n\n    i = 0;\n\n    for (const action of diff) {\n      if (action === 'insert') {\n        insertAt(domElement, i, expectedDomChildren[i]);\n        i++;\n      } else if (action === 'equal') {\n        // Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n        // Do it here (not in the loop above) because only after insertions the `i` index is correct.\n        this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));\n\n        i++;\n      }\n    } // Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n    // comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n    // it was moved to DOM tree out of the removed node.\n\n\n    for (const node of nodesToUnbind) {\n      if (!node.parentNode) {\n        this.domConverter.unbindDomElement(node);\n      }\n    }\n  }\n  /**\n   * Shorthand for diffing two arrays or node lists of DOM nodes.\n   *\n   * @private\n   * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n   * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n   * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n   */\n\n\n  _diffNodeLists(actualDomChildren, expectedDomChildren) {\n    actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);\n    return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter));\n  }\n  /**\n   * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n   * within one `insert`/`delete` action group, for example:\n   *\n   * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n   * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n   * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n   * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n   *\n   * @private\n   * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n   * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n   * @param {Array.<Node>} expectedDom Expected DOM children.\n   * @returns {Array.<String>} Actions array modified with the `replace` actions.\n   */\n\n\n  _findReplaceActions(actions, actualDom, expectedDom) {\n    // If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n    if (actions.indexOf('insert') === -1 || actions.indexOf('delete') === -1) {\n      return actions;\n    }\n\n    let newActions = [];\n    let actualSlice = [];\n    let expectedSlice = [];\n    const counter = {\n      equal: 0,\n      insert: 0,\n      delete: 0\n    };\n\n    for (const action of actions) {\n      if (action === 'insert') {\n        expectedSlice.push(expectedDom[counter.equal + counter.insert]);\n      } else if (action === 'delete') {\n        actualSlice.push(actualDom[counter.equal + counter.delete]);\n      } else {\n        // equal\n        newActions = newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n        newActions.push('equal'); // Reset stored elements on 'equal'.\n\n        actualSlice = [];\n        expectedSlice = [];\n      }\n\n      counter[action]++;\n    }\n\n    return newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n  }\n  /**\n   * Marks text nodes to be synchronized.\n   *\n   * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewNode View node to sync.\n   */\n\n\n  _markDescendantTextToSync(viewNode) {\n    if (!viewNode) {\n      return;\n    }\n\n    if (viewNode.is('$text')) {\n      this.markedTexts.add(viewNode);\n    } else if (viewNode.is('element')) {\n      for (const child of viewNode.getChildren()) {\n        this._markDescendantTextToSync(child);\n      }\n    }\n  }\n  /**\n   * Checks if the selection needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n\n\n  _updateSelection() {\n    // Block updating DOM selection in (non-Android) Blink while the user is selecting to prevent accidental selection collapsing.\n    // Note: Structural changes in DOM must trigger selection rendering, though. Nodes the selection was anchored\n    // to may disappear in DOM which would break the selection (e.g. in real-time collaboration scenarios).\n    // https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723\n    if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {\n      return;\n    } // If there is no selection - remove DOM and fake selections.\n\n\n    if (this.selection.rangeCount === 0) {\n      this._removeDomSelection();\n\n      this._removeFakeSelection();\n\n      return;\n    }\n\n    const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement); // Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\n    if (!this.isFocused || !domRoot) {\n      return;\n    } // Render selection.\n\n\n    if (this.selection.isFake) {\n      this._updateFakeSelection(domRoot);\n    } else {\n      this._removeFakeSelection();\n\n      this._updateDomSelection(domRoot);\n    }\n  }\n  /**\n   * Updates the fake selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n   */\n\n\n  _updateFakeSelection(domRoot) {\n    const domDocument = domRoot.ownerDocument;\n\n    if (!this._fakeSelectionContainer) {\n      this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);\n    }\n\n    const container = this._fakeSelectionContainer; // Bind fake selection container with the current selection *position*.\n\n    this.domConverter.bindFakeSelection(container, this.selection);\n\n    if (!this._fakeSelectionNeedsUpdate(domRoot)) {\n      return;\n    }\n\n    if (!container.parentElement || container.parentElement != domRoot) {\n      domRoot.appendChild(container);\n    }\n\n    container.textContent = this.selection.fakeSelectionLabel || '\\u00A0';\n    const domSelection = domDocument.getSelection();\n    const domRange = domDocument.createRange();\n    domSelection.removeAllRanges();\n    domRange.selectNodeContents(container);\n    domSelection.addRange(domRange);\n  }\n  /**\n   * Updates the DOM selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n   */\n\n\n  _updateDomSelection(domRoot) {\n    const domSelection = domRoot.ownerDocument.defaultView.getSelection(); // Let's check whether DOM selection needs updating at all.\n\n    if (!this._domSelectionNeedsUpdate(domSelection)) {\n      return;\n    } // Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n    // set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n    // and focus of view selection.\n    // Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n    // selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\n\n    const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);\n    const focus = this.domConverter.viewPositionToDom(this.selection.focus);\n    domSelection.collapse(anchor.parent, anchor.offset);\n    domSelection.extend(focus.parent, focus.offset); // Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n\n    if (env.isGecko) {\n      fixGeckoSelectionAfterBr(focus, domSelection);\n    }\n  }\n  /**\n   * Checks whether a given DOM selection needs to be updated.\n   *\n   * @private\n   * @param {Selection} domSelection The DOM selection to check.\n   * @returns {Boolean}\n   */\n\n\n  _domSelectionNeedsUpdate(domSelection) {\n    if (!this.domConverter.isDomSelectionCorrect(domSelection)) {\n      // Current DOM selection is in incorrect position. We need to update it.\n      return true;\n    }\n\n    const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);\n\n    if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {\n      return false;\n    } // If selection is not collapsed, it does not need to be updated if it is similar.\n\n\n    if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {\n      // Selection did not changed and is correct, do not update.\n      return false;\n    } // Selections are not similar.\n\n\n    return true;\n  }\n  /**\n   * Checks whether the fake selection needs to be updated.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.\n   * @returns {Boolean}\n   */\n\n\n  _fakeSelectionNeedsUpdate(domRoot) {\n    const container = this._fakeSelectionContainer;\n    const domSelection = domRoot.ownerDocument.getSelection(); // Fake selection needs to be updated if there's no fake selection container, or the container currently sits\n    // in a different root.\n\n    if (!container || container.parentElement !== domRoot) {\n      return true;\n    } // Make sure that the selection actually is within the fake selection.\n\n\n    if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {\n      return true;\n    }\n\n    return container.textContent !== this.selection.fakeSelectionLabel;\n  }\n  /**\n   * Removes the DOM selection.\n   *\n   * @private\n   */\n\n\n  _removeDomSelection() {\n    for (const doc of this.domDocuments) {\n      const domSelection = doc.getSelection();\n\n      if (domSelection.rangeCount) {\n        const activeDomElement = doc.activeElement;\n        const viewElement = this.domConverter.mapDomToView(activeDomElement);\n\n        if (activeDomElement && viewElement) {\n          doc.getSelection().removeAllRanges();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the fake selection.\n   *\n   * @private\n   */\n\n\n  _removeFakeSelection() {\n    const container = this._fakeSelectionContainer;\n\n    if (container) {\n      container.remove();\n    }\n  }\n  /**\n   * Checks if focus needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n\n\n  _updateFocus() {\n    if (this.isFocused) {\n      const editable = this.selection.editableElement;\n\n      if (editable) {\n        this.domConverter.focus(editable);\n      }\n    }\n  }\n\n}\nmix(Renderer, ObservableMixin); // Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\n\nfunction isEditable(element) {\n  if (element.getAttribute('contenteditable') == 'false') {\n    return false;\n  }\n\n  const parent = element.findAncestor(element => element.hasAttribute('contenteditable'));\n  return !parent || parent.getAttribute('contenteditable') == 'true';\n} // Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\n\n\nfunction addInlineFiller(domDocument, domParentOrArray, offset) {\n  const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n  const nodeAfterFiller = childNodes[offset];\n\n  if (isText(nodeAfterFiller)) {\n    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n    return nodeAfterFiller;\n  } else {\n    const fillerNode = domDocument.createTextNode(INLINE_FILLER);\n\n    if (Array.isArray(domParentOrArray)) {\n      childNodes.splice(offset, 0, fillerNode);\n    } else {\n      insertAt(domParentOrArray, offset, fillerNode);\n    }\n\n    return fillerNode;\n  }\n} // Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction areSimilar(node1, node2) {\n  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && node1.nodeType !== Node.COMMENT_NODE && node2.nodeType !== Node.COMMENT_NODE && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n} // Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction sameNodes(domConverter, actualDomChild, expectedDomChild) {\n  // Elements.\n  if (actualDomChild === expectedDomChild) {\n    return true;\n  } // Texts.\n  else if (isText(actualDomChild) && isText(expectedDomChild)) {\n    return actualDomChild.data === expectedDomChild.data;\n  } // Block fillers.\n  else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {\n    return true;\n  } // Not matching types.\n\n\n  return false;\n} // The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\n\n\nfunction fixGeckoSelectionAfterBr(focus, domSelection) {\n  const parent = focus.parent; // This fix works only when the focus point is at the very end of an element.\n  // There is no point in running it in cases unrelated to the browser bug.\n\n  if (parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1) {\n    return;\n  }\n\n  const childAtOffset = parent.childNodes[focus.offset]; // To stay on the safe side, the fix being as specific as possible, it targets only the\n  // selection which is at the very end of the element and preceded by <br />.\n\n  if (childAtOffset && childAtOffset.tagName == 'BR') {\n    domSelection.addRange(domSelection.getRangeAt(0));\n  }\n}\n\nfunction filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {\n  const childList = Array.from(domChildList);\n\n  if (childList.length == 0 || !fakeSelectionContainer) {\n    return childList;\n  }\n\n  const last = childList[childList.length - 1];\n\n  if (last == fakeSelectionContainer) {\n    childList.pop();\n  }\n\n  return childList;\n} // Creates a fake selection container for a given document.\n//\n// @private\n// @param {Document} domDocument\n// @returns {HTMLElement}\n\n\nfunction createFakeSelectionContainer(domDocument) {\n  const container = domDocument.createElement('div');\n  container.className = 'ck-fake-selection-container';\n  Object.assign(container.style, {\n    position: 'fixed',\n    top: 0,\n    left: '-9999px',\n    // See https://github.com/ckeditor/ckeditor5/issues/752.\n    width: '42px'\n  }); // Fill it with a text node so we can update it later.\n\n  container.textContent = '\\u00A0';\n  return container;\n}","map":{"version":3,"sources":["D:/Project/nhap_mon_cnpm/my-app/node_modules/@ckeditor/ckeditor5-engine/src/view/renderer.js"],"names":["ViewText","ViewPosition","INLINE_FILLER","INLINE_FILLER_LENGTH","startsWithFiller","isInlineFiller","mix","diff","insertAt","remove","ObservableMixin","CKEditorError","isText","isNode","fastDiff","env","Renderer","constructor","domConverter","selection","domDocuments","Set","markedAttributes","markedChildren","markedTexts","set","isBlink","isAndroid","on","isSelecting","render","_inlineFiller","_fakeSelectionContainer","markToSync","type","node","mapViewToDom","parent","add","inlineFillerPosition","isInlineFillerRenderingPossible","element","_updateChildrenMappings","_isSelectionInInlineFiller","_removeInlineFiller","_getInlineFillerPosition","_needsInlineFillerAtSelection","getFirstPosition","parentNode","domPositionToView","_updateAttrs","_updateChildren","has","_updateText","fillerDomPosition","viewPositionToDom","domDocument","ownerDocument","addInlineFiller","offset","_updateFocus","_updateSelection","clear","viewElement","domElement","actualDomChildren","Array","from","childNodes","expectedDomChildren","viewChildrenToDom","withChildren","_diffNodeLists","actions","_findReplaceActions","indexOf","counter","equal","insert","delete","action","insertIndex","deleteIndex","viewChild","getChild","is","_updateElementMappings","unbindDomElement","bindElements","firstPos","_createBefore","rangeCount","isCollapsed","selectionPosition","position","domFillerNode","data","substr","selectionParent","selectionOffset","root","isEditable","getFillerOffset","nodeBefore","nodeAfter","viewText","options","domText","findCorrespondingDomText","newDomText","viewToDom","actualText","expectedText","filler","index","insertData","values","join","deleteData","howMany","domAttrKeys","attributes","map","attr","name","viewAttrKeys","getAttributeKeys","key","value","getAttribute","shouldRenderAttribute","removeAttribute","setAttribute","hasAttribute","bind","i","nodesToUnbind","_markDescendantTextToSync","domToView","filterOutFakeSelectionContainer","sameNodes","actualDom","expectedDom","newActions","actualSlice","expectedSlice","push","concat","areSimilar","x","viewNode","child","getChildren","size","_removeDomSelection","_removeFakeSelection","domRoot","editableElement","isFocused","isFake","_updateFakeSelection","_updateDomSelection","createFakeSelectionContainer","container","bindFakeSelection","_fakeSelectionNeedsUpdate","parentElement","appendChild","textContent","fakeSelectionLabel","domSelection","getSelection","domRange","createRange","removeAllRanges","selectNodeContents","addRange","defaultView","_domSelectionNeedsUpdate","anchor","focus","collapse","extend","isGecko","fixGeckoSelectionAfterBr","isDomSelectionCorrect","oldViewSelection","domSelectionToView","isEqual","isSimilar","anchorNode","contains","doc","activeDomElement","activeElement","mapDomToView","editable","findAncestor","domParentOrArray","nodeAfterFiller","fillerNode","createTextNode","isArray","splice","node1","node2","nodeType","Node","COMMENT_NODE","tagName","toLowerCase","actualDomChild","expectedDomChild","isBlockFiller","ELEMENT_NODE","length","childAtOffset","getRangeAt","domChildList","fakeSelectionContainer","childList","last","pop","createElement","className","Object","assign","style","top","left","width"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module engine/view/renderer\n */\n\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller } from './filler';\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\nimport '../../theme/renderer.css';\n\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\nexport default class Renderer {\n\t/**\n\t * Creates a renderer instance.\n\t *\n\t * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n\t * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n\t */\n\tconstructor( domConverter, selection ) {\n\t\t/**\n\t\t * Set of DOM Documents instances.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<Document>}\n\t\t */\n\t\tthis.domDocuments = new Set();\n\n\t\t/**\n\t\t * Converter instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/domconverter~DomConverter}\n\t\t */\n\t\tthis.domConverter = domConverter;\n\n\t\t/**\n\t\t * Set of nodes which attributes changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedAttributes = new Set();\n\n\t\t/**\n\t\t * Set of elements which child lists changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedChildren = new Set();\n\n\t\t/**\n\t\t * Set of text nodes which text data changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedTexts = new Set();\n\n\t\t/**\n\t\t * View selection. Renderer updates DOM selection based on the view selection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = selection;\n\n\t\t/**\n\t\t * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n\t\t * this is set to `false`.\n\t\t *\n\t\t * @member {Boolean}\n\t\t * @observable\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * Indicates whether the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n\t\t * When they stop selecting, the property goes back to `false`.\n\t\t *\n\t\t * Note: In some browsers, the renderer will stop rendering the selection and inline fillers while the user is making\n\t\t * a selection to avoid glitches in DOM selection\n\t\t * (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\t *\n\t\t * @member {Boolean}\n\t\t * @observable\n\t\t */\n\t\tthis.set( 'isSelecting', false );\n\n\t\t// Rendering the selection and inline filler manipulation should be postponed in (non-Android) Blink until the user finishes\n\t\t// creating the selection in DOM to avoid accidental selection collapsing\n\t\t// (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\t// When the user stops, selecting, all pending changes should be rendered ASAP, though.\n\t\tif ( env.isBlink && !env.isAndroid ) {\n\t\t\tthis.on( 'change:isSelecting', () => {\n\t\t\t\tif ( !this.isSelecting ) {\n\t\t\t\t\tthis.render();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t/**\n\t\t * The text node in which the inline filler was rendered.\n\t\t *\n\t\t * @private\n\t\t * @member {Text}\n\t\t */\n\t\tthis._inlineFiller = null;\n\n\t\t/**\n\t\t * DOM element containing fake selection.\n\t\t *\n\t\t * @private\n\t\t * @type {null|HTMLElement}\n\t\t */\n\t\tthis._fakeSelectionContainer = null;\n\t}\n\n\t/**\n\t * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n\t *\n\t * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n\t *\n\t * @see #markedAttributes\n\t * @see #markedChildren\n\t * @see #markedTexts\n\t *\n\t * @param {module:engine/view/document~ChangeType} type Type of the change.\n\t * @param {module:engine/view/node~Node} node Node to be marked.\n\t */\n\tmarkToSync( type, node ) {\n\t\tif ( type === 'text' ) {\n\t\t\tif ( this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis.markedTexts.add( node );\n\t\t\t}\n\t\t} else {\n\t\t\t// If the node has no DOM element it is not rendered yet,\n\t\t\t// its children/attributes do not need to be marked to be sync.\n\t\t\tif ( !this.domConverter.mapViewToDom( node ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( type === 'attributes' ) {\n\t\t\t\tthis.markedAttributes.add( node );\n\t\t\t} else if ( type === 'children' ) {\n\t\t\t\tthis.markedChildren.add( node );\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * Unknown type passed to Renderer.markToSync.\n\t\t\t\t *\n\t\t\t\t * @error view-renderer-unknown-type\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'view-renderer-unknown-type', this );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n\t * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n\t *\n\t * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n\t * so it does as little as it is needed to update the DOM.\n\t *\n\t * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n\t * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n\t * removed as long as the selection is in the text node which needed it at first.\n\t */\n\trender() {\n\t\tlet inlineFillerPosition;\n\t\tconst isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true;\n\n\t\t// Refresh mappings.\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildrenMappings( element );\n\t\t}\n\n\t\t// Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n\t\t// DOM selection collapsing\n\t\t// (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\tif ( isInlineFillerRenderingPossible ) {\n\t\t\t// There was inline filler rendered in the DOM but it's not\n\t\t\t// at the selection position any more, so we can remove it\n\t\t\t// (cause even if it's needed, it must be placed in another location).\n\t\t\tif ( this._inlineFiller && !this._isSelectionInInlineFiller() ) {\n\t\t\t\tthis._removeInlineFiller();\n\t\t\t}\n\n\t\t\t// If we've got the filler, let's try to guess its position in the view.\n\t\t\tif ( this._inlineFiller ) {\n\t\t\t\tinlineFillerPosition = this._getInlineFillerPosition();\n\t\t\t}\n\t\t\t// Otherwise, if it's needed, create it at the selection position.\n\t\t\telse if ( this._needsInlineFillerAtSelection() ) {\n\t\t\t\tinlineFillerPosition = this.selection.getFirstPosition();\n\n\t\t\t\t// Do not use `markToSync` so it will be added even if the parent is already added.\n\t\t\t\tthis.markedChildren.add( inlineFillerPosition.parent );\n\t\t\t}\n\t\t}\n\t\t// Paranoid check: we make sure the inline filler has any parent so it can be mapped to view position\n\t\t// by DomConverter.\n\t\telse if ( this._inlineFiller && this._inlineFiller.parentNode ) {\n\t\t\t// While the user is making selection, preserve the inline filler at its original position.\n\t\t\tinlineFillerPosition = this.domConverter.domPositionToView( this._inlineFiller );\n\t\t}\n\n\t\tfor ( const element of this.markedAttributes ) {\n\t\t\tthis._updateAttrs( element );\n\t\t}\n\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildren( element, { inlineFillerPosition } );\n\t\t}\n\n\t\tfor ( const node of this.markedTexts ) {\n\t\t\tif ( !this.markedChildren.has( node.parent ) && this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis._updateText( node, { inlineFillerPosition } );\n\t\t\t}\n\t\t}\n\n\t\t// * Check whether the inline filler is required and where it really is in the DOM.\n\t\t//   At this point in most cases it will be in the DOM, but there are exceptions.\n\t\t//   For example, if the inline filler was deep in the created DOM structure, it will not be created.\n\t\t//   Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n\t\t//   it will not be present. Fix those and similar scenarios.\n\t\t// * Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n\t\t//   DOM selection collapsing\n\t\t//   (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\t\tif ( isInlineFillerRenderingPossible ) {\n\t\t\tif ( inlineFillerPosition ) {\n\t\t\t\tconst fillerDomPosition = this.domConverter.viewPositionToDom( inlineFillerPosition );\n\t\t\t\tconst domDocument = fillerDomPosition.parent.ownerDocument;\n\n\t\t\t\tif ( !startsWithFiller( fillerDomPosition.parent ) ) {\n\t\t\t\t\t// Filler has not been created at filler position. Create it now.\n\t\t\t\t\tthis._inlineFiller = addInlineFiller( domDocument, fillerDomPosition.parent, fillerDomPosition.offset );\n\t\t\t\t} else {\n\t\t\t\t\t// Filler has been found, save it.\n\t\t\t\t\tthis._inlineFiller = fillerDomPosition.parent;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is no filler needed.\n\t\t\t\tthis._inlineFiller = null;\n\t\t\t}\n\t\t}\n\n\t\t// First focus the new editing host, then update the selection.\n\t\t// Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\t\tthis._updateFocus();\n\t\tthis._updateSelection();\n\n\t\tthis.markedTexts.clear();\n\t\tthis.markedAttributes.clear();\n\t\tthis.markedChildren.clear();\n\t}\n\n\t/**\n\t * Updates mappings of view element's children.\n\t *\n\t * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n\t * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n\t * Thanks to that these elements do not need to be re-rendered completely.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n\t */\n\t_updateChildrenMappings( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n\t\t\treturn;\n\t\t}\n\n\t\t// Removing nodes from the DOM as we iterate can cause `actualDomChildren`\n\t\t// (which is a live-updating `NodeList`) to get out of sync with the\n\t\t// indices that we compute as we iterate over `actions`.\n\t\t// This would produce incorrect element mappings.\n\t\t//\n\t\t// Converting live list to an array to make the list static.\n\t\tconst actualDomChildren = Array.from(\n\t\t\tthis.domConverter.mapViewToDom( viewElement ).childNodes\n\t\t);\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { withChildren: false } )\n\t\t);\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\t\tconst actions = this._findReplaceActions( diff, actualDomChildren, expectedDomChildren );\n\n\t\tif ( actions.indexOf( 'replace' ) !== -1 ) {\n\t\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'replace' ) {\n\t\t\t\t\tconst insertIndex = counter.equal + counter.insert;\n\t\t\t\t\tconst deleteIndex = counter.equal + counter.delete;\n\t\t\t\t\tconst viewChild = viewElement.getChild( insertIndex );\n\n\t\t\t\t\t// UIElement and RawElement are special cases. Their children are not stored in a view (#799)\n\t\t\t\t\t// so we cannot use them with replacing flow (since they use view children during rendering\n\t\t\t\t\t// which will always result in rendering empty elements).\n\t\t\t\t\tif ( viewChild && !( viewChild.is( 'uiElement' ) || viewChild.is( 'rawElement' ) ) ) {\n\t\t\t\t\t\tthis._updateElementMappings( viewChild, actualDomChildren[ deleteIndex ] );\n\t\t\t\t\t}\n\n\t\t\t\t\tremove( expectedDomChildren[ insertIndex ] );\n\t\t\t\t\tcounter.equal++;\n\t\t\t\t} else {\n\t\t\t\t\tcounter[ action ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates mappings of a given view element.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n\t * @param {Node} domElement The DOM element representing the given view element.\n\t */\n\t_updateElementMappings( viewElement, domElement ) {\n\t\t// Remap 'DomConverter' bindings.\n\t\tthis.domConverter.unbindDomElement( domElement );\n\t\tthis.domConverter.bindElements( domElement, viewElement );\n\n\t\t// View element may have children which needs to be updated, but are not marked, mark them to update.\n\t\tthis.markedChildren.add( viewElement );\n\n\t\t// Because we replace new view element mapping with the existing one, the corresponding DOM element\n\t\t// will not be rerendered. The new view element may have different attributes than the previous one.\n\t\t// Since its corresponding DOM element will not be rerendered, new attributes will not be added\n\t\t// to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n\t\t// detailed case study.\n\t\t// Also there are cases where replaced element is removed from the view structure and then has\n\t\t// its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n\t\t// and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n\t\t// To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n\t\tthis.markedAttributes.add( viewElement );\n\t}\n\n\t/**\n\t * Gets the position of the inline filler based on the current selection.\n\t * Here, we assume that we know that the filler is needed and\n\t * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n\t * it is somewhere at the selection position.\n\t *\n\t * Note: The filler position cannot be restored based on the filler's DOM text node, because\n\t * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n\t * bindings are only dependable after rendering.\n\t *\n\t * @private\n\t * @returns {module:engine/view/position~Position}\n\t */\n\t_getInlineFillerPosition() {\n\t\tconst firstPos = this.selection.getFirstPosition();\n\n\t\tif ( firstPos.parent.is( '$text' ) ) {\n\t\t\treturn ViewPosition._createBefore( this.selection.getFirstPosition().parent );\n\t\t} else {\n\t\t\treturn firstPos;\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` if the selection has not left the inline filler's text node.\n\t * If it is `true`, it means that the filler had been added for a reason and the selection did not\n\t * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n\t */\n\t_isSelectionInInlineFiller() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Note, we can't check if selection's position equals position of the\n\t\t// this._inlineFiller node, because of #663. We may not be able to calculate\n\t\t// the filler's position in the view at this stage.\n\t\t// Instead, we check it the other way – whether selection is anchored in\n\t\t// that text node or next to it.\n\n\t\t// Possible options are:\n\t\t// \"FILLER{}\"\n\t\t// \"FILLERadded-text{}\"\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst position = this.domConverter.viewPositionToDom( selectionPosition );\n\n\t\tif ( position && isText( position.parent ) && startsWithFiller( position.parent ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Removes the inline filler.\n\t *\n\t * @private\n\t */\n\t_removeInlineFiller() {\n\t\tconst domFillerNode = this._inlineFiller;\n\n\t\t// Something weird happened and the stored node doesn't contain the filler's text.\n\t\tif ( !startsWithFiller( domFillerNode ) ) {\n\t\t\t/**\n\t\t\t * The inline filler node was lost. Most likely, something overwrote the filler text node\n\t\t\t * in the DOM.\n\t\t\t *\n\t\t\t * @error view-renderer-filler-was-lost\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-renderer-filler-was-lost', this );\n\t\t}\n\n\t\tif ( isInlineFiller( domFillerNode ) ) {\n\t\t\tdomFillerNode.remove();\n\t\t} else {\n\t\t\tdomFillerNode.data = domFillerNode.data.substr( INLINE_FILLER_LENGTH );\n\t\t}\n\n\t\tthis._inlineFiller = null;\n\t}\n\n\t/**\n\t * Checks if the inline {@link module:engine/view/filler filler} should be added.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler should be added.\n\t */\n\t_needsInlineFillerAtSelection() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst selectionParent = selectionPosition.parent;\n\t\tconst selectionOffset = selectionPosition.offset;\n\n\t\t// If there is no DOM root we do not care about fillers.\n\t\tif ( !this.domConverter.mapViewToDom( selectionParent.root ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !( selectionParent.is( 'element' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Prevent adding inline filler inside elements with contenteditable=false.\n\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\t\tif ( !isEditable( selectionParent ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have block filler, we do not need inline one.\n\t\tif ( selectionOffset === selectionParent.getFillerOffset() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst nodeBefore = selectionPosition.nodeBefore;\n\t\tconst nodeAfter = selectionPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText || nodeAfter instanceof ViewText ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if text needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} viewText View text to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateText( viewText, options ) {\n\t\tconst domText = this.domConverter.findCorrespondingDomText( viewText );\n\t\tconst newDomText = this.domConverter.viewToDom( viewText, domText.ownerDocument );\n\n\t\tconst actualText = domText.data;\n\t\tlet expectedText = newDomText.data;\n\n\t\tconst filler = options.inlineFillerPosition;\n\n\t\tif ( filler && filler.parent == viewText.parent && filler.offset == viewText.index ) {\n\t\t\texpectedText = INLINE_FILLER + expectedText;\n\t\t}\n\n\t\tif ( actualText != expectedText ) {\n\t\t\tconst actions = fastDiff( actualText, expectedText );\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action.type === 'insert' ) {\n\t\t\t\t\tdomText.insertData( action.index, action.values.join( '' ) );\n\t\t\t\t} else { // 'delete'\n\t\t\t\t\tdomText.deleteData( action.index, action.howMany );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if attribute list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement The view element to update.\n\t */\n\t_updateAttrs( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n\t\t\t// in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n\t\t\t// replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n\t\t\t// in 'this._updateChildrenMappings()' so it will be processed separately.\n\t\t\treturn;\n\t\t}\n\n\t\tconst domAttrKeys = Array.from( domElement.attributes ).map( attr => attr.name );\n\t\tconst viewAttrKeys = viewElement.getAttributeKeys();\n\n\t\t// Add or overwrite attributes.\n\t\tfor ( const key of viewAttrKeys ) {\n\t\t\tconst value = viewElement.getAttribute( key );\n\n\t\t\tif ( !this.domConverter.shouldRenderAttribute( key, value ) ) {\n\t\t\t\tdomElement.removeAttribute( key );\n\t\t\t} else {\n\t\t\t\tdomElement.setAttribute( key, value );\n\t\t\t}\n\t\t}\n\n\t\t// Remove from DOM attributes which do not exists in the view.\n\t\tfor ( const key of domAttrKeys ) {\n\t\t\t// Do not remove attributes on `script` elements with special data attributes `data-ck-hidden`.\n\t\t\tif ( viewElement.name === 'script' && key === 'data-ck-hidden' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// All other attributes not present in the DOM should be removed.\n\t\t\tif ( !viewElement.hasAttribute( key ) ) {\n\t\t\t\tdomElement.removeAttribute( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if elements child list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement View element to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateChildren( viewElement, options ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM.\n\t\t\t// There is no need to process it. It will be processed when re-inserted.\n\t\t\treturn;\n\t\t}\n\n\t\tconst inlineFillerPosition = options.inlineFillerPosition;\n\t\tconst actualDomChildren = this.domConverter.mapViewToDom( viewElement ).childNodes;\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { bind: true } )\n\t\t);\n\n\t\t// Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n\t\t// during diffing so text nodes could be compared correctly and also during rendering to maintain\n\t\t// proper order and indexes while updating the DOM.\n\t\tif ( inlineFillerPosition && inlineFillerPosition.parent === viewElement ) {\n\t\t\taddInlineFiller( domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset );\n\t\t}\n\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\n\t\tlet i = 0;\n\t\tconst nodesToUnbind = new Set();\n\n\t\t// Handle deletions first.\n\t\t// This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different\n\t\t// index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,\n\t\t// and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.\n\t\t//\n\t\t// It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.\n\t\tfor ( const action of diff ) {\n\t\t\tif ( action === 'delete' ) {\n\t\t\t\tnodesToUnbind.add( actualDomChildren[ i ] );\n\t\t\t\tremove( actualDomChildren[ i ] );\n\t\t\t} else if ( action === 'equal' ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\ti = 0;\n\n\t\tfor ( const action of diff ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\tinsertAt( domElement, i, expectedDomChildren[ i ] );\n\t\t\t\ti++;\n\t\t\t} else if ( action === 'equal' ) {\n\t\t\t\t// Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n\t\t\t\t// Do it here (not in the loop above) because only after insertions the `i` index is correct.\n\t\t\t\tthis._markDescendantTextToSync( this.domConverter.domToView( expectedDomChildren[ i ] ) );\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n\t\t// comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n\t\t// it was moved to DOM tree out of the removed node.\n\t\tfor ( const node of nodesToUnbind ) {\n\t\t\tif ( !node.parentNode ) {\n\t\t\t\tthis.domConverter.unbindDomElement( node );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Shorthand for diffing two arrays or node lists of DOM nodes.\n\t *\n\t * @private\n\t * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n\t * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n\t * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n\t */\n\t_diffNodeLists( actualDomChildren, expectedDomChildren ) {\n\t\tactualDomChildren = filterOutFakeSelectionContainer( actualDomChildren, this._fakeSelectionContainer );\n\n\t\treturn diff( actualDomChildren, expectedDomChildren, sameNodes.bind( null, this.domConverter ) );\n\t}\n\n\t/**\n\t * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n\t * within one `insert`/`delete` action group, for example:\n\t *\n\t * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n\t * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n\t * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n\t * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n\t *\n\t * @private\n\t * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n\t * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n\t * @param {Array.<Node>} expectedDom Expected DOM children.\n\t * @returns {Array.<String>} Actions array modified with the `replace` actions.\n\t */\n\t_findReplaceActions( actions, actualDom, expectedDom ) {\n\t\t// If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n\t\tif ( actions.indexOf( 'insert' ) === -1 || actions.indexOf( 'delete' ) === -1 ) {\n\t\t\treturn actions;\n\t\t}\n\n\t\tlet newActions = [];\n\t\tlet actualSlice = [];\n\t\tlet expectedSlice = [];\n\n\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\tfor ( const action of actions ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\texpectedSlice.push( expectedDom[ counter.equal + counter.insert ] );\n\t\t\t} else if ( action === 'delete' ) {\n\t\t\t\tactualSlice.push( actualDom[ counter.equal + counter.delete ] );\n\t\t\t} else { // equal\n\t\t\t\tnewActions = newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t\t\t\tnewActions.push( 'equal' );\n\t\t\t\t// Reset stored elements on 'equal'.\n\t\t\t\tactualSlice = [];\n\t\t\t\texpectedSlice = [];\n\t\t\t}\n\t\t\tcounter[ action ]++;\n\t\t}\n\n\t\treturn newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t}\n\n\t/**\n\t * Marks text nodes to be synchronized.\n\t *\n\t * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewNode View node to sync.\n\t */\n\t_markDescendantTextToSync( viewNode ) {\n\t\tif ( !viewNode ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( viewNode.is( '$text' ) ) {\n\t\t\tthis.markedTexts.add( viewNode );\n\t\t} else if ( viewNode.is( 'element' ) ) {\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tthis._markDescendantTextToSync( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the selection needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateSelection() {\n\t\t// Block updating DOM selection in (non-Android) Blink while the user is selecting to prevent accidental selection collapsing.\n\t\t// Note: Structural changes in DOM must trigger selection rendering, though. Nodes the selection was anchored\n\t\t// to may disappear in DOM which would break the selection (e.g. in real-time collaboration scenarios).\n\t\t// https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723\n\t\tif ( env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is no selection - remove DOM and fake selections.\n\t\tif ( this.selection.rangeCount === 0 ) {\n\t\t\tthis._removeDomSelection();\n\t\t\tthis._removeFakeSelection();\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst domRoot = this.domConverter.mapViewToDom( this.selection.editableElement );\n\n\t\t// Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\t\tif ( !this.isFocused || !domRoot ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Render selection.\n\t\tif ( this.selection.isFake ) {\n\t\t\tthis._updateFakeSelection( domRoot );\n\t\t} else {\n\t\t\tthis._removeFakeSelection();\n\t\t\tthis._updateDomSelection( domRoot );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the fake selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n\t */\n\t_updateFakeSelection( domRoot ) {\n\t\tconst domDocument = domRoot.ownerDocument;\n\n\t\tif ( !this._fakeSelectionContainer ) {\n\t\t\tthis._fakeSelectionContainer = createFakeSelectionContainer( domDocument );\n\t\t}\n\n\t\tconst container = this._fakeSelectionContainer;\n\n\t\t// Bind fake selection container with the current selection *position*.\n\t\tthis.domConverter.bindFakeSelection( container, this.selection );\n\n\t\tif ( !this._fakeSelectionNeedsUpdate( domRoot ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !container.parentElement || container.parentElement != domRoot ) {\n\t\t\tdomRoot.appendChild( container );\n\t\t}\n\n\t\tcontainer.textContent = this.selection.fakeSelectionLabel || '\\u00A0';\n\n\t\tconst domSelection = domDocument.getSelection();\n\t\tconst domRange = domDocument.createRange();\n\n\t\tdomSelection.removeAllRanges();\n\t\tdomRange.selectNodeContents( container );\n\t\tdomSelection.addRange( domRange );\n\t}\n\n\t/**\n\t * Updates the DOM selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n\t */\n\t_updateDomSelection( domRoot ) {\n\t\tconst domSelection = domRoot.ownerDocument.defaultView.getSelection();\n\n\t\t// Let's check whether DOM selection needs updating at all.\n\t\tif ( !this._domSelectionNeedsUpdate( domSelection ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n\t\t// set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n\t\t// and focus of view selection.\n\t\t// Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n\t\t// selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\t\tconst anchor = this.domConverter.viewPositionToDom( this.selection.anchor );\n\t\tconst focus = this.domConverter.viewPositionToDom( this.selection.focus );\n\n\t\tdomSelection.collapse( anchor.parent, anchor.offset );\n\t\tdomSelection.extend( focus.parent, focus.offset );\n\n\t\t// Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n\t\tif ( env.isGecko ) {\n\t\t\tfixGeckoSelectionAfterBr( focus, domSelection );\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether a given DOM selection needs to be updated.\n\t *\n\t * @private\n\t * @param {Selection} domSelection The DOM selection to check.\n\t * @returns {Boolean}\n\t */\n\t_domSelectionNeedsUpdate( domSelection ) {\n\t\tif ( !this.domConverter.isDomSelectionCorrect( domSelection ) ) {\n\t\t\t// Current DOM selection is in incorrect position. We need to update it.\n\t\t\treturn true;\n\t\t}\n\n\t\tconst oldViewSelection = domSelection && this.domConverter.domSelectionToView( domSelection );\n\n\t\tif ( oldViewSelection && this.selection.isEqual( oldViewSelection ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If selection is not collapsed, it does not need to be updated if it is similar.\n\t\tif ( !this.selection.isCollapsed && this.selection.isSimilar( oldViewSelection ) ) {\n\t\t\t// Selection did not changed and is correct, do not update.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Selections are not similar.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether the fake selection needs to be updated.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.\n\t * @returns {Boolean}\n\t */\n\t_fakeSelectionNeedsUpdate( domRoot ) {\n\t\tconst container = this._fakeSelectionContainer;\n\t\tconst domSelection = domRoot.ownerDocument.getSelection();\n\n\t\t// Fake selection needs to be updated if there's no fake selection container, or the container currently sits\n\t\t// in a different root.\n\t\tif ( !container || container.parentElement !== domRoot ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Make sure that the selection actually is within the fake selection.\n\t\tif ( domSelection.anchorNode !== container && !container.contains( domSelection.anchorNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn container.textContent !== this.selection.fakeSelectionLabel;\n\t}\n\n\t/**\n\t * Removes the DOM selection.\n\t *\n\t * @private\n\t */\n\t_removeDomSelection() {\n\t\tfor ( const doc of this.domDocuments ) {\n\t\t\tconst domSelection = doc.getSelection();\n\n\t\t\tif ( domSelection.rangeCount ) {\n\t\t\t\tconst activeDomElement = doc.activeElement;\n\t\t\t\tconst viewElement = this.domConverter.mapDomToView( activeDomElement );\n\n\t\t\t\tif ( activeDomElement && viewElement ) {\n\t\t\t\t\tdoc.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the fake selection.\n\t *\n\t * @private\n\t */\n\t_removeFakeSelection() {\n\t\tconst container = this._fakeSelectionContainer;\n\n\t\tif ( container ) {\n\t\t\tcontainer.remove();\n\t\t}\n\t}\n\n\t/**\n\t * Checks if focus needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateFocus() {\n\t\tif ( this.isFocused ) {\n\t\t\tconst editable = this.selection.editableElement;\n\n\t\t\tif ( editable ) {\n\t\t\t\tthis.domConverter.focus( editable );\n\t\t\t}\n\t\t}\n\t}\n}\n\nmix( Renderer, ObservableMixin );\n\n// Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\nfunction isEditable( element ) {\n\tif ( element.getAttribute( 'contenteditable' ) == 'false' ) {\n\t\treturn false;\n\t}\n\n\tconst parent = element.findAncestor( element => element.hasAttribute( 'contenteditable' ) );\n\n\treturn !parent || parent.getAttribute( 'contenteditable' ) == 'true';\n}\n\n// Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\nfunction addInlineFiller( domDocument, domParentOrArray, offset ) {\n\tconst childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n\tconst nodeAfterFiller = childNodes[ offset ];\n\n\tif ( isText( nodeAfterFiller ) ) {\n\t\tnodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n\n\t\treturn nodeAfterFiller;\n\t} else {\n\t\tconst fillerNode = domDocument.createTextNode( INLINE_FILLER );\n\n\t\tif ( Array.isArray( domParentOrArray ) ) {\n\t\t\tchildNodes.splice( offset, 0, fillerNode );\n\t\t} else {\n\t\t\tinsertAt( domParentOrArray, offset, fillerNode );\n\t\t}\n\n\t\treturn fillerNode;\n\t}\n}\n\n// Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction areSimilar( node1, node2 ) {\n\treturn isNode( node1 ) && isNode( node2 ) &&\n\t\t!isText( node1 ) && !isText( node2 ) &&\n\t\tnode1.nodeType !== Node.COMMENT_NODE && node2.nodeType !== Node.COMMENT_NODE &&\n\t\tnode1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n}\n\n// Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction sameNodes( domConverter, actualDomChild, expectedDomChild ) {\n\t// Elements.\n\tif ( actualDomChild === expectedDomChild ) {\n\t\treturn true;\n\t}\n\t// Texts.\n\telse if ( isText( actualDomChild ) && isText( expectedDomChild ) ) {\n\t\treturn actualDomChild.data === expectedDomChild.data;\n\t}\n\t// Block fillers.\n\telse if ( domConverter.isBlockFiller( actualDomChild ) &&\n\t\tdomConverter.isBlockFiller( expectedDomChild ) ) {\n\t\treturn true;\n\t}\n\n\t// Not matching types.\n\treturn false;\n}\n\n// The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\nfunction fixGeckoSelectionAfterBr( focus, domSelection ) {\n\tconst parent = focus.parent;\n\n\t// This fix works only when the focus point is at the very end of an element.\n\t// There is no point in running it in cases unrelated to the browser bug.\n\tif ( parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1 ) {\n\t\treturn;\n\t}\n\n\tconst childAtOffset = parent.childNodes[ focus.offset ];\n\n\t// To stay on the safe side, the fix being as specific as possible, it targets only the\n\t// selection which is at the very end of the element and preceded by <br />.\n\tif ( childAtOffset && childAtOffset.tagName == 'BR' ) {\n\t\tdomSelection.addRange( domSelection.getRangeAt( 0 ) );\n\t}\n}\n\nfunction filterOutFakeSelectionContainer( domChildList, fakeSelectionContainer ) {\n\tconst childList = Array.from( domChildList );\n\n\tif ( childList.length == 0 || !fakeSelectionContainer ) {\n\t\treturn childList;\n\t}\n\n\tconst last = childList[ childList.length - 1 ];\n\n\tif ( last == fakeSelectionContainer ) {\n\t\tchildList.pop();\n\t}\n\n\treturn childList;\n}\n\n// Creates a fake selection container for a given document.\n//\n// @private\n// @param {Document} domDocument\n// @returns {HTMLElement}\nfunction createFakeSelectionContainer( domDocument ) {\n\tconst container = domDocument.createElement( 'div' );\n\n\tcontainer.className = 'ck-fake-selection-container';\n\n\tObject.assign( container.style, {\n\t\tposition: 'fixed',\n\t\ttop: 0,\n\t\tleft: '-9999px',\n\t\t// See https://github.com/ckeditor/ckeditor5/issues/752.\n\t\twidth: '42px'\n\t} );\n\n\t// Fill it with a text node so we can update it later.\n\tcontainer.textContent = '\\u00A0';\n\n\treturn container;\n}\n"]},"metadata":{},"sourceType":"module"}